{:version "0.0-1011",
 :history {:versions ("0.0-1011"
                      "0.0-1006"
                      "0.0-993"
                      "0.0-971"
                      "0.0-927"),
           :details {"0.0-927" {:tag "r927",
                                :date "2012-01-20",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "20110323-r790",
                                :gclosure-com nil},
                     "0.0-971" {:tag "r971",
                                :date "2012-01-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-993" {:tag "r993",
                                :date "2012-02-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-1006" {:tag "r1006",
                                 :date "2012-03-30",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-1011" {:tag "r1011",
                                 :date "2012-04-02",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil}}},
 :clj-not-cljs #{"clojure.core/conj!"
                 "clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.data/EqualityPartition"
                 "clojure.core/*in*"
                 "clojure.core/unchecked-subtract-int"
                 "clojure.main/demunge"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shorts"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.test/deftest-"
                 "clojure.core/unchecked-add"
                 "clojure.core/assoc!"
                 "clojure.core/doubles"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.core/unchecked-byte"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.core/proxy-super"
                 "clojure.core/unchecked-divide-int"
                 "clojure.core/refer"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core/future-call"
                 "clojure.core/persistent!"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/into-array"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core/double-array"
                 "clojure.core/float"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.core/unchecked-float"
                 "clojure.test/testing"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core/agent-error"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.core/*clojure-version*"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.core/unchecked-short"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/sorted-map"
                 "clojure.core/init-proxy"
                 "clojure.core/unchecked-inc-int"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.core/ints"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/short"
                 "clojure.core/unchecked-dec-int"
                 "clojure.core/unchecked-subtract"
                 "clojure.core/sorted-map-by"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/sorted?"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.core/unchecked-negate"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.core/case"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.core/ref-set"
                 "clojure.core/booleans"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.core/*print-length*"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/transient"
                 "clojure.core/with-redefs"
                 "clojure.core/use"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/longs"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/bytes"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.core/memfn"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/sorted-set-by"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.core/list?"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.core/to-array-2d"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/reversible?"
                 "clojure.core/promise"
                 "clojure.core/*compile-files*"
                 "clojure.core/pop!"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.core/unchecked-double"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.core/array-map"
                 "clojure.reflect/resolve-class"
                 "clojure.java.io/as-file"
                 "clojure.core/dissoc!"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/shuffle"
                 "clojure.core/*e"
                 "clojure.core/defonce"
                 "clojure.core/unchecked-inc"
                 "clojure.core/create-ns"
                 "clojure.core/hash-set"
                 "clojure.repl/doc"
                 "clojure.core/aset-int"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.core/int-array"
                 "clojure.test/with-test"
                 "clojure.core/unchecked-remainder-int"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.core/val"
                 "clojure.template/apply-template"
                 "clojure.core/cast"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.core/char"
                 "clojure.core/ensure"
                 "clojure.core/*print-level*"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/ifn?"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/make-array"
                 "clojure.core/bound-fn"
                 "clojure.core/special-symbol?"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/long"
                 "clojure.core/locking"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.core/object-array"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/rseq"
                 "clojure.core/thread-bound?"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/floats"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/sorted-set"
                 "clojure.core/resolve"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/lazy-cat"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core/comparator"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.core/unchecked-add-int"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/key"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/unchecked-int"
                 "clojure.core/error-mode"
                 "clojure.core/subseq"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/disj!"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/pcalls"
                 "clojure.core/with-out-str"
                 "clojure.core/long-array"
                 "clojure.core/ns-unalias"
                 "clojure.core/double"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.test/function?"
                 "clojure.data/Diff"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/unchecked-negate-int"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.data/diff"
                 "clojure.main/main"
                 "clojure.core/unchecked-multiply"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/chars"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.core/unchecked-char"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/int"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.core/byte"
                 "clojure.core/unchecked-dec"
                 "clojure.core/sequence"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.core/unchecked-long"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core/unchecked-multiply-int"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"
                 "clojure.core/rsubseq"},
 :symbols {"cljs.core/keys" {:ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :name-encode "keys",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (seq (map first hash-map)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2609 2612]},
                             :full-name "cljs.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/reset!" {:ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :name-encode "resetBANG",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (when-let [validate (.-validator a)]\n    (assert (validate new-value) \"Validator rejected reference state\"))\n  (let [old-value (.-state a)]\n    (set! (.-state a) new-value)\n    (-notify-watches a old-value new-value))\n  new-value)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3277 3286]},
                               :full-name "cljs.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "clojure.set/select" {:ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :name-encode "select",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :name-encode "delay",
                              :type "macro",
                              :full-name-encode "cljs.core/delay",
                              :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core.Delay (atom {:done false, :value nil}) (fn [] ~@body)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [437 442]},
                              :full-name "cljs.core/delay",
                              :history [["+" "0.0-927"]]},
           "cljs.core/bit-not" {:ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :name-encode "bit-not",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [961 963]},
                                :extra-sources [{:code "(defmacro bit-not [x]\n  (list 'js* \"(~ ~{})\" x))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [141 142]}],
                                :full-name "cljs.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :name-encode "partition",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (= n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (= n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1874 1894]},
                                  :full-name "cljs.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :name-encode "parents",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/parents",
                                :source {:code "(defn parents\n  ([tag] (parents @global-hierarchy tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3534 3540]},
                                :full-name "cljs.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:ns "cljs.core",
                               :name "aclone",
                               :signature ["[array-like]"],
                               :name-encode "aclone",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/aclone",
                               :source {:code "(defn aclone\n  [array-like]\n  #_(goog.array.clone array-like)\n  (js* \"Array.prototype.slice.call(~{array-like})\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [65 69]},
                               :full-name "cljs.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :name-encode "reset-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3344 3347]},
                                    :full-name "cljs.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :name-encode "dispatch-macros",
                                          :type "var",
                                          :full-name-encode "cljs.reader/dispatch-macros",
                                          :source {:code "(def dispatch-macros\n  {\"{\" read-set\n   \"<\" (throwing-reader \"Unreadable form\")\n   \"\\\"\" read-regex\n   \"!\" read-comment\n   \"_\" read-discard})",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [331 336]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :name-encode "current-repl-env",
                                               :type "var",
                                               :full-name-encode "cljs.repl.rhino/current-repl-env",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :name-encode "ICollection",
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ICollection",
                                    :source {:code "(defprotocol ICollection\n  (-conj [coll o]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [124 125]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/ICollection",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/every?" {:ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :name-encode "everyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/everyQMARK",
                               :source {:code "(defn every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1446 1453]},
                               :full-name "cljs.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :name-encode "node",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :name-encode "IEmptyableCollection",
                                             :type "protocol",
                                             :full-name-encode "cljs.core/IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [121 122]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEmptyableCollection",
                                             :history [["+" "0.0-927"]]},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :name-encode "right",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "cljs.core/==" {:ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "EQEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/EQEQ",
                           :source {:code "(defn ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [983 993]},
                           :extra-sources [{:code "(defmacro ==\n  ([x] true)\n  ([x y] (list 'js* \"(~{} === ~{})\" x y))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [108 111]}],
                           :full-name "cljs.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue (type-independent), otherwise false"},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :name-encode "STARtimeoutSTAR",
                                            :type "var",
                                            :full-name-encode "clojure.browser.net/STARtimeoutSTAR",
                                            :source {:code "(def *timeout* 10000)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/clojure/browser/net.cljs",
                                                     :lines [21]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/let*" {:ns "cljs.core",
                             :name "let*",
                             :type "special form",
                             :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/clj/cljs/compiler.clj",
                                      :lines [793 795]},
                             :full-name "cljs.core/let*",
                             :full-name-encode "cljs.core/letSTAR",
                             :name-encode "letSTAR",
                             :history [["+" "0.0-927"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :name-encode "remove-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3744 3747]},
                                      :full-name "cljs.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "cljs.core/frequencies" {:ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :name-encode "frequencies",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (reduce\n   (fn [counts x]\n     (assoc counts x (inc (get counts x 0))))\n   {}\n   coll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2908 2916]},
                                    :full-name "cljs.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/pop" {:ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :name-encode "pop",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/pop",
                            :source {:code "(defn pop\n  [coll]\n  (-pop coll))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [561 566]},
                            :full-name "cljs.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.core/not-every?" {:ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :name-encode "not-everyQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/not-everyQMARK",
                                   :source {:code "(defn not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1455 1458]},
                                   :full-name "cljs.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/some-fn" {:ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :name-encode "some-fn",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1643 1680]},
                                :full-name "cljs.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :name-encode "remove-all",
                                               :type "function",
                                               :full-name-encode "clojure.browser.event/remove-all",
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [98]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :name-encode "doto",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3395 3410]},
                             :full-name "cljs.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred coll]"],
                                   :name-encode "take-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/take-while",
                                   :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2810 2817]},
                                   :full-name "cljs.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"],
                                      :name-encode "evaluate-form",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n     (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n     (try\n       (let [ast (comp/analyze env form)\n             js (comp/emits ast)\n             wrap-js (comp/emits (binding [comp/*cljs-warn-on-undeclared* false]\n                                   (comp/analyze env (wrap form))))]\n         (when (= (:op ast) :ns)\n           (load-dependencies repl-env (into (vals (:requires ast))\n                                             (distinct (vals (:uses ast))))))\n         (when *cljs-verbose*\n           (print js))\n         (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n           (case (:status ret)\n             ;;we eat ns errors because we know goog.provide() will throw when reloaded\n             ;;TODO - file bug with google, this is bs error\n             ;;this is what you get when you try to 'teach new developers'\n             ;;via errors (goog/base.js 104)\n             :error (display-error ret form)\n             :exception (display-error ret form\n                          #(prn \"Error evaluating:\" form :as js))\n             :success (:value ret))))\n       (catch Throwable ex\n         (.printStackTrace ex)\n         (println (str ex))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [56 85]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :name-encode "escape-char-map",
                                          :type "var",
                                          :full-name-encode "cljs.reader/escape-char-map",
                                          :source {:code "(def escape-char-map {\\t \"\\t\"\n                      \\r \"\\r\"\n                      \\n \"\\n\"\n                      \\\\ \\\\\n                      \\\" \\\"\n                      \\b \"\\b\"\n                      \\f \"\\f\"})",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [137 143]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :signature ["[obj type capture]"],
                                                  :name-encode "all-listeners",
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.event/all-listeners",
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/cljs/clojure/browser/event.cljs",
                                                           :lines [90]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/vals" {:ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :name-encode "vals",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (seq (map second hash-map)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2614 2617]},
                             :full-name "cljs.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :name-encode "IDeref",
                               :type "protocol",
                               :full-name-encode "cljs.core/IDeref",
                               :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [159 160]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IDeref",
                               :history [["+" "0.0-927"]]},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :signature ["[obj]"],
                                          :name-encode "log-obj",
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/log-obj",
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [22 23]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/for" {:ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :name-encode "for",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/for",
                            :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (apply str msg)))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      `(fn ~giter [~gxs]\n                         (lazy-seq\n                           (loop [~gxs ~gxs]\n                             (when-first [~bind ~gxs]\n                               ~(do-mod mod-pairs)))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [563 610]},
                            :full-name "cljs.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :signature ["[repl-env filename stream]"],
                                    :name-encode "load-stream",
                                    :type "function",
                                    :full-name-encode "cljs.repl/load-stream",
                                    :source {:code "(defn load-stream [repl-env filename stream]\n  (with-open [r (io/reader stream)]\n    (let [env {:ns (@comp/namespaces comp/*cljs-ns*) :context :statement :locals {}}\n          pbr (clojure.lang.LineNumberingPushbackReader. r)\n          eof (Object.)]\n      (loop [r (read pbr false eof false)]\n        (let [env (assoc env :ns (@comp/namespaces comp/*cljs-ns*))]\n          (when-not (identical? eof r)\n            (evaluate-form repl-env env filename r)\n            (recur (read pbr false eof false))))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [87 96]},
                                    :full-name "cljs.repl/load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :name-encode "instanceQMARK",
                                  :type "function",
                                  :full-name-encode "cljs.core/instanceQMARK",
                                  :source {:code "(defn instance? [t o]\n  (js* \"(~{o} != null && (~{o} instanceof ~{t} || ~{o}.constructor === ~{t} || ~{t} === Object))\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [652 653]},
                                  :full-name "cljs.core/instance?",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/PersistentVector.EMPTY_NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :name-encode "PersistentVectorDOTEMPTY_NODE",
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY_NODE",
                                                    :source {:code "(set! cljs.core.PersistentVector/EMPTY_NODE (js* \"(new Array(32))\"))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [2199]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]]},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :name-encode "read-comment",
                                       :type "var",
                                       :full-name-encode "cljs.reader/read-comment",
                                       :source {:code "(def read-comment skip-line)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [207]},
                                       :full-name "cljs.reader/read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/eval-result" {:ns "cljs.repl.rhino",
                                          :name "eval-result",
                                          :name-encode "eval-result",
                                          :type "multimethod",
                                          :full-name-encode "cljs.repl.rhino/eval-result",
                                          :source {:code "(defmulti eval-result class)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [48]},
                                          :full-name "cljs.repl.rhino/eval-result",
                                          :extra-sources ({:code "(defmethod eval-result :default [r]\n  (.toString r))",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [50
                                                                   51]}
                                                          {:code "(defmethod eval-result nil [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [53]}
                                                          {:code "(defmethod eval-result org.mozilla.javascript.Undefined [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [55]}),
                                          :history [["+" "0.0-927"]]},
           "syntax/whitespace" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "whitespace",
                                :name-encode "whitespace",
                                :type "special character",
                                :full-name-encode "syntax/whitespace",
                                :full-name "syntax/whitespace",
                                :history [["+" "0.0-927"]]},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-number",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-number",
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (contains? macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [220 230]},
                                      :full-name "cljs.reader/read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :name-encode "ILookup",
                                :type "protocol",
                                :full-name-encode "cljs.core/ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [137 138]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ILookup",
                                :history [["+" "0.0-927"]]},
           "cljs.core/when" {:ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :name-encode "when",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [454 458]},
                             :full-name "cljs.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :name-encode "set-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [140 143]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-get",
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/read-get",
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [153 158]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :history [["+" "0.0-927"]]},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :name-encode "read-past",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [159 166]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :signature ["[repl-env ns url]"],
                                                :name-encode "load-javascript",
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/load-javascript",
                                                :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @loaded-libs %) ns)]\n    (when (seq missing)\n      (let [ret (browser-eval (object-query-str ns))]\n        (when-not (and (= (:status ret) :success)\n                       (= (:value ret) \"true\"))\n          (browser-eval (slurp url))))\n      (swap! loaded-libs (partial apply conj) missing))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1011",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [283
                                                                 290]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :name-encode "to-array",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1322 1330]},
                                 :full-name "cljs.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep coll]"],
                                  :name-encode "interpose",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/interpose",
                                  :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1802 1804]},
                                  :full-name "cljs.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep"},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :name-encode "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net/ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [88
                                                                     89]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/Cons" {:ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest]"],
                             :name-encode "Cons",
                             :type "type",
                             :full-name-encode "cljs.core/Cons",
                             :source {:code "(deftype Cons [meta first rest]\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1201 1226]},
                             :full-name "cljs.core/Cons",
                             :history [["+" "0.0-927"]]},
           "cljs.core/re-find" {:ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :name-encode "re-find",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3006 3016]},
                                :full-name "cljs.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :name-encode "IMeta",
                              :type "protocol",
                              :full-name-encode "cljs.core/IMeta",
                              :source {:code "(defprotocol IMeta\n  (-meta [o]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [165 166]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IMeta",
                              :history [["+" "0.0-927"]]},
           "cljs.core/assoc-in" {:ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :name-encode "assoc-in",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1915 1922]},
                                 :full-name "cljs.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "compiler-options/verbose" {:ns "compiler-options",
                                       :name "verbose",
                                       :name-encode "verbose",
                                       :type "option",
                                       :full-name-encode "compiler-options/verbose",
                                       :full-name "compiler-options/verbose",
                                       :history [["+" "0.0-971"]]},
           "clojure.string/join" {:ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :name-encode "join",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/join",
                                  :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [45 51]},
                                  :full-name "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :name-encode "rights",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :name-encode "split-at",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1762 1765]},
                                 :full-name "cljs.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :name-encode "append-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :name-encode "binding",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/binding",
                                :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map vector names vals)\n        resets (reverse (map vector names tempnames))]\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map\n           (fn [[k v]] (list 'set! k v))\n           binds)\n        ~@body\n        (finally\n         ~@(map\n            (fn [[k v]] (list 'set! k v))\n            resets))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [444 467]},
                                :full-name "cljs.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "compiler-options/libs" {:ns "compiler-options",
                                    :name "libs",
                                    :name-encode "libs",
                                    :type "option",
                                    :full-name-encode "compiler-options/libs",
                                    :full-name "compiler-options/libs",
                                    :history [["+" "0.0-971"]]},
           "cljs.core/Set" {:ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :name-encode "Set",
                            :type "type",
                            :full-name-encode "cljs.core/Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :history [["+" "0.0-927"]]},
           "cljs.reader/macro-terminating?" {:ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :signature ["[ch]"],
                                             :name-encode "macro-terminatingQMARK",
                                             :type "function",
                                             :full-name-encode "cljs.reader/macro-terminatingQMARK",
                                             :source {:code "(defn macro-terminating? [ch]\n  (and (not= ch \"#\") (not= ch \\') (not= ch \":\") (contains? macros ch)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/cljs/cljs/reader.cljs",
                                                      :lines [73 74]},
                                             :full-name "cljs.reader/macro-terminating?",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :name-encode "prefers",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3764 3766]},
                                :full-name "cljs.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.core/vary-meta" {:ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f & args]"],
                                  :name-encode "vary-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/vary-meta",
                                  :source {:code "(defn vary-meta\n [obj f & args]\n (with-meta obj (apply f (meta obj) args)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1429 1433]},
                                  :full-name "cljs.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/when-let" {:ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[bindings & body]"],
                                 :name-encode "when-let",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args when-let\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1685 1698]},
                                 :full-name "cljs.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "cljs.core/drop" {:ns "cljs.core",
                             :name "drop",
                             :signature ["[n coll]"],
                             :name-encode "drop",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/drop",
                             :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1721 1729]},
                             :full-name "cljs.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll."},
           "cljs.core/while" {:ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :name-encode "while",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5569 5577]},
                              :full-name "cljs.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :signature ["[ns [& vars]]"],
                                      :name-encode "import-macros",
                                      :type "macro",
                                      :full-name-encode "cljs.core/import-macros",
                                      :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(def ~sym (deref ~var))) syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [27 34]},
                                      :full-name "cljs.core/import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :name-encode "add-in-order",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/add-in-order",
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order) :fns (assoc fns order f)})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [203 204]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :signature ["[x]"],
                                     :name-encode "string-print",
                                     :type "function",
                                     :full-name-encode "cljs.core/string-print",
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3041 3043]},
                                     :full-name "cljs.core/string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/-" {:ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "-",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/-",
                          :source {:code "(defn -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [817 822]},
                          :extra-sources [{:code "(defmacro -\n  ([x] (list 'js* \"(- ~{})\" x))\n  ([x y] (list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [72 75]}],
                          :full-name "cljs.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/loop*" {:ns "cljs.core",
                              :name "loop*",
                              :type "special form",
                              :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/compiler.clj",
                                       :lines [797 799]},
                              :full-name "cljs.core/loop*",
                              :full-name-encode "cljs.core/loopSTAR",
                              :name-encode "loopSTAR",
                              :history [["+" "0.0-927"]]},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :name-encode "vector-zip",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip/vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "syntax/earmuffs" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "earmuffs",
                              :name-encode "earmuffs",
                              :type "convention",
                              :full-name-encode "syntax/earmuffs",
                              :full-name "syntax/earmuffs",
                              :history [["+" "0.0-927"]]},
           "cljs.core/js->clj" {:ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x & options]"],
                                :name-encode "js-GTclj",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/js-GTclj",
                                :source {:code "(defn js->clj\n  [x & options]\n  (let [{:keys [keywordize-keys]} options\n        keyfn (if keywordize-keys keyword str)\n        f (fn thisfn [x]\n            (cond\n             (seq? x) (doall (map thisfn x))\n             (coll? x) (into (empty x) (map thisfn x))\n             (goog.isArray x) (vec (map thisfn x))\n             (goog.isObject x) (into {} (for [k (js-keys x)]\n                                          [(keyfn k)\n                                           (thisfn (aget x k))]))\n             :else x))]\n    (f x)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3429 3446]},
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count]"],
                             :name-encode "List",
                             :type "type",
                             :full-name-encode "cljs.core/List",
                             :source {:code "(deftype List [meta first rest count]\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] rest)\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1123 1155]},
                             :full-name "cljs.core/List",
                             :history [["+" "0.0-927"]]},
           "cljs.core/identical?" {:ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :name-encode "identicalQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/identicalQMARK",
                                   :source {:code "(defn identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [201 204]},
                                   :extra-sources [{:code "(defmacro identical? [a b]\n  (list 'js* \"(~{} === ~{})\" a b))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [57 58]}],
                                   :full-name "cljs.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :name-encode "STARmain-cli-fnSTAR",
                                      :type "var",
                                      :full-name-encode "cljs.core/STARmain-cli-fnSTAR",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [52 56]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :signature ["[s]"],
                                            :name-encode "html-GTdom",
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/html-GTdom",
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [99 100]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/some" {:ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :name-encode "some",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1460 1467]},
                             :full-name "cljs.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/if" {:ns "cljs.core",
                           :name "if",
                           :type "special form",
                           :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :children [test-expr then-expr else-expr]}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [638 645]},
                           :full-name "cljs.core/if",
                           :full-name-encode "cljs.core/if",
                           :name-encode "if",
                           :history [["+" "0.0-927"]]},
           "cljs.core/doall" {:ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "doall",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2981 2993]},
                              :full-name "cljs.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :name-encode "condp",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/condp",
                              :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (cond\n                  (= 0 n) `(throw (js/Error. (str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [469 509]},
                              :full-name "cljs.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :name-encode "down",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :name-encode "IPending",
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IPending",
                                 :source {:code "(defprotocol IPending\n  (-realized? [d]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [192 193]},
                                 :methods [{:name "-realized?",
                                            :signature ["[d]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IPending",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/count" {:ns "cljs.core",
                              :name "count",
                              :signature ["[coll]"],
                              :name-encode "count",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/count",
                              :source {:code "(defn count\n  [coll]\n  (-count coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [495 499]},
                              :full-name "cljs.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :name-encode "bit-test",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-test",
                                 :source {:code "(defn bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [970 973]},
                                 :extra-sources [{:code "(defmacro bit-test [x n]\n  (list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [166 167]}],
                                 :full-name "cljs.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/loop" {:ns "cljs.core",
                             :name "loop",
                             :signature ["[bindings & body]"],
                             :name-encode "loop",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/loop",
                             :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args loop\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (symbol? b) b (gensym))) bs)\n              bfs (reduce1 (fn [ret [b v g]]\n                            (if (symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [4025 4048]},
                             :full-name "cljs.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :name-encode "subvec",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (Subvec. nil v start end)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2280 2289]},
                               :full-name "cljs.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.core/bit-clear" {:ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :name-encode "bit-clear",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [951 954]},
                                  :extra-sources [{:code "(defmacro bit-clear [x n]\n  (list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [160 161]}],
                                  :full-name "cljs.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "syntax/Math-namespace" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "Math-namespace",
                                    :name-encode "Math-namespace",
                                    :type "special namespace",
                                    :full-name-encode "syntax/Math-namespace",
                                    :full-name "syntax/Math-namespace",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :name-encode "gensym",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3384 3392]},
                               :full-name "cljs.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "compiler-options/optimizations" {:ns "compiler-options",
                                             :name "optimizations",
                                             :name-encode "optimizations",
                                             :type "option",
                                             :full-name-encode "compiler-options/optimizations",
                                             :full-name "compiler-options/optimizations",
                                             :history [["+" "0.0-971"]]},
           "cljs.core/in-ns" {:ns "cljs.core",
                              :name "in-ns",
                              :name-encode "in-ns",
                              :type "special form (repl)",
                              :full-name-encode "cljs.core/in-ns",
                              :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                       :title "repl specials table",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/repl.clj",
                                       :lines [134 139]},
                              :full-name "cljs.core/in-ns",
                              :repl-only? true,
                              :history [["+" "0.0-927"]]},
           "cljs.core/+" {:ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "PLUS",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/PLUS",
                          :source {:code "(defn +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more] (reduce + (cljs.core/+ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [810 815]},
                          :extra-sources [{:code "(defmacro +\n  ([] 0)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [66 70]}],
                          :full-name "cljs.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/comp" {:ns "cljs.core",
                             :name "comp",
                             :signature ["[]"
                                         "[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f1 f2 f3 & fs]"],
                             :name-encode "comp",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1500 1527]},
                             :full-name "cljs.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "syntax/comma" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "comma",
                           :name-encode "comma",
                           :type "special character",
                           :full-name-encode "syntax/comma",
                           :full-name "syntax/comma",
                           :history [["+" "0.0-927"]]},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :signature ["[f]"],
                                       :name-encode "desugar-meta",
                                       :type "function",
                                       :full-name-encode "cljs.reader/desugar-meta",
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [269 275]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env sym]"],
                                       :name-encode "load-namespace",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/load-namespace",
                                       :source {:code "(defn load-namespace\n  [repl-env sym]\n  (let [sym (if (and (seq? sym)\n                     (= (first sym) 'quote))\n              (second sym)\n              sym)\n        opts {:output-dir (get repl-env :working-dir \".repl\")}\n        deps (->> (cljsc/add-dependencies opts {:requires [(name sym)] :type :seed})\n                  (remove (comp #{[\"goog\"]} :provides))\n                  (remove (comp #{:seed} :type))\n                  (map #(select-keys % [:provides :url])))]\n    (doseq [{:keys [url provides]} deps]\n      (-load repl-env provides url))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [24 39]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :name-encode "pr",
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core/pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [3121 3127]},
                           :full-name "cljs.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "clojure.string/upper-case" {:ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :name-encode "upper-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (. s (toUpperCase)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [53 56]},
                                        :full-name "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :signature ["[e]"],
                                           :name-encode "expose",
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/expose",
                                           :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [79 80]},
                                           :full-name "clojure.browser.event/expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :name-encode "listen-once",
                                                :type "function",
                                                :full-name-encode "clojure.browser.event/listen-once",
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1011",
                                                         :filename "src/cljs/clojure/browser/event.cljs",
                                                         :lines [53
                                                                 60]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/empty?" {:ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :name-encode "emptyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/emptyQMARK",
                               :source {:code "(defn empty?\n  [coll] (not (seq coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [583 586]},
                               :full-name "cljs.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "compiler-options/pretty-print" {:ns "compiler-options",
                                            :name "pretty-print",
                                            :name-encode "pretty-print",
                                            :type "option",
                                            :full-name-encode "compiler-options/pretty-print",
                                            :full-name "compiler-options/pretty-print",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[opts]"],
                                :name-encode "newline",
                                :type "function",
                                :full-name-encode "cljs.core/newline",
                                :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3095 3098]},
                                :full-name "cljs.core/newline",
                                :history [["+" "0.0-927"]]},
           "cljs.core/replace" {:ns "cljs.core",
                                :name "replace",
                                :signature ["[smap coll]"],
                                :name-encode "replace",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/replace",
                                :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2719 2731]},
                                :full-name "cljs.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
           "cljs.core/rand" {:ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :name-encode "rand",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (js* \"Math.random() * ~{n}\")))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3478 3482]},
                             :full-name "cljs.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[iref key f]"],
                                  :name-encode "add-watch",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3349 3371]},
                                  :full-name "cljs.core/add-watch",
                                  :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :name-encode "loaded-libs",
                                          :type "var",
                                          :full-name-encode "cljs.repl.rhino/loaded-libs",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [19]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :history [["+" "0.0-927"]]},
           "clojure.string/capitalize" {:ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :name-encode "capitalize",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [63 70]},
                                        :full-name "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :name-encode "replicate",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1772 1774]},
                                  :full-name "cljs.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "cljs.core/sequential?" {:ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[x]"],
                                    :name-encode "sequentialQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/sequentialQMARK",
                                    :source {:code "(defn sequential?\n  [x] (satisfies? ISequential x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [606 608]},
                                    :full-name "cljs.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :name-encode "underive",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n     ;; (alter-var-root #'global-hierarchy underive tag parent)\n     (swap! global-hierarchy underive tag parent) nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3593 3612]},
                                 :full-name "cljs.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :name-encode "get-method",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3759 3762]},
                                   :full-name "cljs.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:ns "cljs.core",
                          :name "=",
                          :signature ["[x y]"],
                          :name-encode "EQ",
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :full-name-encode "cljs.core/EQ",
                          :source {:code "(defn =\n  [x y]\n  (-equiv x y))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [206 212]},
                          :full-name "cljs.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "cljs.core/defn-" {:ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :name-encode "defn-",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4331 4335]},
                              :full-name "cljs.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "compiler-options/target" {:ns "compiler-options",
                                      :name "target",
                                      :name-encode "target",
                                      :type "option",
                                      :full-name-encode "compiler-options/target",
                                      :full-name "compiler-options/target",
                                      :history [["+" "0.0-971"]]},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-symbol",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-symbol",
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (get special-symbols token (symbol token)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [248 254]},
                                      :full-name "cljs.reader/read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :signature ["[s]"],
                                           :name-encode "push-back-reader",
                                           :type "function",
                                           :full-name-encode "cljs.reader/push-back-reader",
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (atom 0) (atom nil)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [30 32]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :name-encode "deftype",
                                :type "macro",
                                :full-name-encode "cljs.core/deftype",
                                :source {:code "(defmacro deftype [t fields & impls]\n  (let [adorn-params (fn [sig]\n                       (cons (vary-meta (second sig) assoc :cljs.compiler/fields fields)\n                             (nnext sig)))\n        ;;reshape for extend-type\n        dt->et (fn [specs]\n                 (loop [ret [] s specs]\n                   (if (seq s)\n                     (recur (-> ret\n                                (conj (first s))\n                                (into\n                                 (reduce (fn [v [f sigs]]\n                                           (conj v (cons f (map adorn-params sigs))))\n                                         []\n                                         (group-by first (take-while seq? (next s))))))\n                            (drop-while seq? (next s)))\n                     ret)))\n        r (:name (cljs.compiler/resolve-var (dissoc &env :locals) t))]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields)\n         (set! (.-cljs$core$IPrintable$_pr_seq ~t) (fn [this#] (list ~(str r))))\n         (extend-type ~t ~@(dt->et impls))\n         ~t)\n      `(do\n         (deftype* ~t ~fields)\n         (set! (.-cljs$core$IPrintable$_pr_seq ~t) (fn [this#] (list ~(str r))))\n         ~t))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [262 289]},
                                :full-name "cljs.core/deftype",
                                :history [["+" "0.0-927"]]},
           "cljs.core/Subvec" {:ns "cljs.core",
                               :name "Subvec",
                               :signature ["[meta v start end]"],
                               :name-encode "Subvec",
                               :type "type",
                               :full-name-encode "cljs.core/Subvec",
                               :source {:code "(deftype Subvec [meta v start end]\n  IWithMeta\n  (-with-meta [coll meta] (Subvec. meta v start end))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (= start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (Subvec. meta v start (dec end))))\n\n  ICollection\n  (-conj [coll o]\n    (Subvec. meta (-assoc-n v end o) start (inc end)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (= i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (-nth v (+ start n)))\n  (-nth [coll n not-found]\n    (-nth v (+ start n) not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (let [v-pos (+ start key)]\n      (Subvec. meta (-assoc v v-pos val)\n               start (max end (inc v-pos)))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2208 2278]},
                               :full-name "cljs.core/Subvec",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :name-encode "run-in-order",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/run-in-order",
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting\n         fns fns]\n    (if-let [f (get fns order)]\n      (do (f)\n          (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [206 212]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :signature ["[opts]"],
                                                  :name-encode "compile-client-js",
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/compile-client-js",
                                                  :source {:code "(defn compile-client-js [opts]\n  (cljsc/build '[(ns clojure.browser.repl.client\n                   (:require [goog.events :as event]\n                             [clojure.browser.repl :as repl]))\n                 (defn start [url]\n                   (event/listen js/window\n                                 \"load\"\n                                 (fn []\n                                   (repl/start-evaluator url))))]\n               {:optimizations (:optimizations opts)\n                :output-dir (:working-dir opts)}))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [302
                                                                   312]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/." {:ns "cljs.core",
                          :name ".",
                          :type "special form",
                          :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+]] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)\n         children    [enve]]\n     (case dot-action\n           ::access {:env env :op :dot :children children\n                     :target targetexpr\n                     :field field}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :children (into children argexprs)\n                       :target targetexpr\n                       :method method\n                       :args argexprs})))))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/clj/cljs/compiler.clj",
                                   :lines [977 992]},
                          :full-name "cljs.core/.",
                          :full-name-encode "cljs.core/DOT",
                          :name-encode "DOT",
                          :history [["+" "0.0-927"]]},
           "syntax/js-namespace" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "js-namespace",
                                  :name-encode "js-namespace",
                                  :type "special namespace",
                                  :full-name-encode "syntax/js-namespace",
                                  :full-name "syntax/js-namespace",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :name-encode "extend-protocol",
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core/extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :title "Source code",
                                                 :repo "clojure",
                                                 :tag "clojure-1.3.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [754 792]},
                                        :full-name "cljs.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :name-encode "read",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader/read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [res\n                 (cond\n                  (macros ch) ((macros ch) reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (= res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/reader.cljs",
                                        :lines [338 354]},
                               :full-name "cljs.reader/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
           "cljs.core/EmptyList" {:ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :name-encode "EmptyList",
                                  :type "type",
                                  :full-name-encode "cljs.core/EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] #_(throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1157 1189]},
                                  :full-name "cljs.core/EmptyList",
                                  :history [["+" "0.0-927"]]},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :name-encode "postwalk",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk/postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/clojure/walk.cljs",
                                             :lines [50 56]},
                                    :full-name "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :name-encode "edit",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/re-seq" {:ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :name-encode "re-seq",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (re-seq re post-match))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3018 3025]},
                               :full-name "cljs.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-list",
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-list",
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [203 205]},
                                    :full-name "cljs.reader/read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/Atom" {:ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :name-encode "Atom",
                             :type "type",
                             :full-name-encode "cljs.core/Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintable\n  (-pr-seq [a opts]\n    (concat  [\"#<Atom: \"] (-pr-seq state opts) \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3234 3258]},
                             :full-name "cljs.core/Atom",
                             :history [["+" "0.0-927"]]},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :name-encode "IMap",
                             :type "protocol",
                             :full-name-encode "cljs.core/IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (-dissoc [coll k]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [145 147]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring nil}],
                             :full-name "cljs.core/IMap",
                             :history [["+" "0.0-927"]]},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :signature ["[rdr _]"],
                                      :name-encode "read-vector",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-vector",
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [209 211]},
                                      :full-name "cljs.reader/read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :name-encode "join",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set/join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/set.cljs",
                                        :lines [102 130]},
                               :full-name "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "cljs.core/HashMap" {:ns "cljs.core",
                                :name "HashMap",
                                :signature ["[meta count hashobj]"],
                                :name-encode "HashMap",
                                :type "type",
                                :full-name-encode "cljs.core/HashMap",
                                :source {:code "(deftype HashMap [meta count hashobj]\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (.-length bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2502 2589]},
                                :full-name "cljs.core/HashMap",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :signature ["[opts conn request]"],
                                           :name-encode "handle-get",
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/handle-get",
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (if (.startsWith path \"/repl\")\n      (send-repl-client-page opts conn request)\n      (send-404 conn (:path request)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [182 186]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :history [["+" "0.0-927"]]},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :name-encode "int-pattern",
                                      :type "var",
                                      :full-name-encode "cljs.reader/int-pattern",
                                      :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [95]},
                                      :full-name "cljs.reader/int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y z]"
                                          "[a f x y z & more]"],
                              :name-encode "swapBANG",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (reset! a (f (.-state a))))\n  ([a f x]\n     (reset! a (f (.-state a) x)))\n  ([a f x y]\n     (reset! a (f (.-state a) x y)))\n  ([a f x y z]\n     (reset! a (f (.-state a) x y z)))\n  ([a f x y z & more]\n     (reset! a (apply f (.-state a) x y z more))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3288 3302]},
                              :full-name "cljs.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/finally" {:ns "cljs.core",
                                :name "finally",
                                :signature ["[expr*]"],
                                :name-encode "finally",
                                :history [["+" "0.0-927"]],
                                :type "special form",
                                :full-name-encode "cljs.core/finally",
                                :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [511 539]},
                                :full-name "cljs.core/finally",
                                :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/dec" {:ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :name-encode "dec",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [886 888]},
                            :extra-sources [{:code "(defmacro dec [x]\n  `(- ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [113 114]}],
                            :full-name "cljs.core/dec",
                            :docstring "Returns a number one less than num."},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :name-encode "remove-children",
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom/remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/cljs/clojure/browser/dom.cljs",
                                                           :lines [90
                                                                   94]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/get-validator" {:ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[iref]"],
                                      :name-encode "get-validator",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3330 3333]},
                                      :full-name "cljs.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :name-encode "collQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/collQMARK",
                              :source {:code "(defn coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [588 593]},
                              :full-name "cljs.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/bit-or" {:ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]"],
                               :name-encode "bit-or",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/bit-or",
                               :source {:code "(defn bit-or\n  [x y] (cljs.core/bit-or x y))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [943 945]},
                               :extra-sources [{:code "(defmacro bit-or\n  ([x y] (list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [148 150]}],
                               :full-name "cljs.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :name-encode "nfirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [442 445]},
                               :full-name "cljs.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:ns "cljs.core",
                             :name "keep",
                             :signature ["[f coll]"],
                             :name-encode "keep",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keep",
                             :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [x (f (first s))]\n        (if (nil? x)\n          (keep f (rest s))\n          (cons x (keep f (rest s)))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1578 1588]},
                             :full-name "cljs.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/take" {:ns "cljs.core",
                             :name "take",
                             :signature ["[n coll]"],
                             :name-encode "take",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/take",
                             :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1712 1719]},
                             :full-name "cljs.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
           "cljs.core/cond" {:ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :name-encode "cond",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [534 547]},
                             :full-name "cljs.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]"],
                                :name-encode "bit-and",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-and",
                                :source {:code "(defn bit-and\n  [x y] (cljs.core/bit-and x y))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [939 941]},
                                :extra-sources [{:code "(defmacro bit-and\n  ([x y] (list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [144 146]}],
                                :full-name "cljs.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :name-encode "ObjMapDOTfromObject",
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core/ObjMapDOTfromObject",
                                          :source {:code "(set! cljs.core.ObjMap/fromObject (fn [ks obj] (ObjMap. nil ks obj)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [2495]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :signature ["[event-type]"],
                                                    :name-encode "unique-event-id",
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unique-event-id",
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [92]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :name-encode "project",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "clojure.string/trim-newline" {:ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :name-encode "trim-newline",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/clojure/string.cljs",
                                                   :lines [121 131]},
                                          :full-name "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :signature ["[]"],
                                            :name-encode "stop-server",
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/stop-server",
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [254 256]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :history [["+" "0.0-927"]]},
           "syntax/namespace" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "namespace",
                               :name-encode "namespace",
                               :type "special character",
                               :full-name-encode "syntax/namespace",
                               :full-name "syntax/namespace",
                               :history [["+" "0.0-927"]]},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :name-encode "insert-left",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip/insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/true?" {:ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :name-encode "trueQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/trueQMARK",
                              :source {:code "(defn true?\n  [x] (cljs.core/true? x))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [645 647]},
                              :extra-sources [{:code "(defmacro true? [x]\n  (list 'js* \"~{} === true\" x))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [48 49]}],
                              :full-name "cljs.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :name-encode "xpc-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (.-strobj (reduce (fn [sum [k v]]\n                          (if-let [field (get xpc-config-fields k)]\n                            (assoc sum field v)\n                            sum))\n                       {}\n                       config)))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [118
                                                                  140]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/not" {:ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :name-encode "not",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/not",
                            :source {:code "(defn not\n  [x] (if x false true))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [475 477]},
                            :full-name "cljs.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:ns "cljs.core",
                               :name "js-obj",
                               :signature ["[]"],
                               :name-encode "js-obj",
                               :type "function",
                               :full-name-encode "cljs.core/js-obj",
                               :source {:code "(defn js-obj []\n  (js* \"{}\"))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [626 627]},
                               :full-name "cljs.core/js-obj",
                               :history [["+" "0.0-927"]]},
           "cljs.core/complement" {:ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :name-encode "complement",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/complement",
                                   :source {:code "(defn complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1486 1494]},
                                   :full-name "cljs.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :signature ["[arglist]"],
                               :name-encode "spread",
                               :type "function",
                               :full-name-encode "cljs.core/spread",
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1341 1347]},
                               :full-name "cljs.core/spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :name-encode "keyword",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/keyword",
                                :source {:code "(defn keyword\n  ([name] (cond (keyword? name) name\n                (symbol? name) (str* \"\\uFDD0\" \"'\" (subs name 2))\n                :else (str* \"\\uFDD0\" \"'\" name)))\n  ([ns name] (keyword (str* ns \"/\" name))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1078 1084]},
                                :full-name "cljs.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "cljs.core/sort" {:ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :name-encode "sort",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [748 760]},
                             :full-name "cljs.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :name-encode "trim",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/trim",
                                  :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [106 109]},
                                  :full-name "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :name-encode "meta",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/meta",
                             :source {:code "(defn meta\n  [o]\n  (when (satisfies? IMeta o)\n    (-meta o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [549 553]},
                             :full-name "cljs.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :name-encode "time",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/time",
                             :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.) ())\n         ret# ~expr]\n     (prn (str \"Elapsed time: \" (- (.getTime (js/Date.) ()) start#) \" msecs\"))\n     ret#))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [762 768]},
                             :full-name "cljs.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :name-encode "boolean",
                                :type "function",
                                :full-name-encode "cljs.core/boolean",
                                :source {:code "(defn boolean [x]\n  (if x true false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [662 663]},
                                :full-name "cljs.core/boolean",
                                :history [["+" "0.0-927"]]},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :signature ["[rdr initch]"],
                                     :name-encode "read-token",
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-token",
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [76 84]},
                                     :full-name "cljs.reader/read-token",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/update-in" {:ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f & args]"],
                                  :name-encode "update-in",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f args))\n     (assoc m k (apply f (get m k) args)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1924 1933]},
                                  :full-name "cljs.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f coll]"],
                                    :name-encode "map-indexed",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/map-indexed",
                                    :source {:code "(defn map-indexed\n  [f coll]\n  (let [mapi (fn mpi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (cons (f idx (first s))\n                        (mpi (inc idx) (rest s))))))]\n    (mapi 0 coll)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1565 1576]},
                                    :full-name "cljs.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :name-encode "IStack",
                               :type "protocol",
                               :full-name-encode "cljs.core/IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (-pop [coll]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [152 154]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring nil}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IStack",
                               :history [["+" "0.0-927"]]},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :name-encode "IIndexed",
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [130 131]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IIndexed",
                                 :history [["+" "0.0-927"]]},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :signature ["[data]"],
                                              :name-encode "repl-print",
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/repl-print",
                                              :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [23 25]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :name-encode "xpc-config-fields",
                                                    :type "var",
                                                    :full-name-encode "clojure.browser.net/xpc-config-fields",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [75
                                                                     81]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/nnext" {:ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :name-encode "nnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [452 455]},
                              :full-name "cljs.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :name-encode "STARprint-metaSTAR",
                                     :type "var",
                                     :full-name-encode "cljs.core/STARprint-metaSTAR",
                                     :source {:code "(def *print-meta* false)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3102]},
                                     :full-name "cljs.core/*print-meta*",
                                     :history [["+" "0.0-927"]]},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :signature ["[rdr _]"],
                                        :name-encode "read-dispatch",
                                        :type "function",
                                        :full-name-encode "cljs.reader/read-dispatch",
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (get dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (reader-error rdr \"No dispatch macro for \" ch))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [191 197]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/distinct" {:ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[coll]"],
                                 :name-encode "distinct",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/distinct",
                                 :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2733 2744]},
                                 :full-name "cljs.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :signature ["[sym]"],
                                          :name-encode "wrapping-reader",
                                          :type "function",
                                          :full-name-encode "cljs.reader/wrapping-reader",
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [277 280]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :name-encode "prn",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (newline (pr-opts)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [3152 3156]},
                            :full-name "cljs.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :name-encode "leftmost",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/>=" {:ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "GTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/GTEQ",
                           :source {:code "(defn >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [874 884]},
                           :extra-sources [{:code "(defmacro >=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} >= ~{})\" x y))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [103 106]}],
                           :full-name "cljs.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :signature ["[rdr]"],
                                             :name-encode "read-request",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-request",
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [160 164]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :history [["+" "0.0-927"]]},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :name-encode "macros",
                                 :type "var",
                                 :full-name-encode "cljs.reader/macros",
                                 :source {:code "(def macros\n     { \\\" read-string\n       \\: read-keyword\n       \\; not-implemented ;; never hit this\n       \\' (wrapping-reader 'quote)\n       \\@ (wrapping-reader 'deref)\n       \\^ read-meta\n       \\` not-implemented\n       \\~ not-implemented\n       \\( read-list\n       \\) read-unmatched-delimiter\n       \\[ read-vector\n       \\] read-unmatched-delimiter\n       \\{ read-map\n       \\} read-unmatched-delimiter\n       \\\\ read-char\n       \\% not-implemented\n       \\# read-dispatch\n       })",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/reader.cljs",
                                          :lines [310 328]},
                                 :full-name "cljs.reader/macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/doseq" {:ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :name-encode "doseq",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/doseq",
                              :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n                       \n                       seqsym (when-not (keyword? k) (gensym))\n                       recform (if (keyword? k) recform `(recur (first ~seqsym) ~seqsym))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     :else [true `(let [~seqsym (seq ~v)]\n                                    (when ~seqsym\n                                      (loop [~k (first ~seqsym) ~seqsym ~seqsym]\n                                       ~subform\n                                       (when-let [~seqsym (next ~seqsym)]\n                                        ~@(when needrec [recform])))))]))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [612 647]},
                              :full-name "cljs.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "STAR",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/STAR",
                          :source {:code "(defn *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [824 829]},
                          :extra-sources [{:code "(defmacro *\n  ([] 1)\n  ([x] x)\n  ([x y] (list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [77 81]}],
                          :full-name "cljs.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"],
                             :name-encode "into",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/into",
                             :source {:code "(defn into\n  [to from]\n  (reduce -conj to from))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1868 1872]},
                             :full-name "cljs.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :name-encode "defmethod",
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defmethod",
                                  :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core.MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [757 760]},
                                  :full-name "cljs.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :name-encode "rest",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rest",
                             :source {:code "(defn rest\n  [coll]\n  (-rest (seq coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [419 423]},
                             :full-name "cljs.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.core/dotimes" {:ns "cljs.core",
                                :name "dotimes",
                                :signature ["[bindings & body]"],
                                :name-encode "dotimes",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/dotimes",
                                :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [687 699]},
                                :full-name "cljs.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :name-encode "lefts",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :name-encode "ensure-element",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [105
                                                                  110]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :name-encode "defmacro",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmacro",
                                 :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [405 449]},
                                 :full-name "cljs.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:ns "cljs.core",
                               :name "remove",
                               :signature ["[pred coll]"],
                               :name-encode "remove",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/remove",
                               :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1839 1843]},
                               :full-name "cljs.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
           "cljs.core/ns" {:ns "cljs.core",
                           :name "ns",
                           :type "special form",
                           :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args] _]\n  (let [excludes\n        (reduce (fn [s [k exclude xs]]\n                  (if (= k :refer-clojure)\n                    (do\n                      (assert (= exclude :exclude) \"Only [:refer-clojure :exclude [names]] form supported\")\n                      (into s xs))\n                    s))\n                #{} args)\n        {uses :use requires :require uses-macros :use-macros requires-macros :require-macros :as params}\n        (reduce (fn [m [k & libs]]\n                  (assert (#{:use :use-macros :require :require-macros} k)\n                          \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")\n                  (assoc m k (into {}\n                                   (mapcat (fn [[lib kw expr]]\n                                             (case k\n                                               (:require :require-macros)\n                                               (do (assert (and expr (= :as kw))\n                                                           \"Only (:require [lib.ns :as alias]*) form of :require / :require-macros is supported\")\n                                                   [[expr lib]])\n                                               (:use :use-macros)\n                                               (do (assert (and expr (= :only kw))\n                                                           \"Only (:use [lib.ns :only [names]]*) form of :use / :use-macros is supported\")\n                                                   (map vector expr (repeat lib)))))\n                                           libs))))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (set! *cljs-ns* name)\n    (require 'cljs.core)\n    (doseq [nsym (concat (vals requires-macros) (vals uses-macros))]\n      (clojure.core/require nsym))\n    (swap! namespaces #(-> %\n                           (assoc-in [name :name] name)\n                           (assoc-in [name :excludes] excludes)\n                           (assoc-in [name :uses] uses)\n                           (assoc-in [name :requires] requires)\n                           (assoc-in [name :uses-macros] uses-macros)\n                           (assoc-in [name :requires-macros]\n                                     (into {} (map (fn [[alias nsym]]\n                                                     [alias (find-ns nsym)])\n                                                   requires-macros)))))\n    {:env env :op :ns :name name :uses uses :requires requires\n     :uses-macros uses-macros :requires-macros requires-macros :excludes excludes}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [844 886]},
                           :full-name "cljs.core/ns",
                           :full-name-encode "cljs.core/ns",
                           :name-encode "ns",
                           :history [["+" "0.0-927"]]},
           "cljs.core/if-not" {:ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :name-encode "if-not",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.3.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [702 708]},
                               :full-name "cljs.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :name-encode "path",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f coll]"
                                           "[f coll & colls]"],
                               :name-encode "mapcat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/mapcat",
                               :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1820 1826]},
                               :full-name "cljs.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :name-encode "IWatchable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [195 198]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring nil}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring nil}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IWatchable",
                                   :history [["+" "0.0-927"]]},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :name-encode "rightmost",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :signature ["[repl-env f]"],
                                  :name-encode "load-file",
                                  :type "function",
                                  :full-name-encode "cljs.repl/load-file",
                                  :source {:code "(defn load-file\n  [repl-env f]\n  (binding [comp/*cljs-ns* 'cljs.user]\n    (let [res (if (= \\/ (first f)) f (io/resource f))]\n      (assert res (str \"Can't find \" f \" in classpath\"))\n      (load-stream repl-env f res))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [98 103]},
                                  :full-name "cljs.repl/load-file",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/->" {:ns "cljs.core",
                           :name "->",
                           :signature ["[x]"
                                       "[x form]"
                                       "[x form & more]"],
                           :name-encode "-GT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/-GT",
                           :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1528 1538]},
                           :full-name "cljs.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :name-encode "remove-all-methods",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3739 3742]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "clojure.string/replace-first" {:ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :name-encode "replace-first",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/string.cljs",
                                                    :lines [36 43]},
                                           :full-name "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :name-encode "get-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [129 132]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :name-encode "process",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/process",
                                  :source {:code "(def process (js* \"process\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [8]},
                                  :full-name "cljs.nodejs/process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/not=" {:ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :name-encode "notEQ",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/notEQ",
                             :source {:code "(defn not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1435 1440]},
                             :full-name "cljs.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/js-keys" {:ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :name-encode "js-keys",
                                :type "function",
                                :full-name-encode "cljs.core/js-keys",
                                :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [629 632]},
                                :full-name "cljs.core/js-keys",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :name-encode "browser-eval",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n                   (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try (read-string ret)\n           (catch Exception e\n             {:status :error\n              :value (str \"Could not read return value: \" ret)})))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [258 273]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :name-encode "seq-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :name-encode "server-state",
                                             :type "var",
                                             :full-name-encode "cljs.repl.browser/server-state",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :name-encode "IVector",
                                :type "protocol",
                                :full-name-encode "cljs.core/IVector",
                                :source {:code "(defprotocol IVector\n  (-assoc-n [coll n val]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [156 157]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IVector",
                                :history [["+" "0.0-927"]]},
           "cljs.core/empty" {:ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :name-encode "empty",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/empty",
                              :source {:code "(defn empty\n  [coll]\n  (-empty coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [490 493]},
                              :full-name "cljs.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :name-encode "re-matches",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (= (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2997 3004]},
                                   :full-name "cljs.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :name-encode "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom/DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/cljs/clojure/browser/dom.cljs",
                                                      :lines [16 17]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[tsym & impls]"],
                                    :name-encode "extend-type",
                                    :type "macro",
                                    :full-name-encode "cljs.core/extend-type",
                                    :source {:code "(defmacro extend-type [tsym & impls]\n  (let [resolve #(let [ret (:name (cljs.compiler/resolve-var (dissoc &env :locals) %))]\n                   (assert ret (str \"Can't resolve: \" %))\n                   ret)\n        impl-map (loop [ret {} s impls]\n                   (if (seq s)\n                     (recur (assoc ret (first s) (take-while seq? (next s)))\n                            (drop-while seq? (next s)))\n                     ret))]\n    (if (base-type tsym)\n      (let [t (base-type tsym)\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pfn-prefix (subs (str psym) 0 (clojure.core/inc (.lastIndexOf (str psym) \".\")))]\n                             (cons `(aset ~psym ~t true)\n                                   (map (fn [[f & meths]]\n                                          `(aset ~(symbol (str pfn-prefix f)) ~t (fn ~@meths)))\n                                        sigs))))]\n        `(do ~@(mapcat assign-impls impl-map)))\n      (let [t (resolve tsym)\n            prototype-prefix (str t \".prototype.\")\n            assign-impls (fn [[p sigs]]\n                           (let [psym (resolve p)\n                                 pprefix (protocol-prefix psym)]\n                             (if (= p 'Object)\n                               (let [adapt-params (fn [[sig & body]]\n                                                    (let [[tname & args] sig]\n                                                      (list (with-meta (vec args) (meta sig))\n                                                            (list* 'this-as tname body))))]\n                                 (map (fn [[f & meths]]\n                                        `(set! ~(symbol (str prototype-prefix f)) (fn ~@(map adapt-params meths))))\n                                      sigs))\n                               (cons `(set! ~(symbol (str prototype-prefix pprefix)) true)\n                                     (map (fn [[f & meths]]\n                                            (let [ifn? (= psym 'cljs.core.IFn)\n                                                  pf (if ifn?\n                                                       (str prototype-prefix 'call)\n                                                       (str prototype-prefix pprefix f))\n                                                  adapt-params (fn [[[targ & args :as sig] & body]]\n                                                                 (let [tsym (gensym \"tsym\")]\n                                                                   `(~(with-meta (vec (cons tsym args)) (meta sig))\n                                                                     (this-as ~tsym\n                                                                              (let [~targ ~tsym]\n                                                                                ~@body)))))\n                                                  meths (if ifn?\n                                                          (map adapt-params meths)\n                                                          meths)]\n                                              `(set! ~(symbol pf) (fn ~@meths))))\n                                          sigs)))))]\n        `(do ~@(mapcat assign-impls impl-map))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [211 260]},
                                    :full-name "cljs.core/extend-type",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :name-encode "ISeqable",
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (-seq [o]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [180 181]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/ISeqable",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/assoc" {:ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :name-encode "assoc",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n     (-assoc coll k v))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [518 529]},
                              :full-name "cljs.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :name-encode "xpc-connection",
                                                  :type "var",
                                                  :full-name-encode "clojure.browser.repl/xpc-connection",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/cljs/clojure/browser/repl.cljs",
                                                           :lines [21]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :name-encode "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core/IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [162 163]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :name-encode "start-evaluator",
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl/start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText e/currentTarget\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1011",
                                                            :filename "src/cljs/clojure/browser/repl.cljs",
                                                            :lines [60
                                                                    88]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :name-encode "send-for-eval",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n     (send-for-eval @(connection) form return-value-fn))\n  ([conn form return-value-fn]\n     (do (set-return-value-fn return-value-fn)\n         (send-and-close conn 200 form \"text/javascript\"))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [99 107]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :name-encode "unlisten",
                                             :type "function",
                                             :full-name-encode "clojure.browser.event/unlisten",
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/cljs/clojure/browser/event.cljs",
                                                      :lines [62 69]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :history [["+" "0.0-927"]]},
           "syntax/dot" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "dot",
                         :name-encode "dot",
                         :type "special character",
                         :full-name-encode "syntax/dot",
                         :full-name "syntax/dot",
                         :history [["+" "0.0-927"]]},
           "cljs.core/do" {:ns "cljs.core",
                           :name "do",
                           :type "special form",
                           :source {:code "(defmethod parse 'do\n  [op env [_ & exprs] _]\n  (merge {:env env :op :do} (analyze-block env exprs)))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/clj/cljs/compiler.clj",
                                    :lines [761 763]},
                           :full-name "cljs.core/do",
                           :full-name-encode "cljs.core/do",
                           :name-encode "do",
                           :history [["+" "0.0-927"]]},
           "syntax/unused" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "unused",
                            :name-encode "unused",
                            :type "convention",
                            :full-name-encode "syntax/unused",
                            :full-name "syntax/unused",
                            :history [["+" "0.0-927"]]},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :name-encode "constrain-order",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-off ordering add-in-order order f)\n  (send-off ordering run-in-order))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1011",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [214
                                                                 219]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :name-encode "default-special-fns",
                                            :type "var",
                                            :full-name-encode "cljs.repl/default-special-fns",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [134 139]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/fnil" {:ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :name-encode "fnil",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1542 1563]},
                             :full-name "cljs.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :name-encode "this-as",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/this-as",
                                :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (~'js* \"this\")]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [205 209]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :signature ["[repl-env filename line js]"],
                                         :name-encode "rhino-eval",
                                         :type "function",
                                         :full-name-encode "cljs.repl.rhino/rhino-eval",
                                         :source {:code "(defn rhino-eval\n  [repl-env filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      {:status :exception\n       :value (.toString ex)\n       :stacktrace (stacktrace ex)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [57 66]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :signature ["[meta front rear]"],
                                           :name-encode "PersistentQueueSeq",
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentQueueSeq",
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (-first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2293 2323]},
                                           :full-name "cljs.core/PersistentQueueSeq",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/counted?" {:ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :name-encode "countedQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/countedQMARK",
                                 :source {:code "(defn counted?\n  [x] (satisfies? ICounted x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [610 612]},
                                 :full-name "cljs.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "compiler-options/use-only-custom-externs" {:ns "compiler-options",
                                                       :name "use-only-custom-externs",
                                                       :name-encode "use-only-custom-externs",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/use-only-custom-externs",
                                                       :full-name "compiler-options/use-only-custom-externs",
                                                       :history [["+"
                                                                  "0.0-971"]]},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :signature ["[rdr]"],
                                             :name-encode "read-headers",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-headers",
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [135 140]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :history [["+" "0.0-927"]]},
           "clojure.string/trimr" {:ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :name-encode "trimr",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/trimr",
                                   :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [116 119]},
                                   :full-name "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :name-encode "force",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3417 3422]},
                              :full-name "cljs.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :name-encode "compare-and-setBANG",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= a.state oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3304 3311]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :name-encode "setQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/setQMARK",
                             :source {:code "(defn set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [595 600]},
                             :full-name "cljs.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "cljs.core/load-file" {:ns "cljs.core",
                                  :name "load-file",
                                  :name-encode "load-file",
                                  :type "special form (repl)",
                                  :full-name-encode "cljs.core/load-file",
                                  :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                           :title "repl specials table",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [134 139]},
                                  :full-name "cljs.core/load-file",
                                  :repl-only? true,
                                  :history [["+" "0.0-927"]]},
           "clojure.string/escape" {:ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :name-encode "escape",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [144 160]},
                                    :full-name "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.core/remove-watch" {:ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[iref key]"],
                                     :name-encode "remove-watch",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3373 3378]},
                                     :full-name "cljs.core/remove-watch",
                                     :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :name-encode "IMultiFn",
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-dispatch [mf args]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3666 3674]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-dispatch",
                                            :signature ["[mf args]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn",
                                 :history [["+" "0.0-927"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :name-encode "endQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "clojure.set/superset?" {:ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[set1 set2]"],
                                    :name-encode "supersetQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.set/supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/clojure/set.cljs",
                                             :lines [138 142]},
                                    :full-name "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & {:keys [verbose warn-on-undeclared special-fns]}]"],
                             :name-encode "repl",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl/repl",
                             :source {:code "(defn repl\n  [repl-env & {:keys [verbose warn-on-undeclared special-fns]}]\n  (prn \"Type: \" :cljs/quit \" to quit\")\n  (binding [comp/*cljs-ns* 'cljs.user\n            *cljs-verbose* verbose\n            comp/*cljs-warn-on-undeclared* warn-on-undeclared]\n    (let [env {:context :statement :locals {}}\n          special-fns (merge default-special-fns special-fns)\n          is-special-fn? (set (keys special-fns))]\n      (-setup repl-env)\n      (loop []\n        (print (str \"ClojureScript:\" comp/*cljs-ns* \"> \"))\n        (flush)\n        (let [{:keys [status form]} (read-next-form)]\n          (cond\n           (= form :cljs/quit) :quit\n           \n           (= status :error) (recur)\n           \n           (and (seq? form) (is-special-fn? (first form)))\n           (do (apply (get special-fns (first form)) repl-env (rest form)) (newline) (recur))\n           \n           :else\n           (do (eval-and-print repl-env env form) (recur)))))\n      (-tear-down repl-env))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/clj/cljs/repl.clj",
                                      :lines [141 166]},
                             :full-name "cljs.repl/repl",
                             :docstring "Note - repl will reload core.cljs every time, even if supplied old repl-env"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :name-encode "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net/IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [32 44]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :name-encode "let",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/let",
                            :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args let\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [3953 3964]},
                            :full-name "cljs.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/dorun" {:ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "dorun",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2968 2979]},
                              :full-name "cljs.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :name-encode "pr-str",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3111 3114]},
                               :full-name "cljs.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintable."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :name-encode "IPrintable",
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IPrintable",
                                   :source {:code "(defprotocol IPrintable\n  (-pr-seq [o opts]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [189 190]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :name-encode "defprotocol",
                                    :type "macro",
                                    :full-name-encode "cljs.core/defprotocol",
                                    :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         ((or\n                           (aget ~(fqn fname) (goog.typeOf ~(first sig)))\n                           (aget ~(fqn fname) \"_\")\n                           (throw (missing-protocol\n                                    ~(str psym \".\" fname) ~(first sig))))\n                          ~@sig))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (str prefix (name fname)))]\n                   `(defn ~fname ~@(map #(expand-sig fname slot %) sigs))))]\n    `(do\n       (def ~psym (~'js* \"{}\"))\n       ~@(map method methods))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [398 420]},
                                    :full-name "cljs.core/defprotocol",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/assert" {:ns "cljs.core",
                               :name "assert",
                               :signature ["[x]" "[x message]"],
                               :name-encode "assert",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/assert",
                               :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [541 553]},
                               :full-name "cljs.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :name-encode "declare",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.3.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2665 2668]},
                                :full-name "cljs.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/fn?" {:ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :name-encode "fnQMARK",
                            :type "function",
                            :full-name-encode "cljs.core/fnQMARK",
                            :source {:code "(defn fn? [f]\n  (goog/isFunction f))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [681 682]},
                            :full-name "cljs.core/fn?",
                            :history [["+" "0.0-927"]]},
           "cljs.core/associative?" {:ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[x]"],
                                     :name-encode "associativeQMARK",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/associativeQMARK",
                                     :source {:code "(defn associative?\n  [x] (satisfies? IAssociative x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [602 604]},
                                     :full-name "cljs.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :signature ["[repl-env ns url]"],
                                              :name-encode "load-javascript",
                                              :type "function",
                                              :full-name-encode "cljs.repl.rhino/load-javascript",
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @loaded-libs %) ns)]\n    (when (seq missing)\n      (do (try \n            (-eval (io/reader url) repl-env (.toString url) 1)\n            ;; TODO: don't show errors for goog/base.js line number 105\n            (catch Throwable ex (println (.getMessage ex))))\n          (swap! loaded-libs (partial apply conj) missing)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/clj/cljs/repl/rhino.clj",
                                                       :lines [86 93]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/list*" {:ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :name-encode "listSTAR",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1369 1377]},
                              :full-name "cljs.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/reduce" {:ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :name-encode "reduce",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (-reduce coll f))\n  ([f val coll]\n     (-reduce coll f val)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [772 785]},
                               :full-name "cljs.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :name-encode "has-listener",
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/has-listener",
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [94]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/compare" {:ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :name-encode "compare",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/compare",
                                :source {:code "(defn compare\n  [x y] (garray/defaultCompare x y))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [727 731]},
                                :full-name "cljs.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\nwhen x is logically 'less than', 'equal to', or 'greater than'\ny. Uses google.array.defaultCompare."},
           "cljs.core/contains?" {:ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll v]"],
                                  :name-encode "containsQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/containsQMARK",
                                  :source {:code "(defn contains?\n  [coll v]\n  (if (identical? (-lookup coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [690 699]},
                                  :full-name "cljs.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :name-encode "prefer-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3749 3753]},
                                      :full-name "cljs.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array i]"],
                                  :name-encode "array-seq",
                                  :type "function",
                                  :full-name-encode "cljs.core/array-seq",
                                  :source {:code "(defn array-seq [array i]\n  (prim-seq array i))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [372 373]},
                                  :full-name "cljs.core/array-seq",
                                  :history [["+" "0.0-927"]]},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :signature ["[opts file-path]"],
                                                      :name-encode "create-client-js-file",
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/create-client-js-file",
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1011",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [314
                                                                       318]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :name-encode "STARcljs-verboseSTAR",
                                       :type "dynamic var",
                                       :full-name-encode "cljs.repl/STARcljs-verboseSTAR",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [16]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear]"],
                                        :name-encode "PersistentQueue",
                                        :type "type",
                                        :full-name-encode "cljs.core/PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (-first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear)\n        (PersistentQueue. meta (dec count) (seq rear) []))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o))\n      (PersistentQueue. meta (inc count) (conj front o) [])))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue/EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear))\n        cljs.core.List/EMPTY)))\n\n  ICounted\n  (-count [coll] count))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [2325 2369]},
                                        :full-name "cljs.core/PersistentQueue",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/drop-last" {:ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :name-encode "drop-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1731 1734]},
                                  :full-name "cljs.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs]"],
                                                   :name-encode "PersistentVectorDOTfromArray",
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core/PersistentVectorDOTfromArray",
                                                   :source {:code "(set! cljs.core.PersistentVector/fromArray (fn [xs] (into cljs.core.PersistentVector/EMPTY xs)))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1011",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [2201]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :name-encode "read-string",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [356 360]},
                                      :full-name "cljs.reader/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.core/vector?" {:ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :name-encode "vectorQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/vectorQMARK",
                                :source {:code "(defn vector?\n  [x] (satisfies? IVector x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [621 623]},
                                :full-name "cljs.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :name-encode "defmulti",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmulti",
                                 :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (string? (first options))\n                      (first options)\n                      nil)\n        options     (if (string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\"))\n    (let [options   (apply hash-map options)\n          default   (get options :default :default)\n          ;; hierarchy (get options :hierarchy #'cljs.core.global-hierarchy)\n\t  ]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n\t (let [method-table# (atom {})\n\t       prefer-table# (atom {})\n\t       method-cache# (atom {})\n\t       cached-hierarchy# (atom {})\n\t       hierarchy# (get ~options :hierarchy cljs.core/global-hierarchy)\n\t       ]\n\t   (cljs.core.MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n\t\t\t       method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [711 755]},
                                 :full-name "cljs.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "syntax/rest" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "rest",
                          :name-encode "rest",
                          :type "special character",
                          :full-name-encode "syntax/rest",
                          :full-name "syntax/rest",
                          :history [["+" "0.0-927"]]},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :name-encode "ListDOTEMPTY",
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core/ListDOTEMPTY",
                                   :source {:code "(set! cljs.core.List/EMPTY (EmptyList. nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1191]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :history [["+" "0.0-927"]]},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :signature ["[src event]"],
                                                   :name-encode "dispatch-event",
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/dispatch-event",
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1011",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [75
                                                                    77]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.string/split-lines" {:ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :name-encode "split-lines",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "clojure.string/split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/clojure/string.cljs",
                                                  :lines [101 104]},
                                         :full-name "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :name-encode "loaded-libs",
                                            :type "var",
                                            :full-name-encode "cljs.repl.browser/loaded-libs",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [30]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/areduce" {:ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :name-encode "areduce",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/areduce",
                                :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [676 685]},
                                :full-name "cljs.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the \nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :name-encode "disj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n     (-disjoin coll k))\n  ([coll k & ks]\n     (let [ret (disj coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [568 578]},
                             :full-name "cljs.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "compiler-options/main" {:ns "compiler-options",
                                    :name "main",
                                    :name-encode "main",
                                    :type "option",
                                    :full-name-encode "compiler-options/main",
                                    :full-name "compiler-options/main",
                                    :history [["+" "0.0-971"]]},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :name-encode "event-types",
                                              :type "var",
                                              :full-name-encode "clojure.browser.net/event-types",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [23 30]},
                                              :full-name "clojure.browser.net/event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :name-encode "lower-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (. s (toLowerCase)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [58 61]},
                                        :full-name "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :name-encode "STARprint-fnSTAR",
                                   :type "function",
                                   :full-name-encode "cljs.core/STARprint-fnSTAR",
                                   :source {:code "(def\n  ^{:doc \"Each runtime environment provides a diffenent way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\"}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [15 21]},
                                   :full-name "cljs.core/*print-fn*",
                                   :docstring "Each runtime environment provides a diffenent way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :name-encode "str",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (cond\n        (symbol? x) (. x (substring 2 (.-length x)))\n        (keyword? x) (str* \":\" (. x (substring 2 (.-length x))))\n        (nil? x) \"\"\n        :else (. x (toString))))\n  ([x & ys]\n     ((fn [sb more]\n        (if more\n          (recur (. sb  (append (str (first more)))) (next more))\n          (str* sb)))\n      (gstring/StringBuffer. (str x)) ys)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1048 1063]},
                            :full-name "cljs.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :name-encode "ISequential",
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [183 184]},
                                    :full-name "cljs.core/ISequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/try*" {:ns "cljs.core",
                             :name "try*",
                             :type "special form",
                             :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze-block\n                   (assoc env :context :statement)\n                   fblock))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        mname (when name (munge name))\n        locals (if name\n                 (assoc locals name {:name mname})\n                 locals)\n        catch (when cblock\n                (analyze-block (assoc catchenv :locals locals) (rest cblock)))\n        body (if name (pop body) body)\n        try (when body\n              (analyze-block (if (or name finally) catchenv env) body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name mname\n     :catch catch\n     :children [try {:name mname} catch finally]}))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/clj/cljs/compiler.clj",
                                      :lines [654 687]},
                             :full-name "cljs.core/try*",
                             :full-name-encode "cljs.core/trySTAR",
                             :name-encode "trySTAR",
                             :history [["+" "0.0-927"]]},
           "cljs.core/set" {:ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :name-encode "set",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/set",
                            :source {:code "(defn set\n  [coll]\n  (loop [in (seq coll)\n         out cljs.core.Set/EMPTY]\n    (if-not (empty? in)\n      (recur (rest in) (conj out (first in)))\n      out)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2710 2717]},
                            :full-name "cljs.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :name-encode "print",
                              :type "function",
                              :full-name-encode "cljs.core/print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3129 3134]},
                              :full-name "cljs.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption.",
                              :history [["+" "0.0-927"]]},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :name-encode "type",
                             :type "function",
                             :full-name-encode "cljs.core/type",
                             :source {:code "(defn type [x]\n  (js* \"(~{x}).constructor\"))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [219 220]},
                             :full-name "cljs.core/type",
                             :history [["+" "0.0-971"]]},
           "clojure.string/blank?" {:ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :name-encode "blankQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/blankQMARK",
                                    :source {:code "(defn blank?\n  [s]\n  (let [s (str s)]\n    (if (or\n         (not s)\n         (= \"\" s)\n         (re-matches #\"\\s+\" s))\n      true\n      false)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [133 142]},
                                    :full-name "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :signature ["[parent & children]"],
                                         :name-encode "append",
                                         :type "function",
                                         :full-name-encode "clojure.browser.dom/append",
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/clojure/browser/dom.cljs",
                                                  :lines [12 14]},
                                         :full-name "clojure.browser.dom/append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :name-encode "take-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1736 1743]},
                                  :full-name "cljs.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "clojure.set/intersection" {:ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :name-encode "intersection",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.set/intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "cljs.core/fnext" {:ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :name-encode "fnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [447 450]},
                              :full-name "cljs.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :name-encode "apply",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count args (inc fixed-arity))\n                 fixed-arity)\n           (.apply f f (to-array args))\n           (.cljs$lang$applyTo f args))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (if (<= (bounded-count arglist fixed-arity)\n                 fixed-arity)\n           (.apply f f (to-array arglist))\n           (.cljs$lang$applyTo f arglist))\n         (.apply f f (to-array arglist))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1381 1427]},
                              :full-name "cljs.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :name-encode "prewalk",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk/prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/clojure/walk.cljs",
                                            :lines [58 62]},
                                   :full-name "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :name-encode "flatten",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1860 1866]},
                                :full-name "cljs.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.core/get" {:ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :name-encode "get",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/get",
                            :source {:code "(defn get\n  ([o k]\n     (-lookup o k))\n  ([o k not-found]\n     (-lookup o k not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [511 516]},
                            :full-name "cljs.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.core/.." {:ns "cljs.core",
                           :name "..",
                           :signature ["[x form]" "[x form & more]"],
                           :name-encode "DOTDOT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1510 1526]},
                           :full-name "cljs.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/Range" {:ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step]"],
                              :name-encode "Range",
                              :type "type",
                              :full-name-encode "cljs.core/Range",
                              :source {:code "(deftype Range [meta start end step]\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeq\n  (-first [rng] start)\n  (-rest [rng]\n    (if (-seq rng)\n      (Range. meta (+ start step) end step)\n      (list)))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (hash-coll rng))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (= step 0))\n        start\n        not-found)))\n\n  ISeqable\n  (-seq [rng]\n    (let [comp (if (pos? step) < >)]\n      (when (comp start end)\n        rng)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2819 2874]},
                              :full-name "cljs.core/Range",
                              :history [["+" "0.0-927"]]},
           "cljs.core/zero?" {:ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :name-encode "zeroQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/zeroQMARK",
                              :source {:code "(defn zero? [n]\n  (cljs.core/zero? n))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [999 1000]},
                              :extra-sources [{:code "(defmacro zero? [x]\n  `(== ~x 0))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [119 120]}],
                              :full-name "cljs.core/zero?"},
           "cljs.core/identity" {:ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :name-encode "identity",
                                 :type "function",
                                 :full-name-encode "cljs.core/identity",
                                 :source {:code "(defn identity [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1484]},
                                 :full-name "cljs.core/identity",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/first" {:ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :name-encode "first",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/first",
                              :source {:code "(defn first\n  [coll]\n  (when-let [s (seq coll)]\n    (-first s)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [412 417]},
                              :full-name "cljs.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :name-encode "ratio-pattern",
                                        :type "var",
                                        :full-name-encode "cljs.reader/ratio-pattern",
                                        :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [96]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :name-encode "println-str",
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3147 3150]},
                                    :full-name "cljs.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.core/>" {:ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "GT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/GT",
                          :source {:code "(defn >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [862 872]},
                          :extra-sources [{:code "(defmacro >\n  ([x] true)\n  ([x y] (list 'js* \"(~{} > ~{})\" x y))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [98 101]}],
                          :full-name "cljs.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.core/juxt" {:ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :name-encode "juxt",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2932 2966]},
                             :full-name "cljs.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.core/max" {:ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "max",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/max",
                            :source {:code "(defn max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [890 895]},
                            :extra-sources [{:code "(defmacro max\n  ([x] x)\n  ([x y] (list 'js* \"((~{} > ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [128 131]}],
                            :full-name "cljs.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/*3" {:ns "cljs.core",
                           :name "*3",
                           :name-encode "STAR3",
                           :type "var",
                           :full-name-encode "cljs.core/STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [31 33]},
                           :full-name "cljs.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.core/number?" {:ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :name-encode "numberQMARK",
                                :type "function",
                                :full-name-encode "cljs.core/numberQMARK",
                                :source {:code "(defn number? [n]\n  (goog/isNumber n))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [678 679]},
                                :full-name "cljs.core/number?",
                                :history [["+" "0.0-927"]]},
           "cljs.core/array" {:ns "cljs.core",
                              :name "array",
                              :signature ["[var-args]"],
                              :name-encode "array",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/array",
                              :source {:code "(defn array\n  [var-args]            ;; [& items]\n  (js* \"Array.prototype.slice.call(arguments)\"))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [71 75]},
                              :extra-sources [{:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply str))]\n   (concat\n    (list 'js* (str \"[\" xs-str \"]\"))\n    rest)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [649 656]}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :name-encode "nthnext",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1010 1016]},
                                :full-name "cljs.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :name-encode "re-pattern",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n    (js/RegExp. pattern flags)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3027 3031]},
                                   :full-name "cljs.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :signature ["[proto obj]"],
                                         :name-encode "missing-protocol",
                                         :type "function",
                                         :full-name-encode "cljs.core/missing-protocol",
                                         :source {:code "(defn missing-protocol [proto obj]\n  (js/Error (js* \"~{}+~{}+~{}+~{}+~{}+~{}\"\n                 \"No protocol method \" proto\n                 \" defined for type \" (goog/typeOf obj) \": \" obj)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [58 61]},
                                         :full-name "cljs.core/missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :name-encode "set-text",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom/set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/browser/dom.cljs",
                                                    :lines [122 127]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :name-encode "up",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip/up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :name-encode "IWithMeta",
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (-with-meta [o meta]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [168 169]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IWithMeta",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/bit-and-not" {:ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"],
                                    :name-encode "bit-and-not",
                                    :history [["+" "0.0-927"]],
                                    :type "function/macro",
                                    :full-name-encode "cljs.core/bit-and-not",
                                    :source {:code "(defn bit-and-not\n  [x y] (cljs.core/bit-and-not x y))",
                                             :title "Function code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [947 949]},
                                    :extra-sources [{:code "(defmacro bit-and-not\n  ([x y] (list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :title "Macro code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/clj/cljs/core.clj",
                                                     :lines [156 158]}],
                                    :full-name "cljs.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :name-encode "triml",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/triml",
                                   :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [111 114]},
                                   :full-name "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "compiler-options/output-dir" {:ns "compiler-options",
                                          :name "output-dir",
                                          :name-encode "output-dir",
                                          :type "option",
                                          :full-name-encode "compiler-options/output-dir",
                                          :full-name "compiler-options/output-dir",
                                          :history [["+" "0.0-971"]]},
           "clojure.string/split" {:ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :name-encode "split",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/split",
                                   :source {:code "(defn split\n  ([s re]\n     (vec (.split (str s) re)))\n  ([s re limit]\n     (if (< limit 1)\n       (vec (.split (str s) re))\n       (loop [s s\n              limit limit\n              parts []]\n         (if (= limit 1)\n           (conj parts s)\n           (if-let [m (re-find re s)]\n             (let [index (.indexOf s m)]\n               (recur (.substring s (+ index (count m)))\n                      (dec limit)\n                      (conj parts (.substring s 0 index))))\n             (conj parts s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [81 99]},
                                   :full-name "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.core/hash-map" {:ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :name-encode "hash-map",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out cljs.core.HashMap/EMPTY]\n    (if in\n      (recur (nnext in) (assoc out (first in) (second in)))\n      out)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2600 2607]},
                                 :full-name "cljs.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/rem" {:ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :name-encode "rem",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (js* \"(~{n} - (~{d} * ~{q}))\")))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [920 924]},
                            :full-name "cljs.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :name-encode "IRecord",
                                :type "protocol",
                                :full-name-encode "cljs.core/IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [186 187]},
                                :full-name "cljs.core/IRecord",
                                :docstring "Marker interface indicating a record object",
                                :history [["+" "0.0-927"]]},
           "cljs.core/constantly" {:ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :name-encode "constantly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1496 1498]},
                                   :full-name "cljs.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :signature ["[id]"],
                                              :name-encode "get-element",
                                              :type "function",
                                              :full-name-encode "clojure.browser.dom/get-element",
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/clojure/browser/dom.cljs",
                                                       :lines [96 97]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/and" {:ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :name-encode "and",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/and",
                            :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n   `(let [and# ~x]\n      (if and# (and ~@next) and#))))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [777 787]},
                            :full-name "cljs.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :signature ["[t data]"],
                                                :name-encode "wrap-message",
                                                :type "function",
                                                :full-name-encode "clojure.browser.repl/wrap-message",
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1011",
                                                         :filename "src/cljs/clojure/browser/repl.cljs",
                                                         :lines [57
                                                                 58]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :signature ["[key]"],
                                                    :name-encode "unlisten-by-key",
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unlisten-by-key",
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [71
                                                                     73]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/new" {:ns "cljs.core",
                            :name "new",
                            :type "special form",
                            :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))]\n     {:env env :op :new :ctor ctorexpr :args argexprs :children (conj argexprs ctorexpr)})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [816 822]},
                            :full-name "cljs.core/new",
                            :full-name-encode "cljs.core/new",
                            :name-encode "new",
                            :history [["+" "0.0-927"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :signature ["[& forms]"],
                            :name-encode "try",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/try",
                            :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [511 539]},
                            :full-name "cljs.core/try",
                            :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/iterate" {:ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :name-encode "iterate",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1783 1786]},
                                :full-name "cljs.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :name-encode "lazy-seq",
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-seq",
                                 :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core.LazySeq nil false (fn [] ~@body)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [434 435]},
                                 :full-name "cljs.core/lazy-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/IndexedSeq" {:ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[a i]"],
                                   :name-encode "IndexedSeq",
                                   :type "type",
                                   :full-name-encode "cljs.core/IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [a i]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] (aget a i))\n  (-rest [_] (if (< (inc i) (.-length a))\n               (IndexedSeq. a (inc i))\n               (list)))\n\n  ICounted\n  (-count [_] (- (.-length a) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (.-length a))\n        (aget a i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (.-length a))\n        (aget a i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IReduce\n  (-reduce [_ f]\n    (ci-reduce a f (aget a i) (inc i)))\n  (-reduce [_ f start]\n    (ci-reduce a f start i))\n\n  IHash\n  (-hash [coll] (hash-coll coll)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [329 366]},
                                   :full-name "cljs.core/IndexedSeq",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/next" {:ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :name-encode "next",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/next",
                             :source {:code "(defn next\n  [coll]\n  (when coll\n    (seq (rest coll))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [425 430]},
                             :full-name "cljs.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :name-encode "STARprint-readablySTAR",
                                         :type "var",
                                         :full-name-encode "cljs.core/STARprint-readablySTAR",
                                         :source {:code "(def *print-readably* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3101]},
                                         :full-name "cljs.core/*print-readably*",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :signature ["[]"],
                                               :name-encode "repl-client-js",
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/repl-client-js",
                                               :source {:code "(defn repl-client-js []\n  (slurp @(:client-js @server-state)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [166
                                                                167]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :name-encode "parse-headers",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [115
                                                               123]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/last" {:ns "cljs.core",
                             :name "last",
                             :signature ["[s]"],
                             :name-encode "last",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/last",
                             :source {:code "(defn last\n  [s]\n  (if (next s)\n    (recur (next s))\n    (first s)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [457 462]},
                             :full-name "cljs.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/bit-shift-left" {:ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :name-encode "bit-shift-left",
                                       :history [["+" "0.0-927"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [975 977]},
                                       :extra-sources [{:code "(defmacro bit-shift-left [x n]\n  (list 'js* \"(~{} << ~{})\" x n))",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [169
                                                                170]}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :name-encode "reverse",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [18 21]},
                                     :full-name "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "min",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/min",
                            :source {:code "(defn min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [897 902]},
                            :extra-sources [{:code "(defmacro min\n  ([x] x)\n  ([x y] (list 'js* \"((~{} < ~{}) ? ~{} : ~{})\" x y x y))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [133 136]}],
                            :full-name "cljs.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :signature ["[buffer reader]"],
                                      :name-encode "escape-char",
                                      :type "function",
                                      :full-name-encode "cljs.reader/escape-char",
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (get escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (if (or (= \\u ch) (numeric? ch))\n        (read-unicode-char reader ch)\n        (reader-error reader \"Unsupported escape charater: \\\\\" ch)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [149 157]},
                                      :full-name "cljs.reader/escape-char",
                                      :history [["+" "0.0-927"]]},
           "syntax/auto-gensym" {:syntax-equiv {:edn-url nil,
                                                :clj-url nil},
                                 :ns "syntax",
                                 :name "auto-gensym",
                                 :name-encode "auto-gensym",
                                 :type "special character",
                                 :full-name-encode "syntax/auto-gensym",
                                 :full-name "syntax/auto-gensym",
                                 :history [["+" "0.0-927"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-map",
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-map",
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [213 218]},
                                   :full-name "cljs.reader/read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :name-encode "seq",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/seq",
                            :source {:code "(defn seq\n  [coll]\n  (when coll\n    (-seq coll)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [404 410]},
                            :full-name "cljs.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/defrecord*" {:ns "cljs.core",
                                   :name "defrecord*",
                                   :type "special form",
                                   :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :defrecord* :t t :fields fields}))",
                                            :title "Parser code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [901 912]},
                                   :full-name "cljs.core/defrecord*",
                                   :full-name-encode "cljs.core/defrecordSTAR",
                                   :name-encode "defrecordSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/not-empty" {:ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :name-encode "not-empty",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1442 1444]},
                                  :full-name "cljs.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :name-encode "println",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (newline (pr-opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3141 3145]},
                                :full-name "cljs.core/println",
                                :docstring "Same as print followed by (newline)"},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :name-encode "connect",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl/connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! iframe.style.display\n                         \"none\")))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/browser/repl.cljs",
                                                    :lines [90 109]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :signature ["[parent child index]"],
                                            :name-encode "insert-at",
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/insert-at",
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [102 103]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :name-encode "quot",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (mod n d)]\n    (fix (js* \"((~{n} - ~{rem}) / ~{d})\"))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [914 918]},
                             :full-name "cljs.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :name-encode "get-listener",
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/get-listener",
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [89]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:ns "cljs.core",
                               :name "filter",
                               :signature ["[pred coll]"],
                               :name-encode "filter",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/filter",
                               :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (let [f (first s) r (rest s)]\n        (if (pred f)\n          (cons f (filter pred r))\n          (filter pred r)))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1828 1837]},
                               :full-name "cljs.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :name-encode "branchQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "cljs.core/ObjMap" {:ns "cljs.core",
                               :name "ObjMap",
                               :signature ["[meta keys strobj]"],
                               :name-encode "ObjMap",
                               :type "type",
                               :full-name-encode "cljs.core/ObjMap",
                               :source {:code "(deftype ObjMap [meta keys strobj]\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (.-length keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (.-length keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (obj-map-contains-key? k strobj (aget strobj k) not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (goog/isString k)\n      (let [new-strobj (goog.object/clone strobj)\n            overwrite? (.hasOwnProperty new-strobj k)]\n        (aset new-strobj k v)\n        (if overwrite?\n          (ObjMap. meta keys new-strobj)     ; overwrite\n          (let [new-keys (aclone keys)] ; append\n            (.push new-keys k)\n            (ObjMap. meta new-keys new-strobj))))\n      ; non-string key. game over.\n      (with-meta (into (hash-map k v) (seq coll)) meta)))\n  (-contains-key? [coll k]\n    (obj-map-contains-key? k strobj))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and (goog/isString k) (.hasOwnProperty strobj k))\n      (let [new-keys (aclone keys)\n            new-strobj (goog.object/clone strobj)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2423 2491]},
                               :full-name "cljs.core/ObjMap",
                               :history [["+" "0.0-927"]]},
           "cljs.core/zipmap" {:ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :name-encode "zipmap",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map {}\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        map)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2774 2784]},
                               :full-name "cljs.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :signature ["[seed hash]"],
                                     :name-encode "hash-combine",
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-combine",
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1100 1104]},
                                     :full-name "cljs.core/hash-combine",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/max-key" {:ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "max-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2786 2791]},
                                :full-name "cljs.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :signature ["[conn path]"],
                                         :name-encode "send-404",
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/send-404",
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [91 97]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :name-encode "defrecord",
                                  :type "macro",
                                  :full-name-encode "cljs.core/defrecord",
                                  :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [r (:name (cljs.compiler/resolve-var (dissoc &env :locals) rsym))]\n    `(let []\n       ~(emit-defrecord rsym r fields impls)\n       (set! (.-cljs$core$IPrintable$_pr_seq ~r) (fn [this#] (list ~(str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [389 396]},
                                  :full-name "cljs.core/defrecord",
                                  :history [["+" "0.0-927"]]},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :name-encode "repl-env",
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/repl-env",
                                         :source {:code "(defn repl-env [& {:as opts}]\n  (let [opts (merge {:port 9000 :optimizations :simple :working-dir \".repl\"} opts)]\n    (do (swap! server-state\n               (fn [old] (assoc old :client-js\n                               (future (create-client-js-file\n                                        opts\n                                        (io/file (:working-dir opts) \"client.js\"))))))\n        opts)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [320 327]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/butlast" {:ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :name-encode "butlast",
                                :type "function",
                                :full-name-encode "cljs.core/butlast",
                                :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2747 2751]},
                                :full-name "cljs.core/butlast",
                                :history [["+" "0.0-927"]]},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :name-encode "print-str",
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3136 3139]},
                                  :full-name "cljs.core/print-str",
                                  :docstring "print to a string, returning it"},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :name-encode "hash",
                             :type "function",
                             :full-name-encode "cljs.core/hash",
                             :source {:code "(defn hash [o]\n  (-hash o))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [580 581]},
                             :full-name "cljs.core/hash",
                             :history [["+" "0.0-927"]]},
           "cljs.core/bit-set" {:ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :name-encode "bit-set",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [965 968]},
                                :extra-sources [{:code "(defmacro bit-set [x n]\n  (list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [175 176]}],
                                :full-name "cljs.core/bit-set",
                                :docstring "Set bit at index n"},
           "cljs.core/concat" {:ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :name-encode "concat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (cons (first s) (concat (rest s) y))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (cons (first xys) (cat (rest xys) zs))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1349 1367]},
                               :full-name "cljs.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.core/conj" {:ns "cljs.core",
                             :name "conj",
                             :signature ["[coll x]" "[coll x & xs]"],
                             :name-encode "conj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/conj",
                             :source {:code "(defn conj\n  ([coll x]\n     (-conj coll x))\n  ([coll x & xs]\n     (if xs\n       (recur (conj coll x) (first xs) (next xs))\n       (conj coll x))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [479 488]},
                             :full-name "cljs.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "clojure.set/difference" {:ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :name-encode "difference",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/when-first" {:ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :name-encode "when-first",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args when-first\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when (seq ~xs)\n       (let [~x (first ~xs)]\n         ~@body))))",
                                            :title "Source code",
                                            :repo "clojure",
                                            :tag "clojure-1.3.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4050 4062]},
                                   :full-name "cljs.core/when-first",
                                   :docstring "bindings => x xs\n\nSame as (when (seq xs) (let [x (first xs)] body))"},
           "cljs.core/distinct?" {:ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :name-encode "distinctQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/distinctQMARK",
                                  :source {:code "(defn distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [709 723]},
                                  :full-name "cljs.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[]"],
                                       :name-encode "repl-env",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino/repl-env",
                                       :source {:code "(defn repl-env\n  []\n  (let [cx (Context/enter)\n        scope (.initStandardObjects cx)\n        base (io/resource \"goog/base.js\")\n        deps (io/resource \"goog/deps.js\")\n        new-repl-env {:cx cx :scope scope}]\n    (assert base \"Can't find goog/base.js in classpath\")\n    (assert deps \"Can't find goog/deps.js in classpath\")\n    (swap! current-repl-env (fn [old] new-repl-env))\n    (with-open [r (io/reader base)]\n      (-eval r new-repl-env \"goog/base.js\" 1))\n    (-eval bootjs new-repl-env \"bootjs\" 1)\n    ;; Load deps.js line-by-line to avoid 64K method limit\n    (doseq [^String line (line-seq (io/reader deps))]\n      (-eval line new-repl-env \"goog/deps.js\" 1))\n    new-repl-env))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/repl/rhino.clj",
                                                :lines [122 140]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/pos?" {:ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :name-encode "posQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/posQMARK",
                             :source {:code "(defn pos?\n  [n] (cljs.core/pos? n))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [995 997]},
                             :extra-sources [{:code "(defmacro pos? [x]\n  `(> ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [122 123]}],
                             :full-name "cljs.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "cljs.core/PersistentVector" {:ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail]"],
                                         :name-encode "PersistentVector",
                                         :type "type",
                                         :full-name-encode "cljs.core/PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail]\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (= 1 cnt) (-with-meta cljs.core.PersistentVector/EMPTY meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (aclone tail))\n      :else (let [new-tail (array-for coll (- cnt 2))\n                  nr (pop-tail shift root)\n                  new-root (if (nil? nr) cljs.core.PersistentVector/EMPTY_NODE nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (aget new-root 0) new-tail)\n                (PersistentVector. meta cnt-1 shift new-root new-tail)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [new-tail (aclone tail)]\n        (.push new-tail o)\n        (PersistentVector. meta (inc cnt) shift root new-tail))\n      (let [root-overflow? (> (bit-shift-right cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (aclone cljs.core.PersistentVector/EMPTY_NODE)]\n                           (aset n-r 0 root)\n                           (aset n-r 1 (new-path shift tail))\n                           n-r)\n                       (push-tail coll shift root tail))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o)))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (> cnt 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i cnt)\n                   (cons (-nth coll i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (cond\n       (and (<= 0 k) (< k cnt))\n       (if (<= (tail-off coll) k)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and k 0x01f) v)\n           (PersistentVector. meta cnt shift root new-tail))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root k v) tail))\n       (= k cnt) (-conj coll v)\n       :else (throw (js/Error. (str \"Index \" k \" out of bounds  [0,\" cnt \"]\")))))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f start]\n    (ci-reduce v f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2096 2197]},
                                         :full-name "cljs.core/PersistentVector",
                                         :history [["+" "0.0-1006"]]},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :name-encode "IHash",
                              :type "protocol",
                              :full-name-encode "cljs.core/IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [177 178]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IHash",
                              :history [["+" "0.0-927"]]},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :signature ["[x]"],
                                  :name-encode "is_proto_",
                                  :type "function",
                                  :full-name-encode "cljs.core/is_proto_",
                                  :source {:code "(defn is_proto_\n  [x]\n  (js* \"(~{x}).constructor.prototype === ~{x}\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [48 50]},
                                  :full-name "cljs.core/is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/keep-indexed" {:ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f coll]"],
                                     :name-encode "keep-indexed",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f coll]\n     (let [keepi (fn kpi [idx coll]\n                   (lazy-seq\n                    (when-let [s (seq coll)]\n                      (let [x (f idx (first s))]\n                        (if (nil? x)\n                          (kpi (inc idx) (rest s))\n                          (cons x (kpi (inc idx) (rest s))))))))]\n       (keepi 0 coll))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1590 1602]},
                                     :full-name "cljs.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/bit-shift-right" {:ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :name-encode "bit-shift-right",
                                        :history [["+" "0.0-927"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [979 981]},
                                        :extra-sources [{:code "(defmacro bit-shift-right [x n]\n  (list 'js* \"(~{} >> ~{})\" x n))",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r1011",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [172
                                                                 173]}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "compiler-options/print-input-delimiter" {:ns "compiler-options",
                                                     :name "print-input-delimiter",
                                                     :name-encode "print-input-delimiter",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/print-input-delimiter",
                                                     :full-name "compiler-options/print-input-delimiter",
                                                     :history [["+"
                                                                "0.0-971"]]},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-right",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :name-encode "make-hierarchy",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [3506 3508]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :name-encode "repeat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1767 1770]},
                               :full-name "cljs.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/destructure-map" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "destructure-map",
                                     :name-encode "destructure-map",
                                     :type "binding",
                                     :full-name-encode "syntax/destructure-map",
                                     :source {:code "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n               (let [pvec\n                     (fn [bvec b val]\n                       (let [gvec (gensym \"vec__\")]\n                         (loop [ret (-> bvec (conj gvec) (conj val))\n                                n 0\n                                bs b\n                                seen-rest? false]\n                           (if (seq bs)\n                             (let [firstb (first bs)]\n                               (cond\n                                (= firstb '&) (recur (pb ret (second bs) (list `nthnext gvec n))\n                                                     n\n                                                     (nnext bs)\n                                                     true)\n                                (= firstb :as) (pb ret (second bs) gvec)\n                                :else (if seen-rest?\n                                        (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                        (recur (pb ret firstb  (list `nth gvec n nil))\n                                               (inc n)\n                                               (next bs)\n                                               seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (let [gmap (or (:as b) (gensym \"map__\"))\n                             defaults (:or b)]\n                         (loop [ret (-> bvec (conj gmap) (conj v)\n                                        (conj gmap) (conj `(if (seq? ~gmap) (apply hash-map ~gmap) ~gmap)))\n                                bes (reduce1\n                                     (fn [bes entry]\n                                       (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]\n                           (if (seq bes)\n                             (let [bb (key (first bes))\n                                   bk (val (first bes))\n                                   has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (list `get gmap bk (defaults bb))\n                                                   (list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                 (cond\n                  (symbol? b) (-> bvec (conj b) (conj v))\n                  (vector? b) (pvec bvec b v)\n                  (map? b) (pmap bvec b v)\n                  :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))",
                                              :title "Parser code",
                                              :repo "clojure",
                                              :tag "clojure-1.3.0",
                                              :filename "src/clj/clojure/core.clj",
                                              :lines [3896 3951]},
                                     :full-name "syntax/destructure-map",
                                     :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :signature ["[rule]"],
                                           :name-encode "goog-require",
                                           :type "function",
                                           :full-name-encode "cljs.repl.rhino/goog-require",
                                           :source {:code "(defn goog-require [rule]\n  (when-not (contains? @loaded-libs rule)\n    (let [repl-env @current-repl-env\n          path (string/replace (comp/munge rule) \\. java.io.File/separatorChar)\n          cljs-path (str path \".cljs\")\n          js-path (str \"goog/\"\n                       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                              repl-env\n                              \"<cljs repl>\"\n                              1))]\n      (if-let [res (io/resource cljs-path)]\n        (binding [comp/*cljs-ns* 'cljs.user]\n          (repl/load-stream repl-env res))\n        (if-let [res (io/resource js-path)]\n          (-eval (io/reader res) repl-env js-path 1)\n          (throw (Exception. (str \"Cannot find \" cljs-path \" or \" js-path \" in classpath\")))))\n      (swap! loaded-libs conj rule))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [68 84]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :name-encode "prn-str-with-opts",
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (let [sb (pr-sb objs opts)]\n    (.append sb \\newline)\n    (str sb)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [3077 3082]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :name-encode "MultiFn",
                                :type "type",
                                :full-name-encode "cljs.core/MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-dispatch [mf args] (do-dispatch mf dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog.getUid this)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3684 3731]},
                                :full-name "cljs.core/MultiFn",
                                :history [["+" "0.0-927"]]},
           "cljs.core/not-any?" {:ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :name-encode "not-anyQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/not-anyQMARK",
                                 :source {:code "(defn not-any?\n  [pred coll] (not (some pred coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1469 1472]},
                                 :full-name "cljs.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :signature ["[rdr ch]"],
                                     :name-encode "read-regex",
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-regex",
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string rdr ch) re-pattern))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [301 303]},
                                     :full-name "cljs.reader/read-regex",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :name-encode "next",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :name-encode "IFn",
                            :type "protocol",
                            :full-name-encode "cljs.core/IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q s]\n    [this a b c d e f g h i j k l m n o p q s t]\n    [this a b c d e f g h i j k l m n o p q s t rest]))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [94 116]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q s]"
                                                   "[this a b c d e f g h i j k l m n o p q s t]"
                                                   "[this a b c d e f g h i j k l m n o p q s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn",
                            :history [["+" "0.0-971"]]},
           "cljs.core/aget" {:ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"],
                             :name-encode "aget",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aget",
                             :source {:code "(defn aget\n  [array i]\n  (cljs.core/aget array i))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [77 80]},
                             :extra-sources [{:code "(defmacro aget [a i]\n  (list 'js* \"(~{}[~{}])\" a i))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [60 61]}],
                             :full-name "cljs.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:ns "cljs.core",
                               :name "if-let",
                               :signature ["[bindings then]"
                                           "[bindings then else & oldform]"],
                               :name-encode "if-let",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args if-let\n     (and (vector? bindings) (nil? oldform)) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.3.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1666 1683]},
                               :full-name "cljs.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "SLASH",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/SLASH",
                          :source {:code "(defn /\n  ([x] (/ 1 x))\n  ([x y] (js* \"(~{x} / ~{y})\")) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [831 836]},
                          :extra-sources [{:code "(defmacro /\n  ([x] `(/ 1 ~x))\n  ([x y] (list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [83 86]}],
                          :full-name "cljs.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/min-key" {:ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "min-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2793 2798]},
                                :full-name "cljs.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :name-encode "root",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred coll]"],
                                   :name-encode "drop-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/drop-while",
                                   :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1745 1754]},
                                   :full-name "cljs.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :signature ["[opts conn request]"],
                                                      :name-encode "send-repl-client-page",
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/send-repl-client-page",
                                                      :source {:code "(defn send-repl-client-page\n  [opts conn request]\n  (send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1011",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [169
                                                                       180]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :name-encode "evaluate-javascript",
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl/evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch js/Error e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r1011",
                                                                :filename "src/cljs/clojure/browser/repl.cljs",
                                                                :lines [27
                                                                        36]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "cljs.core/set-validator!" {:ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[iref val]"],
                                       :name-encode "set-validatorBANG",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [3320 3328]},
                                       :full-name "cljs.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "cljs.core/<" {:ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "LT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/LT",
                          :source {:code "(defn <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r1011",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [838 848]},
                          :extra-sources [{:code "(defmacro <\n  ([x] true)\n  ([x y] (list 'js* \"(~{} < ~{})\" x y))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [88 91]}],
                          :full-name "cljs.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.core/catch" {:ns "cljs.core",
                              :name "catch",
                              :signature ["[protoname name expr*]"],
                              :name-encode "catch",
                              :history [["+" "0.0-927"]],
                              :type "special form",
                              :full-name-encode "cljs.core/catch",
                              :source {:code "(defmacro try\n  [& forms]\n  (let [catch? #(and (list? %) (= (first %) 'catch))\n        [body catches] (split-with (complement catch?) forms)\n        [catches fin] (split-with catch? catches)\n        e (gensym \"e\")]\n    (assert (every? #(clojure.core/> (count %) 2) catches) \"catch block must specify a prototype and a name\")\n    (if (seq catches)\n      `(~'try*\n        ~@body\n        (catch ~e\n            (cond\n             ~@(mapcat\n                (fn [[_ type name & cb]]\n                  `[(instance? ~type ~e) (let [~name ~e] ~@cb)])\n                catches)\n             :else (throw ~e)))\n        ~@fin)\n      `(~'try*\n        ~@body\n        ~@fin))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [511 539]},
                              :full-name "cljs.core/catch",
                              :docstring "(try expr* catch-clause* finally-clause?)\n\n Special Form\n\n catch-clause => (catch protoname name expr*)\n finally-clause => (finally expr*)\n\nCatches and handles JavaScript exceptions."},
           "cljs.core/deftype*" {:ns "cljs.core",
                                 :name "deftype*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields] _]\n  (let [t (munge (:name (resolve-var (dissoc env :locals) tsym)))]\n    (swap! namespaces update-in [(-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {}) :name t)]\n               (if-let [line (:line env)]\n                 (-> m\n                     (assoc :file *cljs-file*)\n                     (assoc :line line))\n                 m))))\n    {:env env :op :deftype* :t t :fields fields}))",
                                          :title "Parser code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/clj/cljs/compiler.clj",
                                          :lines [888 899]},
                                 :full-name "cljs.core/deftype*",
                                 :full-name-encode "cljs.core/deftypeSTAR",
                                 :name-encode "deftypeSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/fn" {:ns "cljs.core",
                           :name "fn",
                           :signature ["[& sigs]"],
                           :name-encode "fn",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) (list sigs) sigs)\n          psig (fn* [sig]\n                 (let [[params & body] sig\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [3985 4023]},
                           :full-name "cljs.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :name-encode "split-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2892 2895]},
                                   :full-name "cljs.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :name-encode "IReduce",
                                :type "protocol",
                                :full-name-encode "cljs.core/IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [171 172]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IReduce",
                                :history [["+" "0.0-927"]]},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :name-encode "symbol-pattern",
                                         :type "var",
                                         :full-name-encode "cljs.reader/symbol-pattern",
                                         :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [98]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/repeatedly" {:ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :name-encode "repeatedly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1776 1781]},
                                   :full-name "cljs.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :signature ["[delim rdr recursive?]"],
                                              :name-encode "read-delimited-list",
                                              :type "function",
                                              :full-name-encode "cljs.reader/read-delimited-list",
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a []]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF\"))\n      (if (= delim ch)\n        a\n        (if-let [macrofn (get macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (= mret rdr) a (conj a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (= o rdr) a (conj a o))))))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [168
                                                               181]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/undefined?" {:ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :name-encode "undefinedQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/undefinedQMARK",
                                   :source {:code "(defn undefined? [x]\n  (cljs.core/undefined? x))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [649 650]},
                                   :extra-sources [{:code "(defmacro undefined? [x]\n  (list 'js* \"(void 0 === ~{})\" x))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [54 55]}],
                                   :full-name "cljs.core/undefined?"},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :name-encode "prev",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:ns "cljs.core",
                             :name "seq?",
                             :signature ["[s]"],
                             :name-encode "seqQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/seqQMARK",
                             :source {:code "(defn seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [655 660]},
                             :full-name "cljs.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :name-encode "prn-str",
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core/prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3116 3119]},
                                :full-name "cljs.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/odd?" {:ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :name-encode "oddQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/oddQMARK",
                             :source {:code "(defn odd?\n  [n] (not (even? n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1480 1482]},
                             :full-name "cljs.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:ns "cljs.core",
                             :name "cons",
                             :signature ["[x seq]"],
                             :name-encode "cons",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/cons",
                             :source {:code "(defn cons\n  [x seq]\n  (Cons. nil x seq))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1228 1231]},
                             :full-name "cljs.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-set",
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-set",
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [297 299]},
                                   :full-name "cljs.reader/read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :name-encode "descendants",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @global-hierarchy tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3550 3557]},
                                    :full-name "cljs.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on Java type inheritance\nrelationships."},
           "cljs.core/take-nth" {:ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n coll]"],
                                 :name-encode "take-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/take-nth",
                                 :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2885 2890]},
                                 :full-name "cljs.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :signature ["[msg]"],
                                          :name-encode "throwing-reader",
                                          :type "function",
                                          :full-name-encode "cljs.reader/throwing-reader",
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [282 285]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/even?" {:ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :name-encode "evenQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/evenQMARK",
                              :source {:code "(defn even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1474 1478]},
                              :full-name "cljs.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "compiler-options/foreign-libs" {:ns "compiler-options",
                                            :name "foreign-libs",
                                            :name-encode "foreign-libs",
                                            :type "option",
                                            :full-name-encode "compiler-options/foreign-libs",
                                            :full-name "compiler-options/foreign-libs",
                                            :history [["+" "0.0-971"]]},
           "clojure.set/subset?" {:ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[set1 set2]"],
                                  :name-encode "subsetQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [132 136]},
                                  :full-name "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :name-encode "flush",
                              :type "function",
                              :full-name-encode "cljs.core/flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3045 3046]},
                              :full-name "cljs.core/flush",
                              :history [["+" "0.0-927"]]},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :signature ["[rdr & msg]"],
                                       :name-encode "reader-error",
                                       :type "function",
                                       :full-name-encode "cljs.reader/reader-error",
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (apply str msg)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.reader/reader-error",
                                       :history [["+" "0.0-927"]]},
           "compiler-options/externs" {:ns "compiler-options",
                                       :name "externs",
                                       :name-encode "externs",
                                       :type "option",
                                       :full-name-encode "compiler-options/externs",
                                       :full-name "compiler-options/externs",
                                       :history [["+" "0.0-971"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :name-encode "prewalk-replace",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [80 86]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.core/*1" {:ns "cljs.core",
                           :name "*1",
                           :name-encode "STAR1",
                           :type "var",
                           :full-name-encode "cljs.core/STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [23 25]},
                           :full-name "cljs.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :name-encode "SetDOTEMPTY",
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core/SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :history [["+" "0.0-927"]]},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :signature ["[reader initch]"],
                                            :name-encode "read-unicode-char",
                                            :type "function",
                                            :full-name-encode "cljs.reader/read-unicode-char",
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [145 147]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/dissoc" {:ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :name-encode "dissoc",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n     (-dissoc coll k))\n  ([coll k & ks]\n     (let [ret (dissoc coll k)]\n       (if ks\n         (recur ret (first ks) (next ks))\n         ret))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [531 541]},
                               :full-name "cljs.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.core/ffirst" {:ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :name-encode "ffirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [437 440]},
                               :full-name "cljs.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :name-encode "replace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :name-encode "vec",
                            :type "function",
                            :full-name-encode "cljs.core/vec",
                            :source {:code "(defn vec [coll]\n  (reduce conj cljs.core.PersistentVector/EMPTY coll))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2203 2204]},
                            :full-name "cljs.core/vec",
                            :history [["+" "0.0-927"]]},
           "cljs.core/or" {:ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :name-encode "or",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/or",
                           :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n      `(let [or# ~x]\n         (if or# or# (or ~@next)))))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.3.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [789 799]},
                           :full-name "cljs.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/mod" {:ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :name-encode "mod",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/mod",
                            :source {:code "(defn mod\n  [n d]\n  (cljs.core/mod n d))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [909 912]},
                            :extra-sources [{:code "(defmacro mod [num div]\n  (list 'js* \"(~{} % ~{})\" num div))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [138 139]}],
                            :full-name "cljs.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"],
                             :name-encode "aset",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aset",
                             :source {:code "(defn aset\n  [array i val]\n  (cljs.core/aset array i val))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [82 85]},
                             :extra-sources [{:code "(defmacro aset [a i v]\n  (list 'js* \"(~{}[~{}] = ~{})\" a i v))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [63 64]}],
                             :full-name "cljs.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.core/second" {:ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :name-encode "second",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [432 435]},
                               :full-name "cljs.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/set!" {:ns "cljs.core",
                             :name "set!",
                             :type "special form",
                             :source {:code "(defmethod parse 'set!\n  [_ env [_ target val] _]\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         targetexpr (if (symbol? target)\n                      (do\n                        (let [local (-> env :locals target)]\n                          (assert (or (nil? local)\n                                      (and (:field local)\n                                           (:mutable local)))\n                                  \"Can't set! local var or non-mutable field\"))\n                        (analyze-symbol enve target))\n                      (when (seq? target)\n                        (let [targetexpr (analyze-seq enve target nil)]\n                          (when (:field targetexpr)\n                            targetexpr))))\n         valexpr (analyze enve val)]\n     (assert targetexpr \"set! target must be a field or a symbol naming a var\")\n     {:env env :op :set! :target targetexpr :val valexpr :children [targetexpr valexpr]})))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/clj/cljs/compiler.clj",
                                      :lines [824 842]},
                             :full-name "cljs.core/set!",
                             :full-name-encode "cljs.core/setBANG",
                             :name-encode "setBANG",
                             :history [["+" "0.0-927"]]},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :name-encode "rename",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [83 86]},
                                 :full-name "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/delay?" {:ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :name-encode "delayQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/delayQMARK",
                               :source {:code "(defn delay?\n  [x] (instance? cljs.core.Delay x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3413 3415]},
                               :full-name "cljs.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :name-encode "left",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :signature ["[rdr ch]"],
                                          :name-encode "not-implemented",
                                          :type "function",
                                          :full-name-encode "cljs.reader/not-implemented",
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [187 189]},
                                          :full-name "cljs.reader/not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :name-encode "IAssociative",
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (-contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (-assoc [coll k v]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [140 143]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring nil}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IAssociative",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :name-encode "ObjMapDOTEMPTY",
                                     :parent-type "ObjMap",
                                     :type "var",
                                     :full-name-encode "cljs.core/ObjMapDOTEMPTY",
                                     :source {:code "(set! cljs.core.ObjMap/EMPTY (ObjMap. nil (array) (js-obj)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2493]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/group-by" {:ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :name-encode "group-by",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3495 3504]},
                                 :full-name "cljs.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :name-encode "symbol",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/symbol",
                               :source {:code "(defn symbol\n  ([name] (cond (symbol? name) name\n                (keyword? name) (str* \"\\uFDD1\" \"'\" (subs name 2)))\n     :else (str* \"\\uFDD1\" \"'\" name))\n  ([ns name] (symbol (str* ns \"/\" name))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1071 1076]},
                               :full-name "cljs.core/symbol",
                               :docstring "Returns a Symbol with the given namespace and name."},
           "cljs.core/Delay" {:ns "cljs.core",
                              :name "Delay",
                              :signature ["[state f]"],
                              :name-encode "Delay",
                              :type "type",
                              :full-name-encode "cljs.core/Delay",
                              :source {:code "(deftype Delay [state f]\n  IDeref\n  (-deref [_]\n    (:value (swap! state (fn [{:keys [done] :as curr-state}]\n                           (if done\n                             curr-state,\n                             {:done true :value (f)})))))\n\n  IPending\n  (-realized? [d]\n    (:done @state)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3401 3411]},
                              :full-name "cljs.core/Delay",
                              :history [["+" "0.0-927"]]},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :name-encode "methods",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3755 3757]},
                                :full-name "cljs.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.core/vector" {:ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :name-encode "vector",
                               :type "function",
                               :full-name-encode "cljs.core/vector",
                               :source {:code "(defn vector [& args] (vec args))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2206]},
                               :full-name "cljs.core/vector",
                               :history [["+" "0.0-927"]]},
           "cljs.core/rand-int" {:ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :name-encode "rand-int",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-int",
                                 :source {:code "(defn rand-int\n  [n] (js* \"Math.floor(Math.random() * ~{n})\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3484 3486]},
                                 :full-name "cljs.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/throw" {:ns "cljs.core",
                              :name "throw",
                              :type "special form",
                              :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/compiler.clj",
                                       :lines [647 652]},
                              :full-name "cljs.core/throw",
                              :full-name-encode "cljs.core/throw",
                              :name-encode "throw",
                              :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :name-encode "PersistentQueueDOTEMPTY",
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core/PersistentQueueDOTEMPTY",
                                              :source {:code "(set! cljs.core.PersistentQueue/EMPTY (PersistentQueue. nil 0 nil []))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [2371]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/letfn" {:ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :name-encode "letfn",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.3.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5751 5762]},
                              :full-name "cljs.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.core/recur" {:ns "cljs.core",
                              :name "recur",
                              :type "special form",
                              :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)]\n    (assert frame \"Can't recur here\")\n    (assert (= (count exprs) (count (:names frame))) \"recur argument count mismatch\")\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur}\n      :frame frame\n      :exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs))))))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/compiler.clj",
                                       :lines [801 810]},
                              :full-name "cljs.core/recur",
                              :full-name-encode "cljs.core/recur",
                              :name-encode "recur",
                              :history [["+" "0.0-927"]]},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :signature ["[rdr _]"],
                                       :name-encode "read-discard",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-discard",
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [305 308]},
                                       :full-name "cljs.reader/read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/inc" {:ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :name-encode "inc",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [302 304]},
                            :extra-sources [{:code "(defmacro inc [x]\n  `(+ ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [116 117]}],
                            :full-name "cljs.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/name" {:ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :name-encode "name",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/name",
                             :source {:code "(defn name\n  [x]\n  (cond\n    (string? x) x\n    (or (keyword? x) (symbol? x))\n      (let [i (.lastIndexOf x \"/\")]\n        (if (< i 0)\n          (subs x 2)\n          (subs x (inc i))))\n    :else (throw (js/Error. (str \"Doesn't support name: \" x)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2753 2763]},
                             :full-name "cljs.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.core/cycle" {:ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :name-encode "cycle",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1756 1760]},
                              :full-name "cljs.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "cljs.core/fn*" {:ns "cljs.core",
                            :name "fn*",
                            :type "special form",
                            :source {:code "(defmethod parse 'fn*\n  [op env [_ & args] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        mname (when name (munge name))\n        locals (:locals env)\n        locals (if name (assoc locals name {:name mname}) locals)\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        methods (map #(analyze-fn-method menv locals %) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))]\n    ;;todo - validate unique arities, at most one variadic, variadic takes max required args\n    {:env env :op :fn :name mname :methods methods :variadic variadic\n     :recur-frames *recur-frames* :loop-lets *loop-lets*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [741 759]},
                            :full-name "cljs.core/fn*",
                            :full-name-encode "cljs.core/fnSTAR",
                            :name-encode "fnSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/map" {:ns "cljs.core",
                            :name "map",
                            :signature ["[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :name-encode "map",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/map",
                            :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (cons (f (first s)) (map f (rest s))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1682 1710]},
                            :full-name "cljs.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/amap" {:ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :name-encode "amap",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/amap",
                             :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [661 674]},
                             :full-name "cljs.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting \neach element of ret to the evaluation of expr, returning the new \narray ret."},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :name-encode "children",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "cljs.core/when-not" {:ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :name-encode "when-not",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.3.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [460 464]},
                                 :full-name "cljs.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :name-encode "index",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [88 96]},
                                :full-name "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :name-encode "send-and-close",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [68 89]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :signature ["[& args]"],
                                      :name-encode "log",
                                      :type "function",
                                      :full-name-encode "clojure.browser.dom/log",
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/clojure/browser/dom.cljs",
                                               :lines [19 20]},
                                      :full-name "clojure.browser.dom/log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :name-encode "VectorDOTfromArray",
                                         :history [["+" "0.0-927"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core/VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2024]},
                                         :full-name "cljs.core/Vector.fromArray"},
           "syntax/impure" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "impure",
                            :name-encode "impure",
                            :type "convention",
                            :full-name-encode "syntax/impure",
                            :full-name "syntax/impure",
                            :history [["+" "0.0-927"]]},
           "cljs.core/partition-by" {:ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f coll]"],
                                     :name-encode "partition-by",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/partition-by",
                                     :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2897 2906]},
                                     :full-name "cljs.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
           "cljs.core/sort-by" {:ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :name-encode "sort-by",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [762 770]},
                                :full-name "cljs.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[o meta]"],
                                  :name-encode "with-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (-with-meta o meta))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [543 547]},
                                  :full-name "cljs.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:ns "cljs.core",
                                   :name "NeverEquiv",
                                   :signature ["[]"],
                                   :name-encode "NeverEquiv",
                                   :type "type",
                                   :full-name-encode "cljs.core/NeverEquiv",
                                   :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2373 2375]},
                                   :full-name "cljs.core/NeverEquiv",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/select-keys" {:ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keyseq]"],
                                    :name-encode "select-keys",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2643 2655]},
                                    :full-name "cljs.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :name-encode "ISeq",
                             :type "protocol",
                             :full-name-encode "cljs.core/ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (-rest [coll]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [133 135]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring nil}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISeq",
                             :history [["+" "0.0-927"]]},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :name-encode "postwalk-replace",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk/postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/cljs/clojure/walk.cljs",
                                                     :lines [88 94]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :name-encode "pr-with-opts",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (let [first-obj (first objs)]\n    (doseq [obj objs]\n      (when-not (identical? obj first-obj)\n        (string-print \" \"))\n      (doseq [string (pr-seq obj opts)]\n        (string-print string)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3084 3093]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts"},
           "cljs.core/->>" {:ns "cljs.core",
                            :name "->>",
                            :signature ["[x form]" "[x form & more]"],
                            :name-encode "-GTGT",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/-GTGT",
                            :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.3.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1540 1549]},
                            :full-name "cljs.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.core/nil?" {:ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :name-encode "nilQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/nilQMARK",
                             :source {:code "(defn nil?\n  [x]\n  (identical? x nil))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [214 217]},
                             :extra-sources [{:code "(defmacro nil? [x]\n  `(identical? ~x nil))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [45 46]}],
                             :full-name "cljs.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:return-type String,
                                     :ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :name-encode "bootjs",
                                     :type "var",
                                     :full-name-encode "cljs.repl.rhino/bootjs",
                                     :source {:code "(def ^String bootjs (str \"goog.require = function(rule){\"\n                         \"Packages.clojure.lang.RT[\\\"var\\\"](\\\"cljs.repl.rhino\\\",\\\"goog-require\\\")\"\n                         \".invoke(rule);}\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/clj/cljs/repl/rhino.clj",
                                              :lines [22 24]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/load-namespace" {:ns "cljs.core",
                                       :name "load-namespace",
                                       :name-encode "load-namespace",
                                       :type "special form (repl)",
                                       :full-name-encode "cljs.core/load-namespace",
                                       :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns] (set! comp/*cljs-ns* (second quoted-ns)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                :title "repl specials table",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [134 139]},
                                       :full-name "cljs.core/load-namespace",
                                       :repl-only? true,
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :name-encode "stringify-keys",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk/stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/clojure/walk.cljs",
                                                   :lines [72 78]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :name-encode "order",
                                         :type "var",
                                         :full-name-encode "clojure.browser.repl/order",
                                         :source {:code "(def order (atom 0))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/clojure/browser/repl.cljs",
                                                  :lines [55]},
                                         :full-name "clojure.browser.repl/order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :name-encode "memoize",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3448 3460]},
                                :full-name "cljs.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :name-encode "pr-sequential",
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-sequential",
                                      :source {:code "(defn pr-sequential [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3035 3039]},
                                      :full-name "cljs.core/pr-sequential",
                                      :history [["+" "0.0-927"]]},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :name-encode "make-node",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :name-encode "PersistentVectorDOTEMPTY",
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core/PersistentVectorDOTEMPTY",
                                               :source {:code "(set! cljs.core.PersistentVector/EMPTY (PersistentVector. nil 0 5 cljs.core.PersistentVector/EMPTY_NODE (array)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [2200]},
                                               :full-name "cljs.core/PersistentVector.EMPTY",
                                               :history [["+"
                                                          "0.0-1006"]]},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :name-encode "float-pattern",
                                        :type "var",
                                        :full-name-encode "cljs.reader/float-pattern",
                                        :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [97]},
                                        :full-name "cljs.reader/float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :name-encode "ancestors",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @global-hierarchy tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3542 3548]},
                                  :full-name "cljs.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a Java type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/integer?" {:ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :name-encode "integerQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/integerQMARK",
                                 :source {:code "(defn integer?\n  [n]\n  (and (number? n)\n       (js* \"(~{n} == ~{n}.toFixed())\")))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [684 688]},
                                 :full-name "cljs.core/integer?",
                                 :docstring "Returns true if n is an integer.  Warning: returns true on underflow condition."},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :name-encode "HashMapDOTEMPTY",
                                      :parent-type "HashMap",
                                      :type "var",
                                      :full-name-encode "cljs.core/HashMapDOTEMPTY",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2591]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :name-encode "VectorDOTEMPTY",
                                     :parent-type "Vector",
                                     :type "var",
                                     :full-name-encode "cljs.core/VectorDOTEMPTY",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2022]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :name-encode "xml-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :name-encode "walk",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk/walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/clojure/walk.cljs",
                                         :lines [37 48]},
                                :full-name "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/bit-xor" {:ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]"],
                                :name-encode "bit-xor",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-xor",
                                :source {:code "(defn bit-xor\n  [x y] (cljs.core/bit-xor x y))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [935 937]},
                                :extra-sources [{:code "(defmacro bit-xor\n  ([x y] (list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [152 154]}],
                                :full-name "cljs.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :name-encode "union",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :name-encode "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl/IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [this] \"initialize the environment\")\n  (-evaluate [this filename line js] \"evaluate a javascript string\")\n  (-load [this ns url] \"load code at url into the environment\")\n  (-tear-down [this] \"dispose of the environment\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [18 22]},
                                       :methods [{:name "-setup",
                                                  :signature ["[this]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[this filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[this ns url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[this]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :name-encode "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader/PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [12 15]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/isa?" {:ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :name-encode "isaQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/isaQMARK",
                             :source {:code "(defn isa?\n  ([child parent] (isa? @global-hierarchy child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (= (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (= i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3514 3532]},
                             :full-name "cljs.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a Java type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :name-encode "xhr-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [83
                                                                  86]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/subs" {:ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :name-encode "subs",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1065 1069]},
                             :full-name "cljs.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "cljs.core/symbol?" {:ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :name-encode "symbolQMARK",
                                :type "function",
                                :full-name-encode "cljs.core/symbolQMARK",
                                :source {:code "(defn symbol? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD1)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [674 676]},
                                :full-name "cljs.core/symbol?",
                                :history [["+" "0.0-927"]]},
           "clojure.string/replace" {:ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :name-encode "replace",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [23 34]},
                                     :full-name "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :name-encode "stringQMARK",
                                :type "function",
                                :full-name-encode "cljs.core/stringQMARK",
                                :source {:code "(defn string? [x]\n  (and (goog/isString x)\n       (not (or (= (.charAt x 0) \\uFDD0)\n                (= (.charAt x 0) \\uFDD1)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [665 668]},
                                :full-name "cljs.core/string?",
                                :history [["+" "0.0-927"]]},
           "cljs.core/partition-all" {:ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n coll]"
                                                  "[n step coll]"],
                                      :name-encode "partition-all",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/partition-all",
                                      :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2800 2808]},
                                      :full-name "cljs.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
           "cljs.core/merge-with" {:ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :name-encode "merge-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2627 2641]},
                                   :full-name "cljs.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :name-encode "set-properties",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (.-strobj m)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [134
                                                                  138]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :name-encode "trampoline",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3462 3476]},
                                   :full-name "cljs.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :signature ["[opts conn]"],
                                                  :name-encode "handle-connection",
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/handle-connection",
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1011",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [230
                                                                   238]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :name-encode "send-print",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [41 53]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :name-encode "ICounted",
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ICounted",
                                 :source {:code "(defprotocol ICounted\n  (-count [coll] \"constant time count\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [118 119]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "constant time count"}],
                                 :full-name "cljs.core/ICounted",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/quote" {:ns "cljs.core",
                              :name "quote",
                              :type "special form",
                              :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  {:op :constant :env env :form x})",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/compiler.clj",
                                       :lines [812 814]},
                              :full-name "cljs.core/quote",
                              :full-name-encode "cljs.core/quote",
                              :name-encode "quote",
                              :history [["+" "0.0-927"]]},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :name-encode "IEquiv",
                               :type "protocol",
                               :full-name-encode "cljs.core/IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (-equiv [o other]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [174 175]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IEquiv",
                               :history [["+" "0.0-927"]]},
           "cljs.core/js-delete" {:ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :name-encode "js-delete",
                                  :type "function",
                                  :full-name-encode "cljs.core/js-delete",
                                  :source {:code "(defn js-delete [obj key]\n  (js* \"delete ~{obj}[~{key}]\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [634 635]},
                                  :full-name "cljs.core/js-delete",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/comment" {:ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :name-encode "comment",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.3.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4161 4164]},
                                :full-name "cljs.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :name-encode "special-symbols",
                                          :type "var",
                                          :full-name-encode "cljs.reader/special-symbols",
                                          :source {:code "(def special-symbols\n  {\"nil\" nil\n   \"true\" true\n   \"false\" false})",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [243 246]},
                                          :full-name "cljs.reader/special-symbols",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/js*" {:ns "cljs.core",
                            :name "js*",
                            :type "special form",
                            :source {:code "(defmethod parse 'js*\n  [op env [_ form & args] _]\n  (assert (string? form))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (cons (subs s 0 idx) (seg (subs s (inc end))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       {:env env :op :js :segs (seg form) :args argexprs :children argexprs}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (cons (subs s 0 idx) (cons inner (interp (subs s (inc end)))))))))]\n      {:env env :op :js :code (apply str (interp form))})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [994 1015]},
                            :full-name "cljs.core/js*",
                            :full-name-encode "cljs.core/jsSTAR",
                            :name-encode "jsSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/alength" {:ns "cljs.core",
                                :name "alength",
                                :signature ["[array]"],
                                :name-encode "alength",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/alength",
                                :source {:code "(defn alength\n  [array]\n  (.-length array))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [87 90]},
                                :extra-sources [{:code "(defmacro alength [a]\n  (list 'js* \"~{}.length\" a))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r1011",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [658 659]}],
                                :full-name "cljs.core/alength",
                                :docstring "Returns the length of the Java array. Works on arrays of all types."},
           "cljs.core/tree-seq" {:ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :name-encode "tree-seq",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1845 1858]},
                                 :full-name "cljs.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :signature ["[rdr ch]"],
                                                   :name-encode "read-unmatched-delimiter",
                                                   :type "function",
                                                   :full-name-encode "cljs.reader/read-unmatched-delimiter",
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1011",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [199
                                                                    201]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/every-pred" {:ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :name-encode "every-pred",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1604 1641]},
                                   :full-name "cljs.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :name-encode "rename-keys",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set/rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/clojure/set.cljs",
                                               :lines [72 81]},
                                      :full-name "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :name-encode "peek",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/peek",
                             :source {:code "(defn peek\n  [coll]\n  (-peek coll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [555 559]},
                             :full-name "cljs.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :name-encode "pr-str-with-opts",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (str (pr-sb objs opts)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3071 3075]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/map?" {:ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :name-encode "mapQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapQMARK",
                             :source {:code "(defn map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [614 619]},
                             :full-name "cljs.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "syntax/predicate" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "predicate",
                               :name-encode "predicate",
                               :type "convention",
                               :full-name-encode "syntax/predicate",
                               :full-name "syntax/predicate",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/StringPushbackReader" {:ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :signature ["[s index-atom buffer-atom]"],
                                               :name-encode "StringPushbackReader",
                                               :type "type",
                                               :full-name-encode "cljs.reader/StringPushbackReader",
                                               :source {:code "(deftype StringPushbackReader [s index-atom buffer-atom]\n  PushbackReader\n  (read-char [reader]\n             (if (empty? @buffer-atom)\n               (let [idx @index-atom]\n                 (swap! index-atom inc)\n                 (nth s idx))\n               (let [buf @buffer-atom]\n                 (swap! buffer-atom rest)\n                 (first buf))))\n  (unread [reader ch] (swap! buffer-atom #(cons ch %))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [18 28]},
                                               :full-name "cljs.reader/StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :name-encode "HashMapDOTfromArrays",
                                           :history [["+" "0.0-927"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core/HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (.-length ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2593 2598]},
                                           :full-name "cljs.core/HashMap.fromArrays"},
           "cljs.core/deref" {:ns "cljs.core",
                              :name "deref",
                              :signature ["[o]"],
                              :name-encode "deref",
                              :type "function",
                              :full-name-encode "cljs.core/deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3316 3318]},
                              :full-name "cljs.core/deref",
                              :history [["+" "0.0-927"]]},
           "cljs.core/reductions" {:ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :name-encode "reductions",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2918 2930]},
                                   :full-name "cljs.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :name-encode "falseQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/falseQMARK",
                               :source {:code "(defn false?\n  [x] (cljs.core/false? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [641 643]},
                               :extra-sources [{:code "(defmacro false? [x]\n  (list 'js* \"~{} === false\" x))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [51 52]}],
                               :full-name "cljs.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "cljs.core/bit-flip" {:ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :name-encode "bit-flip",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [956 959]},
                                 :extra-sources [{:code "(defmacro bit-flip [x n]\n  (list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [163 164]}],
                                 :full-name "cljs.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :name-encode "ISet",
                             :type "protocol",
                             :full-name-encode "cljs.core/ISet",
                             :source {:code "(defprotocol ISet\n  (-disjoin [coll v]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [149 150]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISet",
                             :history [["+" "0.0-927"]]},
           "cljs.core/LazySeq" {:ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta realized x]"],
                                :name-encode "LazySeq",
                                :type "type",
                                :full-name-encode "cljs.core/LazySeq",
                                :source {:code "(deftype LazySeq [meta realized x]\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta realized x))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first (lazy-seq-value coll)))\n  (-rest [coll] (rest (lazy-seq-value coll)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (seq (lazy-seq-value coll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1293 1318]},
                                :full-name "cljs.core/LazySeq",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :name-encode "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino/IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/clj/cljs/repl/rhino.clj",
                                             :lines [26 27]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :name-encode "start-server",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1011",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [247 252]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port."},
           "cljs.core/*2" {:ns "cljs.core",
                           :name "*2",
                           :name-encode "STAR2",
                           :type "var",
                           :full-name-encode "cljs.core/STAR2",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [27 29]},
                           :full-name "cljs.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed",
                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :signature ["[]"],
                                                         :name-encode "total-listener-count",
                                                         :type "function",
                                                         :full-name-encode "clojure.browser.event/total-listener-count",
                                                         :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r1011",
                                                                  :filename "src/cljs/clojure/browser/event.cljs",
                                                                  :lines [85
                                                                          86]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/alter-meta!" {:ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[iref f & args]"],
                                    :name-encode "alter-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3335 3342]},
                                    :full-name "cljs.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :signature ["[e]"],
                                                :name-encode "click-element",
                                                :type "function",
                                                :full-name-encode "clojure.browser.dom/click-element",
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r1011",
                                                         :filename "src/cljs/clojure/browser/dom.cljs",
                                                         :lines [145
                                                                 147]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :signature ["[opts server-socket]"],
                                            :name-encode "server-loop",
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/server-loop",
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [240 245]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :history [["+" "0.0-927"]]},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-meta",
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-meta",
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [287 295]},
                                    :full-name "cljs.reader/read-meta",
                                    :history [["+" "0.0-927"]]},
           "syntax/destructure-vector" {:syntax-equiv {:edn-url nil,
                                                       :clj-url nil},
                                        :ns "syntax",
                                        :name "destructure-vector",
                                        :name-encode "destructure-vector",
                                        :type "binding",
                                        :full-name-encode "syntax/destructure-vector",
                                        :source {:code "(defn destructure [bindings]\n  (let [bents (partition 2 bindings)\n        pb (fn pb [bvec b v]\n               (let [pvec\n                     (fn [bvec b val]\n                       (let [gvec (gensym \"vec__\")]\n                         (loop [ret (-> bvec (conj gvec) (conj val))\n                                n 0\n                                bs b\n                                seen-rest? false]\n                           (if (seq bs)\n                             (let [firstb (first bs)]\n                               (cond\n                                (= firstb '&) (recur (pb ret (second bs) (list `nthnext gvec n))\n                                                     n\n                                                     (nnext bs)\n                                                     true)\n                                (= firstb :as) (pb ret (second bs) gvec)\n                                :else (if seen-rest?\n                                        (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                        (recur (pb ret firstb  (list `nth gvec n nil))\n                                               (inc n)\n                                               (next bs)\n                                               seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (let [gmap (or (:as b) (gensym \"map__\"))\n                             defaults (:or b)]\n                         (loop [ret (-> bvec (conj gmap) (conj v)\n                                        (conj gmap) (conj `(if (seq? ~gmap) (apply hash-map ~gmap) ~gmap)))\n                                bes (reduce1\n                                     (fn [bes entry]\n                                       (reduce1 #(assoc %1 %2 ((val entry) %2))\n                                               (dissoc bes (key entry))\n                                               ((key entry) bes)))\n                                     (dissoc b :as :or)\n                                     {:keys #(keyword (str %)), :strs str, :syms #(list `quote %)})]\n                           (if (seq bes)\n                             (let [bb (key (first bes))\n                                   bk (val (first bes))\n                                   has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (list `get gmap bk (defaults bb))\n                                                   (list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                 (cond\n                  (symbol? b) (-> bvec (conj b) (conj v))\n                  (vector? b) (pvec bvec b v)\n                  (map? b) (pmap bvec b v)\n                  :else (throw (new Exception (str \"Unsupported binding form: \" b))))))\n        process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n    (if (every? symbol? (map first bents))\n      bindings\n      (reduce1 process-entry [] bents))))",
                                                 :title "Parser code",
                                                 :repo "clojure",
                                                 :tag "clojure-1.3.0",
                                                 :filename "src/clj/clojure/core.clj",
                                                 :lines [3896 3951]},
                                        :full-name "syntax/destructure-vector",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/range" {:ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :name-encode "range",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/range",
                              :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2876 2883]},
                              :full-name "cljs.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :signature ["[line rdr]"],
                                          :name-encode "read-post",
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser/read-post",
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [142 151]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :name-encode "reify",
                              :type "macro",
                              :full-name-encode "cljs.core/reify",
                              :source {:code "(defmacro reify [& impls]\n  (let [t (gensym \"t\")\n        locals (keys (:locals &env))]\n    `(do\n       (when (undefined? ~t)\n         (deftype ~t [~@locals __meta#]\n           cljs.core.IWithMeta\n           (~'-with-meta [_# __meta#]\n             (new ~t ~@locals __meta#))\n           cljs.core.IMeta\n           (~'-meta [_#] __meta#)\n           ~@impls))\n       (new ~t ~@locals nil))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [191 203]},
                              :full-name "cljs.core/reify",
                              :history [["+" "0.0-927"]]},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :name-encode "satisfiesQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/satisfiesQMARK",
                                   :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p (:name (cljs.compiler/resolve-var (dissoc &env :locals) psym))\n        prefix (protocol-prefix p)]\n    `(let [x# ~x]\n       (if (and x#\n                (. x# ~(symbol (str \"-\" prefix)))        ;; Need prop lookup here\n                (not (. x# (~'hasOwnProperty ~prefix))))\n\t true\n\t (cljs.core/type_satisfies_ ~psym x#)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [422 432]},
                                   :full-name "cljs.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :name-encode "nth",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/nth",
                            :source {:code "(defn nth\n  ([coll n]\n     (-nth coll (.floor js/Math n)))\n  ([coll n not-found]\n     (-nth coll (.floor js/Math n) not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [501 509]},
                            :full-name "cljs.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:ns "cljs.core",
                             :name "list",
                             :signature ["[& items]"],
                             :name-encode "list",
                             :type "function",
                             :full-name-encode "cljs.core/list",
                             :source {:code "(defn list [& items]\n  (reduce conj () (reverse items)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1198 1199]},
                             :full-name "cljs.core/list",
                             :history [["+" "0.0-927"]]},
           "cljs.core/defn" {:ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] body]"
                                         "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                             :name-encode "defn",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/defn",
                             :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.3.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [263 308]},
                             :full-name "cljs.core/defn",
                             :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata"},
           "cljs.core/rand-nth" {:ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :name-encode "rand-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3488 3493]},
                                 :full-name "cljs.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/def" {:ns "cljs.core",
                            :name "def",
                            :type "special form",
                            :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)]\n    (assert (not (namespace sym)) \"Can't def ns-qualified name\")\n    (let [name (munge (:name (resolve-var (dissoc env :locals) sym)))\n          init-expr (when (contains? args :init) (disallowing-recur\n                                                  (analyze (assoc env :context :expr) (:init args) sym)))\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (swap! namespaces update-in [(-> env :ns :name) :defs sym]\n             (fn [m]\n               (let [m (assoc (or m {}) :name name)]\n                 (if-let [line (:line env)]\n                   (-> m\n                       (assoc :file *cljs-file*)\n                       (assoc :line line))\n                   m))))\n      (merge {:env env :op :def :form form\n              :name name :doc doc :init init-expr}\n             (when init-expr {:children [init-expr]})\n             (when export-as {:export export-as})))))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/clj/cljs/compiler.clj",
                                     :lines [689 714]},
                            :full-name "cljs.core/def",
                            :full-name-encode "cljs.core/def",
                            :name-encode "def",
                            :history [["+" "0.0-927"]]},
           "cljs.core/atom" {:ns "cljs.core",
                             :name "atom",
                             :signature ["[x]"
                                         "[x & {:keys [meta validator]}]"],
                             :name-encode "atom",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3260 3275]},
                             :full-name "cljs.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :signature ["[reader initch]"],
                                       :name-encode "read-keyword",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-keyword",
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        [token ns name] (re-matches symbol-pattern token)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if ns?\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [256 267]},
                                       :full-name "cljs.reader/read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:ns "cljs.core",
                               :name "Vector",
                               :signature ["[meta array]"],
                               :name-encode "Vector",
                               :type "type",
                               :full-name-encode "cljs.core/Vector",
                               :source {:code "(deftype Vector [meta array]\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (.-length array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (.-length array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (.-length array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (.-length array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (.-length array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (.-length array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (.-length array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1939 2020]},
                               :full-name "cljs.core/Vector",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :name-encode "skip-line",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (= ch \\n) (= ch \\r) (nil? ch))\n        reader\n        (recur)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [86 93]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :name-encode "namespace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (or (keyword? x) (symbol? x))\n    (let [i (.lastIndexOf x \"/\")]\n      (when (> i -1)\n        (subs x 2 i)))\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2765 2772]},
                                  :full-name "cljs.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :name-encode "require",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/require",
                                  :source {:code "(def require (js* \"require\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [7]},
                                  :full-name "cljs.nodejs/require",
                                  :history [["+" "0.0-927"]]},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :name-encode "EventType",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event/EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1011",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :signature ["[repl-env]"],
                                          :name-encode "rhino-setup",
                                          :type "function",
                                          :full-name-encode "cljs.repl.rhino/rhino-setup",
                                          :source {:code "(defn rhino-setup [repl-env]\n  (let [env {:context :statement :locals {} :ns (@comp/namespaces comp/*cljs-ns*)}\n        scope (:scope repl-env)]\n    (repl/load-file repl-env \"cljs/core.cljs\")\n    (swap! loaded-libs conj \"cljs.core\")\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(ns cljs.user))\n    (ScriptableObject/putProperty scope\n                                  \"out\"\n                                  (Context/javaToJS System/out scope))\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(set! *print-fn* (fn [x] (.print js/out x))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [95 110]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/merge" {:ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :name-encode "merge",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2619 2625]},
                              :full-name "cljs.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :signature ["[connection url data]"],
                                               :name-encode "send-result",
                                               :type "function",
                                               :full-name-encode "clojure.browser.repl/send-result",
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/cljs/clojure/browser/repl.cljs",
                                                        :lines [38 39]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :name-encode "keywordize-keys",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [64 70]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :name-encode "derive",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap! global-hierarchy derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3559 3591]},
                               :full-name "cljs.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :name-encode "zipper",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :name-encode "remove",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "cljs.repl.browser/handle-post" {:ns "cljs.repl.browser",
                                            :name "handle-post",
                                            :signature ["[_ m]"],
                                            :name-encode "handle-post",
                                            :history [["+" "0.0-927"]],
                                            :type "multimethod",
                                            :full-name-encode "cljs.repl.browser/handle-post",
                                            :source {:code "(defmulti handle-post (fn [_ m] (:type m)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1011",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [192]},
                                            :extra-sources ({:code "(defmethod handle-post :ready [conn _]\n  (do (reset! loaded-libs #{})\n      (send ordering (fn [_] {:expecting nil :fns {}}))\n      (send-for-eval conn\n                     (cljsc/-compile\n                      '[(ns cljs.user)\n                        (set! *print-fn* clojure.browser.repl/repl-print)] {})\n                     identity)))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [194
                                                                     201]}
                                                            {:code "(defmethod handle-post :print [conn {:keys [content order]}]\n  (do (constrain-order order (fn [] (do (print (read-string content))\n                                       (.flush *out*))))\n      (send-and-close conn 200 \"ignore__\")))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [221
                                                                     224]}
                                                            {:code "(defmethod handle-post :result [conn {:keys [content order]}]\n  (constrain-order order (fn [] (do (return-value content)\n                                   (set-connection conn)))))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r1011",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [226
                                                                     228]}),
                                            :full-name "cljs.repl.browser/handle-post"},
           "cljs.core/find" {:ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :name-encode "find",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and coll\n             (associative? coll)\n             (contains? coll k))\n    [k (-lookup coll k)]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [701 707]},
                             :full-name "cljs.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :name-encode "STARprint-dupSTAR",
                                    :type "var",
                                    :full-name-encode "cljs.core/STARprint-dupSTAR",
                                    :source {:code "(def *print-dup* false)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r1011",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3103]},
                                    :full-name "cljs.core/*print-dup*",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/partial" {:ns "cljs.core",
                                :name "partial",
                                :signature ["[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :name-encode "partial",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/partial",
                                :source {:code "(defn partial\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1529 1540]},
                                :full-name "cljs.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "cljs.core/keyword?" {:ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :name-encode "keywordQMARK",
                                 :type "function",
                                 :full-name-encode "cljs.core/keywordQMARK",
                                 :source {:code "(defn keyword? [x]\n  (and (goog/isString x)\n       (= (.charAt x 0) \\uFDD0)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [670 672]},
                                 :full-name "cljs.core/keyword?",
                                 :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/stacktrace" {:ns "cljs.repl.rhino",
                                         :name "stacktrace",
                                         :name-encode "stacktrace",
                                         :type "multimethod",
                                         :full-name-encode "cljs.repl.rhino/stacktrace",
                                         :source {:code "(defmulti stacktrace class)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [40]},
                                         :full-name "cljs.repl.rhino/stacktrace",
                                         :extra-sources ({:code "(defmethod stacktrace :default [e]\n  (apply str (interpose \"\\n\" (map #(str \"        \" (.toString %)) (.getStackTrace e)))))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/clj/cljs/repl/rhino.clj",
                                                          :lines [42
                                                                  43]}
                                                         {:code "(defmethod stacktrace org.mozilla.javascript.RhinoException [e]\n  (.getScriptStackTrace e))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r1011",
                                                          :filename "src/clj/cljs/repl/rhino.clj",
                                                          :lines [45
                                                                  46]}),
                                         :history [["+" "0.0-927"]]},
           "compiler-options/output-to" {:ns "compiler-options",
                                         :name "output-to",
                                         :name-encode "output-to",
                                         :type "option",
                                         :full-name-encode "compiler-options/output-to",
                                         :full-name "compiler-options/output-to",
                                         :history [["+" "0.0-971"]]},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :signature ["[obj type capture event]"],
                                                   :name-encode "fire-listeners",
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/fire-listeners",
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r1011",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [82
                                                                    83]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/interleave" {:ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :name-encode "interleave",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1788 1800]},
                                   :full-name "cljs.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :name-encode "STARflush-on-newlineSTAR",
                                           :type "var",
                                           :full-name-encode "cljs.core/STARflush-on-newlineSTAR",
                                           :source {:code "(def *flush-on-newline* true)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3100]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/get-in" {:ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :name-encode "get-in",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (reduce get m ks))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (let [m (get m (first ks) sentinel)]\n           (if (identical? sentinel m)\n             not-found\n             (recur sentinel m (next ks))))\n         m))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1011",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1896 1913]},
                               :full-name "cljs.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of ke(ys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :name-encode "element",
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/element",
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1011",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [79 88]},
                                          :full-name "clojure.browser.dom/element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :signature ["[prim i]"],
                                 :name-encode "prim-seq",
                                 :type "function",
                                 :full-name-encode "cljs.core/prim-seq",
                                 :source {:code "(defn prim-seq [prim i]\n  (when-not (= 0 (.-length prim))\n    (IndexedSeq. prim i)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [368 370]},
                                 :full-name "cljs.core/prim-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/<=" {:ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "LTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/LTEQ",
                           :source {:code "(defn <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [850 860]},
                           :extra-sources [{:code "(defmacro <=\n  ([x] true)\n  ([x y] (list 'js* \"(~{} <= ~{})\" x y))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [93 96]}],
                           :full-name "cljs.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :name-encode "map-invert",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [98 100]},
                                     :full-name "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :name-encode "listen",
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/listen",
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1011",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [44 51]},
                                           :full-name "clojure.browser.event/listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:ns "cljs.core",
                             :name "neg?",
                             :signature ["[x]"],
                             :name-encode "negQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/negQMARK",
                             :source {:code "(defn neg?\n  [x] (cljs.core/neg? x))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1002 1004]},
                             :extra-sources [{:code "(defmacro neg? [x]\n  `(< ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [125 126]}],
                             :full-name "cljs.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :name-encode "replace-node",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom/replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1011",
                                                        :filename "src/cljs/clojure/browser/dom.cljs",
                                                        :lines [112
                                                                120]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "cljs.core/reverse" {:ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :name-encode "reverse",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (reduce conj () coll))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1193 1196]},
                                :full-name "cljs.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :name-encode "ordering",
                                         :type "var",
                                         :full-name-encode "cljs.repl.browser/ordering",
                                         :source {:code "(def ordering (agent {:expecting nil :fns {}}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1011",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [190]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/realized?" {:ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[d]"],
                                  :name-encode "realizedQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/realizedQMARK",
                                  :source {:code "(defn realized?\n  [d]\n  (-realized? d))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3424 3427]},
                                  :full-name "cljs.core/realized?",
                                  :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
 :namespaces {"clojure.zip" {:ns "clojure.zip",
                             :name-encode "clojure.zip",
                             :type "namespace",
                             :full-name-encode "clojure.zip",
                             :source {:code "(ns ^{:doc \"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet\"\n       :author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [12 16]},
                             :author "Rich Hickey",
                             :full-name "clojure.zip",
                             :docstring "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet",
                             :history [["+" "0.0-927"]]},
              "cljs.repl.browser" {:ns "cljs.repl.browser",
                                   :name-encode "cljs.repl.browser",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.browser",
                                   :source {:code "(ns cljs.repl.browser\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.string :as str]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.closure :as cljsc]\n            [cljs.repl :as repl])\n  (:import java.io.BufferedReader\n           java.io.BufferedWriter\n           java.io.InputStreamReader\n           java.io.OutputStreamWriter\n           java.net.Socket\n           java.net.ServerSocket\n           cljs.repl.IJavaScriptEnv))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1011",
                                            :filename "src/clj/cljs/repl/browser.clj",
                                            :lines [9 22]},
                                   :full-name "cljs.repl.browser",
                                   :history [["+" "0.0-927"]]},
              "cljs.repl.rhino" {:ns "cljs.repl.rhino",
                                 :name-encode "cljs.repl.rhino",
                                 :type "namespace",
                                 :full-name-encode "cljs.repl.rhino",
                                 :source {:code "(ns cljs.repl.rhino\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.repl :as repl])\n  (:import cljs.repl.IJavaScriptEnv\n           [org.mozilla.javascript Context ScriptableObject]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r1011",
                                          :filename "src/clj/cljs/repl/rhino.clj",
                                          :lines [9 16]},
                                 :full-name "cljs.repl.rhino",
                                 :history [["+" "0.0-927"]]},
              "clojure.browser.dom" {:ns "clojure.browser.dom",
                                     :name-encode "clojure.browser.dom",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.dom",
                                     :source {:code "(ns clojure.browser.dom\n  (:require [goog.dom :as gdom]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/browser/dom.cljs",
                                              :lines [9 10]},
                                     :full-name "clojure.browser.dom",
                                     :history [["+" "0.0-927"]]},
              "clojure.set" {:ns "clojure.set",
                             :name-encode "clojure.set",
                             :type "namespace",
                             :full-name-encode "clojure.set",
                             :source {:code "(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/clojure/set.cljs",
                                      :lines [9 11]},
                             :author "Rich Hickey",
                             :full-name "clojure.set",
                             :docstring "Set operations such as union/intersection.",
                             :history [["+" "0.0-927"]]},
              "cljs.nodejs" {:ns "cljs.nodejs",
                             :name-encode "cljs.nodejs",
                             :type "namespace",
                             :full-name-encode "cljs.nodejs",
                             :source {:code "(ns cljs.nodejs)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/nodejs.cljs",
                                      :lines [4]},
                             :full-name "cljs.nodejs",
                             :history [["+" "0.0-927"]]},
              "clojure.walk" {:ns "clojure.walk",
                              :name-encode "clojure.walk",
                              :type "namespace",
                              :full-name-encode "clojure.walk",
                              :source {:code "(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r1011",
                                       :filename "src/cljs/clojure/walk.cljs",
                                       :lines [23 35]},
                              :author "Stuart Sierra",
                              :full-name "clojure.walk",
                              :docstring "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.",
                              :history [["+" "0.0-927"]]},
              "clojure.browser.event" {:ns "clojure.browser.event",
                                       :name-encode "clojure.browser.event",
                                       :type "namespace",
                                       :full-name-encode "clojure.browser.event",
                                       :source {:code "(ns ^{:doc \"This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.\"\n      :author \"Bobby Calderwood\"}\n  clojure.browser.event\n  (:require [goog.events :as events]\n            [goog.events.EventTarget :as gevent-target]\n            [goog.events.EventType   :as gevent-type]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r1011",
                                                :filename "src/cljs/clojure/browser/event.cljs",
                                                :lines [9 15]},
                                       :author "Bobby Calderwood",
                                       :full-name "clojure.browser.event",
                                       :docstring "This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.",
                                       :history [["+" "0.0-927"]]},
              "cljs.reader" {:ns "cljs.reader",
                             :name-encode "cljs.reader",
                             :type "namespace",
                             :full-name-encode "cljs.reader",
                             :source {:code "(ns cljs.reader\n  (:require [goog.string :as gstring]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r1011",
                                      :filename "src/cljs/cljs/reader.cljs",
                                      :lines [9 10]},
                             :full-name "cljs.reader",
                             :history [["+" "0.0-927"]]},
              "clojure.string" {:ns "clojure.string",
                                :name-encode "clojure.string",
                                :type "namespace",
                                :full-name-encode "clojure.string",
                                :source {:code "(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring]\n            [goog.string.StringBuffer :as gstringbuf]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1011",
                                         :filename "src/cljs/clojure/string.cljs",
                                         :lines [9 12]},
                                :full-name "clojure.string",
                                :history [["+" "0.0-927"]]},
              "cljs.repl" {:ns "cljs.repl",
                           :name-encode "cljs.repl",
                           :type "namespace",
                           :full-name-encode "cljs.repl",
                           :source {:code "(ns cljs.repl\n  (:refer-clojure :exclude [load-file])\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.closure :as cljsc]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/clj/cljs/repl.clj",
                                    :lines [9 14]},
                           :full-name "cljs.repl",
                           :history [["+" "0.0-927"]]},
              "clojure.browser.net" {:ns "clojure.browser.net",
                                     :name-encode "clojure.browser.net",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.net",
                                     :source {:code "(ns ^{:doc \"Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.\"\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.net\n  (:require [clojure.browser.event :as event]\n            [goog.net.XhrIo :as gxhrio]\n            [goog.net.EventType :as gnet-event-type]\n            [goog.net.xpc.CfgFields :as gxpc-config-fields]\n            [goog.net.xpc.CrossPageChannel :as xpc]\n            #_[goog.net.WebSocket :as gwebsocket]\n            [goog.json :as gjson]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1011",
                                              :filename "src/cljs/clojure/browser/net.cljs",
                                              :lines [9 19]},
                                     :author "Bobby Calderwood and Alex Redington",
                                     :full-name "clojure.browser.net",
                                     :docstring "Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.",
                                     :history [["+" "0.0-927"]]},
              "syntax" {:ns "syntax",
                        :pseudo-ns? true,
                        :type "namespace",
                        :full-name "syntax",
                        :full-name-encode "syntax",
                        :history [["+" "0.0-927"]]},
              "cljs.core" {:ns "cljs.core",
                           :name-encode "cljs.core",
                           :type "namespace",
                           :full-name-encode "cljs.core",
                           :source {:code "(ns cljs.core\n  (:require [goog.string :as gstring]\n            [goog.string.StringBuffer :as gstringbuf]\n            [goog.object :as gobject]\n            [goog.array :as garray]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r1011",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [9 13]},
                           :full-name "cljs.core",
                           :history [["+" "0.0-927"]]},
              "compiler-options" {:ns "compiler-options",
                                  :pseudo-ns? true,
                                  :type "namespace",
                                  :full-name "compiler-options",
                                  :full-name-encode "compiler-options",
                                  :history [["+" "0.0-971"]]},
              "clojure.browser.repl" {:ns "clojure.browser.repl",
                                      :name-encode "clojure.browser.repl",
                                      :type "namespace",
                                      :full-name-encode "clojure.browser.repl",
                                      :source {:code "(ns ^{:doc \"Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!\"\n\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.repl\n  (:require [clojure.browser.net   :as net]\n            [clojure.browser.event :as event]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1011",
                                               :filename "src/cljs/clojure/browser/repl.cljs",
                                               :lines [9 19]},
                                      :author "Bobby Calderwood and Alex Redington",
                                      :full-name "clojure.browser.repl",
                                      :docstring "Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!",
                                      :history [["+" "0.0-927"]]}},
 :api {:syntax {:changes {"0.0-927" {:added #{"syntax/whitespace"
                                              "syntax/earmuffs"
                                              "syntax/Math-namespace"
                                              "syntax/comma"
                                              "syntax/js-namespace"
                                              "syntax/namespace"
                                              "syntax/dot"
                                              "syntax/unused"
                                              "syntax/rest"
                                              "syntax/auto-gensym"
                                              "syntax/destructure-map"
                                              "syntax/impure"
                                              "syntax/predicate"
                                              "syntax/destructure-vector"}},
                          "0.0-971" {},
                          "0.0-993" {},
                          "0.0-1006" {},
                          "0.0-1011" {}},
                :symbol-names #{"syntax/whitespace"
                                "syntax/earmuffs"
                                "syntax/Math-namespace"
                                "syntax/comma"
                                "syntax/js-namespace"
                                "syntax/namespace"
                                "syntax/dot"
                                "syntax/unused"
                                "syntax/rest"
                                "syntax/auto-gensym"
                                "syntax/destructure-map"
                                "syntax/impure"
                                "syntax/predicate"
                                "syntax/destructure-vector"},
                :namespace-names #{"syntax"}},
       :options {:changes {"0.0-927" {},
                           "0.0-971" {:added #{"compiler-options/verbose"
                                               "compiler-options/libs"
                                               "compiler-options/optimizations"
                                               "compiler-options/pretty-print"
                                               "compiler-options/target"
                                               "compiler-options/use-only-custom-externs"
                                               "compiler-options/main"
                                               "compiler-options/output-dir"
                                               "compiler-options/print-input-delimiter"
                                               "compiler-options/foreign-libs"
                                               "compiler-options/externs"
                                               "compiler-options/output-to"}},
                           "0.0-993" {},
                           "0.0-1006" {},
                           "0.0-1011" {}},
                 :symbol-names #{"compiler-options/verbose"
                                 "compiler-options/libs"
                                 "compiler-options/optimizations"
                                 "compiler-options/pretty-print"
                                 "compiler-options/target"
                                 "compiler-options/use-only-custom-externs"
                                 "compiler-options/main"
                                 "compiler-options/output-dir"
                                 "compiler-options/print-input-delimiter"
                                 "compiler-options/foreign-libs"
                                 "compiler-options/externs"
                                 "compiler-options/output-to"},
                 :namespace-names #{"compiler-options"}},
       :library {:changes {"0.0-927" {:added #{"cljs.core/keys"
                                               "cljs.core/reset!"
                                               "clojure.set/select"
                                               "cljs.core/delay"
                                               "cljs.core/bit-not"
                                               "cljs.core/partition"
                                               "cljs.core/parents"
                                               "cljs.core/aclone"
                                               "cljs.core/reset-meta!"
                                               "cljs.reader/dispatch-macros"
                                               "cljs.core/ICollection"
                                               "cljs.core/every?"
                                               "clojure.zip/node"
                                               "cljs.core/IEmptyableCollection"
                                               "clojure.zip/right"
                                               "cljs.core/=="
                                               "clojure.browser.net/*timeout*"
                                               "cljs.core/let*"
                                               "cljs.core/remove-method"
                                               "cljs.core/frequencies"
                                               "cljs.core/pop"
                                               "cljs.core/not-every?"
                                               "cljs.core/some-fn"
                                               "clojure.browser.event/remove-all"
                                               "cljs.core/doto"
                                               "cljs.core/take-while"
                                               "cljs.reader/escape-char-map"
                                               "clojure.browser.event/all-listeners"
                                               "cljs.core/vals"
                                               "cljs.core/IDeref"
                                               "clojure.browser.dom/log-obj"
                                               "cljs.core/for"
                                               "cljs.core/instance?"
                                               "cljs.reader/read-comment"
                                               "cljs.reader/read-number"
                                               "cljs.core/ILookup"
                                               "cljs.core/when"
                                               "clojure.browser.dom/set-value"
                                               "cljs.reader/read-past"
                                               "cljs.core/to-array"
                                               "cljs.core/interpose"
                                               "clojure.browser.net/ICrossPageChannel"
                                               "cljs.core/Cons"
                                               "cljs.core/re-find"
                                               "cljs.core/IMeta"
                                               "cljs.core/assoc-in"
                                               "clojure.string/join"
                                               "clojure.zip/rights"
                                               "cljs.core/split-at"
                                               "clojure.zip/append-child"
                                               "cljs.core/binding"
                                               "cljs.core/Set"
                                               "cljs.reader/macro-terminating?"
                                               "cljs.core/prefers"
                                               "cljs.core/vary-meta"
                                               "cljs.core/when-let"
                                               "cljs.core/drop"
                                               "cljs.core/while"
                                               "cljs.core/import-macros"
                                               "cljs.core/string-print"
                                               "cljs.core/-"
                                               "cljs.core/loop*"
                                               "clojure.zip/vector-zip"
                                               "cljs.core/js->clj"
                                               "cljs.core/List"
                                               "cljs.core/identical?"
                                               "cljs.core/*main-cli-fn*"
                                               "clojure.browser.dom/html->dom"
                                               "cljs.core/some"
                                               "cljs.core/if"
                                               "cljs.core/doall"
                                               "cljs.core/condp"
                                               "clojure.zip/down"
                                               "cljs.core/IPending"
                                               "cljs.core/count"
                                               "cljs.core/bit-test"
                                               "cljs.core/loop"
                                               "cljs.core/subvec"
                                               "cljs.core/bit-clear"
                                               "cljs.core/gensym"
                                               "cljs.core/in-ns"
                                               "cljs.core/+"
                                               "cljs.core/comp"
                                               "cljs.reader/desugar-meta"
                                               "cljs.core/pr"
                                               "clojure.string/upper-case"
                                               "clojure.browser.event/expose"
                                               "clojure.browser.event/listen-once"
                                               "cljs.core/empty?"
                                               "cljs.core/newline"
                                               "cljs.core/replace"
                                               "cljs.core/rand"
                                               "cljs.core/add-watch"
                                               "clojure.string/capitalize"
                                               "cljs.core/replicate"
                                               "cljs.core/sequential?"
                                               "cljs.core/underive"
                                               "cljs.core/get-method"
                                               "cljs.core/="
                                               "cljs.core/defn-"
                                               "cljs.reader/read-symbol"
                                               "cljs.reader/push-back-reader"
                                               "cljs.core/deftype"
                                               "cljs.core/Subvec"
                                               "cljs.core/."
                                               "cljs.core/extend-protocol"
                                               "cljs.reader/read"
                                               "cljs.core/EmptyList"
                                               "clojure.walk/postwalk"
                                               "clojure.zip/edit"
                                               "cljs.core/re-seq"
                                               "cljs.reader/read-list"
                                               "cljs.core/Atom"
                                               "cljs.core/IMap"
                                               "cljs.reader/read-vector"
                                               "clojure.set/join"
                                               "cljs.core/HashMap"
                                               "cljs.reader/int-pattern"
                                               "cljs.core/swap!"
                                               "cljs.core/finally"
                                               "cljs.core/dec"
                                               "clojure.browser.dom/remove-children"
                                               "cljs.core/get-validator"
                                               "cljs.core/coll?"
                                               "cljs.core/bit-or"
                                               "cljs.core/nfirst"
                                               "cljs.core/keep"
                                               "cljs.core/take"
                                               "cljs.core/cond"
                                               "cljs.core/bit-and"
                                               "cljs.core/ObjMap.fromObject"
                                               "clojure.browser.event/unique-event-id"
                                               "clojure.set/project"
                                               "clojure.string/trim-newline"
                                               "clojure.zip/insert-left"
                                               "cljs.core/true?"
                                               "clojure.browser.net/xpc-connection"
                                               "cljs.core/not"
                                               "cljs.core/js-obj"
                                               "cljs.core/complement"
                                               "cljs.core/spread"
                                               "cljs.core/keyword"
                                               "cljs.core/sort"
                                               "clojure.string/trim"
                                               "cljs.core/meta"
                                               "cljs.core/time"
                                               "cljs.core/boolean"
                                               "cljs.reader/read-token"
                                               "cljs.core/update-in"
                                               "cljs.core/map-indexed"
                                               "cljs.core/IStack"
                                               "cljs.core/IIndexed"
                                               "clojure.browser.repl/repl-print"
                                               "clojure.browser.net/xpc-config-fields"
                                               "cljs.core/nnext"
                                               "cljs.core/*print-meta*"
                                               "cljs.reader/read-dispatch"
                                               "cljs.core/distinct"
                                               "cljs.reader/wrapping-reader"
                                               "cljs.core/prn"
                                               "clojure.zip/leftmost"
                                               "cljs.core/>="
                                               "cljs.reader/macros"
                                               "cljs.core/doseq"
                                               "cljs.core/*"
                                               "cljs.core/into"
                                               "cljs.core/defmethod"
                                               "cljs.core/rest"
                                               "cljs.core/dotimes"
                                               "clojure.zip/lefts"
                                               "clojure.browser.dom/ensure-element"
                                               "cljs.core/defmacro"
                                               "cljs.core/remove"
                                               "cljs.core/ns"
                                               "cljs.core/if-not"
                                               "clojure.zip/path"
                                               "cljs.core/mapcat"
                                               "cljs.core/IWatchable"
                                               "clojure.zip/rightmost"
                                               "cljs.core/->"
                                               "cljs.core/remove-all-methods"
                                               "clojure.string/replace-first"
                                               "clojure.browser.dom/get-value"
                                               "cljs.nodejs/process"
                                               "cljs.core/not="
                                               "cljs.core/js-keys"
                                               "clojure.zip/seq-zip"
                                               "cljs.core/IVector"
                                               "cljs.core/empty"
                                               "cljs.core/re-matches"
                                               "clojure.browser.dom/DOMBuilder"
                                               "cljs.core/extend-type"
                                               "cljs.core/ISeqable"
                                               "cljs.core/assoc"
                                               "clojure.browser.repl/xpc-connection"
                                               "cljs.core/IDerefWithTimeout"
                                               "clojure.browser.repl/start-evaluator"
                                               "clojure.browser.event/unlisten"
                                               "cljs.core/do"
                                               "cljs.core/fnil"
                                               "cljs.core/this-as"
                                               "cljs.core/PersistentQueueSeq"
                                               "cljs.core/counted?"
                                               "clojure.string/trimr"
                                               "cljs.core/force"
                                               "cljs.core/compare-and-set!"
                                               "cljs.core/set?"
                                               "cljs.core/load-file"
                                               "clojure.string/escape"
                                               "cljs.core/remove-watch"
                                               "cljs.core/IMultiFn"
                                               "clojure.zip/end?"
                                               "clojure.set/superset?"
                                               "clojure.browser.net/IConnection"
                                               "cljs.core/let"
                                               "cljs.core/dorun"
                                               "cljs.core/pr-str"
                                               "cljs.core/IPrintable"
                                               "cljs.core/defprotocol"
                                               "cljs.core/assert"
                                               "cljs.core/declare"
                                               "cljs.core/fn?"
                                               "cljs.core/associative?"
                                               "cljs.core/list*"
                                               "cljs.core/reduce"
                                               "clojure.browser.event/has-listener"
                                               "cljs.core/compare"
                                               "cljs.core/contains?"
                                               "cljs.core/prefer-method"
                                               "cljs.core/array-seq"
                                               "cljs.core/PersistentQueue"
                                               "cljs.core/drop-last"
                                               "cljs.reader/read-string"
                                               "cljs.core/vector?"
                                               "cljs.core/defmulti"
                                               "cljs.core/List.EMPTY"
                                               "clojure.browser.event/dispatch-event"
                                               "clojure.string/split-lines"
                                               "cljs.core/areduce"
                                               "cljs.core/disj"
                                               "clojure.browser.net/event-types"
                                               "clojure.string/lower-case"
                                               "cljs.core/*print-fn*"
                                               "cljs.core/str"
                                               "cljs.core/ISequential"
                                               "cljs.core/try*"
                                               "cljs.core/set"
                                               "cljs.core/print"
                                               "clojure.string/blank?"
                                               "clojure.browser.dom/append"
                                               "cljs.core/take-last"
                                               "clojure.set/intersection"
                                               "cljs.core/fnext"
                                               "cljs.core/apply"
                                               "clojure.walk/prewalk"
                                               "cljs.core/flatten"
                                               "cljs.core/get"
                                               "cljs.core/.."
                                               "cljs.core/Range"
                                               "cljs.core/zero?"
                                               "cljs.core/identity"
                                               "cljs.core/first"
                                               "cljs.reader/ratio-pattern"
                                               "cljs.core/>"
                                               "cljs.core/juxt"
                                               "cljs.core/max"
                                               "cljs.core/*3"
                                               "cljs.core/number?"
                                               "cljs.core/array"
                                               "cljs.core/nthnext"
                                               "cljs.core/re-pattern"
                                               "cljs.core/missing-protocol"
                                               "clojure.browser.dom/set-text"
                                               "clojure.zip/up"
                                               "cljs.core/IWithMeta"
                                               "cljs.core/bit-and-not"
                                               "clojure.string/triml"
                                               "clojure.string/split"
                                               "cljs.core/hash-map"
                                               "cljs.core/rem"
                                               "cljs.core/IRecord"
                                               "cljs.core/constantly"
                                               "clojure.browser.dom/get-element"
                                               "cljs.core/and"
                                               "clojure.browser.repl/wrap-message"
                                               "clojure.browser.event/unlisten-by-key"
                                               "cljs.core/new"
                                               "cljs.core/try"
                                               "cljs.core/iterate"
                                               "cljs.core/lazy-seq"
                                               "cljs.core/IndexedSeq"
                                               "cljs.core/next"
                                               "cljs.core/*print-readably*"
                                               "cljs.core/last"
                                               "cljs.core/bit-shift-left"
                                               "clojure.string/reverse"
                                               "cljs.core/min"
                                               "cljs.reader/escape-char"
                                               "cljs.reader/read-map"
                                               "cljs.core/seq"
                                               "cljs.core/defrecord*"
                                               "cljs.core/not-empty"
                                               "cljs.core/println"
                                               "clojure.browser.repl/connect"
                                               "clojure.browser.dom/insert-at"
                                               "cljs.core/quot"
                                               "clojure.browser.event/get-listener"
                                               "cljs.core/filter"
                                               "clojure.zip/branch?"
                                               "cljs.core/ObjMap"
                                               "cljs.core/zipmap"
                                               "cljs.core/hash-combine"
                                               "cljs.core/max-key"
                                               "clojure.zip/insert-child"
                                               "cljs.core/defrecord"
                                               "cljs.core/butlast"
                                               "cljs.core/hash"
                                               "cljs.core/bit-set"
                                               "cljs.core/concat"
                                               "cljs.core/conj"
                                               "clojure.set/difference"
                                               "cljs.core/when-first"
                                               "cljs.core/distinct?"
                                               "cljs.core/pos?"
                                               "cljs.core/IHash"
                                               "cljs.core/is_proto_"
                                               "cljs.core/keep-indexed"
                                               "cljs.core/bit-shift-right"
                                               "clojure.zip/insert-right"
                                               "cljs.core/make-hierarchy"
                                               "cljs.core/repeat"
                                               "cljs.core/MultiFn"
                                               "cljs.core/not-any?"
                                               "cljs.reader/read-regex"
                                               "clojure.zip/next"
                                               "cljs.core/aget"
                                               "cljs.core/if-let"
                                               "cljs.core//"
                                               "cljs.core/min-key"
                                               "clojure.zip/root"
                                               "cljs.core/drop-while"
                                               "clojure.browser.repl/evaluate-javascript"
                                               "cljs.core/set-validator!"
                                               "cljs.core/<"
                                               "cljs.core/catch"
                                               "cljs.core/deftype*"
                                               "cljs.core/fn"
                                               "cljs.core/split-with"
                                               "cljs.core/IReduce"
                                               "cljs.reader/symbol-pattern"
                                               "cljs.core/repeatedly"
                                               "cljs.reader/read-delimited-list"
                                               "cljs.core/undefined?"
                                               "clojure.zip/prev"
                                               "cljs.core/seq?"
                                               "cljs.core/odd?"
                                               "cljs.core/cons"
                                               "cljs.reader/read-set"
                                               "cljs.core/descendants"
                                               "cljs.core/take-nth"
                                               "cljs.reader/throwing-reader"
                                               "cljs.core/even?"
                                               "clojure.set/subset?"
                                               "cljs.core/flush"
                                               "cljs.reader/reader-error"
                                               "clojure.walk/prewalk-replace"
                                               "cljs.core/*1"
                                               "cljs.core/Set.EMPTY"
                                               "cljs.reader/read-unicode-char"
                                               "cljs.core/dissoc"
                                               "cljs.core/ffirst"
                                               "clojure.zip/replace"
                                               "cljs.core/vec"
                                               "cljs.core/or"
                                               "cljs.core/mod"
                                               "cljs.core/aset"
                                               "cljs.core/second"
                                               "cljs.core/set!"
                                               "clojure.set/rename"
                                               "cljs.core/delay?"
                                               "clojure.zip/left"
                                               "cljs.reader/not-implemented"
                                               "cljs.core/IAssociative"
                                               "cljs.core/ObjMap.EMPTY"
                                               "cljs.core/group-by"
                                               "cljs.core/symbol"
                                               "cljs.core/Delay"
                                               "cljs.core/methods"
                                               "cljs.core/vector"
                                               "cljs.core/rand-int"
                                               "cljs.core/throw"
                                               "cljs.core/PersistentQueue.EMPTY"
                                               "cljs.core/letfn"
                                               "cljs.core/recur"
                                               "cljs.reader/read-discard"
                                               "cljs.core/inc"
                                               "cljs.core/name"
                                               "cljs.core/cycle"
                                               "cljs.core/fn*"
                                               "cljs.core/map"
                                               "cljs.core/amap"
                                               "clojure.zip/children"
                                               "cljs.core/when-not"
                                               "clojure.set/index"
                                               "clojure.browser.dom/log"
                                               "cljs.core/Vector.fromArray"
                                               "cljs.core/partition-by"
                                               "cljs.core/sort-by"
                                               "cljs.core/with-meta"
                                               "cljs.core/NeverEquiv"
                                               "cljs.core/select-keys"
                                               "cljs.core/ISeq"
                                               "clojure.walk/postwalk-replace"
                                               "cljs.core/pr-with-opts"
                                               "cljs.core/->>"
                                               "cljs.core/nil?"
                                               "cljs.core/load-namespace"
                                               "clojure.walk/stringify-keys"
                                               "clojure.browser.repl/order"
                                               "cljs.core/memoize"
                                               "cljs.core/pr-sequential"
                                               "clojure.zip/make-node"
                                               "cljs.reader/float-pattern"
                                               "cljs.core/ancestors"
                                               "cljs.core/integer?"
                                               "cljs.core/HashMap.EMPTY"
                                               "cljs.core/Vector.EMPTY"
                                               "clojure.zip/xml-zip"
                                               "clojure.walk/walk"
                                               "cljs.core/bit-xor"
                                               "clojure.set/union"
                                               "cljs.reader/PushbackReader"
                                               "cljs.core/isa?"
                                               "clojure.browser.net/xhr-connection"
                                               "cljs.core/subs"
                                               "cljs.core/symbol?"
                                               "clojure.string/replace"
                                               "cljs.core/string?"
                                               "cljs.core/partition-all"
                                               "cljs.core/merge-with"
                                               "clojure.browser.dom/set-properties"
                                               "cljs.core/trampoline"
                                               "clojure.browser.repl/send-print"
                                               "cljs.core/ICounted"
                                               "cljs.core/quote"
                                               "cljs.core/IEquiv"
                                               "cljs.core/js-delete"
                                               "cljs.core/comment"
                                               "cljs.reader/special-symbols"
                                               "cljs.core/js*"
                                               "cljs.core/alength"
                                               "cljs.core/tree-seq"
                                               "cljs.reader/read-unmatched-delimiter"
                                               "cljs.core/every-pred"
                                               "clojure.set/rename-keys"
                                               "cljs.core/peek"
                                               "cljs.core/pr-str-with-opts"
                                               "cljs.core/map?"
                                               "cljs.reader/StringPushbackReader"
                                               "cljs.core/HashMap.fromArrays"
                                               "cljs.core/deref"
                                               "cljs.core/reductions"
                                               "cljs.core/false?"
                                               "cljs.core/bit-flip"
                                               "cljs.core/ISet"
                                               "cljs.core/LazySeq"
                                               "cljs.core/*2"
                                               "clojure.browser.event/total-listener-count"
                                               "cljs.core/alter-meta!"
                                               "clojure.browser.dom/click-element"
                                               "cljs.reader/read-meta"
                                               "cljs.core/range"
                                               "cljs.core/reify"
                                               "cljs.core/satisfies?"
                                               "cljs.core/nth"
                                               "cljs.core/list"
                                               "cljs.core/defn"
                                               "cljs.core/rand-nth"
                                               "cljs.core/def"
                                               "cljs.core/atom"
                                               "cljs.reader/read-keyword"
                                               "cljs.core/Vector"
                                               "cljs.reader/skip-line"
                                               "cljs.core/namespace"
                                               "cljs.nodejs/require"
                                               "clojure.browser.event/EventType"
                                               "cljs.core/merge"
                                               "clojure.browser.repl/send-result"
                                               "clojure.walk/keywordize-keys"
                                               "cljs.core/derive"
                                               "clojure.zip/zipper"
                                               "clojure.zip/remove"
                                               "cljs.core/find"
                                               "cljs.core/*print-dup*"
                                               "cljs.core/partial"
                                               "cljs.core/keyword?"
                                               "clojure.browser.event/fire-listeners"
                                               "cljs.core/interleave"
                                               "cljs.core/*flush-on-newline*"
                                               "cljs.core/get-in"
                                               "clojure.browser.dom/element"
                                               "cljs.core/prim-seq"
                                               "cljs.core/<="
                                               "clojure.set/map-invert"
                                               "clojure.browser.event/listen"
                                               "cljs.core/neg?"
                                               "clojure.browser.dom/replace-node"
                                               "cljs.core/reverse"
                                               "cljs.core/realized?"}},
                           "0.0-971" {:added #{"cljs.core/type"
                                               "cljs.core/IFn"}},
                           "0.0-993" {},
                           "0.0-1006" {:added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                                "cljs.core/PersistentVector.fromArray"
                                                "cljs.core/PersistentVector"
                                                "cljs.core/PersistentVector.EMPTY"}},
                           "0.0-1011" {:added #{"cljs.core/println-str"
                                                "cljs.core/print-str"
                                                "cljs.core/prn-str-with-opts"
                                                "cljs.core/prn-str"}}},
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/reset!"
                                 "clojure.set/select"
                                 "cljs.core/delay"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/=="
                                 "clojure.browser.net/*timeout*"
                                 "cljs.core/let*"
                                 "cljs.core/remove-method"
                                 "cljs.core/frequencies"
                                 "cljs.core/pop"
                                 "cljs.core/not-every?"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.core/for"
                                 "cljs.core/instance?"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.reader/read-comment"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "clojure.browser.dom/set-value"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/assoc-in"
                                 "clojure.string/join"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.core/Set"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.core/prefers"
                                 "cljs.core/vary-meta"
                                 "cljs.core/when-let"
                                 "cljs.core/drop"
                                 "cljs.core/while"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/-"
                                 "cljs.core/loop*"
                                 "clojure.zip/vector-zip"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/some"
                                 "cljs.core/if"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.core/gensym"
                                 "cljs.core/in-ns"
                                 "cljs.core/+"
                                 "cljs.core/comp"
                                 "cljs.reader/desugar-meta"
                                 "cljs.core/pr"
                                 "clojure.string/upper-case"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/empty?"
                                 "cljs.core/newline"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "clojure.string/capitalize"
                                 "cljs.core/replicate"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.core/defn-"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.core/Subvec"
                                 "cljs.core/."
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "clojure.walk/postwalk"
                                 "clojure.zip/edit"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/Atom"
                                 "cljs.core/IMap"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/finally"
                                 "cljs.core/dec"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/ObjMap.fromObject"
                                 "clojure.browser.event/unique-event-id"
                                 "clojure.set/project"
                                 "clojure.string/trim-newline"
                                 "clojure.zip/insert-left"
                                 "cljs.core/true?"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IStack"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/prn"
                                 "clojure.zip/leftmost"
                                 "cljs.core/>="
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.core/dotimes"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.core/ns"
                                 "cljs.core/if-not"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/IWatchable"
                                 "clojure.zip/rightmost"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "clojure.string/replace-first"
                                 "clojure.browser.dom/get-value"
                                 "cljs.nodejs/process"
                                 "cljs.core/not="
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/IVector"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "clojure.browser.repl/start-evaluator"
                                 "clojure.browser.event/unlisten"
                                 "cljs.core/do"
                                 "cljs.core/fnil"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "cljs.core/load-file"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/IMultiFn"
                                 "clojure.zip/end?"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/dorun"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/list*"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.reader/read-string"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "clojure.string/split-lines"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/try*"
                                 "cljs.core/set"
                                 "cljs.core/print"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "clojure.set/intersection"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.core/get"
                                 "cljs.core/.."
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.core/max"
                                 "cljs.core/*3"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "clojure.string/split"
                                 "cljs.core/hash-map"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/constantly"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/and"
                                 "clojure.browser.repl/wrap-message"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/new"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/last"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/defrecord*"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "clojure.browser.repl/connect"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "clojure.zip/branch?"
                                 "cljs.core/ObjMap"
                                 "cljs.core/zipmap"
                                 "cljs.core/hash-combine"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/butlast"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/concat"
                                 "cljs.core/conj"
                                 "clojure.set/difference"
                                 "cljs.core/when-first"
                                 "cljs.core/distinct?"
                                 "cljs.core/pos?"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "cljs.core/is_proto_"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/catch"
                                 "cljs.core/deftype*"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/repeatedly"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.core/prn-str"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/even?"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.core/second"
                                 "cljs.core/set!"
                                 "clojure.set/rename"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "cljs.core/symbol"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/throw"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/letfn"
                                 "cljs.core/recur"
                                 "cljs.reader/read-discard"
                                 "cljs.core/inc"
                                 "cljs.core/name"
                                 "cljs.core/cycle"
                                 "cljs.core/fn*"
                                 "cljs.core/map"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "cljs.core/ISeq"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/nil?"
                                 "cljs.core/load-namespace"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "clojure.zip/make-node"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/ancestors"
                                 "cljs.core/integer?"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/partition-all"
                                 "cljs.core/merge-with"
                                 "clojure.browser.dom/set-properties"
                                 "cljs.core/trampoline"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/quote"
                                 "cljs.core/IEquiv"
                                 "cljs.core/js-delete"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.core/js*"
                                 "cljs.core/alength"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "cljs.core/every-pred"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.core/ISet"
                                 "cljs.core/LazySeq"
                                 "cljs.core/*2"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.reader/read-meta"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/def"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.nodejs/require"
                                 "clojure.browser.event/EventType"
                                 "cljs.core/merge"
                                 "clojure.browser.repl/send-result"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "clojure.zip/remove"
                                 "cljs.core/find"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/interleave"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "clojure.browser.dom/replace-node"
                                 "cljs.core/reverse"
                                 "cljs.core/realized?"},
                 :namespace-names #{"clojure.zip"
                                    "clojure.browser.dom"
                                    "clojure.set"
                                    "cljs.nodejs"
                                    "clojure.walk"
                                    "clojure.browser.event"
                                    "cljs.reader"
                                    "clojure.string"
                                    "clojure.browser.net"
                                    "cljs.core"
                                    "clojure.browser.repl"}},
       :compiler {:changes {"0.0-927" {:added #{"cljs.repl.rhino/current-repl-env"
                                                "cljs.repl/evaluate-form"
                                                "cljs.repl/load-stream"
                                                "cljs.repl.rhino/eval-result"
                                                "cljs.repl.browser/read-get"
                                                "cljs.repl.browser/load-javascript"
                                                "cljs.repl.browser/add-in-order"
                                                "cljs.repl/load-namespace"
                                                "cljs.repl.rhino/loaded-libs"
                                                "cljs.repl.browser/run-in-order"
                                                "cljs.repl.browser/compile-client-js"
                                                "cljs.repl.browser/handle-get"
                                                "cljs.repl.browser/stop-server"
                                                "cljs.repl.browser/read-request"
                                                "cljs.repl/load-file"
                                                "cljs.repl.browser/browser-eval"
                                                "cljs.repl.browser/server-state"
                                                "cljs.repl.browser/send-for-eval"
                                                "cljs.repl.browser/constrain-order"
                                                "cljs.repl.rhino/rhino-eval"
                                                "cljs.repl.browser/read-headers"
                                                "cljs.repl/repl"
                                                "cljs.repl.rhino/load-javascript"
                                                "cljs.repl.browser/create-client-js-file"
                                                "cljs.repl/*cljs-verbose*"
                                                "cljs.repl.browser/loaded-libs"
                                                "cljs.repl.browser/repl-client-js"
                                                "cljs.repl.browser/parse-headers"
                                                "cljs.repl.browser/send-404"
                                                "cljs.repl.browser/repl-env"
                                                "cljs.repl.rhino/repl-env"
                                                "cljs.repl.rhino/goog-require"
                                                "cljs.repl.browser/send-repl-client-page"
                                                "cljs.repl.browser/send-and-close"
                                                "cljs.repl.rhino/bootjs"
                                                "cljs.repl/IJavaScriptEnv"
                                                "cljs.repl.browser/handle-connection"
                                                "cljs.repl.rhino/IEval"
                                                "cljs.repl.browser/start-server"
                                                "cljs.repl.browser/server-loop"
                                                "cljs.repl.browser/read-post"
                                                "cljs.repl.rhino/rhino-setup"
                                                "cljs.repl.browser/handle-post"
                                                "cljs.repl.rhino/stacktrace"
                                                "cljs.repl.browser/ordering"}},
                            "0.0-971" {},
                            "0.0-993" {:added #{"cljs.repl/default-special-fns"}},
                            "0.0-1006" {},
                            "0.0-1011" {}},
                  :symbol-names #{"cljs.repl.rhino/current-repl-env"
                                  "cljs.repl/evaluate-form"
                                  "cljs.repl/load-stream"
                                  "cljs.repl.rhino/eval-result"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl/load-namespace"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl.browser/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.repl/repl"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.repl.browser/handle-post"
                                  "cljs.repl.rhino/stacktrace"
                                  "cljs.repl.browser/ordering"},
                  :namespace-names #{"cljs.repl.browser"
                                     "cljs.repl.rhino"
                                     "cljs.repl"}}}}
