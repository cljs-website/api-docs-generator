{:version "0.0-2199",
 :history {:versions ("0.0-2199"
                      "0.0-2197"
                      "0.0-2173"
                      "0.0-2156"
                      "0.0-2138"
                      "0.0-2134"
                      "0.0-2127"
                      "0.0-2120"
                      "0.0-2080"
                      "0.0-2075"
                      "0.0-2069"
                      "0.0-2067"
                      "0.0-2060"
                      "0.0-2030"
                      "0.0-2027"
                      "0.0-2024"
                      "0.0-2014"
                      "0.0-1978"
                      "0.0-1934"
                      "0.0-1933"
                      "0.0-1913"
                      "0.0-1909"
                      "0.0-1896"
                      "0.0-1895"
                      "0.0-1889"
                      "0.0-1886"
                      "0.0-1885"
                      "0.0-1878"
                      "0.0-1877"
                      "0.0-1859"
                      "0.0-1853"
                      "0.0-1847"
                      "0.0-1844"
                      "0.0-1843"
                      "0.0-1835"
                      "0.0-1820"
                      "0.0-1806"
                      "0.0-1803"
                      "0.0-1798"
                      "0.0-1586"
                      "0.0-1576"
                      "0.0-1552"
                      "0.0-1535"
                      "0.0-1513"
                      "0.0-1503"
                      "0.0-1450"
                      "0.0-1449"
                      "0.0-1443"
                      "0.0-1424"
                      "0.0-1236"
                      "0.0-1211"
                      "0.0-1011"
                      "0.0-1006"
                      "0.0-993"
                      "0.0-971"
                      "0.0-927"),
           :details {"0.0-2030" {:tag "r2030",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2067" {:tag "r2067",
                                 :date "2013-11-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2134" {:tag "r2134",
                                 :date "2013-12-30",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1803" {:tag "r1803",
                                 :date "2013-05-06",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1886" {:tag "r1886",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2138" {:tag "r2138",
                                 :date "2013-12-31",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2127" {:tag "r2127",
                                 :date "2013-12-20",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2199" {:tag "r2199",
                                 :date "2014-04-01",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2120" {:tag "r2120",
                                 :date "2013-12-13",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1878" {:tag "r1878",
                                 :date "2013-09-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1236" {:tag "r1236",
                                 :date "2012-05-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2060" {:tag "r2060",
                                 :date "2013-11-21",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1424" {:tag "r1424",
                                 :date "2012-06-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-1885" {:tag "r1885",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1535" {:tag "r1535",
                                 :date "2012-11-08",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-1859" {:tag "r1859",
                                 :date "2013-08-19",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1853" {:tag "r1853",
                                 :date "2013-08-05",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2197" {:tag "r2197",
                                 :date "2014-03-26",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2075" {:tag "r2075",
                                 :date "2013-11-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1909" {:tag "r1909",
                                 :date "2013-09-27",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.8",
                                 :treader-tag "tools.reader-0.7.8",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1552" {:tag "r1552",
                                 :date "2012-12-03",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-2080" {:tag "r2080",
                                 :date "2013-11-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1806" {:tag "r1806",
                                 :date "2013-05-10",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1576" {:tag "r1576",
                                 :date "2013-01-27",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-1844" {:tag "r1844",
                                 :date "2013-07-19",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1586" {:tag "r1586",
                                 :date "2013-02-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1443" {:tag "r1443",
                                 :date "2012-07-06",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-1006" {:tag "r1006",
                                 :date "2012-03-30",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-1913" {:tag "r1913",
                                 :date "2013-10-05",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.8",
                                 :treader-tag "tools.reader-0.7.8",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2069" {:tag "r2069",
                                 :date "2013-11-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1513" {:tag "r1513",
                                 :date "2012-10-19",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376-2",
                                 :gclosure-com nil},
                     "0.0-1503" {:tag "r1503",
                                 :date "2012-10-12",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376-2",
                                 :gclosure-com nil},
                     "0.0-1933" {:tag "r1933",
                                 :date "2013-10-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.9",
                                 :treader-tag "tools.reader-0.7.9",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1895" {:tag "r1895",
                                 :date "2013-09-24",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-971" {:tag "r971",
                                :date "2012-01-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-2027" {:tag "r2027",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1978" {:tag "r1978",
                                 :date "2013-10-28",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1843" {:tag "r1843",
                                 :date "2013-07-16",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1835" {:tag "r1835",
                                 :date "2013-06-21",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1450" {:tag "r1450",
                                 :date "2012-07-25",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2173" {:tag "r2173",
                                 :date "2014-02-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1798" {:tag "r1798",
                                 :date "2013-05-03",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1877" {:tag "r1877",
                                 :date "2013-09-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1211" {:tag "r1211",
                                 :date "2012-05-09",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-1449" {:tag "r1449",
                                 :date "2012-07-24",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-993" {:tag "r993",
                                :date "2012-02-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-1011" {:tag "r1011",
                                 :date "2012-04-02",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-2156" {:tag "r2156",
                                 :date "2014-01-29",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1847" {:tag "r1847",
                                 :date "2013-07-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-927" {:tag "r927",
                                :date "2012-01-20",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "20110323-r790",
                                :gclosure-com nil},
                     "0.0-1934" {:tag "r1934",
                                 :date "2013-10-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.9",
                                 :treader-tag "tools.reader-0.7.9",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1820" {:tag "r1820",
                                 :date "2013-06-07",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2024" {:tag "r2024",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1889" {:tag "r1889",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1896" {:tag "r1896",
                                 :date "2013-09-24",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2014" {:tag "r2014",
                                 :date "2013-11-06",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil}}},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.core/*in*"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.test/use-fixtures"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.core/proxy-super"
                 "clojure.core/refer"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.test/do-report"
                 "clojure.core/send"
                 "clojure.test/testing"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core/agent-error"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.java.io/make-writer"
                 "clojure.test/test-var"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.test/testing-contexts-str"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.test/join-fixtures"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.test/run-tests"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.test/successful?"
                 "clojure.core/await"
                 "clojure.test/testing-vars-str"
                 "clojure.core/supers"
                 "clojure.test/is"
                 "clojure.reflect/Field"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.core/require"
                 "clojure.pprint/pprint-tab"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.core/ref-set"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test/run-all-tests"
                 "clojure.test.tap/with-tap-output"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/*data-readers*"
                 "clojure.core/use"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.main/repl-requires"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/nthrest"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.test/compose-fixtures"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.core/test"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.core/with-bindings*"
                 "clojure.test/test-ns"
                 "clojure.test/assert-predicate"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.reflect/->Field"
                 "clojure.core/*default-data-reader-fn*"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.edn/read"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/send-via"
                 "clojure.core/set-agent-send-executor!"
                 "clojure.core/*e"
                 "clojure.core/create-ns"
                 "clojure.repl/doc"
                 "clojure.core/aset-int"
                 "clojure.edn/read-string"
                 "clojure.test/test-all-vars"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.reflect/map->Method"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.test/with-test"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.template/apply-template"
                 "clojure.core/set-agent-send-off-executor!"
                 "clojure.core/cast"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.core/ensure"
                 "clojure.string/re-quote-replacement"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/locking"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.test/are"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.core/resolve"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/file-seq"
                 "clojure.core/ns-interns"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core.reducers/->Cat"
                 "clojure.core/get-thread-bindings"
                 "clojure.core/var"
                 "clojure.stacktrace/e"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/error-mode"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/definterface"
                 "clojure.core/pcalls"
                 "clojure.core/ns-unalias"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.test/function?"
                 "clojure.pprint/pprint"
                 "clojure.test/deftest"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.main/main"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.test/try-expr"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.test/report"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.reflect/->JavaReflector"
                 "clojure.core/*compiler-options*"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.main/with-read-known"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :symbols {"cljs.core/keys" {:ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :name-encode "keys",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (KeySeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [6069 6073]},
                             :full-name "cljs.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/unchecked-negate" {:ns "cljs.core",
                                         :name "unchecked-negate",
                                         :signature ["[x]"],
                                         :name-encode "unchecked-negate",
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-negate",
                                         :source {:code "(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [1622 1623]},
                                         :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/clj/cljs/core.clj",
                                                          :lines [388
                                                                  389]}],
                                         :full-name "cljs.core/unchecked-negate"},
           "cljs.core/reset!" {:ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :name-encode "resetBANG",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (assert (validate new-value) \"Validator rejected reference state\"))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7151 7164]},
                               :full-name "cljs.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/ITransientCollection" {:ns "cljs.core",
                                             :name "ITransientCollection",
                                             :name-encode "ITransientCollection",
                                             :implementations #{"TransientArrayMap"
                                                                "TransientVector"
                                                                "TransientHashMap"
                                                                "TransientHashSet"},
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/ITransientCollection",
                                             :source {:code "(defprotocol ITransientCollection\n  (^clj -conj! [tcoll val])\n  (^clj -persistent! [tcoll]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [347 349]},
                                             :methods [{:name "-conj!",
                                                        :signature ["[tcoll val]"],
                                                        :docstring nil}
                                                       {:name "-persistent!",
                                                        :signature ["[tcoll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/ITransientCollection"},
           "cljs.core/transient" {:ns "cljs.core",
                                  :name "transient",
                                  :signature ["[coll]"],
                                  :name-encode "transient",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transient",
                                  :source {:code "(defn transient\n  [coll]\n  (-as-transient coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2505 2508]},
                                  :full-name "cljs.core/transient",
                                  :docstring "Returns a new, transient version of the collection, in constant time."},
           "cljs.core/Fn" {:ns "cljs.core",
                           :name "Fn",
                           :name-encode "Fn",
                           :implementations #{"function"},
                           :history [["+" "0.0-1552"]],
                           :type "protocol",
                           :full-name-encode "cljs.core/Fn",
                           :source {:code "(defprotocol Fn\n  \"Marker protocol\")",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [199 200]},
                           :full-name "cljs.core/Fn",
                           :docstring "Marker protocol"},
           "clojure.data/EqualityPartition" {:ns "clojure.data",
                                             :name "EqualityPartition",
                                             :name-encode "EqualityPartition",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.data/EqualityPartition",
                                             :source {:code "(defprotocol EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/clojure/data.cljs",
                                                      :lines [75 77]},
                                             :methods [{:name "equality-partition",
                                                        :signature ["[x]"],
                                                        :docstring "Implementation detail. Subject to change."}],
                                             :full-name "clojure.data/EqualityPartition",
                                             :docstring "Implementation detail. Subject to change."},
           "cljs.core/ex-message" {:ns "cljs.core",
                                   :name "ex-message",
                                   :signature ["[ex]"],
                                   :name-encode "ex-message",
                                   :history [["+" "0.0-1576"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/ex-message",
                                   :source {:code "(defn ex-message\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7760 7766]},
                                   :full-name "cljs.core/ex-message",
                                   :docstring "Alpha - subject to change.\nReturns the message attached to the given Error / ExceptionInfo object.\nFor non-Errors returns nil."},
           "clojure.set/select" {:ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :name-encode "select",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :name-encode "delay",
                              :type "macro",
                              :full-name-encode "cljs.core/delay",
                              :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core/Delay (atom {:done false, :value nil}) (fn [] ~@body)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1045 1050]},
                              :full-name "cljs.core/delay",
                              :history [["+" "0.0-927"]]},
           "cljs.core/float" {:return-type number,
                              :ns "cljs.core",
                              :name "float",
                              :signature ["[x]"],
                              :name-encode "float",
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/float",
                              :source {:code "(defn ^number float [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1566]},
                              :extra-sources [{:code "(defmacro float [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [352]}],
                              :full-name "cljs.core/float"},
           "cljs.core/bit-not" {:ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :name-encode "bit-not",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1738 1740]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [479 480]}],
                                :full-name "cljs.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :name-encode "partition",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3147 3167]},
                                  :full-name "cljs.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition upto n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/IEncodeJS" {:ns "cljs.core",
                                  :name "IEncodeJS",
                                  :name-encode "IEncodeJS",
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IEncodeJS",
                                  :source {:code "(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7312 7315]},
                                  :methods [{:name "-clj->js",
                                             :signature ["[x]"],
                                             :docstring "Recursively transforms clj values to JavaScript"}
                                            {:name "-key->js",
                                             :signature ["[x]"],
                                             :docstring "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}],
                                  :full-name "cljs.core/IEncodeJS",
                                  :history [["+" "0.0-1552"]]},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :name-encode "parents",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/parents",
                                :source {:code "(defn parents\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7477 7483]},
                                :full-name "cljs.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :name-encode "aclone",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/aclone",
                               :source {:code "(defn aclone\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [153 160]},
                               :full-name "cljs.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :name-encode "reset-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7227 7230]},
                                    :full-name "cljs.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "cljs.core/IReset" {:ns "cljs.core",
                               :name "IReset",
                               :name-encode "IReset",
                               :type "protocol",
                               :full-name-encode "cljs.core/IReset",
                               :source {:code "(defprotocol IReset\n  (-reset! [o new-value]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7098 7099]},
                               :methods [{:name "-reset!",
                                          :signature ["[o new-value]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IReset",
                               :history [["+" "0.0-2173"]]},
           "warnings/invoke-ctor" {:ns "warnings",
                                   :name "invoke-ctor",
                                   :type "warning",
                                   :full-name "warnings/invoke-ctor",
                                   :full-name-encode "warnings/invoke-ctor",
                                   :name-encode "invoke-ctor",
                                   :history [["+" "0.0-2060"]]},
           "cljs.core/Box" {:ns "cljs.core",
                            :name "Box",
                            :signature ["[val]"],
                            :name-encode "Box",
                            :type "type",
                            :full-name-encode "cljs.core/Box",
                            :source {:code "(deftype Box [^:mutable val])",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [4495]},
                            :full-name "cljs.core/Box",
                            :history [["+" "0.0-1424"]]},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :signature ["[s]"],
                                          :name-encode "dispatch-macros",
                                          :type "function",
                                          :full-name-encode "cljs.reader/dispatch-macros",
                                          :source {:code "(defn dispatch-macros [s]\n  (cond\n   (identical? s \"{\") read-set\n   (identical? s \"<\") (throwing-reader \"Unreadable form\")\n   (identical? s \"\\\"\") read-regex\n   (identical? s\"!\") read-comment\n   (identical? s \"_\") read-discard\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [403 410]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "closure-warnings/externs-validation" {:ns "closure-warnings",
                                                  :name "externs-validation",
                                                  :type "warning",
                                                  :full-name "closure-warnings/externs-validation",
                                                  :full-name-encode "closure-warnings/externs-validation",
                                                  :name-encode "externs-validation",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :name-encode "current-repl-env",
                                               :type "var",
                                               :full-name-encode "cljs.repl.rhino/current-repl-env",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :name-encode "ICollection",
                                    :implementations #{"Subvec"
                                                       "PersistentQueue"
                                                       "PersistentHashMap"
                                                       "PersistentTreeSet"
                                                       "PersistentArrayMapSeq"
                                                       "RedNode"
                                                       "EmptyList"
                                                       "ObjMap"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "ValSeq"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "PersistentQueueSeq"
                                                       "ChunkedSeq"
                                                       "ArrayNodeSeq"
                                                       "KeySeq"
                                                       "IndexedSeq"
                                                       "PersistentTreeMap"
                                                       "PersistentTreeMapSeq"
                                                       "RSeq"
                                                       "PersistentArrayMap"
                                                       "PersistentHashSet"
                                                       "NodeSeq"
                                                       "List"
                                                       "Cons"
                                                       "LazySeq"},
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ICollection",
                                    :source {:code "(defprotocol ICollection\n  (^clj -conj [coll o]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [235 236]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/ICollection"},
           "warnings/redef" {:ns "warnings",
                             :name "redef",
                             :type "warning",
                             :full-name "warnings/redef",
                             :full-name-encode "warnings/redef",
                             :name-encode "redef",
                             :history [["+" "0.0-1835"]]},
           "cljs.core/every?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :name-encode "everyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/everyQMARK",
                               :source {:code "(defn ^boolean every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2650 2657]},
                               :full-name "cljs.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :name-encode "node",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :name-encode "IEmptyableCollection",
                                             :implementations #{"Subvec"
                                                                "PersistentQueue"
                                                                "PersistentHashMap"
                                                                "PersistentTreeSet"
                                                                "PersistentArrayMapSeq"
                                                                "RedNode"
                                                                "EmptyList"
                                                                "ObjMap"
                                                                "BlackNode"
                                                                "PersistentVector"
                                                                "ValSeq"
                                                                "ChunkedCons"
                                                                "Range"
                                                                "PersistentQueueSeq"
                                                                "ChunkedSeq"
                                                                "ArrayNodeSeq"
                                                                "KeySeq"
                                                                "IndexedSeq"
                                                                "PersistentTreeMap"
                                                                "PersistentTreeMapSeq"
                                                                "RSeq"
                                                                "PersistentArrayMap"
                                                                "PersistentHashSet"
                                                                "NodeSeq"
                                                                "List"
                                                                "Cons"
                                                                "LazySeq"},
                                             :history [["+" "0.0-927"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [232 233]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEmptyableCollection"},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :name-encode "right",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "cljs.core/int-array" {:ns "cljs.core",
                                  :name "int-array",
                                  :signature ["[size-or-seq]"
                                              "[size init-val-or-seq]"],
                                  :name-encode "int-array",
                                  :type "function",
                                  :full-name-encode "cljs.core/int-array",
                                  :source {:code "(defn int-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2371 2389]},
                                  :full-name "cljs.core/int-array",
                                  :history [["+" "0.0-1798"]]},
           "cljs.core/==" {:return-type boolean,
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "EQEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/EQEQ",
                           :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1775 1786]},
                           :extra-sources [{:code "(defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [444 447]}],
                           :full-name "cljs.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
           "cljs.core/dissoc!" {:ns "cljs.core",
                                :name "dissoc!",
                                :signature ["[tcoll key]"
                                            "[tcoll key & ks]"],
                                :name-encode "dissocBANG",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/dissocBANG",
                                :source {:code "(defn dissoc!\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key & ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2540 2548]},
                                :full-name "cljs.core/dissoc!",
                                :docstring "Returns a transient map that doesn't contain a mapping for key(s)."},
           "clojure.reflect/meta" {:ns "clojure.reflect",
                                   :name "meta",
                                   :signature ["[sym cb]"],
                                   :name-encode "meta",
                                   :history [["+" "0.0-1503"]],
                                   :type "function",
                                   :full-name-encode "clojure.reflect/meta",
                                   :source {:code "(defn meta\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/reflect.cljs",
                                            :lines [24 30]},
                                   :full-name "clojure.reflect/meta",
                                   :docstring "Queries the reflection api with a fully qualified symbol, then calls\ncallback fn cb with the evaluated cljs map containing that symbol's\nmeta information."},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :name-encode "STARtimeoutSTAR",
                                            :type "var",
                                            :full-name-encode "clojure.browser.net/STARtimeoutSTAR",
                                            :source {:code "(def *timeout* 10000)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/browser/net.cljs",
                                                     :lines [21]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/let*" {:ns "cljs.core",
                             :name "let*",
                             :type "special form",
                             :source {:code "(defmethod parse 'let*\n  [op encl-env form _]\n  (analyze-let encl-env form false))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [853 855]},
                             :extra-sources ({:code "(defmethod emit* :let [ast]\n  (emit-let ast false))",
                                              :title "Emitting code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/compiler.clj",
                                              :lines [651 652]}),
                             :full-name "cljs.core/let*",
                             :full-name-encode "cljs.core/letSTAR",
                             :name-encode "letSTAR",
                             :history [["+" "0.0-927"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :name-encode "remove-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7693 7696]},
                                      :full-name "cljs.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "cljs.core/array-chunk" {:ns "cljs.core",
                                    :name "array-chunk",
                                    :signature ["[arr]"
                                                "[arr off]"
                                                "[arr off end]"],
                                    :name-encode "array-chunk",
                                    :type "function",
                                    :full-name-encode "cljs.core/array-chunk",
                                    :source {:code "(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2258 2264]},
                                    :full-name "cljs.core/array-chunk",
                                    :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/drop" {:ns "clojure.core.reducers",
                                         :name "drop",
                                         :signature ["[n]" "[n coll]"],
                                         :name-encode "drop",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/drop",
                                         :source {:code "(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [178 190]},
                                         :full-name "clojure.core.reducers/drop",
                                         :docstring "Elides the first n values from the reduction of coll."},
           "syntax/symbol" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "symbol",
                            :name-encode "symbol",
                            :type "syntax",
                            :full-name-encode "syntax/symbol",
                            :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  {:line line :column column\n                   :end-line (get-line-number rdr)\n                   :end-column (int (get-column-number rdr))})))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [263 285]}),
                            :full-name "syntax/symbol",
                            :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentArrayMap.fromArrays" {:ns "cljs.core",
                                                      :name "PersistentArrayMap.fromArrays",
                                                      :signature ["[ks vs]"],
                                                      :name-encode "PersistentArrayMapDOTfromArrays",
                                                      :history [["+"
                                                                 "0.0-1211"]
                                                                ["-"
                                                                 "0.0-1798"]],
                                                      :parent-type "PersistentArrayMap",
                                                      :type "function",
                                                      :full-name-encode "cljs.core/PersistentArrayMapDOTfromArrays",
                                                      :source {:code "(set! cljs.core.PersistentArrayMap/fromArrays\n      (fn [ks vs]\n        (let [len (count ks)]\n          (loop [i   0\n                 out (transient cljs.core.PersistentArrayMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1586",
                                                               :filename "src/cljs/cljs/core.cljs",
                                                               :lines [3976
                                                                       3983]},
                                                      :full-name "cljs.core/PersistentArrayMap.fromArrays",
                                                      :removed {:in "0.0-1798",
                                                                :last-seen "0.0-1586"}},
           "cljs.core/frequencies" {:ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :name-encode "frequencies",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [6647 6654]},
                                    :full-name "cljs.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/pop" {:ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :name-encode "pop",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/pop",
                            :source {:code "(defn pop\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1070 1076]},
                            :full-name "cljs.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.core/not-every?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :name-encode "not-everyQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/not-everyQMARK",
                                   :source {:code "(defn ^boolean not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2659 2662]},
                                   :full-name "cljs.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/some-fn" {:ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :name-encode "some-fn",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2872 2909]},
                                :full-name "cljs.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "vector",
                            :name-encode "vector",
                            :type "syntax",
                            :full-name-encode "syntax/vector",
                            :extra-sources ({:code "(defn- read-vector\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-vector (read-delimited \\] rdr true)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta the-vector\n      (when start-line\n        {:line start-line\n         :column start-column\n         :end-line end-line\n         :end-column end-column}))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [182 194]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [578 597]}),
                            :full-name "syntax/vector",
                            :history [["+" "0.0-1853"]]},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :name-encode "remove-all",
                                               :type "function",
                                               :full-name-encode "clojure.browser.event/remove-all",
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [98]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :name-encode "doto",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.5.1",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3463 3478]},
                             :full-name "cljs.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred coll]"],
                                   :name-encode "take-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/take-while",
                                   :source {:code "(defn take-while\n  [pred coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (when (pred (first s))\n       (cons (first s) (take-while pred (rest s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6495 6502]},
                                   :full-name "cljs.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects."},
           "closure-warnings/duplicate-message" {:ns "closure-warnings",
                                                 :name "duplicate-message",
                                                 :type "warning",
                                                 :full-name "closure-warnings/duplicate-message",
                                                 :full-name-encode "closure-warnings/duplicate-message",
                                                 :name-encode "duplicate-message",
                                                 :history [["+"
                                                            "0.0-2120"]]},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"],
                                      :name-encode "evaluate-form",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n     (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n     (try\n       (binding [ana/*cljs-file* filename]\n         (let [ast (ana/analyze env form)\n               js (comp/emit-str ast)\n               wrap-js\n               (if (:source-map repl-env)\n                 (binding [comp/*source-map-data*\n                           (atom {:source-map (sorted-map)\n                                  :gen-col 0\n                                  :gen-line 0})]\n                   (let [js (comp/emit-str (ana/no-warn (ana/analyze env (wrap form))))\n                         t (System/currentTimeMillis)]\n                     (str js\n                          \"\\n//# sourceURL=repl-\" t \".js\"\n                          \"\\n//# sourceMappingURL=data:application/json;base64,\"\n                          (DatatypeConverter/printBase64Binary\n                           (.getBytes\n                            (sm/encode\n                             {(str \"repl-\" t \".cljs\")\n                              (:source-map @comp/*source-map-data*)}\n                             {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                              :file  (str \"repl-\" t \".js\")\n                              :sources-content\n                              [(or (:source (meta form))\n                                   ;; handle strings / primitives without metadata\n                                   (with-out-str (pr form)))]})\n                            \"UTF-8\")))))\n                 (comp/emit-str (ana/no-warn (ana/analyze env (wrap form)))))]\n           (when (= (:op ast) :ns)\n             (load-dependencies repl-env (into (vals (:requires ast))\n                                               (distinct (vals (:uses ast))))))\n           (when *cljs-verbose*\n             (print js))\n           (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n             (case (:status ret)\n               ;;we eat ns errors because we know goog.provide() will throw when reloaded\n               ;;TODO - file bug with google, this is bs error\n               ;;this is what you get when you try to 'teach new developers'\n               ;;via errors (goog/base.js 104)\n               :error (display-error ret form)\n               :exception (display-error ret form\n                                         #(prn \"Error evaluating:\" form :as js))\n               :success (:value ret)))))\n       (catch Throwable ex\n         (.printStackTrace ex)\n         (println (str ex))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [73 125]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :signature ["[c]"],
                                          :name-encode "escape-char-map",
                                          :type "function",
                                          :full-name-encode "cljs.reader/escape-char-map",
                                          :source {:code "(defn escape-char-map [c]\n  (cond\n   (identical? c \\t) \"\\t\"\n   (identical? c \\r) \"\\r\"\n   (identical? c \\n) \"\\n\"\n   (identical? c \\\\) \\\\\n   (identical? c \\\") \\\"\n   (identical? c \\b) \"\\b\"\n   (identical? c \\f) \"\\f\"\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [158 167]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "closure-warnings/tweaks" {:ns "closure-warnings",
                                      :name "tweaks",
                                      :type "warning",
                                      :full-name "closure-warnings/tweaks",
                                      :full-name-encode "closure-warnings/tweaks",
                                      :name-encode "tweaks",
                                      :history [["+" "0.0-2120"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :signature ["[obj type capture]"],
                                                  :name-encode "all-listeners",
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.event/all-listeners",
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/cljs/clojure/browser/event.cljs",
                                                           :lines [90]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/ITransientSet" {:ns "cljs.core",
                                      :name "ITransientSet",
                                      :name-encode "ITransientSet",
                                      :implementations #{"TransientHashSet"},
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientSet",
                                      :source {:code "(defprotocol ITransientSet\n  (^clj -disjoin! [tcoll v]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [361 362]},
                                      :methods [{:name "-disjoin!",
                                                 :signature ["[tcoll v]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientSet"},
           "closure-warnings/es5-strict" {:ns "closure-warnings",
                                          :name "es5-strict",
                                          :type "warning",
                                          :full-name "closure-warnings/es5-strict",
                                          :full-name-encode "closure-warnings/es5-strict",
                                          :name-encode "es5-strict",
                                          :history [["+" "0.0-2120"]]},
           "cljs.core/vals" {:ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :name-encode "vals",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (ValSeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [6133 6137]},
                             :full-name "cljs.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :name-encode "IDeref",
                               :implementations #{"Reduced"
                                                  "Delay"
                                                  "Atom"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IDeref",
                               :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [279 280]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IDeref"},
           "cljs.core/string-hash-cache" {:ns "cljs.core",
                                          :name "string-hash-cache",
                                          :name-encode "string-hash-cache",
                                          :type "var",
                                          :full-name-encode "cljs.core/string-hash-cache",
                                          :source {:code "(def string-hash-cache (js-obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1093]},
                                          :full-name "cljs.core/string-hash-cache",
                                          :history [["+" "0.0-1424"]]},
           "warnings/protocol-deprecated" {:ns "warnings",
                                           :name "protocol-deprecated",
                                           :type "warning",
                                           :full-name "warnings/protocol-deprecated",
                                           :full-name-encode "warnings/protocol-deprecated",
                                           :name-encode "protocol-deprecated",
                                           :history [["+" "0.0-1835"]]},
           "cljs.core/array-map" {:ns "cljs.core",
                                  :name "array-map",
                                  :signature ["[& keyvals]"],
                                  :name-encode "array-map",
                                  :history [["+" "0.0-1211"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/array-map",
                                  :source {:code "(defn array-map\n  [& keyvals]\n  (PersistentArrayMap. nil (quot (count keyvals) 2) (apply array keyvals) nil))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5978 5982]},
                                  :extra-sources [{:code "(defmacro array-map\n  ([] `cljs.core.PersistentArrayMap.EMPTY)\n  ([& kvs]\n    (core/cond\n      (core/> (count kvs) 16)\n      `(hash-map ~@kvs)\n      \n      (let [keys (map first (partition 2 kvs))]\n        (core/and (every? #(= (:op %) :constant)\n                    (map #(cljs.analyzer/analyze &env %) keys))\n                  (= (count (into #{} keys)) (count keys))))\n      `(cljs.core.PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n\n      :else\n      `(cljs.core.PersistentArrayMap.fromArray (array ~@kvs) true false))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [1349 1363]}],
                                  :full-name "cljs.core/array-map",
                                  :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :signature ["[obj]"],
                                          :name-encode "log-obj",
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/log-obj",
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [23 24]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.nodejs/enable-util-print!" {:ns "cljs.nodejs",
                                             :name "enable-util-print!",
                                             :signature ["[]"],
                                             :name-encode "enable-util-printBANG",
                                             :type "function",
                                             :full-name-encode "cljs.nodejs/enable-util-printBANG",
                                             :source {:code "(defn enable-util-print! []\n  (set! cljs.core/string-print (.-print (require \"util\"))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/nodejs.cljs",
                                                      :lines [11 12]},
                                             :full-name "cljs.nodejs/enable-util-print!",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "cljs.core/for" {:ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :name-encode "for",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/for",
                            :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (core/keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (core/cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_ \"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                            (loop [~gxs ~gxs]\n                              (when-first [~bind ~gxs]\n                                ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (core/cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (core/keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# ^not-native (chunk-first ~gxs)\n                                           size# (count c#)\n                                           ~gb (chunk-buffer size#)]\n                                       (if (coercive-boolean\n                                            (loop [~gi 0]\n                                              (if (< ~gi size#)\n                                                (let [~bind (-nth c# ~gi)]\n                                                  ~(do-cmod mod-pairs))\n                                                true)))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [1173 1258]},
                            :full-name "cljs.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "syntax/inst-literal" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "inst-literal",
                                  :name-encode "inst-literal",
                                  :type "tagged literal",
                                  :full-name-encode "syntax/inst-literal",
                                  :extra-sources ({:code "(defn read-inst\n  [form]\n  (when-not (string? form)\n    (throw (RuntimeException. \"Instance literal expects a string for its timestamp.\")))\n  (try\n    (inst/read-instant-date form)\n    (catch Throwable e\n      (throw (RuntimeException. (.getMessage e))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [19 26]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [44 48]}),
                                  :full-name "syntax/inst-literal",
                                  :history [["+" "0.0-1424"]]},
           "cljs.core/unchecked-multiply-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-multiply-int",
                                               :signature ["[]"
                                                           "[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :name-encode "unchecked-multiply-int",
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-multiply-int",
                                               :source {:code "(defn ^number unchecked-multiply-int\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [1615
                                                                1620]},
                                               :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r2199",
                                                                :filename "src/clj/cljs/core.clj",
                                                                :lines [385
                                                                        386]}],
                                               :full-name "cljs.core/unchecked-multiply-int",
                                               :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/cond->" {:ns "cljs.core",
                               :name "cond->",
                               :signature ["[expr & clauses]"],
                               :name-encode "cond-GT",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/cond-GT",
                               :source {:code "(defmacro cond->\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (-> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.5.1",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [6775 6787]},
                               :full-name "cljs.core/cond->",
                               :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression."},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :signature ["[repl-env filename res]"],
                                    :name-encode "load-stream",
                                    :type "function",
                                    :full-name-encode "cljs.repl/load-stream",
                                    :source {:code "(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (doseq [form (ana/forms-seq res filename)]\n      (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n        (evaluate-form repl-env env filename form)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [127 131]},
                                    :full-name "cljs.repl/load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :name-encode "instanceQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/instanceQMARK",
                                  :source {:code "(defn ^boolean instance? [t o]\n  (cljs.core/instance? t o))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [402 403]},
                                  :extra-sources [{:code "(defmacro instance? [t o]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? t)\n               (core/list 'js* \"(~{} instanceof ~{})\" o t)\n               `(let [t# ~t o# ~o]\n                  (~'js* \"(~{} instanceof ~{})\" o# t#)))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [311 318]}],
                                  :full-name "cljs.core/instance?"},
           "cljs.core/ValSeq" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "ValSeq",
                               :signature ["[mseq _meta]"],
                               :name-encode "ValSeq",
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/ValSeq",
                               :source {:code "(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (ValSeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY _meta))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6080 6131]},
                               :full-name "cljs.core/ValSeq"},
           "cljs.core/rseq" {:return-type seq,
                             :ns "cljs.core",
                             :name "rseq",
                             :signature ["[coll]"],
                             :name-encode "rseq",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/rseq",
                             :source {:code "(defn ^seq rseq [coll]\n  (-rseq coll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2006 2007]},
                             :full-name "cljs.core/rseq"},
           "cljs.core/PersistentVector.EMPTY_NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :name-encode "PersistentVectorDOTEMPTY_NODE",
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY_NODE",
                                                    :source {:code "(set! cljs.core.PersistentVector.EMPTY_NODE (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3479]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]]},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :name-encode "read-comment",
                                       :type "var",
                                       :full-name-encode "cljs.reader/read-comment",
                                       :source {:code "(def read-comment skip-line)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [274]},
                                       :full-name "cljs.reader/read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/eval-result" {:ns "cljs.repl.rhino",
                                          :name "eval-result",
                                          :name-encode "eval-result",
                                          :type "multimethod",
                                          :full-name-encode "cljs.repl.rhino/eval-result",
                                          :source {:code "(defmulti eval-result class)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [47]},
                                          :full-name "cljs.repl.rhino/eval-result",
                                          :extra-sources ({:code "(defmethod eval-result :default [r]\n  (.toString r))",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [49
                                                                   50]}
                                                          {:code "(defmethod eval-result nil [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [52]}
                                                          {:code "(defmethod eval-result org.mozilla.javascript.Undefined [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [54]}),
                                          :history [["+" "0.0-927"]]},
           "cljs.core/ITransientMap" {:ns "cljs.core",
                                      :name "ITransientMap",
                                      :name-encode "ITransientMap",
                                      :implementations #{"TransientArrayMap"
                                                         "TransientHashMap"},
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientMap",
                                      :source {:code "(defprotocol ITransientMap\n  (^clj -dissoc! [tcoll key]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [354 355]},
                                      :methods [{:name "-dissoc!",
                                                 :signature ["[tcoll key]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientMap"},
           "closure-warnings/check-types" {:ns "closure-warnings",
                                           :name "check-types",
                                           :type "warning",
                                           :full-name "closure-warnings/check-types",
                                           :full-name-encode "closure-warnings/check-types",
                                           :name-encode "check-types",
                                           :history [["+" "0.0-2120"]]},
           "syntax/whitespace" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "whitespace",
                                :name-encode "whitespace",
                                :type "special character",
                                :full-name-encode "syntax/whitespace",
                                :full-name "syntax/whitespace",
                                :history [["+" "0.0-927"]]},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-number",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-number",
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (macros ch))\n      (do\n        (unread reader ch)\n        (let [s (. buffer (toString))]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [287 297]},
                                      :full-name "cljs.reader/read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :name-encode "ILookup",
                                :implementations #{"Subvec"
                                                   "PersistentHashMap"
                                                   "PersistentTreeSet"
                                                   "RedNode"
                                                   "TransientArrayMap"
                                                   "ObjMap"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "TransientVector"
                                                   "PersistentTreeMap"
                                                   "PersistentArrayMap"
                                                   "PersistentHashSet"
                                                   "TransientHashMap"
                                                   "TransientHashSet"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [253 254]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ILookup"},
           "cljs.core/when" {:ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :name-encode "when",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.5.1",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [471 475]},
                             :full-name "cljs.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "cljs.core/ArrayNodeSeq" {:protocols #{"ISeqable"
                                                  "IMeta"
                                                  "IWithMeta"
                                                  "IEmptyableCollection"
                                                  "IReduce"
                                                  "ISequential"
                                                  "ISeq"
                                                  "ICollection"
                                                  "IHash"
                                                  "IPrintWithWriter"
                                                  "IEquiv"},
                                     :ns "cljs.core",
                                     :name "ArrayNodeSeq",
                                     :signature ["[meta nodes i s __hash]"],
                                     :name-encode "ArrayNodeSeq",
                                     :history [["+" "0.0-1211"]],
                                     :type "type",
                                     :full-name-encode "cljs.core/ArrayNodeSeq",
                                     :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (ArrayNodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll] (create-array-node-seq nil nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5056 5095]},
                                     :full-name "cljs.core/ArrayNodeSeq"},
           "cljs.core/list?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "list?",
                              :signature ["[x]"],
                              :name-encode "listQMARK",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/listQMARK",
                              :source {:code "(defn ^boolean list? [x]\n  (satisfies? IList x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2084 2085]},
                              :full-name "cljs.core/list?"},
           "cljs.core/val" {:ns "cljs.core",
                            :name "val",
                            :signature ["[map-entry]"],
                            :name-encode "val",
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :full-name-encode "cljs.core/val",
                            :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [6139 6142]},
                            :full-name "cljs.core/val",
                            :docstring "Returns the value in the map entry."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :name-encode "set-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [142 145]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-get",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/read-get",
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [154 159]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/BitmapIndexedNode" {:ns "cljs.core",
                                          :name "BitmapIndexedNode",
                                          :signature ["[edit bitmap arr]"],
                                          :name-encode "BitmapIndexedNode",
                                          :type "type",
                                          :full-name-encode "cljs.core/BitmapIndexedNode",
                                          :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc cljs.core.BitmapIndexedNode.EMPTY (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc cljs.core.BitmapIndexedNode.EMPTY\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          [key-or-nil val-or-node]\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! cljs.core.BitmapIndexedNode.EMPTY edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! cljs.core.BitmapIndexedNode.EMPTY\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (aset removed-leaf? 0 true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [4558 4752]},
                                          :full-name "cljs.core/BitmapIndexedNode",
                                          :history [["+" "0.0-1211"]]},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :name-encode "read-past",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [222 229]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :signature ["[repl-env ns-list url]"],
                                                :name-encode "load-javascript",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/load-javascript",
                                                :source {:code "(defn load-javascript\n  [repl-env ns-list url]\n  (let [missing (remove #(contains? @loaded-libs %) ns-list)]\n    (when (seq missing)\n      (browser-eval (slurp url))\n      (swap! loaded-libs (partial apply conj) missing))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [168
                                                                 178]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :docstring "Accepts a REPL environment, a list of namespaces, and a URL for a\nJavaScript file which contains the implementation for the list of\nnamespaces. Will load the JavaScript file into the REPL environment\nif any of the namespaces have not already been loaded from the\nClojureScript REPL."},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :name-encode "to-array",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2350 2358]},
                                 :full-name "cljs.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep coll]"],
                                  :name-encode "interpose",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/interpose",
                                  :source {:code "(defn interpose\n  [sep coll] (drop 1 (interleave (repeat sep) coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3038 3040]},
                                  :full-name "cljs.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep"},
           "cljs.core/IMapEntry" {:ns "cljs.core",
                                  :name "IMapEntry",
                                  :name-encode "IMapEntry",
                                  :implementations #{"RedNode"
                                                     "BlackNode"
                                                     "PersistentVector"},
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IMapEntry",
                                  :source {:code "(defprotocol IMapEntry\n  (-key [coll])\n  (-val [coll]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [265 267]},
                                  :methods [{:name "-key",
                                             :signature ["[coll]"],
                                             :docstring nil}
                                            {:name "-val",
                                             :signature ["[coll]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IMapEntry"},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :name-encode "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net/ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [88
                                                                     89]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/Cons" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IEmptyableCollection"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "ASeq"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"
                                          "IList"},
                             :ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest __hash]"],
                             :name-encode "Cons",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Cons",
                             :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll __hash))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n  \n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2031 2074]},
                             :full-name "cljs.core/Cons"},
           "cljs.core/re-find" {:ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :name-encode "re-find",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (let [matches (.exec re s)]\n    (when-not (nil? matches)\n      (if (== (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6747 6757]},
                                :full-name "cljs.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :name-encode "IMeta",
                              :implementations #{"Subvec"
                                                 "Symbol"
                                                 "PersistentQueue"
                                                 "PersistentHashMap"
                                                 "PersistentTreeSet"
                                                 "PersistentArrayMapSeq"
                                                 "RedNode"
                                                 "EmptyList"
                                                 "ObjMap"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "ValSeq"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "PersistentTreeMap"
                                                 "PersistentTreeMapSeq"
                                                 "RSeq"
                                                 "function"
                                                 "PersistentArrayMap"
                                                 "PersistentHashSet"
                                                 "NodeSeq"
                                                 "List"
                                                 "Atom"
                                                 "Cons"
                                                 "LazySeq"},
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IMeta",
                              :source {:code "(defprotocol IMeta\n  (^clj-or-nil -meta [o]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [285 286]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IMeta"},
           "cljs.core/assoc-in" {:ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :name-encode "assoc-in",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3190 3197]},
                                 :full-name "cljs.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "compiler-options/verbose" {:ns "compiler-options",
                                       :name "verbose",
                                       :name-encode "verbose",
                                       :type "option",
                                       :full-name-encode "compiler-options/verbose",
                                       :full-name "compiler-options/verbose",
                                       :history [["+" "0.0-971"]]},
           "closure-warnings/undefined-variables" {:ns "closure-warnings",
                                                   :name "undefined-variables",
                                                   :type "warning",
                                                   :full-name "closure-warnings/undefined-variables",
                                                   :full-name-encode "closure-warnings/undefined-variables",
                                                   :name-encode "undefined-variables",
                                                   :history [["+"
                                                              "0.0-2120"]]},
           "clojure.string/join" {:ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :name-encode "join",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/join",
                                  :source {:code "(defn join\n  ([coll]\n     (apply str coll))\n  ([separator coll]\n     (apply str (interpose separator coll))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [45 51]},
                                  :full-name "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "cljs.core/*unchecked-if*" {:ns "cljs.core",
                                       :name "*unchecked-if*",
                                       :name-encode "STARunchecked-ifSTAR",
                                       :type "var",
                                       :full-name-encode "cljs.core/STARunchecked-ifSTAR",
                                       :source {:code "(def *unchecked-if* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [18]},
                                       :full-name "cljs.core/*unchecked-if*",
                                       :history [["+" "0.0-1211"]]},
           "cljs.core/seqable?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "seqable?",
                                 :signature ["[s]"],
                                 :name-encode "seqableQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/seqableQMARK",
                                 :source {:code "(defn ^boolean seqable?\n  [s]\n  (satisfies? ISeqable s))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1236 1239]},
                                 :full-name "cljs.core/seqable?",
                                 :docstring "Return true if s satisfies ISeqable"},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :name-encode "rights",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :name-encode "split-at",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2998 3001]},
                                 :full-name "cljs.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :name-encode "append-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :name-encode "binding",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/binding",
                                :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1074 1085]},
                                :full-name "cljs.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "compiler-options/libs" {:ns "compiler-options",
                                    :name "libs",
                                    :name-encode "libs",
                                    :type "option",
                                    :full-name-encode "compiler-options/libs",
                                    :full-name "compiler-options/libs",
                                    :history [["+" "0.0-971"]]},
           "cljs.core/Set" {:protocols #{"IFn"
                                         "ISeqable"
                                         "IMeta"
                                         "IWithMeta"
                                         "IEmptyableCollection"
                                         "ISet"
                                         "ICounted"
                                         "ILookup"
                                         "ICollection"
                                         "IHash"
                                         "IPrintable"
                                         "IEquiv"},
                            :ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :name-encode "Set",
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1211"]],
                            :type "type",
                            :full-name-encode "cljs.core/Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :removed {:in "0.0-1211",
                                      :last-seen "0.0-1011"}},
           "cljs.core/sorted-map" {:ns "cljs.core",
                                   :name "sorted-map",
                                   :signature ["[& keyvals]"],
                                   :name-encode "sorted-map",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/sorted-map",
                                   :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out cljs.core.PersistentTreeMap.EMPTY]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [5997 6004]},
                                   :full-name "cljs.core/sorted-map",
                                   :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
           "cljs.reader/macro-terminating?" {:return-type boolean,
                                             :ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :signature ["[ch]"],
                                             :name-encode "macro-terminatingQMARK",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader/macro-terminatingQMARK",
                                             :source {:code "(defn ^boolean macro-terminating? [ch]\n  (and (not (identical? ch \"#\"))\n       (not (identical? ch \\'))\n       (not (identical? ch \":\"))\n       (macros ch)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/reader.cljs",
                                                      :lines [72 76]},
                                             :full-name "cljs.reader/macro-terminating?"},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :name-encode "prefers",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7713 7715]},
                                :full-name "cljs.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.core/vary-meta" {:ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f]"
                                              "[obj f a]"
                                              "[obj f a b]"
                                              "[obj f a b c]"
                                              "[obj f a b c d]"
                                              "[obj f a b c d & args]"],
                                  :name-encode "vary-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/vary-meta",
                                  :source {:code "(defn vary-meta\n  ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d & args]\n   (with-meta obj (apply f (meta obj) a b c d args))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2623 2637]},
                                  :full-name "cljs.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/unchecked-add" {:return-type number,
                                      :ns "cljs.core",
                                      :name "unchecked-add",
                                      :signature ["[]"
                                                  "[x]"
                                                  "[x y]"
                                                  "[x y & more]"],
                                      :name-encode "unchecked-add",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-add",
                                      :source {:code "(defn ^number unchecked-add\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1575 1580]},
                                      :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [361
                                                               362]}],
                                      :full-name "cljs.core/unchecked-add",
                                      :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/when-let" {:ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[bindings & body]"],
                                 :name-encode "when-let",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.5.1",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1704 1717]},
                                 :full-name "cljs.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "clojure.core.reducers/folder" {:ns "clojure.core.reducers",
                                           :name "folder",
                                           :signature ["[coll xf]"],
                                           :name-encode "folder",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/folder",
                                           :source {:code "(defn folder\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [79 94]},
                                           :full-name "clojure.core.reducers/folder",
                                           :docstring "Given a foldable collection, and a transformation function xf,\nreturns a foldable collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/ASeq" {:ns "cljs.core",
                             :name "ASeq",
                             :name-encode "ASeq",
                             :implementations #{"ChunkedCons"
                                                "ChunkedSeq"
                                                "IndexedSeq"
                                                "List"
                                                "Cons"},
                             :type "protocol",
                             :full-name-encode "cljs.core/ASeq",
                             :source {:code "(defprotocol ASeq)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [244]},
                             :full-name "cljs.core/ASeq",
                             :history [["+" "0.0-1211"]]},
           "cljs.core/drop" {:ns "cljs.core",
                             :name "drop",
                             :signature ["[n coll]"],
                             :name-encode "drop",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/drop",
                             :source {:code "(defn drop\n  [n coll]\n  (let [step (fn [n coll]\n               (let [s (seq coll)]\n                 (if (and (pos? n) s)\n                   (recur (dec n) (rest s))\n                   s)))]\n    (lazy-seq (step n coll))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2957 2965]},
                             :full-name "cljs.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll."},
           "cljs.core/IAtom" {:ns "cljs.core",
                              :name "IAtom",
                              :name-encode "IAtom",
                              :implementations #{"Atom"},
                              :type "protocol",
                              :full-name-encode "cljs.core/IAtom",
                              :source {:code "(defprotocol IAtom)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7096]},
                              :full-name "cljs.core/IAtom",
                              :history [["+" "0.0-2173"]]},
           "cljs.core/reduceable?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reduceable?",
                                    :signature ["[x]"],
                                    :name-encode "reduceableQMARK",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reduceableQMARK",
                                    :source {:code "(defn ^boolean reduceable?\n  [x] (satisfies? IReduce x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1163 1165]},
                                    :full-name "cljs.core/reduceable?",
                                    :docstring "Returns true if coll satisfies IReduce"},
           "cljs.core/while" {:ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :name-encode "while",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.5.1",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5713 5721]},
                              :full-name "cljs.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "closure-warnings/const" {:ns "closure-warnings",
                                     :name "const",
                                     :type "warning",
                                     :full-name "closure-warnings/const",
                                     :full-name-encode "closure-warnings/const",
                                     :name-encode "const",
                                     :history [["+" "0.0-2120"]]},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :signature ["[ns [& vars]]"],
                                      :name-encode "import-macros",
                                      :type "macro",
                                      :full-name-encode "cljs.core/import-macros",
                                      :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(do (def ~sym (deref ~var))\n                                     ;for AOT compilation\n                                     (alter-meta! (var ~sym) assoc :macro true)))\n                       syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [43 53]},
                                      :full-name "cljs.core/import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :name-encode "add-in-order",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/add-in-order",
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order) :fns (assoc fns order f)})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [124 125]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :signature ["[x]"],
                                     :name-encode "string-print",
                                     :type "function",
                                     :full-name-encode "cljs.core/string-print",
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6798 6800]},
                                     :full-name "cljs.core/string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/-" {:return-type number,
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "-",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/-",
                          :source {:code "(defn ^number -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1466 1471]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [403 406]}],
                          :full-name "cljs.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/loop*" {:ns "cljs.core",
                              :name "loop*",
                              :type "special form",
                              :source {:code "(defmethod parse 'loop*\n  [op encl-env form _]\n  (analyze-let encl-env form true))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [857 859]},
                              :extra-sources ({:code "(defmethod emit* :loop [ast]\n  (emit-let ast true))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [654 655]}),
                              :full-name "cljs.core/loop*",
                              :full-name-encode "cljs.core/loopSTAR",
                              :name-encode "loopSTAR",
                              :history [["+" "0.0-927"]]},
           "cljs.core/vector-seq" {:ns "cljs.core",
                                   :name "vector-seq",
                                   :signature ["[v offset]"],
                                   :name-encode "vector-seq",
                                   :history [["+" "0.0-1211"]
                                             ["-" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/vector-seq",
                                   :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1236",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2522 2540]},
                                   :full-name "cljs.core/vector-seq",
                                   :removed {:in "0.0-1424",
                                             :last-seen "0.0-1236"}},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :name-encode "vector-zip",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip/vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.reader/read-2-chars" {:ns "cljs.reader",
                                       :name "read-2-chars",
                                       :signature ["[reader]"],
                                       :name-encode "read-2-chars",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-2-chars",
                                       :source {:code "(defn read-2-chars [reader]\n  (.toString\n    (gstring/StringBuffer.\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [173 177]},
                                       :full-name "cljs.reader/read-2-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/chunk" {:ns "cljs.core",
                              :name "chunk",
                              :signature ["[b]"],
                              :name-encode "chunk",
                              :type "function",
                              :full-name-encode "cljs.core/chunk",
                              :source {:code "(defn chunk [b]\n  (.chunk b))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2334 2335]},
                              :full-name "cljs.core/chunk",
                              :history [["+" "0.0-1424"]]},
           "cljs.core/conj!" {:ns "cljs.core",
                              :name "conj!",
                              :signature ["[tcoll val]"
                                          "[tcoll val & vals]"],
                              :name-encode "conjBANG",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/conjBANG",
                              :source {:code "(defn conj!\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2517 2526]},
                              :full-name "cljs.core/conj!",
                              :docstring "Adds x to the transient collection, and return coll. The 'addition'\nmay happen at different 'places' depending on the concrete type."},
           "syntax/earmuffs" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "earmuffs",
                              :name-encode "earmuffs",
                              :type "convention",
                              :full-name-encode "syntax/earmuffs",
                              :full-name "syntax/earmuffs",
                              :history [["+" "0.0-927"]]},
           "cljs.core/print-map" {:ns "cljs.core",
                                  :name "print-map",
                                  :signature ["[m print-one writer opts]"],
                                  :name-encode "print-map",
                                  :type "function",
                                  :full-name-encode "cljs.core/print-map",
                                  :source {:code "(defn print-map [m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    \"{\" \", \" \"}\"\n    opts (seq m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6985 6993]},
                                  :full-name "cljs.core/print-map",
                                  :history [["+" "0.0-2120"]]},
           "cljs.core/js->clj" {:ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :name-encode "js-GTclj",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/js-GTclj",
                                :source {:code "(defn js->clj\n  ([x] (js->clj x {:keywordize-keys false}))\n  ([x & opts]\n    (cond\n      (satisfies? IEncodeClojure x)\n      (-js->clj x (apply array-map opts))\n\n      (seq opts)\n      (let [{:keys [keywordize-keys]} opts\n            keyfn (if keywordize-keys keyword str)\n            f (fn thisfn [x]\n                (cond\n                  (seq? x)\n                  (doall (map thisfn x))\n\n                  (coll? x)\n                  (into (empty x) (map thisfn x))\n\n                  (array? x)\n                  (vec (map thisfn x))\n                   \n                  (identical? (type x) js/Object)\n                  (into {} (for [k (js-keys x)]\n                             [(keyfn k) (thisfn (aget x k))]))\n\n                  :else x))]\n        (f x)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7353 7383]},
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IStack"
                                          "IEmptyableCollection"
                                          "ICounted"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "ASeq"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"
                                          "IList"},
                             :ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count __hash]"],
                             :name-encode "List",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/List",
                             :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List.EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1894 1949]},
                             :full-name "cljs.core/List"},
           "cljs.core/identical?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :name-encode "identicalQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/identicalQMARK",
                                   :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [78 81]},
                                   :extra-sources [{:code "(defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [308 309]}],
                                   :full-name "cljs.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :name-encode "STARmain-cli-fnSTAR",
                                      :type "var",
                                      :full-name-encode "cljs.core/STARmain-cli-fnSTAR",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [121 125]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :signature ["[s]"],
                                            :name-encode "html-GTdom",
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/html-GTdom",
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [101 102]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :history [["+" "0.0-927"]]},
           "cljs.repl.server/handlers" {:ns "cljs.repl.server",
                                        :name "handlers",
                                        :name-encode "handlers",
                                        :type "var",
                                        :full-name-encode "cljs.repl.server/handlers",
                                        :source {:code "(defonce handlers (atom {}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [44]},
                                        :full-name "cljs.repl.server/handlers",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/chunk-next" {:ns "cljs.core",
                                   :name "chunk-next",
                                   :signature ["[s]"],
                                   :name-encode "chunk-next",
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-next",
                                   :source {:code "(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2343 2346]},
                                   :full-name "cljs.core/chunk-next",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/enable-console-print!" {:ns "cljs.core",
                                              :name "enable-console-print!",
                                              :signature ["[]"],
                                              :name-encode "enable-console-printBANG",
                                              :history [["+"
                                                         "0.0-2060"]],
                                              :type "function",
                                              :full-name-encode "cljs.core/enable-console-printBANG",
                                              :source {:code "(defn enable-console-print!\n  []\n  (set! *print-newline* false)\n  (set! *print-fn*\n    (fn [& args]\n      (.apply js/console.log js/console (into-array args)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [49 55]},
                                              :full-name "cljs.core/enable-console-print!",
                                              :docstring "Set *print-fn* to console.log"},
           "cljs.core/sorted?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "sorted?",
                                :signature ["[x]"],
                                :name-encode "sortedQMARK",
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :full-name-encode "cljs.core/sortedQMARK",
                                :source {:code "(defn ^boolean sorted?\n  [x] (satisfies? ISorted x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1159 1161]},
                                :full-name "cljs.core/sorted?",
                                :docstring "Returns true if coll satisfies ISorted"},
           "cljs.core/some" {:ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :name-encode "some",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2664 2671]},
                             :full-name "cljs.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/PersistentArrayMapSeq" {:protocols #{"ISeqable"
                                                           "IMeta"
                                                           "IWithMeta"
                                                           "IEmptyableCollection"
                                                           "ICounted"
                                                           "IReduce"
                                                           "ISequential"
                                                           "ISeq"
                                                           "ICollection"
                                                           "IHash"
                                                           "IPrintWithWriter"
                                                           "INext"
                                                           "IEquiv"},
                                              :ns "cljs.core",
                                              :name "PersistentArrayMapSeq",
                                              :signature ["[arr i _meta]"],
                                              :name-encode "PersistentArrayMapSeq",
                                              :history [["+"
                                                         "0.0-1820"]],
                                              :type "type",
                                              :full-name-encode "cljs.core/PersistentArrayMapSeq",
                                              :source {:code "(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  \n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (PersistentArrayMapSeq. arr i new-meta))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY _meta))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n  \n  ISeq\n  (-first [coll]\n    [(aget arr i) (aget arr (inc i))])\n\n  (-rest [coll]\n    (if (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [4232
                                                               4281]},
                                              :full-name "cljs.core/PersistentArrayMapSeq"},
           "cljs.reader/make-unicode-char" {:ns "cljs.reader",
                                            :name "make-unicode-char",
                                            :signature ["[code-str]"],
                                            :name-encode "make-unicode-char",
                                            :type "function",
                                            :full-name-encode "cljs.reader/make-unicode-char",
                                            :source {:code "(defn make-unicode-char [code-str]\n    (let [code (js/parseInt code-str 16)]\n      (.fromCharCode js/String code)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [195 197]},
                                            :full-name "cljs.reader/make-unicode-char",
                                            :history [["+" "0.0-1424"]]},
           "cljs.core/if" {:ns "cljs.core",
                           :name "if",
                           :type "special form",
                           :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name]\n  (when (< (count form) 3)\n    (throw (error env \"Too few arguments to if\")))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (analyze env then)\n        else-expr (analyze env else)]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked @*unchecked-if*\n     :children [test-expr then-expr else-expr]}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [470 480]},
                           :extra-sources ({:code "(defmethod emit* :if\n  [{:keys [test then else env unchecked]}]\n  (let [context (:context env)\n        checked (not (or unchecked (safe-test? env test)))]\n    (if (= :expr context)\n      (emits \"(\" (when checked \"cljs.core.truth_\") \"(\" test \")?\" then \":\" else \")\")\n      (do\n        (if checked\n          (emitln \"if(cljs.core.truth_(\" test \"))\")\n          (emitln \"if(\" test \")\"))\n        (emitln \"{\" then \"} else\")\n        (emitln \"{\" else \"}\")))))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [377 388]}),
                           :full-name "cljs.core/if",
                           :full-name-encode "cljs.core/if",
                           :name-encode "if",
                           :history [["+" "0.0-927"]]},
           "clojure.core.reducers/Cat" {:protocols #{"CollFold"
                                                     "cljs.core/ISeqable"
                                                     "cljs.core/IReduce"
                                                     "cljs.core/ICounted"},
                                        :ns "clojure.core.reducers",
                                        :name "Cat",
                                        :signature ["[cnt left right]"],
                                        :name-encode "Cat",
                                        :history [["+" "0.0-1236"]],
                                        :type "type",
                                        :full-name-encode "clojure.core.reducers/Cat",
                                        :source {:code "(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [193 211]},
                                        :full-name "clojure.core.reducers/Cat"},
           "cljs.core/write-all" {:ns "cljs.core",
                                  :name "write-all",
                                  :signature ["[writer & ss]"],
                                  :name-encode "write-all",
                                  :type "function",
                                  :full-name-encode "cljs.core/write-all",
                                  :source {:code "(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6794 6796]},
                                  :full-name "cljs.core/write-all",
                                  :history [["+" "0.0-1503"]]},
           "cljs.core/doall" {:ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "doall",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6719 6731]},
                              :full-name "cljs.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :name-encode "condp",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/condp",
                              :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (core/cond\n                  (= 0 n) `(throw (js/Error. (core/str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1087 1127]},
                              :full-name "cljs.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :name-encode "down",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :name-encode "IPending",
                                 :implementations #{"Delay"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IPending",
                                 :source {:code "(defprotocol IPending\n  (^boolean -realized? [d]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [336 337]},
                                 :methods [{:name "-realized?",
                                            :signature ["[d]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IPending"},
           "cljs.core/count" {:ns "cljs.core",
                              :name "count",
                              :signature ["[coll]"],
                              :name-encode "count",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/count",
                              :source {:code "(defn count\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count ^not-native coll)\n\n      (array? coll)\n      (alength coll)\n    \n      (string? coll)\n      (alength coll)\n\n      (native-satisfies? ICounted coll)\n      (-count coll)\n\n      :else (accumulating-seq-count coll))\n    0))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [862 881]},
                              :full-name "cljs.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :name-encode "bit-test",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-test",
                                 :source {:code "(defn bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1747 1750]},
                                 :extra-sources [{:code "(defmacro ^::ana/numeric bit-test [x n]\n  (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [512 513]}],
                                 :full-name "cljs.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/js-mod" {:ns "cljs.core",
                               :name "js-mod",
                               :signature ["[n d]"],
                               :name-encode "js-mod",
                               :history [["+" "0.0-1552"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/js-mod",
                               :source {:code "(defn js-mod\n  [n d]\n  (cljs.core/js-mod n d))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1681 1684]},
                               :extra-sources [{:code "(defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [476 477]}],
                               :full-name "cljs.core/js-mod",
                               :docstring "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"},
           "cljs.core/loop" {:ns "cljs.core",
                             :name "loop",
                             :signature ["[bindings & body]"],
                             :name-encode "loop",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/loop",
                             :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (core/symbol? b) b (gensym))) bs)\n              bfs (reduce (fn [ret [b v g]]\n                            (if (core/symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map core/vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [154 176]},
                             :full-name "cljs.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :name-encode "subvec",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (build-subvec nil v start end nil)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3692 3701]},
                               :full-name "cljs.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.core/bit-clear" {:ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :name-encode "bit-clear",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1728 1731]},
                                  :extra-sources [{:code "(defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [506 507]}],
                                  :full-name "cljs.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "syntax/Math-namespace" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "Math-namespace",
                                    :name-encode "Math-namespace",
                                    :type "special namespace",
                                    :full-name-encode "syntax/Math-namespace",
                                    :full-name "syntax/Math-namespace",
                                    :history [["+" "0.0-927"]]},
           "repl-options/warn-on-undeclared" {:ns "repl-options",
                                              :name "warn-on-undeclared",
                                              :name-encode "warn-on-undeclared",
                                              :type "option",
                                              :full-name-encode "repl-options/warn-on-undeclared",
                                              :full-name "repl-options/warn-on-undeclared",
                                              :history [["+"
                                                         "0.0-971"]]},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :name-encode "gensym",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7267 7275]},
                               :full-name "cljs.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "compiler-options/optimizations" {:ns "compiler-options",
                                             :name "optimizations",
                                             :name-encode "optimizations",
                                             :type "option",
                                             :full-name-encode "compiler-options/optimizations",
                                             :full-name "compiler-options/optimizations",
                                             :history [["+" "0.0-971"]]},
           "cljs.core/in-ns" {:ns "cljs.core",
                              :name "in-ns",
                              :name-encode "in-ns",
                              :type "special form (repl)",
                              :full-name-encode "cljs.core/in-ns",
                              :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (swap! env/*compiler* update-in [::ana/namespaces ns-name] {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                       :title "repl specials table",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/repl.clj",
                                       :lines [162 171]},
                              :full-name "cljs.core/in-ns",
                              :repl-only? true,
                              :history [["+" "0.0-927"]]},
           "cljs.core/Symbol" {:protocols #{"IFn"
                                            "IMeta"
                                            "IWithMeta"
                                            "IHash"
                                            "INamed"
                                            "IComparable"
                                            "IPrintWithWriter"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Symbol",
                               :signature ["[ns name str _hash _meta]"],
                               :name-encode "Symbol",
                               :history [["+" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Symbol",
                               :source {:code "(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n  IFn\n  (-invoke [sym coll]\n    (-lookup coll sym nil))\n  (-invoke [sym coll not-found]\n    (-lookup coll sym not-found))\n  IMeta\n  (-meta [_] _meta)\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [423 447]},
                               :full-name "cljs.core/Symbol"},
           "cljs.core/shuffle" {:ns "cljs.core",
                                :name "shuffle",
                                :signature ["[coll]"],
                                :name-encode "shuffle",
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core/shuffle",
                                :source {:code "(defn shuffle\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1393 1398]},
                                :full-name "cljs.core/shuffle",
                                :docstring "Return a random permutation of coll"},
           "cljs.core/+" {:return-type number,
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "PLUS",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/PLUS",
                          :source {:code "(defn ^number +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1458 1464]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [344 348]}],
                          :full-name "cljs.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/clone" {:ns "cljs.core",
                              :name "clone",
                              :signature ["[value]"],
                              :name-encode "clone",
                              :type "function",
                              :full-name-encode "cljs.core/clone",
                              :source {:code "(defn clone [value]\n  (-clone value))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [464 465]},
                              :full-name "cljs.core/clone",
                              :history [["+" "0.0-2134"]]},
           "cljs.core/comp" {:ns "cljs.core",
                             :name "comp",
                             :signature ["[]"
                                         "[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f1 f2 f3 & fs]"],
                             :name-encode "comp",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2704 2731]},
                             :full-name "cljs.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "syntax/comma" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "comma",
                           :name-encode "comma",
                           :type "special character",
                           :full-name-encode "syntax/comma",
                           :full-name "syntax/comma",
                           :history [["+" "0.0-927"]]},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :signature ["[f]"],
                                       :name-encode "desugar-meta",
                                       :type "function",
                                       :full-name-encode "cljs.reader/desugar-meta",
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [341 347]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env sym]"],
                                       :name-encode "load-namespace",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/load-namespace",
                                       :source {:code "(defn load-namespace\n  [repl-env sym]\n  (let [sym (if (and (seq? sym)\n                     (= (first sym) 'quote))\n              (second sym)\n              sym)\n        deps (->> (cljsc/add-dependencies (env->opts repl-env)\n                                          {:requires [(name sym)] :type :seed})\n                  (remove (comp #{[\"goog\"]} :provides))\n                  (remove (comp #{:seed} :type))\n                  (map #(select-keys % [:provides :url])))]\n    (doseq [{:keys [url provides]} deps]\n      (-load repl-env provides url))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [41 56]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :name-encode "pr",
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core/pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [6946 6952]},
                           :full-name "cljs.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "compiler-options/static-fns" {:ns "compiler-options",
                                          :name "static-fns",
                                          :name-encode "static-fns",
                                          :type "option",
                                          :full-name-encode "compiler-options/static-fns",
                                          :full-name "compiler-options/static-fns",
                                          :history [["+" "0.0-1424"]]},
           "clojure.string/upper-case" {:ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :name-encode "upper-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (.toUpperCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [53 56]},
                                        :full-name "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "cljs.core/chars" {:ns "cljs.core",
                              :name "chars",
                              :signature ["[x]"],
                              :name-encode "chars",
                              :type "function",
                              :full-name-encode "cljs.core/chars",
                              :source {:code "(defn chars [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1674]},
                              :full-name "cljs.core/chars",
                              :history [["+" "0.0-1798"]]},
           "syntax/string" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "string",
                            :name-encode "string",
                            :type "syntax",
                            :full-name-encode "syntax/string",
                            :extra-sources ({:code "(defn- read-string*\n  [reader _]\n  (loop [sb (StringBuilder.)\n         ch (read-char reader)]\n    (case ch\n      nil (reader-error reader \"EOF while reading string\")\n      \\\\ (recur (doto sb (.append (escape-char sb reader)))\n                (read-char reader))\n      \\\" (str sb)\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [252 261]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [578 597]}),
                            :full-name "syntax/string",
                            :history [["+" "0.0-1853"]]},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :signature ["[e]"],
                                           :name-encode "expose",
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/expose",
                                           :source {:code "(defn expose [e]\n  (goog.events/expose e))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [79 80]},
                                           :full-name "clojure.browser.event/expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :name-encode "listen-once",
                                                :type "function",
                                                :full-name-encode "clojure.browser.event/listen-once",
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (goog.events/listenOnce src\n                             (get (event-types src) type type)\n                             fn\n                             capture?)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/clojure/browser/event.cljs",
                                                         :lines [53
                                                                 60]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/empty?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :name-encode "emptyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/emptyQMARK",
                               :source {:code "(defn ^boolean empty?\n  [coll] (or (nil? coll)\n             (not (seq coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1131 1135]},
                               :full-name "cljs.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "compiler-options/pretty-print" {:ns "compiler-options",
                                            :name "pretty-print",
                                            :name-encode "pretty-print",
                                            :type "option",
                                            :full-name-encode "compiler-options/pretty-print",
                                            :full-name "compiler-options/pretty-print",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[opts]"],
                                :name-encode "newline",
                                :type "function",
                                :full-name-encode "cljs.core/newline",
                                :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6931 6934]},
                                :full-name "cljs.core/newline",
                                :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashMap" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMap"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IKVReduce"
                                                       "IEditableCollection"
                                                       "IEmptyableCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IAssociative"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentHashMap",
                                          :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                          :name-encode "PersistentHashMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashMap",
                                          :source {:code "(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj coll entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta cljs.core.PersistentHashMap.EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons [nil nil-val] s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              cljs.core.BitmapIndexedNode.EMPTY\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (.kv-reduce root f init)\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5113 5214]},
                                          :full-name "cljs.core/PersistentHashMap"},
           "cljs.core/replace" {:ns "cljs.core",
                                :name "replace",
                                :signature ["[smap coll]"],
                                :name-encode "replace",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/replace",
                                :source {:code "(defn replace\n  [smap coll]\n  (if (vector? coll)\n    (let [n (count coll)]\n      (reduce (fn [v i]\n                (if-let [e (find smap (nth v i))]\n                  (assoc v i (second e))\n                  v))\n              coll (take n (iterate inc 0))))\n    (map #(if-let [e (find smap %)] (second e) %) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6416 6428]},
                                :full-name "cljs.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap"},
           "cljs.core/rand" {:ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :name-encode "rand",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7415 7419]},
                             :full-name "cljs.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[iref key f]"],
                                  :name-encode "add-watch",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7232 7254]},
                                  :full-name "cljs.core/add-watch",
                                  :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :name-encode "loaded-libs",
                                          :type "var",
                                          :full-name-encode "cljs.repl.rhino/loaded-libs",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1552",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [20]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1576"]],
                                          :removed {:in "0.0-1576",
                                                    :last-seen "0.0-1552"}},
           "cljs.core/cloneable?" {:ns "cljs.core",
                                   :name "cloneable?",
                                   :signature ["[value]"],
                                   :name-encode "cloneableQMARK",
                                   :type "function",
                                   :full-name-encode "cljs.core/cloneableQMARK",
                                   :source {:code "(defn cloneable? [value]\n  (satisfies? ICloneable value))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [467 468]},
                                   :full-name "cljs.core/cloneable?",
                                   :history [["+" "0.0-2156"]]},
           "clojure.string/capitalize" {:ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :name-encode "capitalize",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [63 70]},
                                        :full-name "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/short" {:return-type number,
                              :ns "cljs.core",
                              :name "short",
                              :signature ["[x]"],
                              :name-encode "short",
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/short",
                              :source {:code "(defn ^number short [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1565]},
                              :extra-sources [{:code "(defmacro short [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [351]}],
                              :full-name "cljs.core/short"},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :name-encode "replicate",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3008 3010]},
                                  :full-name "cljs.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "cljs.core/ArrayChunk" {:protocols #{"ICounted"
                                                "IReduce"
                                                "IChunk"
                                                "IIndexed"},
                                   :ns "cljs.core",
                                   :name "ArrayChunk",
                                   :signature ["[arr off end]"],
                                   :name-encode "ArrayChunk",
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ArrayChunk",
                                   :source {:code "(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2234 2256]},
                                   :full-name "cljs.core/ArrayChunk"},
           "cljs.core/sequential?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[x]"],
                                    :name-encode "sequentialQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/sequentialQMARK",
                                    :source {:code "(defn ^boolean sequential?\n  [x] (satisfies? ISequential x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1155 1157]},
                                    :full-name "cljs.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :name-encode "underive",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7536 7555]},
                                 :full-name "cljs.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :name-encode "get-method",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7708 7711]},
                                   :full-name "cljs.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:return-type boolean,
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "EQ",
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :full-name-encode "cljs.core/EQ",
                          :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [526 542]},
                          :full-name "cljs.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "cljs.repl.server/dispatch-on" {:ns "cljs.repl.server",
                                           :name "dispatch-on",
                                           :signature ["[method pred handler]"
                                                       "[method {:as m}]"],
                                           :name-encode "dispatch-on",
                                           :history [["+" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.server/dispatch-on",
                                           :source {:code "(defn dispatch-on\n  ([method pred handler]\n     (dispatch-on method {:pred pred :handler handler}))\n  ([method {:as m}]\n     (swap! handlers (fn [old]\n                       (update-in old [method] #(conj (vec %) m))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/repl/server.clj",
                                                    :lines [46 57]},
                                           :full-name "cljs.repl.server/dispatch-on",
                                           :docstring "Registers a handler to be dispatched based on a request method and a\npredicate.\n\npred should be a function that accepts an options map, a connection,\nand a request map and returns a boolean value based on whether or not\nthat request should be dispatched to the related handler."},
           "cljs.reader/deregister-default-tag-parser!" {:ns "cljs.reader",
                                                         :name "deregister-default-tag-parser!",
                                                         :signature ["[]"],
                                                         :name-encode "deregister-default-tag-parserBANG",
                                                         :type "function",
                                                         :full-name-encode "cljs.reader/deregister-default-tag-parserBANG",
                                                         :source {:code "(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2199",
                                                                  :filename "src/cljs/cljs/reader.cljs",
                                                                  :lines [595
                                                                          599]},
                                                         :full-name "cljs.reader/deregister-default-tag-parser!",
                                                         :history [["+"
                                                                    "0.0-1576"]]},
           "syntax/comment" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "comment",
                             :name-encode "comment",
                             :type "syntax",
                             :full-name-encode "syntax/comment",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [120 122]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [578 597]}),
                             :full-name "syntax/comment",
                             :history [["+" "0.0-1853"]]},
           "cljs.core/defn-" {:ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :name-encode "defn-",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.5.1",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4455 4459]},
                              :full-name "cljs.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "compiler-options/target" {:ns "compiler-options",
                                      :name "target",
                                      :name-encode "target",
                                      :type "option",
                                      :full-name-encode "compiler-options/target",
                                      :full-name "compiler-options/target",
                                      :history [["+" "0.0-971"]]},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-symbol",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-symbol",
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (gstring/contains token \"/\")\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\")) (.-length token)))\n      (special-symbols token (symbol token)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [317 323]},
                                      :full-name "cljs.reader/read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :signature ["[s]"],
                                           :name-encode "push-back-reader",
                                           :type "function",
                                           :full-name-encode "cljs.reader/push-back-reader",
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (array) -1))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [28 30]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "closure-warnings/access-controls" {:ns "closure-warnings",
                                               :name "access-controls",
                                               :type "warning",
                                               :full-name "closure-warnings/access-controls",
                                               :full-name-encode "closure-warnings/access-controls",
                                               :name-encode "access-controls",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :name-encode "deftype",
                                :type "macro",
                                :full-name-encode "cljs.core/deftype",
                                :source {:code "(defmacro deftype [t fields & impls]\n  (let [r (:name (cljs.analyzer/resolve-var (dissoc &env :locals) t))\n        [fpps pmasks] (prepare-protocol-masks &env impls)\n        protocols (collect-protocols impls &env)\n        t (vary-meta t assoc\n            :protocols protocols\n            :skip-protocol-flag fpps) ]\n    (if (seq impls)\n      `(do\n         (deftype* ~t ~fields ~pmasks)\n         (set! (.-cljs$lang$type ~t) true)\n         (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n         (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n         (extend-type ~t ~@(dt->et t impls fields true))\n         ~(build-positional-factory t r fields)\n         ~t)\n      `(do\n         (deftype* ~t ~fields ~pmasks)\n         (set! (.-cljs$lang$type ~t) true)\n         (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n         (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opts#] (-write writer# ~(core/str r))))\n         ~(build-positional-factory t r fields)\n         ~t))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [843 865]},
                                :full-name "cljs.core/deftype",
                                :history [["+" "0.0-927"]]},
           "cljs.core/longs" {:ns "cljs.core",
                              :name "longs",
                              :signature ["[x]"],
                              :name-encode "longs",
                              :type "function",
                              :full-name-encode "cljs.core/longs",
                              :source {:code "(defn longs [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1679]},
                              :full-name "cljs.core/longs",
                              :history [["+" "0.0-1798"]]},
           "cljs.core/Subvec" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IReversible"
                                            "IStack"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "IReduce"
                                            "ILookup"
                                            "ISequential"
                                            "ICollection"
                                            "IHash"
                                            "IComparable"
                                            "IPrintWithWriter"
                                            "IIndexed"
                                            "IAssociative"
                                            "IVector"
                                            "IEquiv"
                                            "ICloneable"},
                               :ns "cljs.core",
                               :name "Subvec",
                               :signature ["[meta v start end __hash]"],
                               :name-encode "Subvec",
                               :history [["+" "0.0-927"]],
                               :type "type",
                               :full-name-encode "cljs.core/Subvec",
                               :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (build-subvec meta v start end __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector.EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (== start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (<= end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (<= end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. \"Subvec's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil)))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3589 3679]},
                               :full-name "cljs.core/Subvec"},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :name-encode "run-in-order",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/run-in-order",
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting\n         fns fns]\n    (if-let [f (get fns order)]\n      (do (f)\n          (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [127 133]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :signature ["[opts]"],
                                                  :name-encode "compile-client-js",
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/compile-client-js",
                                                  :source {:code "(defn compile-client-js [opts]\n  (cljsc/build '[(ns clojure.browser.repl.client\n                   (:require [goog.events :as event]\n                             [clojure.browser.repl :as repl]))\n                 (defn start [url]\n                   (event/listen js/window\n                                 \"load\"\n                                 (fn []\n                                   (repl/start-evaluator url))))]\n               {:optimizations (:optimizations opts)\n                :output-dir (:working-dir opts)}))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [193
                                                                   203]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/." {:ns "cljs.core",
                          :name ".",
                          :type "special form",
                          :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)]\n     (case dot-action\n           ::access {:env env :op :dot :form form\n                     :target targetexpr\n                     :field field\n                     :children [targetexpr]\n                     :tag (-> form meta :tag)}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :form form\n                       :target targetexpr\n                       :method method\n                       :args argexprs\n                       :children (into [targetexpr] argexprs)\n                       :tag (-> form meta :tag)})))))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [1236 1254]},
                          :extra-sources ({:code "(defmethod emit* :dot\n  [{:keys [target field method args env]}]\n  (emit-wrap env\n             (if field\n               (emits target \".\" (munge field #{}))\n               (emits target \".\" (munge method #{}) \"(\"\n                      (comma-sep args)\n                      \")\"))))",
                                           :title "Emitting code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/compiler.clj",
                                           :lines [826 833]}),
                          :full-name "cljs.core/.",
                          :full-name-encode "cljs.core/DOT",
                          :name-encode "DOT",
                          :history [["+" "0.0-927"]]},
           "syntax/js-namespace" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "js-namespace",
                                  :name-encode "js-namespace",
                                  :type "special namespace",
                                  :full-name-encode "syntax/js-namespace",
                                  :full-name "syntax/js-namespace",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/IReversible" {:ns "cljs.core",
                                    :name "IReversible",
                                    :name-encode "IReversible",
                                    :implementations #{"Subvec"
                                                       "PersistentTreeSet"
                                                       "PersistentVector"
                                                       "IndexedSeq"
                                                       "PersistentTreeMap"},
                                    :history [["+" "0.0-1211"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IReversible",
                                    :source {:code "(defprotocol IReversible\n  (^clj -rseq [coll]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [315 316]},
                                    :methods [{:name "-rseq",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IReversible"},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :name-encode "extend-protocol",
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core/extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :title "Source code",
                                                 :repo "clojure",
                                                 :tag "clojure-1.5.1",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [802 840]},
                                        :full-name "cljs.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :name-encode "read",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader/read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF while reading\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [f (macros ch)\n                 res\n                 (cond\n                  f (f reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (identical? res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/reader.cljs",
                                        :lines [412 429]},
                               :full-name "cljs.reader/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
           "cljs.core/EmptyList" {:protocols #{"ISeqable"
                                               "IMeta"
                                               "IWithMeta"
                                               "IStack"
                                               "IEmptyableCollection"
                                               "ICounted"
                                               "IReduce"
                                               "ISequential"
                                               "ISeq"
                                               "ICollection"
                                               "IHash"
                                               "IPrintWithWriter"
                                               "INext"
                                               "IEquiv"
                                               "ICloneable"
                                               "IList"},
                                  :ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :name-encode "EmptyList",
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] 0)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1951 1999]},
                                  :full-name "cljs.core/EmptyList"},
           "cljs.core/specify!" {:ns "cljs.core",
                                 :name "specify!",
                                 :signature ["[expr & impls]"],
                                 :name-encode "specifyBANG",
                                 :type "macro",
                                 :full-name-encode "cljs.core/specifyBANG",
                                 :source {:code "(defmacro specify! [expr & impls]\n  (let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [620 624]},
                                 :full-name "cljs.core/specify!",
                                 :history [["+" "0.0-2156"]]},
           "warnings/undeclared-var" {:ns "warnings",
                                      :name "undeclared-var",
                                      :type "warning",
                                      :full-name "warnings/undeclared-var",
                                      :full-name-encode "warnings/undeclared-var",
                                      :name-encode "undeclared-var",
                                      :history [["+" "0.0-2014"]]},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :name-encode "postwalk",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk/postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/clojure/walk.cljs",
                                             :lines [50 56]},
                                    :full-name "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "repl-options/src" {:ns "repl-options",
                               :name "src",
                               :name-encode "src",
                               :type "option",
                               :full-name-encode "repl-options/src",
                               :full-name "repl-options/src",
                               :history [["+" "0.0-1503"]]},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :name-encode "edit",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/re-seq" {:ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :name-encode "re-seq",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (when (seq post-match) (re-seq re post-match)))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6759 6766]},
                               :full-name "cljs.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-list",
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-list",
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [270 272]},
                                    :full-name "cljs.reader/read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/IKVReduce" {:ns "cljs.core",
                                  :name "IKVReduce",
                                  :name-encode "IKVReduce",
                                  :implementations #{"PersistentHashMap"
                                                     "ObjMap"
                                                     "PersistentVector"
                                                     "PersistentTreeMap"
                                                     "PersistentArrayMap"},
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IKVReduce",
                                  :source {:code "(defprotocol IKVReduce\n  (-kv-reduce [coll f init]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [294 295]},
                                  :methods [{:name "-kv-reduce",
                                             :signature ["[coll f init]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IKVReduce"},
           "cljs.core/Atom" {:protocols #{"IWatchable"
                                          "IMeta"
                                          "IDeref"
                                          "IHash"
                                          "IPrintWithWriter"
                                          "IAtom"
                                          "IEquiv"},
                             :ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :name-encode "Atom",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  IAtom\n  \n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IPrintWithWriter\n  (-pr-writer [a writer opts]\n    (-write writer \"#<Atom: \")\n    (pr-writer state writer opts)\n    (-write writer \">\"))\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f)))\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7104 7132]},
                             :full-name "cljs.core/Atom"},
           "clojure.core.reducers/foldcat" {:ns "clojure.core.reducers",
                                            :name "foldcat",
                                            :signature ["[coll]"],
                                            :name-encode "foldcat",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/foldcat",
                                            :source {:code "(defn foldcat\n  [coll]\n  (fold cat append! coll))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [237 240]},
                                            :full-name "clojure.core.reducers/foldcat",
                                            :docstring "Equivalent to (fold cat append! coll)"},
           "cljs.core/specify" {:ns "cljs.core",
                                :name "specify",
                                :signature ["[expr & impls]"],
                                :name-encode "specify",
                                :type "macro",
                                :full-name-encode "cljs.core/specify",
                                :source {:code "(defmacro specify [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [626 628]},
                                :full-name "cljs.core/specify",
                                :history [["+" "0.0-2138"]]},
           "cljs.repl.server/start" {:ns "cljs.repl.server",
                                     :name "start",
                                     :signature ["[opts]"],
                                     :name-encode "start",
                                     :history [["+" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl.server/start",
                                     :source {:code "(defn start\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/repl/server.clj",
                                              :lines [164 169]},
                                     :full-name "cljs.repl.server/start",
                                     :docstring "Start the server on the specified port."},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :name-encode "IMap",
                             :implementations #{"PersistentHashMap"
                                                "ObjMap"
                                                "PersistentTreeMap"
                                                "PersistentArrayMap"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [261 263]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring nil}],
                             :full-name "cljs.core/IMap"},
           "cljs.core/pr-sequential-writer" {:ns "cljs.core",
                                             :name "pr-sequential-writer",
                                             :signature ["[writer print-one begin sep end opts coll]"],
                                             :name-encode "pr-sequential-writer",
                                             :type "function",
                                             :full-name-encode "cljs.core/pr-sequential-writer",
                                             :source {:code "(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer \"#\")\n      (do\n        (-write writer begin)\n        (when (seq coll)\n          (print-one (first coll) writer opts))\n        (loop [coll (next coll) n (:print-length opts)]\n          (when (and coll (or (nil? n) (not (zero? n))))\n            (-write writer sep)\n            (print-one (first coll) writer opts)\n            (recur (next coll) (dec n))))\n        (when (:print-length opts)\n          (-write writer sep)\n          (print-one \"...\" writer opts))\n        (-write writer end)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [6776
                                                              6792]},
                                             :full-name "cljs.core/pr-sequential-writer",
                                             :history [["+"
                                                        "0.0-1503"]]},
           "cljs.core/unchecked-multiply" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-multiply",
                                           :signature ["[]"
                                                       "[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :name-encode "unchecked-multiply",
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-multiply",
                                           :source {:code "(defn ^number unchecked-multiply\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [1608 1613]},
                                           :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/clj/cljs/core.clj",
                                                            :lines [382
                                                                    383]}],
                                           :full-name "cljs.core/unchecked-multiply",
                                           :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :signature ["[rdr _]"],
                                      :name-encode "read-vector",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-vector",
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [276 278]},
                                      :full-name "cljs.reader/read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :name-encode "join",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set/join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/set.cljs",
                                        :lines [102 130]},
                               :full-name "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "closure-warnings/fileoverview-jsdoc" {:ns "closure-warnings",
                                                  :name "fileoverview-jsdoc",
                                                  :type "warning",
                                                  :full-name "closure-warnings/fileoverview-jsdoc",
                                                  :full-name-encode "closure-warnings/fileoverview-jsdoc",
                                                  :name-encode "fileoverview-jsdoc",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/HashMap" {:protocols #{"IFn"
                                             "ISeqable"
                                             "IMap"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "ICounted"
                                             "ILookup"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IAssociative"
                                             "IPrintable"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "HashMap",
                                :signature ["[meta count hashobj __hash]"],
                                :name-encode "HashMap",
                                :history [["+" "0.0-927"]
                                          ["-" "0.0-1798"]],
                                :type "type",
                                :full-name-encode "cljs.core/HashMap",
                                :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (alength bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1586",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3737 3828]},
                                :full-name "cljs.core/HashMap",
                                :removed {:in "0.0-1798",
                                          :last-seen "0.0-1586"}},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :signature ["[opts conn request]"],
                                           :name-encode "handle-get",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/handle-get",
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (cond\n     (.startsWith path \"/repl\") (send-repl-client-page opts conn request)\n     (:serve-static opts) (send-static opts conn request)\n     :else (send-404 conn (:path request)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1450",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [199 204]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :removed {:in "0.0-1503",
                                                     :last-seen "0.0-1450"}},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :name-encode "int-pattern",
                                      :type "var",
                                      :full-name-encode "cljs.reader/int-pattern",
                                      :source {:code "(def int-pattern (re-pattern \"([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+)|0[0-9]+)(N)?\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [97]},
                                      :full-name "cljs.reader/int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :name-encode "swapBANG",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a)))\n       (-swap! a f)))\n  ([a f x]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x))\n       (-swap! a f x)))\n  ([a f x y]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x y))\n       (-swap! a f x y)))\n  ([a f x y & more]\n     (if (instance? Atom a)\n       (reset! a (apply f (.-state a) x y more))\n       (-swap! a f x y more))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7172 7192]},
                              :full-name "cljs.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/finally" {:ns "cljs.core",
                                :name "finally",
                                :type "special form",
                                :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                         :title "Parser code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/analyzer.clj",
                                         :lines [489 548]},
                                :extra-sources ({:code "(defmethod emit* :try\n  [{:keys [env try catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :constant (:op finally)) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                                 :title "Emitting code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/compiler.clj",
                                                 :lines [614 629]}),
                                :full-name "cljs.core/finally",
                                :full-name-encode "cljs.core/finally",
                                :name-encode "finally",
                                :history [["+" "0.0-927"]]},
           "warnings/extending-base-js-type" {:ns "warnings",
                                              :name "extending-base-js-type",
                                              :type "warning",
                                              :full-name "warnings/extending-base-js-type",
                                              :full-name-encode "warnings/extending-base-js-type",
                                              :name-encode "extending-base-js-type",
                                              :history [["+"
                                                         "0.0-2024"]]},
           "cljs.core/dec" {:ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :name-encode "dec",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1537 1539]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [449 450]}],
                            :full-name "cljs.core/dec",
                            :docstring "Returns a number one less than num."},
           "cljs.core/*clojurescript-version*" {:ns "cljs.core",
                                                :name "*clojurescript-version*",
                                                :name-encode "STARclojurescript-versionSTAR",
                                                :type "var",
                                                :full-name-encode "cljs.core/STARclojurescript-versionSTAR",
                                                :source {:code "(def *clojurescript-version*)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [16]},
                                                :full-name "cljs.core/*clojurescript-version*",
                                                :history [["+"
                                                           "0.0-2014"]]},
           "clojure.core.reducers/fold" {:ns "clojure.core.reducers",
                                         :name "fold",
                                         :signature ["[reducef coll]"
                                                     "[combinef reducef coll]"
                                                     "[n combinef reducef coll]"],
                                         :name-encode "fold",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/fold",
                                         :source {:code "(defn fold\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [49 64]},
                                         :full-name "clojure.core.reducers/fold",
                                         :docstring "Reduces a collection using a (potentially parallel) reduce-combine\nstrategy. The collection is partitioned into groups of approximately\nn (default 512), each of which is reduced with reducef (with a seed\nvalue obtained by calling (combinef) with no arguments). The results\nof these reductions are then reduced with combinef (default\nreducef). combinef must be associative, and, when called with no\narguments, (combinef) must produce its identity element. These\noperations may be performed in parallel, but the results will\npreserve order.\n\nNote: Performing operations in parallel is currently not implemented."},
           "cljs.core/StringBufferWriter" {:protocols #{"IWriter"},
                                           :ns "cljs.core",
                                           :name "StringBufferWriter",
                                           :signature ["[sb]"],
                                           :name-encode "StringBufferWriter",
                                           :history [["+" "0.0-1503"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/StringBufferWriter",
                                           :source {:code "(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [383 386]},
                                           :full-name "cljs.core/StringBufferWriter"},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :name-encode "remove-children",
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom/remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/cljs/clojure/browser/dom.cljs",
                                                           :lines [92
                                                                   96]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/BlackNode" {:protocols #{"IFn"
                                               "ISeqable"
                                               "IMeta"
                                               "IWithMeta"
                                               "IStack"
                                               "IEmptyableCollection"
                                               "ICounted"
                                               "IReduce"
                                               "ILookup"
                                               "ISequential"
                                               "ICollection"
                                               "IHash"
                                               "IPrintWithWriter"
                                               "IIndexed"
                                               "IAssociative"
                                               "IVector"
                                               "IEquiv"
                                               "IMapEntry"},
                                  :ns "cljs.core",
                                  :name "BlackNode",
                                  :signature ["[key val left right __hash]"],
                                  :name-encode "BlackNode",
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/BlackNode",
                                  :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5493 5593]},
                                  :full-name "cljs.core/BlackNode"},
           "cljs.core/some->" {:ns "cljs.core",
                               :name "some->",
                               :signature ["[expr & forms]"],
                               :name-encode "some-GT",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/some-GT",
                               :source {:code "(defmacro some->\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.5.1",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [6813 6822]},
                               :full-name "cljs.core/some->",
                               :docstring "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc"},
           "cljs.core/get-validator" {:ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[iref]"],
                                      :name-encode "get-validator",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7213 7216]},
                                      :full-name "cljs.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :name-encode "collQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/collQMARK",
                              :source {:code "(defn ^boolean coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1137 1142]},
                              :full-name "cljs.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/unchecked-negate-int" {:ns "cljs.core",
                                             :name "unchecked-negate-int",
                                             :signature ["[x]"],
                                             :name-encode "unchecked-negate-int",
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-negate-int",
                                             :source {:code "(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [1625
                                                              1626]},
                                             :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r2199",
                                                              :filename "src/clj/cljs/core.clj",
                                                              :lines [391
                                                                      392]}],
                                             :full-name "cljs.core/unchecked-negate-int"},
           "cljs.core/bit-or" {:ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]"],
                               :name-encode "bit-or",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/bit-or",
                               :source {:code "(defn bit-or\n  [x y] (cljs.core/bit-or x y))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1720 1722]},
                               :extra-sources [{:code "(defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [491 493]}],
                               :full-name "cljs.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :name-encode "nfirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [810 813]},
                               :full-name "cljs.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:ns "cljs.core",
                             :name "keep",
                             :signature ["[f coll]"],
                             :name-encode "keep",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keep",
                             :source {:code "(defn keep\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2789 2808]},
                             :full-name "cljs.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/take" {:ns "cljs.core",
                             :name "take",
                             :signature ["[n coll]"],
                             :name-encode "take",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/take",
                             :source {:code "(defn take\n  [n coll]\n  (lazy-seq\n   (when (pos? n)\n     (when-let [s (seq coll)]\n      (cons (first s) (take (dec n) (rest s)))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2948 2955]},
                             :full-name "cljs.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n."},
           "cljs.core/PersistentHashSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashSet.EMPTY",
                                                :name-encode "PersistentHashSetDOTEMPTY",
                                                :parent-type "PersistentHashSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashSetDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentHashSet.EMPTY\n  (PersistentHashSet. nil cljs.core.PersistentArrayMap.EMPTY 0))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [6245
                                                                 6246]},
                                                :full-name "cljs.core/PersistentHashSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/cond" {:ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :name-encode "cond",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.5.1",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [551 564]},
                             :full-name "cljs.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]"],
                                :name-encode "bit-and",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-and",
                                :source {:code "(defn bit-and\n  [x y] (cljs.core/bit-and x y))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1716 1718]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [482 484]}],
                                :full-name "cljs.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :name-encode "ObjMapDOTfromObject",
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core/ObjMapDOTfromObject",
                                          :source {:code "(set! cljs.core.ObjMap.fromObject (fn [ks obj] (ObjMap. nil ks obj 0 nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [4153]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "cljs.core/PersistentArrayMap" {:protocols #{"IFn"
                                                        "ISeqable"
                                                        "IMap"
                                                        "IMeta"
                                                        "IWithMeta"
                                                        "IKVReduce"
                                                        "IEditableCollection"
                                                        "IEmptyableCollection"
                                                        "ICounted"
                                                        "ILookup"
                                                        "ICollection"
                                                        "IHash"
                                                        "IPrintWithWriter"
                                                        "IAssociative"
                                                        "IEquiv"
                                                        "ICloneable"},
                                           :ns "cljs.core",
                                           :name "PersistentArrayMap",
                                           :signature ["[meta cnt arr __hash]"],
                                           :name-encode "PersistentArrayMap",
                                           :history [["+" "0.0-1211"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentArrayMap",
                                           :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentArrayMap. meta cnt arr __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj coll entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta cljs.core.PersistentArrayMap.EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD)\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into cljs.core.PersistentHashMap.EMPTY coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4287 4394]},
                                           :full-name "cljs.core/PersistentArrayMap"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :signature ["[event-type]"],
                                                    :name-encode "unique-event-id",
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unique-event-id",
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [92]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "closure-warnings/debugger-statement-present" {:ns "closure-warnings",
                                                          :name "debugger-statement-present",
                                                          :type "warning",
                                                          :full-name "closure-warnings/debugger-statement-present",
                                                          :full-name-encode "closure-warnings/debugger-statement-present",
                                                          :name-encode "debugger-statement-present",
                                                          :history [["+"
                                                                     "0.0-2120"]]},
           "cljs.core/ObjMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                 :name "ObjMap.HASHMAP_THRESHOLD",
                                                 :name-encode "ObjMapDOTHASHMAP_THRESHOLD",
                                                 :parent-type "ObjMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/ObjMapDOTHASHMAP_THRESHOLD",
                                                 :source {:code "(set! cljs.core.ObjMap.HASHMAP_THRESHOLD 8)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [4151]},
                                                 :full-name "cljs.core/ObjMap.HASHMAP_THRESHOLD",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :name-encode "project",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "cljs.core/int" {:ns "cljs.core",
                            :name "int",
                            :signature ["[x]"],
                            :name-encode "int",
                            :history [["+" "0.0-1211"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/int",
                            :source {:code "(defn int\n  [x]\n  (bit-or x 0))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1652 1655]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [495 496]}],
                            :full-name "cljs.core/int",
                            :docstring "Coerce to int by stripping decimal places."},
           "clojure.reflect/macroexpand" {:ns "clojure.reflect",
                                          :name "macroexpand",
                                          :signature ["[form]"],
                                          :name-encode "macroexpand",
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "clojure.reflect/macroexpand",
                                          :source {:code "(defn macroexpand\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/clojure/reflect.cljs",
                                                   :lines [32 36]},
                                          :full-name "clojure.reflect/macroexpand",
                                          :docstring "Queries the reflection api with a quoted macro form, then calls the\ncallback function with the macroexpanded form, as a string."},
           "syntax/quote" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "quote",
                           :name-encode "quote",
                           :type "syntax",
                           :full-name-encode "syntax/quote",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.3",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [578 597]}),
                           :full-name "syntax/quote",
                           :history [["+" "0.0-1853"]]},
           "clojure.string/trim-newline" {:ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :name-encode "trim-newline",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/clojure/string.cljs",
                                                   :lines [147 157]},
                                          :full-name "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "cljs.repl.reflect/parse-param" {:ns "cljs.repl.reflect",
                                            :name "parse-param",
                                            :signature ["[path]"],
                                            :name-encode "parse-param",
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/parse-param",
                                            :source {:code "(defn parse-param\n  [path]\n  (-> (str/split path #\"\\?\")\n      (last)\n      (str/split #\"=\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/reflect.clj",
                                                     :lines [44 50]},
                                            :full-name "cljs.repl.reflect/parse-param",
                                            :docstring "Parses the query parameter of a path of the form \"/reflect?var=foo\"\ninto the vector [\"var\" \"foo\"]."},
           "cljs.core/pr-seq-writer" {:ns "cljs.core",
                                      :name "pr-seq-writer",
                                      :signature ["[objs writer opts]"],
                                      :name-encode "pr-seq-writer",
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-seq-writer",
                                      :source {:code "(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6895 6899]},
                                      :full-name "cljs.core/pr-seq-writer",
                                      :history [["+" "0.0-1503"]]},
           "cljs.repl/analyze-source" {:ns "cljs.repl",
                                       :name "analyze-source",
                                       :signature ["[src-dir]"],
                                       :name-encode "analyze-source",
                                       :history [["+" "0.0-1503"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/analyze-source",
                                       :source {:code "(defn analyze-source\n  [src-dir]\n  (if-let [src-dir (and (not (empty? src-dir))\n                     (File. src-dir))]\n    (doseq [file (comp/cljs-files-in src-dir)]\n      (ana/analyze-file (str \"file://\" (.getAbsolutePath file))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [173 180]},
                                       :full-name "cljs.repl/analyze-source",
                                       :docstring "Given a source directory, analyzes all .cljs files. Used to populate\n(:cljs.analyzer/namespaces compiler-env) so as to support code reflection."},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :signature ["[]"],
                                            :name-encode "stop-server",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/stop-server",
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [272 274]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.core/chunk-cons" {:ns "cljs.core",
                                   :name "chunk-cons",
                                   :signature ["[chunk rest]"],
                                   :name-encode "chunk-cons",
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-cons",
                                   :source {:code "(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2326 2329]},
                                   :full-name "cljs.core/chunk-cons",
                                   :history [["+" "0.0-1424"]]},
           "syntax/namespace" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "namespace",
                               :name-encode "namespace",
                               :type "special character",
                               :full-name-encode "syntax/namespace",
                               :full-name "syntax/namespace",
                               :history [["+" "0.0-927"]]},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :name-encode "insert-left",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip/insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/*print-level*" {:ns "cljs.core",
                                      :name "*print-level*",
                                      :name-encode "STARprint-levelSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARprint-levelSTAR",
                                      :source {:code "(def ^:dynamic *print-level* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [38]},
                                      :full-name "cljs.core/*print-level*",
                                      :history [["+" "0.0-2120"]]},
           "cljs.core/true?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :name-encode "trueQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/trueQMARK",
                              :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1222 1224]},
                              :extra-sources [{:code "(defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [285 286]}],
                              :full-name "cljs.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "cljs.core/unchecked-substract-int" {:return-type number,
                                                :ns "cljs.core",
                                                :name "unchecked-substract-int",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :name-encode "unchecked-substract-int",
                                                :history [["+"
                                                           "0.0-1798"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/unchecked-substract-int",
                                                :source {:code "(defn ^number unchecked-substract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-substract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1640
                                                                 1645]},
                                                :full-name "cljs.core/unchecked-substract-int",
                                                :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :name-encode "xpc-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (goog.Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (goog.net.xpc.CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (goog.net.xpc.CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (aset field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [118
                                                                  140]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/not" {:return-type boolean,
                            :ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :name-encode "not",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/not",
                            :source {:code "(defn ^boolean not\n  [x] (if x false true))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [94 96]},
                            :full-name "cljs.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:ns "cljs.core",
                               :name "js-obj",
                               :signature ["[]" "[& keyvals]"],
                               :name-encode "js-obj",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/js-obj",
                               :source {:code "(defn js-obj\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1184 1188]},
                               :extra-sources [{:code "(defmacro js-obj [& rest]\n  (let [sym-or-str? (fn [x] (core/or (core/symbol? x) (core/string? x)))\n        filter-on-keys (fn [f coll]\n                         (->> coll\n                              (filter (fn [[k _]] (f k)))\n                              (into {})))\n        kvs (into {} (map vec (partition 2 rest)))\n        sym-pairs (filter-on-keys core/symbol? kvs)\n        expr->local (zipmap\n                     (filter (complement sym-or-str?) (keys kvs))\n                     (repeatedly gensym))\n        obj (gensym \"obj\")]\n    `(let [~@(apply concat (clojure.set/map-invert expr->local))\n           ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n       ~@(map (fn [[k v]] `(aset ~obj ~k ~v)) sym-pairs)\n       ~@(map (fn [[k v]] `(aset ~obj ~v ~(core/get kvs k))) expr->local)\n       ~obj)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [1398 1414]}],
                               :full-name "cljs.core/js-obj"},
           "cljs.core/complement" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :name-encode "complement",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/complement",
                                   :source {:code "(defn ^boolean complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2690 2698]},
                                   :full-name "cljs.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :signature ["[arglist]"],
                               :name-encode "spread",
                               :type "function",
                               :full-name-encode "cljs.core/spread",
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2459 2465]},
                               :full-name "cljs.core/spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/unchecked-double" {:return-type number,
                                         :ns "cljs.core",
                                         :name "unchecked-double",
                                         :signature ["[x]"],
                                         :name-encode "unchecked-double",
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-double",
                                         :source {:code "(defn ^number unchecked-double [x] x)",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [1573]},
                                         :extra-sources [{:code "(defmacro unchecked-double [x] x)",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/clj/cljs/core.clj",
                                                          :lines [359]}],
                                         :full-name "cljs.core/unchecked-double"},
           "closure-warnings/undefined-names" {:ns "closure-warnings",
                                               :name "undefined-names",
                                               :type "warning",
                                               :full-name "closure-warnings/undefined-names",
                                               :full-name-encode "closure-warnings/undefined-names",
                                               :name-encode "undefined-names",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :name-encode "keyword",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/keyword",
                                :source {:code "(defn keyword\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (string? name) (let [parts (.split name \"/\")]\n                             (if (== (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name] (Keyword. ns name (str (when ns (str ns \"/\")) name) nil)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2137 2149]},
                                :full-name "cljs.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "syntax/keyword-qualify" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "keyword-qualify",
                                     :name-encode "keyword-qualify",
                                     :type "syntax",
                                     :full-name-encode "syntax/keyword-qualify",
                                     :extra-sources ({:code "(defn- read-keyword\n  [reader initch]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                                      :title "Reader code",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-0.8.3",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [299 317]}
                                                     {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                      :title "Reader table",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-0.8.3",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [578 597]}),
                                     :full-name "syntax/keyword-qualify",
                                     :history [["+" "0.0-1853"]]},
           "cljs.core/sort" {:ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :name-encode "sort",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1352 1364]},
                             :full-name "cljs.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :name-encode "trim",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/trim",
                                  :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [132 135]},
                                  :full-name "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :name-encode "meta",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/meta",
                             :source {:code "(defn meta\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1056 1061]},
                             :full-name "cljs.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "clojure.core.reducers/monoid" {:ns "clojure.core.reducers",
                                           :name "monoid",
                                           :signature ["[op ctor]"],
                                           :name-encode "monoid",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/monoid",
                                           :source {:code "(defn monoid\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [242 249]},
                                           :full-name "clojure.core.reducers/monoid",
                                           :docstring "Builds a combining fn out of the supplied operator and identity\nconstructor. op must be associative and ctor called with no args\nmust return an identity value for it."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :name-encode "time",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/time",
                             :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.))\n         ret# ~expr]\n     (prn (core/str \"Elapsed time: \" (- (.getTime (js/Date.)) start#) \" msecs\"))\n     ret#))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1519 1525]},
                             :full-name "cljs.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:return-type boolean,
                                :ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :name-encode "boolean",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/boolean",
                                :source {:code "(defn ^boolean boolean [x]\n  (if x true false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1241 1242]},
                                :full-name "cljs.core/boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :signature ["[rdr initch]"],
                                     :name-encode "read-token",
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-token",
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (gstring/StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (. sb (toString)))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [78 86]},
                                     :full-name "cljs.reader/read-token",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/update-in" {:ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :name-encode "update-in",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3199 3224]},
                                  :full-name "cljs.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f coll]"],
                                    :name-encode "map-indexed",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/map-indexed",
                                    :source {:code "(defn map-indexed\n  [f coll]\n  (letfn [(mapi [idx coll]\n            (lazy-seq\n             (when-let [s (seq coll)]\n               (if (chunked-seq? s)\n                 (let [c (chunk-first s)\n                       size (count c)\n                       b (chunk-buffer size)]\n                   (dotimes [i size]\n                     (chunk-append b (f (+ idx i) (-nth c i))))\n                   (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                 (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n    (mapi 0 coll)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2770 2787]},
                                    :full-name "cljs.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
           "cljs.core/printf" {:ns "cljs.core",
                               :name "printf",
                               :signature ["[fmt & args]"],
                               :name-encode "printf",
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/printf",
                               :source {:code "(defn printf\n  [fmt & args]\n  (print (apply format fmt args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6758 6761]},
                               :full-name "cljs.core/printf",
                               :docstring "Prints formatted output, as per format",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "clojure.core.reducers/map" {:ns "clojure.core.reducers",
                                        :name "map",
                                        :signature ["[f]" "[f coll]"],
                                        :name-encode "map",
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/map",
                                        :source {:code "(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [96 104]},
                                        :full-name "clojure.core.reducers/map",
                                        :docstring "Applies f to every value in the reduction of coll. Foldable."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :name-encode "IStack",
                               :implementations #{"Subvec"
                                                  "PersistentQueue"
                                                  "RedNode"
                                                  "EmptyList"
                                                  "BlackNode"
                                                  "PersistentVector"
                                                  "List"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (^clj -pop [coll]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [272 274]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring nil}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IStack"},
           "cljs.reader/parse-and-validate-timestamp" {:ns "cljs.reader",
                                                       :name "parse-and-validate-timestamp",
                                                       :signature ["[s]"],
                                                       :name-encode "parse-and-validate-timestamp",
                                                       :type "function",
                                                       :full-name-encode "cljs.reader/parse-and-validate-timestamp",
                                                       :source {:code "(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v] \n        (re-matches timestamp-regex s)]\n    (if-not v\n      (reader-error nil (str \"Unrecognized date/time syntax: \" s))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (= offset-sign \"-\") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 \"timestamp month field must be in range 1..12\")\n         (check 1 days (days-in-month months (leap-year? years)) \"timestamp day field must be in range 1..last day in month\")\n         (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n         (check 0 minutes 59 \"timestamp minute field must be in range 0..59\")\n         (check 0 seconds (if (= minutes 59) 60 59) \"timestamp second field must be in range 0..60\")\n         (check 0 fraction 999 \"timestamp millisecond field must be in range 0..999\")\n         offset]))))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r2199",
                                                                :filename "src/cljs/cljs/reader.cljs",
                                                                :lines [480
                                                                        503]},
                                                       :full-name "cljs.reader/parse-and-validate-timestamp",
                                                       :history [["+"
                                                                  "0.0-1853"]]},
           "closure-warnings/missing-properties" {:ns "closure-warnings",
                                                  :name "missing-properties",
                                                  :type "warning",
                                                  :full-name "closure-warnings/missing-properties",
                                                  :full-name-encode "closure-warnings/missing-properties",
                                                  :name-encode "missing-properties",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/ISorted" {:ns "cljs.core",
                                :name "ISorted",
                                :name-encode "ISorted",
                                :implementations #{"PersistentTreeSet"
                                                   "PersistentTreeMap"},
                                :history [["+" "0.0-1211"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ISorted",
                                :source {:code "(defprotocol ISorted\n  (^clj -sorted-seq [coll ascending?])\n  (^clj -sorted-seq-from [coll k ascending?])\n  (-entry-key [coll entry])\n  (-comparator [coll]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [318 322]},
                                :methods [{:name "-sorted-seq",
                                           :signature ["[coll ascending?]"],
                                           :docstring nil}
                                          {:name "-sorted-seq-from",
                                           :signature ["[coll k ascending?]"],
                                           :docstring nil}
                                          {:name "-entry-key",
                                           :signature ["[coll entry]"],
                                           :docstring nil}
                                          {:name "-comparator",
                                           :signature ["[coll]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ISorted"},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :name-encode "IIndexed",
                                 :implementations #{"Subvec"
                                                    "RedNode"
                                                    "ArrayChunk"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "Range"
                                                    "TransientVector"
                                                    "IndexedSeq"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [241 242]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IIndexed"},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :signature ["[data]"],
                                              :name-encode "repl-print",
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/repl-print",
                                              :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [23 25]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :name-encode "xpc-config-fields",
                                                    :type "var",
                                                    :full-name-encode "clojure.browser.net/xpc-config-fields",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (js->clj goog.net.xpc.CfgFields))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [75
                                                                     81]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/ISwap" {:ns "cljs.core",
                              :name "ISwap",
                              :name-encode "ISwap",
                              :type "protocol",
                              :full-name-encode "cljs.core/ISwap",
                              :source {:code "(defprotocol ISwap\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7101 7102]},
                              :methods [{:name "-swap!",
                                         :signature ["[o f]"
                                                     "[o f a]"
                                                     "[o f a b]"
                                                     "[o f a b xs]"],
                                         :docstring nil}],
                              :full-name "cljs.core/ISwap",
                              :history [["+" "0.0-2173"]]},
           "cljs.core/nnext" {:ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :name-encode "nnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [820 823]},
                              :full-name "cljs.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :name-encode "STARprint-metaSTAR",
                                     :type "dynamic var",
                                     :full-name-encode "cljs.core/STARprint-metaSTAR",
                                     :source {:code "(def ^:dynamic *print-meta* false)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [35]},
                                     :full-name "cljs.core/*print-meta*",
                                     :history [["+" "0.0-927"]]},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :signature ["[rdr _]"],
                                        :name-encode "read-dispatch",
                                        :type "function",
                                        :full-name-encode "cljs.reader/read-dispatch",
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (if-let [obj (maybe-read-tagged-type rdr ch)]\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [256 264]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/distinct" {:ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[coll]"],
                                 :name-encode "distinct",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/distinct",
                                 :source {:code "(defn distinct\n  [coll]\n  (let [step (fn step [xs seen]\n               (lazy-seq\n                ((fn [[f :as xs] seen]\n                   (when-let [s (seq xs)]\n                     (if (contains? seen f)\n                       (recur (rest s) seen)\n                       (cons f (step (rest s) (conj seen f))))))\n                 xs seen)))]\n    (step coll #{})))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6430 6441]},
                                 :full-name "cljs.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :signature ["[sym]"],
                                          :name-encode "wrapping-reader",
                                          :type "function",
                                          :full-name-encode "cljs.reader/wrapping-reader",
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [349 352]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/double-array" {:ns "cljs.core",
                                     :name "double-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :name-encode "double-array",
                                     :type "function",
                                     :full-name-encode "cljs.core/double-array",
                                     :source {:code "(defn double-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2411 2429]},
                                     :full-name "cljs.core/double-array",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :name-encode "prn",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [6978 6983]},
                            :full-name "cljs.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "cljs.core/chunked-seq" {:ns "cljs.core",
                                    :name "chunked-seq",
                                    :signature ["[vec i off]"
                                                "[vec node i off]"
                                                "[vec node i off meta]"],
                                    :name-encode "chunked-seq",
                                    :type "function",
                                    :full-name-encode "cljs.core/chunked-seq",
                                    :source {:code "(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3581 3585]},
                                    :full-name "cljs.core/chunked-seq",
                                    :history [["+" "0.0-1424"]]},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :name-encode "leftmost",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/>=" {:return-type boolean,
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "GTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/GTEQ",
                           :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1525 1535]},
                           :extra-sources [{:code "(defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [439 442]}],
                           :full-name "cljs.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :signature ["[rdr]"],
                                             :name-encode "read-request",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-request",
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [161 165]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :signature ["[c]"],
                                 :name-encode "macros",
                                 :type "function",
                                 :full-name-encode "cljs.reader/macros",
                                 :source {:code "(defn macros [c]\n  (cond\n   (identical? c \\\") read-string*\n   (identical? c \\:) read-keyword\n   (identical? c \\;) read-comment\n   (identical? c \\') (wrapping-reader 'quote)\n   (identical? c \\@) (wrapping-reader 'deref)\n   (identical? c \\^) read-meta\n   (identical? c \\`) not-implemented\n   (identical? c \\~) not-implemented\n   (identical? c \\() read-list\n   (identical? c \\)) read-unmatched-delimiter\n   (identical? c \\[) read-vector\n   (identical? c \\]) read-unmatched-delimiter\n   (identical? c \\{) read-map\n   (identical? c \\}) read-unmatched-delimiter\n   (identical? c \\\\) read-char\n   (identical? c \\#) read-dispatch\n   :else nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/reader.cljs",
                                          :lines [382 400]},
                                 :full-name "cljs.reader/macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/doseq" {:ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :name-encode "doseq",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/doseq",
                              :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n\n                       seqsym (gensym \"seq__\")\n                       recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (core/cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                     :else (let [chunksym (with-meta (gensym \"chunk__\")\n                                            {:tag 'not-native})\n                                 countsym (gensym \"count__\")\n                                 isym     (gensym \"i__\")\n                                 recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                 steppair-chunk (step recform-chunk (nnext exprs))\n                                 subform-chunk  (steppair-chunk 1)]\n                             [true `(loop [~seqsym   (seq ~v)\n                                           ~chunksym nil\n                                           ~countsym 0\n                                           ~isym     0]\n                                      (if (coercive-boolean (< ~isym ~countsym))\n                                        (let [~k (-nth ~chunksym ~isym)]\n                                          ~subform-chunk\n                                          ~@(when needrec [recform-chunk]))\n                                        (when-let [~seqsym (seq ~seqsym)]\n                                          (if (chunked-seq? ~seqsym)\n                                            (let [c# (chunk-first ~seqsym)]\n                                              (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                            (let [~k (first ~seqsym)]\n                                              ~subform\n                                              ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1260 1314]},
                              :full-name "cljs.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:return-type number,
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "STAR",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/STAR",
                          :source {:code "(defn ^number *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1473 1478]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [408 412]}],
                          :full-name "cljs.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"],
                             :name-encode "into",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/into",
                             :source {:code "(defn into\n  [to from]\n  (if-not (nil? to)\n    (if (implements? IEditableCollection to)\n      (persistent! (reduce -conj! (transient to) from))\n      (reduce -conj to from))\n    (reduce conj () from)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3112 3120]},
                             :full-name "cljs.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined."},
           "cljs.repl.server/state" {:ns "cljs.repl.server",
                                     :name "state",
                                     :name-encode "state",
                                     :type "var",
                                     :full-name-encode "cljs.repl.server/state",
                                     :source {:code "(defonce state (atom {:socket nil\n                      :connection nil\n                      :promised-conn nil}))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/repl/server.clj",
                                              :lines [16 18]},
                                     :full-name "cljs.repl.server/state",
                                     :history [["+" "0.0-1503"]]},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :name-encode "defmethod",
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defmethod",
                                  :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [1514 1517]},
                                  :full-name "cljs.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:return-type seq,
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :name-encode "rest",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rest",
                             :source {:code "(defn ^seq rest\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest ^not-native coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [504 515]},
                             :full-name "cljs.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.reader/unicode-4-pattern" {:ns "cljs.reader",
                                            :name "unicode-4-pattern",
                                            :name-encode "unicode-4-pattern",
                                            :type "var",
                                            :full-name-encode "cljs.reader/unicode-4-pattern",
                                            :source {:code "(def unicode-4-pattern (re-pattern \"[0-9A-Fa-f]{4}\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [188]},
                                            :full-name "cljs.reader/unicode-4-pattern",
                                            :history [["+" "0.0-1424"]]},
           "closure-warnings/ambiguous-function-decl" {:ns "closure-warnings",
                                                       :name "ambiguous-function-decl",
                                                       :type "warning",
                                                       :full-name "closure-warnings/ambiguous-function-decl",
                                                       :full-name-encode "closure-warnings/ambiguous-function-decl",
                                                       :name-encode "ambiguous-function-decl",
                                                       :history [["+"
                                                                  "0.0-2120"]]},
           "cljs.core/dotimes" {:ns "cljs.core",
                                :name "dotimes",
                                :signature ["[bindings & body]"],
                                :name-encode "dotimes",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/dotimes",
                                :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1447 1459]},
                                :full-name "cljs.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :name-encode "lefts",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :name-encode "ensure-element",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [107
                                                                  112]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :name-encode "defmacro",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmacro",
                                 :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.5.1",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [422 466]},
                                 :full-name "cljs.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:ns "cljs.core",
                               :name "remove",
                               :signature ["[pred coll]"],
                               :name-encode "remove",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/remove",
                               :source {:code "(defn remove\n  [pred coll]\n  (filter (complement pred) coll))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3083 3087]},
                               :full-name "cljs.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects."},
           "cljs.core/set-print-fn!" {:ns "cljs.core",
                                      :name "set-print-fn!",
                                      :signature ["[f]"],
                                      :name-encode "set-print-fnBANG",
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/set-print-fnBANG",
                                      :source {:code "(defn set-print-fn!\n  [f] (set! *print-fn* f))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [28 30]},
                                      :full-name "cljs.core/set-print-fn!",
                                      :docstring "Set *print-fn* to f."},
           "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :name-encode "PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :source {:code "(set! cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r2199",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [4398]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-1211"]]},
           "cljs.core/ns" {:ns "cljs.core",
                           :name "ns",
                           :type "special form",
                           :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _]\n  (when-not (symbol? name) \n    (throw (error env \"Namespaces must be named by a symbol.\")))\n  (let [docstring (if (string? (first args)) (first args))\n        args      (if docstring (next args) args)\n        metadata  (if (map? (first args)) (first args))\n        args      (desugar-ns-specs (if metadata (next args) args))\n        excludes  (parse-ns-excludes env args)\n        deps      (atom #{})\n        aliases   (atom {:fns #{} :macros #{}})\n        spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                      :require-macros (partial parse-require-spec env true deps aliases)\n                      :use            (comp (partial parse-require-spec env false deps aliases)\n                                            (partial use->require env))\n                      :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                            (partial use->require env))\n                      :import         (partial parse-import-spec env deps)}\n        valid-forms (atom #{:use :use-macros :require :require-macros :import})\n        {uses :use requires :require use-macros :use-macros require-macros :require-macros imports :import :as params}\n        (reduce (fn [m [k & libs]]\n                  (when-not (#{:use :use-macros :require :require-macros :import} k)\n                    (throw (error env \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")))\n                  (when-not (@valid-forms k)\n                    (throw (error env (str \"Only one \" k \" form is allowed per namespace definition\"))))\n                  (swap! valid-forms disj k)\n                  (apply merge-with merge m (map (spec-parsers k) libs)))\n                {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (when (and *analyze-deps* (seq @deps))\n      (analyze-deps name @deps env))\n    (when (seq uses)\n      (check-uses uses env))\n    (set! *cljs-ns* name)\n    (load-core)\n    (doseq [nsym (concat (vals require-macros) (vals use-macros))]\n      (clojure.core/require nsym))\n    (when (seq use-macros)\n      (check-use-macros use-macros env))\n    (swap! env/*compiler* update-in [::namespaces name] assoc\n      :name name\n      :doc docstring\n      :excludes excludes\n      :uses uses\n      :requires requires\n      :use-macros use-macros\n      :require-macros require-macros\n      :imports imports)\n    {:env env :op :ns :form form :name name :doc docstring :uses uses :requires requires :imports imports\n     :use-macros use-macros :require-macros require-macros :excludes excludes}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [1102 1150]},
                           :extra-sources ({:code "(defmethod emit* :ns\n  [{:keys [name requires uses require-macros env]}]\n  (emitln \"goog.provide('\" (munge name) \"');\")\n  (when-not (= name 'cljs.core)\n    (emitln \"goog.require('cljs.core');\"))\n  (doseq [lib (into (vals requires) (distinct (vals uses)))]\n    (emitln \"goog.require('\" (munge lib) \"');\")))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [775 781]}),
                           :full-name "cljs.core/ns",
                           :full-name-encode "cljs.core/ns",
                           :name-encode "ns",
                           :history [["+" "0.0-927"]]},
           "cljs.core/if-not" {:ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :name-encode "if-not",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.5.1",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [719 725]},
                               :full-name "cljs.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "cljs.repl.reflect/macroexpand" {:ns "cljs.repl.reflect",
                                            :name "macroexpand",
                                            :signature ["[form]"],
                                            :name-encode "macroexpand",
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/macroexpand",
                                            :source {:code "(defn macroexpand [form]\n  \"Fully expands a cljs macro form.\"\n  (let [mform (analyzer/macroexpand-1 {} form)]\n    (if (identical? form mform)\n      mform\n      (macroexpand mform))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/reflect.clj",
                                                     :lines [32 37]},
                                            :full-name "cljs.repl.reflect/macroexpand",
                                            :history [["+" "0.0-1503"]]},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :name-encode "path",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f coll]"
                                           "[f coll & colls]"],
                               :name-encode "mapcat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/mapcat",
                               :source {:code "(defn mapcat\n  ([f coll]\n    (flatten1 (map f coll)))\n  ([f coll & colls]\n    (flatten1 (apply map f coll colls))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3056 3062]},
                               :full-name "cljs.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection."},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :name-encode "IWatchable",
                                   :implementations #{"Atom"},
                                   :history [["+" "0.0-927"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [339 342]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring nil}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring nil}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IWatchable"},
           "warnings/variadic-max-arity" {:ns "warnings",
                                          :name "variadic-max-arity",
                                          :type "warning",
                                          :full-name "warnings/variadic-max-arity",
                                          :full-name-encode "warnings/variadic-max-arity",
                                          :name-encode "variadic-max-arity",
                                          :history [["+" "0.0-2014"]]},
           "compiler-options/preamble" {:ns "compiler-options",
                                        :name "preamble",
                                        :name-encode "preamble",
                                        :type "option",
                                        :full-name-encode "compiler-options/preamble",
                                        :full-name "compiler-options/preamble",
                                        :history [["+" "0.0-2127"]]},
           "cljs.core/unchecked-inc-int" {:ns "cljs.core",
                                          :name "unchecked-inc-int",
                                          :signature ["[x]"],
                                          :name-encode "unchecked-inc-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-inc-int",
                                          :source {:code "(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1605 1606]},
                                          :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [379
                                                                   380]}],
                                          :full-name "cljs.core/unchecked-inc-int"},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :name-encode "rightmost",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.core/PersistentArrayMap.EMPTY" {:ns "cljs.core",
                                                 :name "PersistentArrayMap.EMPTY",
                                                 :name-encode "PersistentArrayMapDOTEMPTY",
                                                 :parent-type "PersistentArrayMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/PersistentArrayMapDOTEMPTY",
                                                 :source {:code "(set! cljs.core.PersistentArrayMap.EMPTY (PersistentArrayMap. nil 0 (array) nil))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [4396]},
                                                 :full-name "cljs.core/PersistentArrayMap.EMPTY",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "cljs.repl.server/read-request" {:ns "cljs.repl.server",
                                            :name "read-request",
                                            :signature ["[rdr]"],
                                            :name-encode "read-request",
                                            :type "function",
                                            :full-name-encode "cljs.repl.server/read-request",
                                            :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/server.clj",
                                                     :lines [95 99]},
                                            :full-name "cljs.repl.server/read-request",
                                            :history [["+" "0.0-1503"]]},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :signature ["[repl-env f]"],
                                  :name-encode "load-file",
                                  :type "function",
                                  :full-name-encode "cljs.repl/load-file",
                                  :source {:code "(defn load-file\n  [repl-env f]\n  (binding [ana/*cljs-ns* 'cljs.user]\n    (let [res (if (= \\/ (first f)) f (io/resource f))]\n      (assert res (str \"Can't find \" f \" in classpath\"))\n      (load-stream repl-env f res))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [133 138]},
                                  :full-name "cljs.repl/load-file",
                                  :history [["+" "0.0-927"]]},
           "closure-warnings/check-regexp" {:ns "closure-warnings",
                                            :name "check-regexp",
                                            :type "warning",
                                            :full-name "closure-warnings/check-regexp",
                                            :full-name-encode "closure-warnings/check-regexp",
                                            :name-encode "check-regexp",
                                            :history [["+" "0.0-2120"]]},
           "compiler-options/closure-warnings" {:ns "compiler-options",
                                                :name "closure-warnings",
                                                :name-encode "closure-warnings",
                                                :type "option",
                                                :full-name-encode "compiler-options/closure-warnings",
                                                :full-name "compiler-options/closure-warnings",
                                                :sub-options-ns "closure-warnings",
                                                :history [["+"
                                                           "0.0-2120"]]},
           "cljs.core/unchecked-subtract" {:ns "cljs.core",
                                           :name "unchecked-subtract",
                                           :signature ["[& xs]"],
                                           :name-encode "unchecked-subtract",
                                           :type "macro",
                                           :full-name-encode "cljs.core/unchecked-subtract",
                                           :source {:code "(defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [397 398]},
                                           :full-name "cljs.core/unchecked-subtract",
                                           :history [["+" "0.0-1798"]]},
           "cljs.core/->" {:ns "cljs.core",
                           :name "->",
                           :signature ["[x]"
                                       "[x form]"
                                       "[x form & more]"],
                           :name-encode "-GT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/-GT",
                           :source {:code "(defmacro ->\n  ([x] x)\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n              (list form x)))\n  ([x form & more] `(-> (-> ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.5.1",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1545 1555]},
                           :full-name "cljs.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :name-encode "remove-all-methods",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [7688 7691]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "cljs.core/unchecked-add-int" {:return-type number,
                                          :ns "cljs.core",
                                          :name "unchecked-add-int",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :name-encode "unchecked-add-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-add-int",
                                          :source {:code "(defn ^number unchecked-add-int\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1582 1587]},
                                          :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [364
                                                                   365]}],
                                          :full-name "cljs.core/unchecked-add-int",
                                          :docstring "Returns the sum of nums. (+) returns 0."},
           "clojure.string/replace-first" {:ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :name-encode "replace-first",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/string.cljs",
                                                    :lines [36 43]},
                                           :full-name "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/reduced?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "reduced?",
                                 :signature ["[r]"],
                                 :name-encode "reducedQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/reducedQMARK",
                                 :source {:code "(defn ^boolean reduced?\n  [r]\n  (instance? Reduced r))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [593 596]},
                                 :full-name "cljs.core/reduced?",
                                 :docstring "Returns true if x is the result of a call to reduced"},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :name-encode "get-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [131 134]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "clojure.core.reducers/CollFold" {:ns "clojure.core.reducers",
                                             :name "CollFold",
                                             :name-encode "CollFold",
                                             :type "protocol",
                                             :full-name-encode "clojure.core.reducers/CollFold",
                                             :source {:code "(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/clojure/core/reducers.cljs",
                                                      :lines [46 47]},
                                             :methods [{:name "coll-fold",
                                                        :signature ["[coll n combinef reducef]"],
                                                        :docstring nil}],
                                             :full-name "clojure.core.reducers/CollFold",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :name-encode "process",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/process",
                                  :source {:code "(def process (js* \"process\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [8]},
                                  :full-name "cljs.nodejs/process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/some->>" {:ns "cljs.core",
                                :name "some->>",
                                :signature ["[expr & forms]"],
                                :name-encode "some-GTGT",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/some-GTGT",
                                :source {:code "(defmacro some->>\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.5.1",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [6824 6833]},
                                :full-name "cljs.core/some->>",
                                :docstring "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc"},
           "cljs.core/unchecked-inc" {:ns "cljs.core",
                                      :name "unchecked-inc",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-inc",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-inc",
                                      :source {:code "(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1602 1603]},
                                      :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [376
                                                               377]}],
                                      :full-name "cljs.core/unchecked-inc"},
           "cljs.core/not=" {:return-type boolean,
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :name-encode "notEQ",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/notEQ",
                             :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2639 2644]},
                             :full-name "cljs.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/unchecked-subtract-int" {:ns "cljs.core",
                                               :name "unchecked-subtract-int",
                                               :signature ["[& xs]"],
                                               :name-encode "unchecked-subtract-int",
                                               :type "macro",
                                               :full-name-encode "cljs.core/unchecked-subtract-int",
                                               :source {:code "(defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [400
                                                                401]},
                                               :full-name "cljs.core/unchecked-subtract-int",
                                               :history [["+"
                                                          "0.0-1798"]]},
           "cljs.core/ex-data" {:ns "cljs.core",
                                :name "ex-data",
                                :signature ["[ex]"],
                                :name-encode "ex-data",
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-data",
                                :source {:code "(defn ex-data\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7752 7758]},
                                :full-name "cljs.core/ex-data",
                                :docstring "Alpha - subject to change.\nReturns exception data (a map) if ex is an ExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/PersistentTreeMapSeq" {:protocols #{"ISeqable"
                                                          "IMeta"
                                                          "IWithMeta"
                                                          "IEmptyableCollection"
                                                          "ICounted"
                                                          "IReduce"
                                                          "ISequential"
                                                          "ISeq"
                                                          "ICollection"
                                                          "IHash"
                                                          "IPrintWithWriter"
                                                          "IEquiv"},
                                             :ns "cljs.core",
                                             :name "PersistentTreeMapSeq",
                                             :signature ["[meta stack ascending? cnt __hash]"],
                                             :name-encode "PersistentTreeMapSeq",
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "type",
                                             :full-name-encode "cljs.core/PersistentTreeMapSeq",
                                             :source {:code "(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta]\n    (PersistentTreeMapSeq. meta stack ascending? cnt __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [5338
                                                              5385]},
                                             :full-name "cljs.core/PersistentTreeMapSeq"},
           "cljs.core/js-keys" {:ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :name-encode "js-keys",
                                :type "function",
                                :full-name-encode "cljs.core/js-keys",
                                :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1190 1193]},
                                :full-name "cljs.core/js-keys",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :name-encode "browser-eval",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n                   (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try (read-string ret)\n           (catch Exception e\n             {:status :error\n              :value (str \"Could not read return value: \" ret)})))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [151 166]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :name-encode "seq-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :name-encode "server-state",
                                             :type "var",
                                             :full-name-encode "cljs.repl.browser/server-state",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :name-encode "IVector",
                                :implementations #{"Subvec"
                                                   "RedNode"
                                                   "BlackNode"
                                                   "PersistentVector"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IVector",
                                :source {:code "(defprotocol IVector\n  (^clj -assoc-n [coll n val]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [276 277]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IVector"},
           "cljs.core/persistent!" {:ns "cljs.core",
                                    :name "persistent!",
                                    :signature ["[tcoll]"],
                                    :name-encode "persistentBANG",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/persistentBANG",
                                    :source {:code "(defn persistent!\n  [tcoll]\n  (-persistent! tcoll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2510 2515]},
                                    :full-name "cljs.core/persistent!",
                                    :docstring "Returns a new, persistent version of the transient collection, in\nconstant time. The transient collection cannot be used after this\ncall, any such use will throw an exception."},
           "cljs.core/empty" {:ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :name-encode "empty",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/empty",
                              :source {:code "(defn empty\n  [coll]\n  (when-not (nil? coll)\n    (-empty coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [850 854]},
                              :full-name "cljs.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :name-encode "re-matches",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (let [matches (.exec re s)]\n    (when (= (first matches) s)\n      (if (== (count matches) 1)\n        (first matches)\n        (vec matches)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6738 6745]},
                                   :full-name "cljs.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "syntax/meta" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "meta",
                          :name-encode "meta",
                          :type "syntax",
                          :full-name-encode "syntax/meta",
                          :extra-sources ({:code "(defn- read-meta\n  [rdr _]\n  (log-source rdr\n    (let [[line column] (when (indexing-reader? rdr)\n                          [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n          m (desugar-meta (read rdr true nil true))]\n      (when-not (map? m)\n        (reader-error rdr \"Metadata must be Symbol, Keyword, String or Map\"))\n      (let [o (read rdr true nil true)]\n        (if (instance? IMeta o)\n          (let [m (if (and line\n                           (seq? o))\n                    (assoc m :line line\n                           :column column)\n                    m)]\n            (if (instance? IObj o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (reader-error rdr \"Metadata can only be applied to IMetas\"))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [324 342]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [578 597]}),
                          :full-name "syntax/meta",
                          :history [["+" "0.0-1853"]]},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :name-encode "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom/DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/clojure/browser/dom.cljs",
                                                      :lines [17 18]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "syntax/regex" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "regex",
                           :name-encode "regex",
                           :type "syntax",
                           :full-name-encode "syntax/regex",
                           :extra-sources ({:code "(defn read-regex\n  [rdr ch]\n  (let [sb (StringBuilder.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\\" ch)\n        (Pattern/compile (str sb))\n        (if (nil? ch)\n          (reader-error rdr \"EOF while reading regex\")\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (reader-error rdr \"EOF while reading regex\"))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.3",
                                            :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                            :lines [129 144]}
                                           {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.3",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [599 610]}),
                           :full-name "syntax/regex",
                           :history [["+" "0.0-1853"]]},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[type-sym & impls]"],
                                    :name-encode "extend-type",
                                    :type "macro",
                                    :full-name-encode "cljs.core/extend-type",
                                    :source {:code "(defmacro extend-type [type-sym & impls]\n  (let [env &env\n        resolve (partial resolve-var env)\n        impl-map (->impl-map impls)\n        [type assign-impls] (if-let [type (base-type type-sym)]\n                              [type base-assign-impls]\n                              [(resolve type-sym) proto-assign-impls])]\n    (when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n                    (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n          {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [773 784]},
                                    :full-name "cljs.core/extend-type",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :name-encode "ISeqable",
                                 :implementations #{"Subvec"
                                                    "PersistentQueue"
                                                    "PersistentHashMap"
                                                    "PersistentTreeSet"
                                                    "PersistentArrayMapSeq"
                                                    "RedNode"
                                                    "EmptyList"
                                                    "ObjMap"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "ValSeq"
                                                    "ChunkedCons"
                                                    "Range"
                                                    "PersistentQueueSeq"
                                                    "ChunkedSeq"
                                                    "ArrayNodeSeq"
                                                    "KeySeq"
                                                    "IndexedSeq"
                                                    "PersistentTreeMap"
                                                    "PersistentTreeMapSeq"
                                                    "RSeq"
                                                    "PersistentArrayMap"
                                                    "PersistentHashSet"
                                                    "NodeSeq"
                                                    "List"
                                                    "Cons"
                                                    "LazySeq"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (^clj-or-nil -seq [o]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [303 304]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/ISeqable"},
           "cljs.core/assoc" {:ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :name-encode "assoc",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (hash-map k v)))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1009 1022]},
                              :full-name "cljs.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :name-encode "xpc-connection",
                                                  :type "var",
                                                  :full-name-encode "clojure.browser.repl/xpc-connection",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/cljs/clojure/browser/repl.cljs",
                                                           :lines [21]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :name-encode "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core/IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [282 283]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "warnings/invalid-protocol-symbol" {:ns "warnings",
                                               :name "invalid-protocol-symbol",
                                               :type "warning",
                                               :full-name "warnings/invalid-protocol-symbol",
                                               :full-name-encode "warnings/invalid-protocol-symbol",
                                               :name-encode "invalid-protocol-symbol",
                                               :history [["+"
                                                          "0.0-2014"]]},
           "syntax/eval" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "eval",
                          :name-encode "eval",
                          :type "syntax",
                          :full-name-encode "syntax/eval",
                          :extra-sources ({:code "(defn- read-eval\n  [rdr _]\n  (when-not *read-eval*\n    (reader-error rdr \"#= not allowed when *read-eval* is false\"))\n  (let [o (read rdr true nil true)]\n    (if (symbol? o)\n      (RT/classForName (str ^Symbol o))\n      (if (list? o)\n        (let [fs (first o)\n              o (rest o)\n              fs-name (name fs)]\n          (cond\n           (= fs 'var) (let [vs (first o)]\n                         (RT/var (namespace vs) (name vs)))\n           (.endsWith fs-name \".\")\n           (let [args (to-array o)]\n             (-> fs-name (subs 0 (dec (count fs-name)))\n                RT/classForName (Reflector/invokeConstructor args)))\n\n           (Compiler/namesStaticMember fs)\n           (let [args (to-array o)]\n             (Reflector/invokeStaticMethod (namespace fs) fs-name args))\n\n           :else\n           (let [v (Compiler/maybeResolveIn *ns* fs)]\n             (if (var? v)\n               (apply v o)\n               (reader-error rdr \"Can't resolve \" fs)))))\n        (throw (IllegalArgumentException. \"Unsupported #= form\"))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [412 440]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [599 610]}),
                          :full-name "syntax/eval",
                          :history [["+" "0.0-1853"]]},
           "clojure.core.reducers/cat" {:ns "clojure.core.reducers",
                                        :name "cat",
                                        :signature ["[]"
                                                    "[ctor]"
                                                    "[left right]"],
                                        :name-encode "cat",
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/cat",
                                        :source {:code "(defn cat\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [213 230]},
                                        :full-name "clojure.core.reducers/cat",
                                        :docstring "A high-performance combining fn that yields the catenation of the\nreduced values. The result is reducible, foldable, seqable and\ncounted, providing the identity collections are reducible, seqable\nand counted. The single argument version will build a combining fn\nwith the supplied identity constructor. Tests for identity\nwith (zero? (count x)). See also foldcat."},
           "cljs.core/unchecked-substract" {:return-type number,
                                            :ns "cljs.core",
                                            :name "unchecked-substract",
                                            :signature ["[x]"
                                                        "[x y]"
                                                        "[x y & more]"],
                                            :name-encode "unchecked-substract",
                                            :history [["+" "0.0-1798"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/unchecked-substract",
                                            :source {:code "(defn ^number unchecked-substract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-substract (cljs.core/unchecked-subtract x y) more)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [1633
                                                             1638]},
                                            :full-name "cljs.core/unchecked-substract",
                                            :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :name-encode "start-evaluator",
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl/start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText (.-currentTarget e)\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/cljs/clojure/browser/repl.cljs",
                                                            :lines [60
                                                                    88]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :name-encode "send-for-eval",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n     (send-for-eval @(server/connection) form return-value-fn))\n  ([conn form return-value-fn]\n     (do (set-return-value-fn return-value-fn)\n         (server/send-and-close conn 200 form \"text/javascript\"))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [32 40]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :name-encode "unlisten",
                                             :type "function",
                                             :full-name-encode "clojure.browser.event/unlisten",
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (goog.events/unlisten src\n                           (get (event-types src) type type)\n                           fn\n                           capture?)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/clojure/browser/event.cljs",
                                                      :lines [62 69]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :history [["+" "0.0-927"]]},
           "syntax/dot" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "dot",
                         :name-encode "dot",
                         :type "special character",
                         :full-name-encode "syntax/dot",
                         :full-name "syntax/dot",
                         :history [["+" "0.0-927"]]},
           "cljs.core/do" {:ns "cljs.core",
                           :name "do",
                           :type "special form",
                           :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _]\n  (let [statements (disallowing-recur\n                     (seq (map #(analyze (assoc env :context :statement) %) (butlast exprs))))\n        ret (if (<= (count exprs) 1)\n              (analyze env (first exprs))\n              (analyze (assoc env :context (if (= :statement (:context env)) :statement :return)) (last exprs)))]\n    {:env env :op :do :form form\n     :statements statements :ret ret\n     :children (conj (vec statements) ret)}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [785 794]},
                           :extra-sources ({:code "(defmethod emit* :do\n  [{:keys [statements ret env]}]\n  (let [context (:context env)]\n    (when (and statements (= :expr context)) (emits \"(function (){\"))\n    (when statements\n      (emits statements))\n    (emit ret)\n    (when (and statements (= :expr context)) (emits \"})()\"))))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [605 612]}),
                           :full-name "cljs.core/do",
                           :full-name-encode "cljs.core/do",
                           :name-encode "do",
                           :history [["+" "0.0-927"]]},
           "syntax/unused" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "unused",
                            :name-encode "unused",
                            :type "convention",
                            :full-name-encode "syntax/unused",
                            :full-name "syntax/unused",
                            :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashMap.fromArrays" {:ns "cljs.core",
                                                     :name "PersistentHashMap.fromArrays",
                                                     :signature ["[ks vs]"],
                                                     :name-encode "PersistentHashMapDOTfromArrays",
                                                     :history [["+"
                                                                "0.0-1211"]],
                                                     :parent-type "PersistentHashMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentHashMapDOTfromArrays",
                                                     :source {:code "(set! cljs.core.PersistentHashMap.fromArrays\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient cljs.core.PersistentHashMap.EMPTY)]\n        (if (< i len)\n          (recur (inc i) (-assoc! out (aget ks i) (aget vs i)))\n          (persistent! out))))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2199",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [5218
                                                                      5224]},
                                                     :full-name "cljs.core/PersistentHashMap.fromArrays"},
           "cljs.core/special-symbol?" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "special-symbol?",
                                        :signature ["[x]"],
                                        :name-encode "special-symbolQMARK",
                                        :history [["+" "0.0-1803"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/special-symbolQMARK",
                                        :source {:code "(defn ^boolean special-symbol? [x]\n  (contains?\n    '#{if def fn* do let* loop* letfn* throw try\n       recur new set! ns deftype* defrecord* . js* & quote}\n    x))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [7783 7787]},
                                        :full-name "cljs.core/special-symbol?"},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :name-encode "constrain-order",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-off ordering add-in-order order f)\n  (send-off ordering run-in-order))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [135
                                                                 140]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :name-encode "default-special-fns",
                                            :type "var",
                                            :full-name-encode "cljs.repl/default-special-fns",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (swap! env/*compiler* update-in [::ana/namespaces ns-name] {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [162 171]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/format" {:ns "cljs.core",
                               :name "format",
                               :signature ["[fmt & args]"],
                               :name-encode "format",
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/format",
                               :source {:code "(defn format\n  [fmt & args]\n  (apply gstring/format fmt args))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1771 1774]},
                               :full-name "cljs.core/format",
                               :docstring "Formats a string using goog.string.format.",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "cljs.core/sorted-set" {:ns "cljs.core",
                                   :name "sorted-set",
                                   :signature ["[& keys]"],
                                   :name-encode "sorted-set",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/sorted-set",
                                   :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj cljs.core.PersistentTreeSet.EMPTY keys)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6404 6407]},
                                   :full-name "cljs.core/sorted-set",
                                   :docstring "Returns a new sorted set with supplied keys."},
           "cljs.core/fnil" {:ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :name-encode "fnil",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2747 2768]},
                             :full-name "cljs.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "warnings/fn-arity" {:ns "warnings",
                                :name "fn-arity",
                                :type "warning",
                                :full-name "warnings/fn-arity",
                                :full-name-encode "warnings/fn-arity",
                                :name-encode "fn-arity",
                                :history [["+" "0.0-1853"]]},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :name-encode "this-as",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/this-as",
                                :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [633 637]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :signature ["[repl-env filename line js]"],
                                         :name-encode "rhino-eval",
                                         :type "function",
                                         :full-name-encode "cljs.repl.rhino/rhino-eval",
                                         :source {:code "(defn rhino-eval\n  [repl-env filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      {:status :exception\n       :value (.toString ex)\n       :stacktrace (stacktrace ex)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [56 65]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:protocols #{"ISeqable"
                                                        "IMeta"
                                                        "IWithMeta"
                                                        "IEmptyableCollection"
                                                        "ISequential"
                                                        "ISeq"
                                                        "ICollection"
                                                        "IHash"
                                                        "IEquiv"},
                                           :ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :signature ["[meta front rear __hash]"],
                                           :name-encode "PersistentQueueSeq",
                                           :history [["+" "0.0-927"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentQueueSeq",
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3891 3925]},
                                           :full-name "cljs.core/PersistentQueueSeq"},
           "cljs.core/counted?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :name-encode "countedQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/countedQMARK",
                                 :source {:code "(defn ^boolean counted?\n  [x] (satisfies? ICounted x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [664 666]},
                                 :full-name "cljs.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "compiler-options/use-only-custom-externs" {:ns "compiler-options",
                                                       :name "use-only-custom-externs",
                                                       :name-encode "use-only-custom-externs",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/use-only-custom-externs",
                                                       :full-name "compiler-options/use-only-custom-externs",
                                                       :history [["+"
                                                                  "0.0-971"]]},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :signature ["[rdr]"],
                                             :name-encode "read-headers",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-headers",
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [136 141]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "clojure.string/trimr" {:ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :name-encode "trimr",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/trimr",
                                   :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [142 145]},
                                   :full-name "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "clojure.core.reducers/take" {:ns "clojure.core.reducers",
                                         :name "take",
                                         :signature ["[n]" "[n coll]"],
                                         :name-encode "take",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/take",
                                         :source {:code "(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [164 176]},
                                         :full-name "clojure.core.reducers/take",
                                         :docstring "Ends the reduction of coll after consuming n values."},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :name-encode "force",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7300 7305]},
                              :full-name "cljs.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :name-encode "compare-and-setBANG",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [a oldval newval]\n  (if (= (.-state a) oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [7194 7201]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is identical to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :name-encode "setQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/setQMARK",
                             :source {:code "(defn ^boolean set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1144 1149]},
                             :full-name "cljs.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "cljs.repl.server/set-connection" {:ns "cljs.repl.server",
                                              :name "set-connection",
                                              :signature ["[conn]"],
                                              :name-encode "set-connection",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/set-connection",
                                              :source {:code "(defn set-connection\n  [conn]\n  (if-let [promised-conn (:promised-conn @state)]\n    (do (swap! state (fn [old] (-> old\n                                         (assoc :connection nil)\n                                         (assoc :promised-conn nil))))\n        (deliver promised-conn conn))\n    (swap! state (fn [old] (assoc old :connection conn)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/repl/server.clj",
                                                       :lines [32 42]},
                                              :full-name "cljs.repl.server/set-connection",
                                              :docstring "Given a new available connection, either use it to deliver the\nconnection which was promised or store the connection for later\nuse."},
           "cljs.core/load-file" {:ns "cljs.core",
                                  :name "load-file",
                                  :name-encode "load-file",
                                  :type "special form (repl)",
                                  :full-name-encode "cljs.core/load-file",
                                  :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (swap! env/*compiler* update-in [::ana/namespaces ns-name] {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                           :title "repl specials table",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [162 171]},
                                  :full-name "cljs.core/load-file",
                                  :repl-only? true,
                                  :history [["+" "0.0-927"]]},
           "syntax/unquote-splicing" {:syntax-equiv {:edn-url nil,
                                                     :clj-url nil},
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :name-encode "unquote-splicing",
                                      :type "syntax",
                                      :full-name-encode "syntax/unquote-splicing",
                                      :extra-sources ({:code "(defn- read-unquote\n  [rdr comma]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~))))",
                                                       :title "Reader code",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-0.8.3",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [444
                                                               449]}
                                                      {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                       :title "Reader table",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-0.8.3",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [578
                                                               597]}),
                                      :full-name "syntax/unquote-splicing",
                                      :history [["+" "0.0-1853"]]},
           "cljs.core/unchecked-dec" {:ns "cljs.core",
                                      :name "unchecked-dec",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-dec",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-dec",
                                      :source {:code "(defn unchecked-dec [x]\n  (cljs.core/unchecked-dec x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1589 1590]},
                                      :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [367
                                                               368]}],
                                      :full-name "cljs.core/unchecked-dec"},
           "clojure.string/escape" {:ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :name-encode "escape",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (gstring/StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [164 180]},
                                    :full-name "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.core/remove-watch" {:ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[iref key]"],
                                     :name-encode "remove-watch",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [7256 7261]},
                                     :full-name "cljs.core/remove-watch",
                                     :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
           "closure-warnings/check-useless-code" {:ns "closure-warnings",
                                                  :name "check-useless-code",
                                                  :type "warning",
                                                  :full-name "closure-warnings/check-useless-code",
                                                  :full-name-encode "closure-warnings/check-useless-code",
                                                  :name-encode "check-useless-code",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "syntax/true" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "true",
                          :name-encode "true",
                          :type "special symbol",
                          :full-name-encode "syntax/true",
                          :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  {:line line :column column\n                   :end-line (get-line-number rdr)\n                   :end-column (int (get-column-number rdr))})))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [263 285]}),
                          :full-name "syntax/true",
                          :history [["+" "0.0-1853"]]},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :name-encode "IMultiFn",
                                 :implementations #{"MultiFn"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf])\n  (-dispatch [mf args]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7609 7617]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-dispatch",
                                            :signature ["[mf args]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn"},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :name-encode "endQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "clojure.set/superset?" {:ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[set1 set2]"],
                                    :name-encode "supersetQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.set/supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/clojure/set.cljs",
                                             :lines [138 142]},
                                    :full-name "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & {:keys [analyze-path verbose warn-on-undeclared special-fns static-fns], :as opts, :or {warn-on-undeclared true}}]"],
                             :name-encode "repl",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl/repl",
                             :source {:code "(defn repl\n  [repl-env & {:keys [analyze-path verbose warn-on-undeclared special-fns static-fns] :as opts\n               :or {warn-on-undeclared true}}]\n  (print \"To quit, type: \")\n  (prn :cljs/quit)\n  (env/with-compiler-env\n    (or (::env/compiler repl-env) (env/default-compiler-env opts))\n    (binding [ana/*cljs-ns* 'cljs.user\n              *cljs-verbose* verbose\n              ana/*cljs-warnings* (assoc ana/*cljs-warnings*\n                                    :unprovided warn-on-undeclared\n                                    :undeclared-var warn-on-undeclared\n                                    :undeclared-ns warn-on-undeclared\n                                    :undeclared-ns-form warn-on-undeclared)\n              ana/*cljs-static-fns* static-fns]\n      (when analyze-path\n        (analyze-source analyze-path))\n      (let [env {:context :expr :locals {}}\n            special-fns (merge default-special-fns special-fns)\n            is-special-fn? (set (keys special-fns))\n            read-error (Object.)]\n        (-setup repl-env)\n        (loop []\n          (print (str \"ClojureScript:\" ana/*cljs-ns* \"> \"))\n          (flush)\n          (let [rdr (readers/source-logging-push-back-reader\n                     (java.io.PushbackReader. (io/reader *in*))\n                     1\n                     \"NO_SOURCE_FILE\")\n                form (try\n                       (binding [*ns* (create-ns ana/*cljs-ns*)\n                                 reader/*data-readers* tags/*cljs-data-readers*\n                                 reader/*alias-map*\n                                 (apply merge\n                                        ((juxt :requires :require-macros)\n                                         (ana/get-namespace ana/*cljs-ns*)))]\n                         (reader/read rdr nil read-error))\n                       (catch Exception e\n                         (println (.getMessage e))\n                         read-error))]\n            (cond\n             (identical? form read-error) (recur)\n             (= form :cljs/quit) :quit\n\n             (and (seq? form) (is-special-fn? (first form)))\n             (do (apply (get special-fns (first form)) repl-env (rest form))\n                 (newline)\n                 (recur))\n\n             :else\n             (do (eval-and-print repl-env env form)\n                 (recur)))))\n        (-tear-down repl-env)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/repl.clj",
                                      :lines [182 235]},
                             :full-name "cljs.repl/repl",
                             :docstring "Note - repl will reload core.cljs every time, even if supplied old repl-env"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :name-encode "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net/IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [32 44]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :name-encode "let",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/let",
                            :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [142 152]},
                            :full-name "cljs.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/unchecked-divide-int" {:return-type number,
                                             :ns "cljs.core",
                                             :name "unchecked-divide-int",
                                             :signature ["[x]"
                                                         "[x y]"
                                                         "[x y & more]"],
                                             :name-encode "unchecked-divide-int",
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-divide-int",
                                             :source {:code "(defn ^number unchecked-divide-int\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [1595
                                                              1600]},
                                             :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r2199",
                                                              :filename "src/clj/cljs/core.clj",
                                                              :lines [373
                                                                      374]}],
                                             :full-name "cljs.core/unchecked-divide-int",
                                             :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/dorun" {:ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "dorun",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6706 6717]},
                              :full-name "cljs.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/with-redefs" {:ns "cljs.core",
                                    :name "with-redefs",
                                    :signature ["[bindings & body]"],
                                    :name-encode "with-redefs",
                                    :history [["+" "0.0-1806"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/with-redefs",
                                    :source {:code "(defmacro with-redefs\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map core/vector names vals)\n        resets (reverse (map core/vector names tempnames))\n        bind-value (fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave tempnames names)]\n       (try\n        ~@(map bind-value binds)\n        ~@body\n        (finally\n         ~@(map bind-value resets))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1052 1072]},
                                    :full-name "cljs.core/with-redefs",
                                    :docstring "binding => var-symbol temp-value-expr\n\nTemporarily redefines vars while executing the body.  The\ntemp-value-exprs will be evaluated and each resulting value will\nreplace in parallel the root value of its var.  After the body is\nexecuted, the root values of all the vars will be set back to their\nold values. Useful for mocking out functions during testing."},
           "cljs.core/unsigned-bit-shift-right" {:ns "cljs.core",
                                                 :name "unsigned-bit-shift-right",
                                                 :signature ["[x n]"],
                                                 :name-encode "unsigned-bit-shift-right",
                                                 :history [["+"
                                                            "0.0-2080"]],
                                                 :type "function/macro",
                                                 :full-name-encode "cljs.core/unsigned-bit-shift-right",
                                                 :source {:code "(defn unsigned-bit-shift-right\n  [x n] (cljs.core/unsigned-bit-shift-right x n))",
                                                          :title "Function code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [1764
                                                                  1766]},
                                                 :extra-sources [{:code "(defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                  :title "Macro code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2199",
                                                                  :filename "src/clj/cljs/core.clj",
                                                                  :lines [524
                                                                          525]}],
                                                 :full-name "cljs.core/unsigned-bit-shift-right",
                                                 :docstring "Bitwise shift right with zero fill"},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :name-encode "pr-str",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6936 6939]},
                               :full-name "cljs.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :name-encode "IPrintable",
                                   :implementations #{"Subvec"
                                                      "boolean"
                                                      "string"
                                                      "PersistentQueue"
                                                      "PersistentHashMap"
                                                      "PersistentTreeSet"
                                                      "js/Date"
                                                      "RedNode"
                                                      "EmptyList"
                                                      "ObjMap"
                                                      "BlackNode"
                                                      "PersistentVector"
                                                      "ChunkedCons"
                                                      "Range"
                                                      "ChunkedSeq"
                                                      "ArrayNodeSeq"
                                                      "IndexedSeq"
                                                      "number"
                                                      "PersistentTreeMap"
                                                      "PersistentTreeMapSeq"
                                                      "RSeq"
                                                      "Vector"
                                                      "function"
                                                      "PersistentArrayMap"
                                                      "PersistentHashSet"
                                                      "HashMap"
                                                      "NodeSeq"
                                                      "List"
                                                      "Atom"
                                                      "nil"
                                                      "Cons"
                                                      "LazySeq"
                                                      "array"
                                                      "UUID"},
                                   :history [["+" "0.0-927"]
                                             ["-" "0.0-1798"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IPrintable",
                                   :source {:code "(defprotocol ^:deprecated IPrintable\n  \"Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.\"\n  (-pr-seq [o opts]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1586",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [253 257]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :docstring "Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.",
                                   :removed {:in "0.0-1798",
                                             :last-seen "0.0-1586"}},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :name-encode "defprotocol",
                                    :type "macro",
                                    :full-name-encode "cljs.core/defprotocol",
                                    :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n        psym (vary-meta psym assoc :protocol-symbol true)\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (core/str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (core/string? (first doc+methods)) (next doc+methods) doc+methods)\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (core/str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         (let [x# (if (nil? ~(first sig)) nil ~(first sig))]\n                           ((or\n                             (aget ~(fqn fname) (goog.typeOf x#))\n                             (aget ~(fqn fname) \"_\")\n                             (throw (missing-protocol\n                                     ~(core/str psym \".\" fname) ~(first sig))))\n                            ~@sig)))))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (core/str prefix (name fname)))\n                       fname (vary-meta fname assoc :protocol p)]\n                   `(defn ~fname ~@(map (fn [sig]\n                                          (expand-sig fname\n                                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                                      sig))\n                                        sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (js-obj))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [967 998]},
                                    :full-name "cljs.core/defprotocol",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/ints" {:ns "cljs.core",
                             :name "ints",
                             :signature ["[x]"],
                             :name-encode "ints",
                             :type "function",
                             :full-name-encode "cljs.core/ints",
                             :source {:code "(defn ints [x] x)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1676]},
                             :full-name "cljs.core/ints",
                             :history [["+" "0.0-1798"]]},
           "cljs.core/assert" {:ns "cljs.core",
                               :name "assert",
                               :signature ["[x]" "[x message]"],
                               :name-encode "assert",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/assert",
                               :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1159 1171]},
                               :full-name "cljs.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :name-encode "declare",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.5.1",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2720 2723]},
                                :full-name "cljs.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/PersistentTreeMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeMap.EMPTY",
                                                :name-encode "PersistentTreeMapDOTEMPTY",
                                                :parent-type "PersistentTreeMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeMapDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentTreeMap.EMPTY (PersistentTreeMap. compare nil 0 nil 0))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [5967]},
                                                :full-name "cljs.core/PersistentTreeMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/fn?" {:return-type boolean,
                            :ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :name-encode "fnQMARK",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/fnQMARK",
                            :source {:code "(defn ^boolean fn? [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1038 1039]},
                            :full-name "cljs.core/fn?"},
           "cljs.core/associative?" {:return-type boolean,
                                     :ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[x]"],
                                     :name-encode "associativeQMARK",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/associativeQMARK",
                                     :source {:code "(defn ^boolean associative?\n  [x] (satisfies? IAssociative x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1151 1153]},
                                     :full-name "cljs.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :signature ["[repl-env ns url]"],
                                              :name-encode "load-javascript",
                                              :type "function",
                                              :full-name-encode "cljs.repl.rhino/load-javascript",
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (let [missing (remove #(contains? @(:loaded-libs repl-env) %) ns)]\n    (when (seq missing)\n      (do (try\n            (with-open [reader (io/reader url)]\n              (-eval reader repl-env (.toString url) 1))\n            ;; TODO: don't show errors for goog/base.js line number 105\n            (catch Throwable ex (println (.getMessage ex))))\n          (swap! (:loaded-libs repl-env) (partial apply conj) missing)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/repl/rhino.clj",
                                                       :lines [86 94]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/IList" {:ns "cljs.core",
                              :name "IList",
                              :name-encode "IList",
                              :implementations #{"EmptyList"
                                                 "List"
                                                 "Cons"},
                              :history [["+" "0.0-1211"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IList",
                              :source {:code "(defprotocol IList\n  \"Marker interface indicating a persistent list\")",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [309 310]},
                              :full-name "cljs.core/IList",
                              :docstring "Marker interface indicating a persistent list"},
           "cljs.core/list*" {:ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :name-encode "listSTAR",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2492 2500]},
                              :full-name "cljs.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/PersistentArrayMap.fromArray" {:ns "cljs.core",
                                                     :name "PersistentArrayMap.fromArray",
                                                     :signature ["[arr no-clone no-check]"],
                                                     :name-encode "PersistentArrayMapDOTfromArray",
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :parent-type "PersistentArrayMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentArrayMapDOTfromArray",
                                                     :source {:code "(set! cljs.core.PersistentArrayMap.fromArray\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (let [arr (if no-clone arr (aclone arr))] \n      (if no-check\n        (let [cnt (/ (alength arr) 2)]\n          (PersistentArrayMap. nil cnt arr nil))\n        (let [len (alength arr)]\n          (loop [i 0\n                 ret (transient cljs.core.PersistentArrayMap.EMPTY)]\n            (if (< i len)\n              (recur (+ i 2)\n                (-assoc! ret (aget arr i) (aget arr (inc i))))\n              (-persistent! ret))))))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2199",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [4400
                                                                      4412]},
                                                     :full-name "cljs.core/PersistentArrayMap.fromArray"},
           "cljs.core/reduce" {:ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :name-encode "reduce",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n       \n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n       \n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1400 1441]},
                               :full-name "cljs.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :name-encode "has-listener",
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/has-listener",
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [94]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/unchecked-dec-int" {:ns "cljs.core",
                                          :name "unchecked-dec-int",
                                          :signature ["[x]"],
                                          :name-encode "unchecked-dec-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-dec-int",
                                          :source {:code "(defn unchecked-dec-int [x]\n  (cljs.core/unchecked-dec-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1592 1593]},
                                          :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [370
                                                                   371]}],
                                          :full-name "cljs.core/unchecked-dec-int"},
           "cljs.core/PersistentHashMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashMap.EMPTY",
                                                :name-encode "PersistentHashMapDOTEMPTY",
                                                :parent-type "PersistentHashMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashMapDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentHashMap.EMPTY (PersistentHashMap. nil 0 nil false nil 0))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [5216]},
                                                :full-name "cljs.core/PersistentHashMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/compare" {:return-type number,
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :name-encode "compare",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/compare",
                                :source {:code "(defn ^number compare\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (identical? (type x) (type y))\n   (if (implements? IComparable x)\n     (-compare ^not-native x y)\n     (garray/defaultCompare x y))\n\n   :else\n   (throw (js/Error. \"compare on non-nil objects of different types\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1300 1319]},
                                :full-name "cljs.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\n when x is logically 'less than', 'equal to', or 'greater than'\n y. Uses IComparable if available and google.array.defaultCompare for objects\nof the same type and special-cases nil to be less than any other object."},
           "cljs.core/contains?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll v]"],
                                  :name-encode "containsQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/containsQMARK",
                                  :source {:code "(defn ^boolean contains?\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1255 1264]},
                                  :full-name "cljs.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :name-encode "prefer-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7698 7702]},
                                      :full-name "cljs.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :name-encode "array-seq",
                                  :type "function",
                                  :full-name-encode "cljs.core/array-seq",
                                  :source {:code "(defn array-seq\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [741 745]},
                                  :full-name "cljs.core/array-seq",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/to-array-2d" {:ns "cljs.core",
                                    :name "to-array-2d",
                                    :signature ["[coll]"],
                                    :name-encode "to-array-2d",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/to-array-2d",
                                    :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2360 2369]},
                                    :full-name "cljs.core/to-array-2d",
                                    :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
           "cljs.core/ICloneable" {:ns "cljs.core",
                                   :name "ICloneable",
                                   :name-encode "ICloneable",
                                   :implementations #{"Subvec"
                                                      "PersistentQueue"
                                                      "PersistentHashMap"
                                                      "PersistentTreeSet"
                                                      "EmptyList"
                                                      "PersistentVector"
                                                      "Range"
                                                      "IndexedSeq"
                                                      "PersistentTreeMap"
                                                      "RSeq"
                                                      "PersistentArrayMap"
                                                      "PersistentHashSet"
                                                      "List"
                                                      "Cons"},
                                   :history [["+" "0.0-2134"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/ICloneable",
                                   :source {:code "(defprotocol ICloneable\n  (^clj -clone [value]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [226 227]},
                                   :methods [{:name "-clone",
                                              :signature ["[value]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/ICloneable"},
           "warnings/multiple-variadic-overloads" {:ns "warnings",
                                                   :name "multiple-variadic-overloads",
                                                   :type "warning",
                                                   :full-name "warnings/multiple-variadic-overloads",
                                                   :full-name-encode "warnings/multiple-variadic-overloads",
                                                   :name-encode "multiple-variadic-overloads",
                                                   :history [["+"
                                                              "0.0-2014"]]},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :signature ["[opts file-path]"],
                                                      :name-encode "create-client-js-file",
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/create-client-js-file",
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r2199",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [205
                                                                       209]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.core/*print-length*" {:ns "cljs.core",
                                       :name "*print-length*",
                                       :name-encode "STARprint-lengthSTAR",
                                       :type "dynamic var",
                                       :full-name-encode "cljs.core/STARprint-lengthSTAR",
                                       :source {:code "(def ^:dynamic *print-length* nil)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [37]},
                                       :full-name "cljs.core/*print-length*",
                                       :history [["+" "0.0-2060"]]},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :name-encode "STARcljs-verboseSTAR",
                                       :type "dynamic var",
                                       :full-name-encode "cljs.repl/STARcljs-verboseSTAR",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [24]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:protocols #{"ISeqable"
                                                     "IMeta"
                                                     "IWithMeta"
                                                     "IStack"
                                                     "IEmptyableCollection"
                                                     "ICounted"
                                                     "ISequential"
                                                     "ISeq"
                                                     "ICollection"
                                                     "IHash"
                                                     "IPrintWithWriter"
                                                     "IEquiv"
                                                     "ICloneable"},
                                        :ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear __hash]"],
                                        :name-encode "PersistentQueue",
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.PersistentQueue.EMPTY)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [3927 3977]},
                                        :full-name "cljs.core/PersistentQueue"},
           "compiler-options/hashbang" {:ns "compiler-options",
                                        :name "hashbang",
                                        :name-encode "hashbang",
                                        :type "option",
                                        :full-name-encode "compiler-options/hashbang",
                                        :full-name "compiler-options/hashbang",
                                        :history [["+" "0.0-2197"]]},
           "cljs.repl.server/read-post" {:ns "cljs.repl.server",
                                         :name "read-post",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-post",
                                         :type "function",
                                         :full-name-encode "cljs.repl.server/read-post",
                                         :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/repl/server.clj",
                                                  :lines [77 86]},
                                         :full-name "cljs.repl.server/read-post",
                                         :history [["+" "0.0-1503"]]},
           "cljs.core/drop-last" {:ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :name-encode "drop-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2967 2970]},
                                  :full-name "cljs.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "closure-warnings/strict-module-dep-check" {:ns "closure-warnings",
                                                       :name "strict-module-dep-check",
                                                       :type "warning",
                                                       :full-name "closure-warnings/strict-module-dep-check",
                                                       :full-name-encode "closure-warnings/strict-module-dep-check",
                                                       :name-encode "strict-module-dep-check",
                                                       :history [["+"
                                                                  "0.0-2120"]]},
           "cljs.core/array?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "array?",
                               :signature ["[x]"],
                               :name-encode "arrayQMARK",
                               :history [["+" "0.0-1798"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/arrayQMARK",
                               :source {:code "(defn ^boolean array? [x]\n  (cljs.core/array? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [88 89]},
                               :extra-sources [{:code "(defmacro array? [x]\n  (if (= :nodejs (:target @env/*compiler*))\n    (bool-expr `(.isArray js/Array ~x))\n    (bool-expr (core/list 'js* \"~{} instanceof Array\" x))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [291 294]}],
                               :full-name "cljs.core/array?"},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs no-clone]"],
                                                   :name-encode "PersistentVectorDOTfromArray",
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core/PersistentVectorDOTfromArray",
                                                   :source {:code "(set! cljs.core.PersistentVector.fromArray\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (< l 32)\n        (PersistentVector. nil l 5 cljs.core.PersistentVector.EMPTY_NODE xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 cljs.core.PersistentVector.EMPTY_NODE node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (< i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [3484
                                                                    3495]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "compiler-options/warnings" {:ns "compiler-options",
                                        :name "warnings",
                                        :name-encode "warnings",
                                        :type "option",
                                        :full-name-encode "compiler-options/warnings",
                                        :full-name "compiler-options/warnings",
                                        :sub-options-ns "warnings",
                                        :history [["+" "0.0-1443"]]},
           "cljs.core/filterv" {:ns "cljs.core",
                                :name "filterv",
                                :signature ["[pred coll]"],
                                :name-encode "filterv",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/filterv",
                                :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3138 3145]},
                                :full-name "cljs.core/filterv",
                                :docstring "Returns a vector of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.core/IComparable" {:ns "cljs.core",
                                    :name "IComparable",
                                    :name-encode "IComparable",
                                    :implementations #{"Subvec"
                                                       "Symbol"
                                                       "PersistentVector"
                                                       "Keyword"},
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IComparable",
                                    :source {:code "(defprotocol IComparable\n  (^number -compare [x y]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [364 365]},
                                    :methods [{:name "-compare",
                                               :signature ["[x y]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IComparable"},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :name-encode "read-string",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r true nil false)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [431 435]},
                                      :full-name "cljs.reader/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.reader/unicode-2-pattern" {:ns "cljs.reader",
                                            :name "unicode-2-pattern",
                                            :name-encode "unicode-2-pattern",
                                            :type "var",
                                            :full-name-encode "cljs.reader/unicode-2-pattern",
                                            :source {:code "(def unicode-2-pattern (re-pattern \"[0-9A-Fa-f]{2}\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [187]},
                                            :full-name "cljs.reader/unicode-2-pattern",
                                            :history [["+" "0.0-1424"]]},
           "cljs.core/check-string-hash-cache" {:ns "cljs.core",
                                                :name "check-string-hash-cache",
                                                :signature ["[k]"],
                                                :name-encode "check-string-hash-cache",
                                                :type "function",
                                                :full-name-encode "cljs.core/check-string-hash-cache",
                                                :source {:code "(defn check-string-hash-cache [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1102
                                                                 1109]},
                                                :full-name "cljs.core/check-string-hash-cache",
                                                :history [["+"
                                                           "0.0-1424"]]},
           "cljs.core/vector?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :name-encode "vectorQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/vectorQMARK",
                                :source {:code "(defn ^boolean vector?\n  [x] (satisfies? IVector x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1174 1176]},
                                :full-name "cljs.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :name-encode "defmulti",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmulti",
                                 :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (core/string? (first options))\n                      (first options)\n                      nil)\n        options     (if (core/string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)]\n    (when (= (count options) 1)\n      (throw (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")))\n    (let [options   (apply core/hash-map options)\n          default   (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (get ~options :hierarchy (cljs.core/get-global-hierarchy))]\n           (cljs.core/MultiFn. ~(name mm-name) ~dispatch-fn ~default hierarchy#\n                               method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1471 1512]},
                                 :full-name "cljs.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "syntax/rest" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "rest",
                          :name-encode "rest",
                          :type "special character",
                          :full-name-encode "syntax/rest",
                          :full-name "syntax/rest",
                          :history [["+" "0.0-927"]]},
           "cljs.core/Keyword" {:protocols #{"IFn"
                                             "IHash"
                                             "INamed"
                                             "IComparable"
                                             "IPrintWithWriter"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "Keyword",
                                :signature ["[ns name fqn _hash]"],
                                :name-encode "Keyword",
                                :history [["+" "0.0-1424"]],
                                :type "type",
                                :full-name-encode "cljs.core/Keyword",
                                :source {:code "(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str \":\" fqn))\n  \n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [_]\n    ; This was checking if _hash == -1, should it stay that way?\n    (if (nil? _hash)\n      (do\n        (set! _hash (+ (hash-combine (hash ns) (hash name))\n                        0x9e3779b9))\n        _hash)\n      _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str \":\" fqn))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2087 2117]},
                                :full-name "cljs.core/Keyword"},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :name-encode "ListDOTEMPTY",
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core/ListDOTEMPTY",
                                   :source {:code "(set! cljs.core.List.EMPTY (EmptyList. nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2001]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :history [["+" "0.0-927"]]},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :signature ["[src event]"],
                                                   :name-encode "dispatch-event",
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/dispatch-event",
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (goog.events/dispatchEvent src event))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [75
                                                                    77]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.string/split-lines" {:ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :name-encode "split-lines",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "clojure.string/split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/clojure/string.cljs",
                                                  :lines [127 130]},
                                         :full-name "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :name-encode "loaded-libs",
                                            :type "var",
                                            :full-name-encode "cljs.repl.browser/loaded-libs",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [23]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/areduce" {:ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :name-encode "areduce",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/areduce",
                                :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1436 1445]},
                                :full-name "cljs.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :name-encode "disj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1078 1090]},
                             :full-name "cljs.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "compiler-options/main" {:ns "compiler-options",
                                    :name "main",
                                    :name-encode "main",
                                    :type "option",
                                    :full-name-encode "compiler-options/main",
                                    :full-name "compiler-options/main",
                                    :history [["+" "0.0-971"]]},
           "cljs.core/IEditableCollection" {:ns "cljs.core",
                                            :name "IEditableCollection",
                                            :name-encode "IEditableCollection",
                                            :implementations #{"PersistentHashMap"
                                                               "ObjMap"
                                                               "PersistentVector"
                                                               "PersistentArrayMap"
                                                               "PersistentHashSet"},
                                            :history [["+" "0.0-1211"]],
                                            :type "protocol",
                                            :full-name-encode "cljs.core/IEditableCollection",
                                            :source {:code "(defprotocol IEditableCollection\n  (^clj -as-transient [coll]))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [344 345]},
                                            :methods [{:name "-as-transient",
                                                       :signature ["[coll]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IEditableCollection"},
           "cljs.core/unchecked-char" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-char",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-char",
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-char",
                                       :source {:code "(defn ^number unchecked-char [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1570]},
                                       :extra-sources [{:code "(defmacro unchecked-char [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [356]}],
                                       :full-name "cljs.core/unchecked-char"},
           "cljs.core/keyword-identical?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "keyword-identical?",
                                           :signature ["[x y]"],
                                           :name-encode "keyword-identicalQMARK",
                                           :history [["+" "0.0-1877"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/keyword-identicalQMARK",
                                           :source {:code "(defn ^boolean keyword-identical? [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x)\n             (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2122 2128]},
                                           :full-name "cljs.core/keyword-identical?"},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :name-encode "event-types",
                                              :type "var",
                                              :full-name-encode "clojure.browser.net/event-types",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (. k (toLowerCase)))\n            v])\n         (merge\n          (js->clj goog.net.EventType)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [23 30]},
                                              :full-name "clojure.browser.net/event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :name-encode "lower-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (.toLowerCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [58 61]},
                                        :full-name "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :name-encode "STARprint-fnSTAR",
                                   :type "dynamic var",
                                   :full-name-encode "cljs.core/STARprint-fnSTAR",
                                   :source {:code "(def\n  ^{:doc \"Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [20 26]},
                                   :full-name "cljs.core/*print-fn*",
                                   :docstring "Each runtime environment provides a different way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :name-encode "str",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (if (nil? x)\n         \"\"\n         (.toString x)))\n  ([x & ys]\n    (loop [sb (gstring/StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1811 1823]},
                            :extra-sources [{:code "(defmacro str [& xs]\n  (let [strs (->> (repeat (count xs) \"cljs.core.str(~{})\")\n                  (interpose \",\")\n                  (apply core/str))]\n    (list* 'js* (core/str \"[\" strs \"].join('')\") xs)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [203 207]}],
                            :full-name "cljs.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :name-encode "ISequential",
                                    :implementations #{"Subvec"
                                                       "PersistentQueue"
                                                       "PersistentArrayMapSeq"
                                                       "RedNode"
                                                       "EmptyList"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "ValSeq"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "PersistentQueueSeq"
                                                       "ChunkedSeq"
                                                       "ArrayNodeSeq"
                                                       "KeySeq"
                                                       "IndexedSeq"
                                                       "PersistentTreeMapSeq"
                                                       "RSeq"
                                                       "NodeSeq"
                                                       "List"
                                                       "Cons"
                                                       "LazySeq"},
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [306 307]},
                                    :full-name "cljs.core/ISequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.core/try*" {:ns "cljs.core",
                             :name "try*",
                             :type "special form",
                             :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze (assoc env :context :statement) `(do ~@fblock)))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        locals (if name\n                 (assoc locals name\n                   {:name name\n                    :line (get-line name env)\n                    :column (get-col name env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) `(do ~@(rest cblock))))\n        body (if name (pop body) body)\n        try (analyze (if (or name finally) catchenv env) `(do ~@body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name name\n     :catch catch\n     :children [try catch finally]}))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1913",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [280 312]},
                             :full-name "cljs.core/try*",
                             :full-name-encode "cljs.core/trySTAR",
                             :name-encode "trySTAR",
                             :history [["+" "0.0-927"]
                                       ["-" "0.0-1933"]],
                             :removed {:in "0.0-1933",
                                       :last-seen "0.0-1913"}},
           "closure-warnings/non-standard-jsdoc" {:ns "closure-warnings",
                                                  :name "non-standard-jsdoc",
                                                  :type "warning",
                                                  :full-name "closure-warnings/non-standard-jsdoc",
                                                  :full-name-encode "closure-warnings/non-standard-jsdoc",
                                                  :name-encode "non-standard-jsdoc",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/key-test" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "key-test",
                                 :signature ["[key other]"],
                                 :name-encode "key-test",
                                 :history [["+" "0.0-1424"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/key-test",
                                 :source {:code "(defn ^boolean key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (= key other)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4499 4503]},
                                 :full-name "cljs.core/key-test"},
           "cljs.core/set" {:ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :name-encode "set",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/set",
                            :source {:code "(defn set\n  [coll]\n  (let [^not-native in (seq coll)]\n    (cond\n      (nil? in) #{}\n\n      (and (instance? IndexedSeq in) (zero? (.-i in)))\n      (set-from-indexed-seq in)\n\n      :else\n      (loop [in in\n              ^not-native out (-as-transient #{})]\n        (if-not (nil? in)\n          (recur (-next in) (-conj! out (-first in)))\n          (-persistent! out))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [6383 6398]},
                            :full-name "cljs.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "cljs.core/obj-map" {:ns "cljs.core",
                                :name "obj-map",
                                :signature ["[& keyvals]"],
                                :name-encode "obj-map",
                                :history [["+" "0.0-1443"]],
                                :type "function",
                                :full-name-encode "cljs.core/obj-map",
                                :source {:code "(defn obj-map\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (aset obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (cljs.core.ObjMap.fromObject ks obj)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5984 5995]},
                                :full-name "cljs.core/obj-map",
                                :docstring "keyval => key val\nReturns a new object map with supplied mappings."},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :name-encode "print",
                              :type "function",
                              :full-name-encode "cljs.core/print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6954 6959]},
                              :full-name "cljs.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption.",
                              :history [["+" "0.0-927"]]},
           "cljs.core/ArrayNode" {:ns "cljs.core",
                                  :name "ArrayNode",
                                  :signature ["[edit cnt arr]"],
                                  :name-encode "ArrayNode",
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayNode",
                                  :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc cljs.core.BitmapIndexedNode.EMPTY (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! cljs.core.BitmapIndexedNode.EMPTY edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  @init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4769 4864]},
                                  :full-name "cljs.core/ArrayNode",
                                  :history [["+" "0.0-1211"]]},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :name-encode "type",
                             :type "function",
                             :full-name-encode "cljs.core/type",
                             :source {:code "(defn type [x]\n  (when-not (nil? x)\n    (.-constructor x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [127 129]},
                             :full-name "cljs.core/type",
                             :history [["+" "0.0-971"]]},
           "clojure.string/blank?" {:ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :name-encode "blankQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/blankQMARK",
                                    :source {:code "(defn blank?\n  [s]\n  (gstring/isEmptySafe s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [159 162]},
                                    :full-name "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "syntax/keyword" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "keyword",
                             :name-encode "keyword",
                             :type "syntax",
                             :full-name-encode "syntax/keyword",
                             :extra-sources ({:code "(defn- read-keyword\n  [reader initch]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [299 317]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [578 597]}),
                             :full-name "syntax/keyword",
                             :history [["+" "0.0-1853"]]},
           "cljs.reader/maybe-read-tagged-type" {:ns "cljs.reader",
                                                 :name "maybe-read-tagged-type",
                                                 :signature ["[rdr initch]"],
                                                 :name-encode "maybe-read-tagged-type",
                                                 :type "function",
                                                 :full-name-encode "cljs.reader/maybe-read-tagged-type",
                                                 :source {:code "(defn maybe-read-tagged-type\n  [rdr initch]\n  (let [tag (read-symbol rdr initch)\n        pfn (get @*tag-table* (str tag))\n        dfn @*default-data-reader-fn*]\n    (cond\n     pfn (pfn (read rdr true nil false))\n     dfn (dfn tag (read rdr true nil false))\n     :else (reader-error rdr\n                         \"Could not find tag parser for \" (str tag)\n                         \" in \" (pr-str (keys @*tag-table*))))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/reader.cljs",
                                                          :lines [563
                                                                  573]},
                                                 :full-name "cljs.reader/maybe-read-tagged-type",
                                                 :history [["+"
                                                            "0.0-1236"]]},
           "cljs.core/IChunkedSeq" {:ns "cljs.core",
                                    :name "IChunkedSeq",
                                    :name-encode "IChunkedSeq",
                                    :implementations #{"ChunkedCons"
                                                       "ChunkedSeq"},
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IChunkedSeq",
                                    :source {:code "(defprotocol IChunkedSeq\n  (-chunked-first [coll])\n  (-chunked-rest [coll]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [370 372]},
                                    :methods [{:name "-chunked-first",
                                               :signature ["[coll]"],
                                               :docstring nil}
                                              {:name "-chunked-rest",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IChunkedSeq"},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :signature ["[parent & children]"],
                                         :name-encode "append",
                                         :type "function",
                                         :full-name-encode "clojure.browser.dom/append",
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/clojure/browser/dom.cljs",
                                                  :lines [13 15]},
                                         :full-name "clojure.browser.dom/append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :name-encode "take-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2972 2979]},
                                  :full-name "cljs.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "cljs.core/key->js" {:ns "cljs.core",
                                :name "key->js",
                                :signature ["[k]"],
                                :name-encode "key-GTjs",
                                :type "function",
                                :full-name-encode "cljs.core/key-GTjs",
                                :source {:code "(defn key->js [k]\n  (if (satisfies? IEncodeJS k)\n    (-clj->js k)\n    (if (or (string? k)\n            (number? k)\n            (keyword? k)\n            (symbol? k))\n      (clj->js k)\n      (pr-str k))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7319 7327]},
                                :full-name "cljs.core/key->js",
                                :history [["+" "0.0-1798"]]},
           "cljs.core/TransientHashMap" {:protocols #{"ITransientCollection"
                                                      "ICounted"
                                                      "ILookup"
                                                      "ITransientAssociative"
                                                      "ITransientMap"},
                                         :ns "cljs.core",
                                         :name "TransientHashMap",
                                         :signature ["[edit root count has-nil? nil-val]"],
                                         :name-encode "TransientHashMap",
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashMap",
                                         :source {:code "(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (if (satisfies? IMapEntry o)\n        (.assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                cljs.core.BitmapIndexedNode.EMPTY\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if (aget removed-leaf? 0)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [5226 5327]},
                                         :full-name "cljs.core/TransientHashMap"},
           "clojure.set/intersection" {:ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :name-encode "intersection",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.set/intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "warnings/invalid-arithmetic" {:ns "warnings",
                                          :name "invalid-arithmetic",
                                          :type "warning",
                                          :full-name "warnings/invalid-arithmetic",
                                          :full-name-encode "warnings/invalid-arithmetic",
                                          :name-encode "invalid-arithmetic",
                                          :history [["+" "0.0-2067"]]},
           "cljs.core/fnext" {:ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :name-encode "fnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [815 818]},
                              :full-name "cljs.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :name-encode "apply",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count args (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc args)\n            (.cljs$lang$applyTo f args)))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2574 2620]},
                              :full-name "cljs.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :name-encode "prewalk",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk/prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/walk.cljs",
                                            :lines [58 62]},
                                   :full-name "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :name-encode "flatten",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3104 3110]},
                                :full-name "cljs.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.core/get" {:ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :name-encode "get",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/get",
                            :source {:code "(defn get\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k)\n\n        (array? o)\n        (when (< k (.-length o))\n          (aget o k))\n        \n        (string? o)\n        (when (< k (.-length o))\n          (aget o k))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n        \n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k not-found)\n\n        (array? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n        \n        (string? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [967 1007]},
                            :full-name "cljs.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.core/char" {:ns "cljs.core",
                             :name "char",
                             :signature ["[x]"],
                             :name-encode "char",
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core/char",
                             :source {:code "(defn char\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1557 1563]},
                             :full-name "cljs.core/char",
                             :docstring "Coerce to char"},
           "cljs.core/.." {:ns "cljs.core",
                           :name "..",
                           :signature ["[x form]" "[x form & more]"],
                           :name-encode "DOTDOT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.5.1",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1527 1543]},
                           :full-name "cljs.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/floats" {:ns "cljs.core",
                               :name "floats",
                               :signature ["[x]"],
                               :name-encode "floats",
                               :type "function",
                               :full-name-encode "cljs.core/floats",
                               :source {:code "(defn floats [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1677]},
                               :full-name "cljs.core/floats",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/Range" {:protocols #{"ISeqable"
                                           "IMeta"
                                           "IWithMeta"
                                           "IEmptyableCollection"
                                           "ICounted"
                                           "IReduce"
                                           "ISequential"
                                           "ISeq"
                                           "ICollection"
                                           "IHash"
                                           "IPrintWithWriter"
                                           "IIndexed"
                                           "INext"
                                           "IEquiv"
                                           "ICloneable"},
                              :ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step __hash]"],
                              :name-encode "Range",
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Range",
                              :source {:code "(deftype Range [meta start end step ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step __hash))\n\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step __hash))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng]\n    (if (pos? step)\n      (when (< start end)\n        rng)\n      (when (> start end)\n        rng)))\n\n  ISeq\n  (-first [rng]\n    (when-not (nil? (-seq rng)) start))\n  (-rest [rng]\n    (if-not (nil? (-seq rng))\n      (Range. meta (+ start step) end step nil)\n      ()))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. meta (+ start step) end step nil))\n      (when (> (+ start step) end)\n        (Range. meta (+ start step) end step nil))))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta cljs.core.List.EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (js/Math.ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f s] (ci-reduce rng f s)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6540 6613]},
                              :full-name "cljs.core/Range"},
           "cljs.core/zero?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :name-encode "zeroQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/zeroQMARK",
                              :source {:code "(defn ^boolean zero? [n]\n  (cljs.core/zero? n))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1792 1793]},
                              :extra-sources [{:code "(defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [455 456]}],
                              :full-name "cljs.core/zero?"},
           "cljs.core/identity" {:ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :name-encode "identity",
                                 :type "function",
                                 :full-name-encode "cljs.core/identity",
                                 :source {:code "(defn identity [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2688]},
                                 :full-name "cljs.core/identity",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/first" {:ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :name-encode "first",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/first",
                              :source {:code "(defn first\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first ^not-native coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [493 502]},
                              :full-name "cljs.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :name-encode "ratio-pattern",
                                        :type "var",
                                        :full-name-encode "cljs.reader/ratio-pattern",
                                        :source {:code "(def ratio-pattern (re-pattern \"([-+]?[0-9]+)/([0-9]+)\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [98]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :name-encode "println-str",
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [6973 6976]},
                                    :full-name "cljs.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.core/>" {:return-type boolean,
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "GT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/GT",
                          :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1513 1523]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [434 437]}],
                          :full-name "cljs.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.core/juxt" {:ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :name-encode "juxt",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [6670 6704]},
                             :full-name "cljs.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.core/max" {:return-type number,
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "max",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/max",
                            :source {:code "(defn ^number max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1541 1546]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [464 468]}],
                            :full-name "cljs.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/with-out-str" {:ns "cljs.core",
                                     :name "with-out-str",
                                     :signature ["[& body]"],
                                     :name-encode "with-out-str",
                                     :history [["+" "0.0-1535"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/with-out-str",
                                     :source {:code "(defmacro with-out-str\n  [& body]\n  `(let [sb# (goog.string/StringBuffer.)]\n     (binding [cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1572 1580]},
                                     :full-name "cljs.core/with-out-str",
                                     :docstring "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls."},
           "cljs.core/*3" {:ns "cljs.core",
                           :name "*3",
                           :name-encode "STAR3",
                           :type "var",
                           :full-name-encode "cljs.core/STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [65 67]},
                           :full-name "cljs.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.core/memfn" {:ns "cljs.core",
                              :name "memfn",
                              :signature ["[name & args]"],
                              :name-encode "memfn",
                              :history [["+" "0.0-1443"]],
                              :type "macro",
                              :full-name-encode "cljs.core/memfn",
                              :source {:code "(defmacro memfn\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.5.1",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [3480 3491]},
                              :full-name "cljs.core/memfn",
                              :docstring "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a Java method as\na first-class fn. name may be type-hinted with the method receiver's\ntype in order to avoid reflective calls."},
           "cljs.core/IEncodeClojure" {:ns "cljs.core",
                                       :name "IEncodeClojure",
                                       :name-encode "IEncodeClojure",
                                       :type "protocol",
                                       :full-name-encode "cljs.core/IEncodeClojure",
                                       :source {:code "(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [7350 7351]},
                                       :methods [{:name "-js->clj",
                                                  :signature ["[x options]"],
                                                  :docstring "Transforms JavaScript values to Clojure"}],
                                       :full-name "cljs.core/IEncodeClojure",
                                       :history [["+" "0.0-1552"]]},
           "cljs.core/TransientArrayMap" {:protocols #{"ITransientCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ITransientAssociative"
                                                       "ITransientMap"},
                                          :ns "cljs.core",
                                          :name "TransientArrayMap",
                                          :signature ["[editable? len arr]"],
                                          :name-encode "TransientArrayMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/TransientArrayMap",
                                          :source {:code "(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (if (satisfies? IMapEntry o)\n        (-assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\")))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [4416 4482]},
                                          :full-name "cljs.core/TransientArrayMap"},
           "cljs.core/cond->>" {:ns "cljs.core",
                                :name "cond->>",
                                :signature ["[expr & clauses]"],
                                :name-encode "cond-GTGT",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/cond-GTGT",
                                :source {:code "(defmacro cond->>\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (->> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.5.1",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [6789 6801]},
                                :full-name "cljs.core/cond->>",
                                :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression."},
           "cljs.core/number?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :name-encode "numberQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/numberQMARK",
                                :source {:code "(defn ^boolean number? [n]\n  (cljs.core/number? n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [91 92]},
                                :extra-sources [{:code "(defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [320 321]}],
                                :full-name "cljs.core/number?"},
           "cljs.core/array" {:return-type array,
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[var-args]"],
                              :name-encode "array",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/array",
                              :source {:code "(defn ^array array\n  [var-args]            ;; [& items]\n  (.call (.-slice (.-prototype js/Array)) (cljs.core/js-arguments)))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [162 166]},
                              :extra-sources [{:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [1316 1323]}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :name-encode "nthnext",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1801 1807]},
                                :full-name "cljs.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :name-encode "re-pattern",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n    (js/RegExp. pattern flags)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6768 6772]},
                                   :full-name "cljs.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :signature ["[proto obj]"],
                                         :name-encode "missing-protocol",
                                         :type "function",
                                         :full-name-encode "cljs.core/missing-protocol",
                                         :source {:code "(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [131 138]},
                                         :full-name "cljs.core/missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :name-encode "set-text",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom/set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/browser/dom.cljs",
                                                    :lines [124 129]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :name-encode "up",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip/up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :name-encode "IWithMeta",
                                  :implementations #{"Subvec"
                                                     "Symbol"
                                                     "PersistentQueue"
                                                     "PersistentHashMap"
                                                     "PersistentTreeSet"
                                                     "PersistentArrayMapSeq"
                                                     "RedNode"
                                                     "EmptyList"
                                                     "ObjMap"
                                                     "BlackNode"
                                                     "PersistentVector"
                                                     "ValSeq"
                                                     "ChunkedCons"
                                                     "Range"
                                                     "PersistentQueueSeq"
                                                     "ChunkedSeq"
                                                     "ArrayNodeSeq"
                                                     "KeySeq"
                                                     "PersistentTreeMap"
                                                     "PersistentTreeMapSeq"
                                                     "RSeq"
                                                     "PersistentArrayMap"
                                                     "PersistentHashSet"
                                                     "NodeSeq"
                                                     "List"
                                                     "Cons"
                                                     "LazySeq"},
                                  :history [["+" "0.0-927"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (^clj -with-meta [o meta]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [288 289]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IWithMeta"},
           "cljs.core/bit-and-not" {:ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"],
                                    :name-encode "bit-and-not",
                                    :history [["+" "0.0-927"]],
                                    :type "function/macro",
                                    :full-name-encode "cljs.core/bit-and-not",
                                    :source {:code "(defn bit-and-not\n  [x y] (cljs.core/bit-and-not x y))",
                                             :title "Function code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1724 1726]},
                                    :extra-sources [{:code "(defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :title "Macro code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/core.clj",
                                                     :lines [502 504]}],
                                    :full-name "cljs.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :name-encode "triml",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/triml",
                                   :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [137 140]},
                                   :full-name "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "cljs.core/chunk-append" {:ns "cljs.core",
                                     :name "chunk-append",
                                     :signature ["[b x]"],
                                     :name-encode "chunk-append",
                                     :type "function",
                                     :full-name-encode "cljs.core/chunk-append",
                                     :source {:code "(defn chunk-append [b x]\n  (.add b x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2331 2332]},
                                     :full-name "cljs.core/chunk-append",
                                     :history [["+" "0.0-1424"]]},
           "compiler-options/output-dir" {:ns "compiler-options",
                                          :name "output-dir",
                                          :name-encode "output-dir",
                                          :type "option",
                                          :full-name-encode "compiler-options/output-dir",
                                          :full-name "compiler-options/output-dir",
                                          :history [["+" "0.0-971"]]},
           "syntax/character" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "character",
                               :name-encode "character",
                               :type "syntax",
                               :full-name-encode "syntax/character",
                               :extra-sources ({:code "(defn- read-char*\n  [rdr backslash]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (read-token rdr ch)\n            token-len (count token)]\n        (cond\n\n         (== 1 token-len)  (Character/valueOf (nth token 0))\n\n         (= token \"newline\") \\newline\n         (= token \"space\") \\space\n         (= token \"tab\") \\tab\n         (= token \"backspace\") \\backspace\n         (= token \"formfeed\") \\formfeed\n         (= token \"return\") \\return\n\n         (.startsWith token \"u\")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (int c)]\n           (if (and (> ic upper-limit)\n                    (< ic lower-limit))\n             (reader-error rdr \"Invalid character constant: \\\\u\" (Integer/toString ic 16))\n             c))\n\n         (.startsWith token \"x\")\n         (read-unicode-char token 1 2 16)\n\n         (.startsWith token \"o\")\n         (let [len (dec token-len)]\n           (if (> len 3)\n             (reader-error rdr \"Invalid octal escape sequence length: \" len)\n             (let [uc (read-unicode-char token 1 len 8)]\n               (if (> (int uc) 0377)\n                 (reader-error rdr \"Octal escape sequence must be in range [0, 377]\")\n                 uc))))\n\n         :else (reader-error rdr \"Unsupported character: \\\\\" token)))\n      (reader-error rdr \"EOF while reading character\"))))",
                                                :title "Reader code",
                                                :repo "tools.reader",
                                                :tag "tools.reader-0.8.3",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [107 145]}
                                               {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                :title "Reader table",
                                                :repo "tools.reader",
                                                :tag "tools.reader-0.8.3",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [578 597]}),
                               :full-name "syntax/character",
                               :history [["+" "0.0-1853"]]},
           "syntax/unreadable" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "unreadable",
                                :name-encode "unreadable",
                                :type "syntax",
                                :full-name-encode "syntax/unreadable",
                                :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                                 :title "Reader table",
                                                 :repo "tools.reader",
                                                 :tag "tools.reader-0.8.3",
                                                 :filename "src/main/clojure/clojure/tools/reader.clj",
                                                 :lines [599 610]}),
                                :full-name "syntax/unreadable",
                                :history [["+" "0.0-1853"]]},
           "cljs.core/regexp?" {:ns "cljs.core",
                                :name "regexp?",
                                :signature ["[o]"],
                                :name-encode "regexpQMARK",
                                :type "function",
                                :full-name-encode "cljs.core/regexpQMARK",
                                :source {:code "(defn regexp? [o]\n  (instance? js/RegExp o))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6735 6736]},
                                :full-name "cljs.core/regexp?",
                                :history [["+" "0.0-1424"]]},
           "clojure.string/split" {:ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :name-encode "split",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/split",
                                   :source {:code "(defn split\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (= (str re) \"/(?:)/\")\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (= limit 1)\n               (conj parts s)\n               (if-let [m (re-find re s)]\n                 (let [index (.indexOf s m)]\n                   (recur (.substring s (+ index (count m)))\n                          (dec limit)\n                          (conj parts (.substring s 0 index))))\n                 (conj parts s)))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [104 125]},
                                   :full-name "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.reader/read-4-chars" {:ns "cljs.reader",
                                       :name "read-4-chars",
                                       :signature ["[reader]"],
                                       :name-encode "read-4-chars",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-4-chars",
                                       :source {:code "(defn read-4-chars [reader]\n  (.toString\n    (gstring/StringBuffer.\n      (read-char reader)\n      (read-char reader)\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [179 185]},
                                       :full-name "cljs.reader/read-4-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/hash-map" {:ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :name-encode "hash-map",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient cljs.core.PersistentHashMap.EMPTY)]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [5969 5976]},
                                 :extra-sources [{:code "(defmacro hash-map\n  ([] `cljs.core.PersistentHashMap.EMPTY)\n  ([& kvs]\n    (let [pairs (partition 2 kvs)\n          ks    (map first pairs)\n          vs    (map second pairs)]\n      (vary-meta\n        `(cljs.core.PersistentHashMap.fromArrays (array ~@ks) (array ~@vs))\n        assoc :tag 'cljs.core/PersistentHashMap))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1365 1373]}],
                                 :full-name "cljs.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/mapv" {:ns "cljs.core",
                             :name "mapv",
                             :signature ["[f coll]"
                                         "[f c1 c2]"
                                         "[f c1 c2 c3]"
                                         "[f c1 c2 c3 & colls]"],
                             :name-encode "mapv",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapv",
                             :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3122 3136]},
                             :full-name "cljs.core/mapv",
                             :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/rem" {:ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :name-encode "rem",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1697 1701]},
                            :full-name "cljs.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :name-encode "IRecord",
                                :type "protocol",
                                :full-name-encode "cljs.core/IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [312 313]},
                                :full-name "cljs.core/IRecord",
                                :docstring "Marker interface indicating a record object",
                                :history [["+" "0.0-927"]]},
           "cljs.core/constantly" {:ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :name-encode "constantly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2700 2702]},
                                   :full-name "cljs.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :signature ["[id]"],
                                              :name-encode "get-element",
                                              :type "function",
                                              :full-name-encode "clojure.browser.dom/get-element",
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/clojure/browser/dom.cljs",
                                                       :lines [98 99]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/UUID" {:protocols #{"IHash"
                                          "IPrintWithWriter"
                                          "IEquiv"},
                             :ns "cljs.core",
                             :name "UUID",
                             :signature ["[uuid]"],
                             :name-encode "UUID",
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/UUID",
                             :source {:code "(deftype UUID [uuid]\n  Object\n  (toString [_] uuid)\n\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (goog.string/hashCode (pr-str this))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7719 7733]},
                             :full-name "cljs.core/UUID"},
           "warnings/overload-arity" {:ns "warnings",
                                      :name "overload-arity",
                                      :type "warning",
                                      :full-name "warnings/overload-arity",
                                      :full-name-encode "warnings/overload-arity",
                                      :name-encode "overload-arity",
                                      :history [["+" "0.0-2014"]]},
           "clojure.core.reducers/reduce" {:ns "clojure.core.reducers",
                                           :name "reduce",
                                           :signature ["[f coll]"
                                                       "[f init coll]"],
                                           :name-encode "reduce",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/reduce",
                                           :source {:code "(defn reduce\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (array-reduce coll f init)\n         :else (-reduce coll f init)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [33 44]},
                                           :full-name "clojure.core.reducers/reduce",
                                           :docstring "Like core/reduce except:\n  When init is not provided, (f) is used.\n  Maps are reduced with reduce-kv"},
           "cljs.core/and" {:ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :name-encode "and",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/and",
                            :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n    (let [forms (concat [x] next)]\n      (if (every? #(simple-test-expr? &env %)\n            (map #(cljs.analyzer/analyze &env %) forms))\n        (let [and-str (->> (repeat (count forms) \"(~{})\")\n                        (interpose \" && \")\n                        (apply core/str))]\n          (bool-expr `(~'js* ~and-str ~@forms)))\n        `(let [and# ~x]\n           (if and# (and ~@next) and#))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [217 233]},
                            :full-name "cljs.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :signature ["[t data]"],
                                                :name-encode "wrap-message",
                                                :type "function",
                                                :full-name-encode "clojure.browser.repl/wrap-message",
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/clojure/browser/repl.cljs",
                                                         :lines [57
                                                                 58]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.reader/deregister-tag-parser!" {:ns "cljs.reader",
                                                 :name "deregister-tag-parser!",
                                                 :signature ["[tag]"],
                                                 :name-encode "deregister-tag-parserBANG",
                                                 :type "function",
                                                 :full-name-encode "cljs.reader/deregister-tag-parserBANG",
                                                 :source {:code "(defn deregister-tag-parser!\n  [tag]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/reader.cljs",
                                                          :lines [582
                                                                  587]},
                                                 :full-name "cljs.reader/deregister-tag-parser!",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "clojure.reflect/print-doc" {:ns "clojure.reflect",
                                        :name "print-doc",
                                        :signature ["[{:keys [name method-params doc]}]"],
                                        :name-encode "print-doc",
                                        :type "function",
                                        :full-name-encode "clojure.reflect/print-doc",
                                        :source {:code "(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/clojure/reflect.cljs",
                                                 :lines [38 42]},
                                        :full-name "clojure.reflect/print-doc",
                                        :history [["+" "0.0-1503"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :signature ["[key]"],
                                                    :name-encode "unlisten-by-key",
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unlisten-by-key",
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (goog.events/unlistenByKey key))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [71
                                                                     73]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/new" {:ns "cljs.core",
                            :name "new",
                            :type "special form",
                            :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _]\n  (when-not (symbol? ctor) \n    (throw (error env \"First arg to new must be a symbol\")))\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         argexprs (vec (map #(analyze enve %) args))\n         known-num-fields (:num-fields (resolve-existing-var env ctor))\n         argc (count args)]\n     (when (and (not (-> ctor meta :internal-ctor))\n                known-num-fields (not= known-num-fields argc))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :ctor ctorexpr :args argexprs\n      :children (into [ctorexpr] argexprs)\n      :tag (let [name (-> ctorexpr :info :name)]\n             (or ('{js/Object object\n                    js/String string\n                    js/Array  array\n                    js/Number number\n                    js/Function function\n                    js/Boolean boolean} name)\n                 name))})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [880 902]},
                            :extra-sources ({:code "(defmethod emit* :new\n  [{:keys [ctor args env]}]\n  (emit-wrap env\n             (emits \"(new \" ctor \"(\"\n                    (comma-sep args)\n                    \"))\")))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [764 769]}),
                            :full-name "cljs.core/new",
                            :full-name-encode "cljs.core/new",
                            :name-encode "new",
                            :history [["+" "0.0-927"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :type "special form",
                            :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [489 548]},
                            :extra-sources ({:code "(defmethod emit* :try\n  [{:keys [env try catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :constant (:op finally)) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [614 629]}),
                            :full-name "cljs.core/try",
                            :full-name-encode "cljs.core/try",
                            :name-encode "try",
                            :history [["+" "0.0-927"]]},
           "cljs.core/iterate" {:ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :name-encode "iterate",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3019 3022]},
                                :full-name "cljs.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :name-encode "lazy-seq",
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-seq",
                                 :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1042 1043]},
                                 :full-name "cljs.core/lazy-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/IndexedSeq" {:protocols #{"ISeqable"
                                                "IReversible"
                                                "IEmptyableCollection"
                                                "ICounted"
                                                "IReduce"
                                                "ISequential"
                                                "ISeq"
                                                "ICollection"
                                                "IHash"
                                                "ASeq"
                                                "IPrintWithWriter"
                                                "IIndexed"
                                                "INext"
                                                "IEquiv"
                                                "ICloneable"},
                                   :ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[arr i]"],
                                   :name-encode "IndexedSeq",
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [arr i]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i))\n\n  ISeqable\n  (-seq [this] this)\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               nil))\n\n  ICounted\n  (-count [_] (- (alength arr) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (alength arr))\n        (aget arr i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (alength arr))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] cljs.core.List.EMPTY)\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [672 732]},
                                   :full-name "cljs.core/IndexedSeq"},
           "cljs.repl.server/parse-headers" {:ns "cljs.repl.server",
                                             :name "parse-headers",
                                             :signature ["[header-lines]"],
                                             :name-encode "parse-headers",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.server/parse-headers",
                                             :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/clj/cljs/repl/server.clj",
                                                      :lines [60 68]},
                                             :full-name "cljs.repl.server/parse-headers",
                                             :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/KeySeq" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "KeySeq",
                               :signature ["[mseq _meta]"],
                               :name-encode "KeySeq",
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/KeySeq",
                               :source {:code "(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (KeySeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY _meta))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n  \n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6016 6067]},
                               :full-name "cljs.core/KeySeq"},
           "cljs.core/next" {:return-type seq,
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :name-encode "next",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/next",
                             :source {:code "(defn ^seq next\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next ^not-native coll)\n      (seq (rest coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [517 524]},
                             :full-name "cljs.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :name-encode "STARprint-readablySTAR",
                                         :type "dynamic var",
                                         :full-name-encode "cljs.core/STARprint-readablySTAR",
                                         :source {:code "(def ^:dynamic *print-readably* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [34]},
                                         :full-name "cljs.core/*print-readably*",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :signature ["[]"],
                                               :name-encode "repl-client-js",
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/repl-client-js",
                                               :source {:code "(defn repl-client-js []\n  (slurp @(:client-js @browser-state)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [48 49]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "compiler-options/source-map" {:ns "compiler-options",
                                          :name "source-map",
                                          :name-encode "source-map",
                                          :type "option",
                                          :full-name-encode "compiler-options/source-map",
                                          :full-name "compiler-options/source-map",
                                          :history [["+" "0.0-1798"]]},
           "cljs.core/booleans" {:ns "cljs.core",
                                 :name "booleans",
                                 :signature ["[x]"],
                                 :name-encode "booleans",
                                 :type "function",
                                 :full-name-encode "cljs.core/booleans",
                                 :source {:code "(defn booleans [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1672]},
                                 :full-name "cljs.core/booleans",
                                 :history [["+" "0.0-1798"]]},
           "cljs.core/not-native" {:ns "cljs.core",
                                   :name "not-native",
                                   :name-encode "not-native",
                                   :type "var",
                                   :full-name-encode "cljs.core/not-native",
                                   :source {:code "(def not-native nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [74]},
                                   :full-name "cljs.core/not-native",
                                   :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :name-encode "parse-headers",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1450",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [116
                                                               124]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request.",
                                              :removed {:in "0.0-1503",
                                                        :last-seen "0.0-1450"}},
           "cljs.core/last" {:ns "cljs.core",
                             :name "last",
                             :signature ["[s]"],
                             :name-encode "last",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/last",
                             :source {:code "(defn last\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [825 831]},
                             :full-name "cljs.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/pr-str*" {:ns "cljs.core",
                                :name "pr-str*",
                                :signature ["[obj]"],
                                :name-encode "pr-strSTAR",
                                :history [["+" "0.0-1806"]],
                                :type "function",
                                :full-name-encode "cljs.core/pr-strSTAR",
                                :source {:code "(defn pr-str*\n  [^not-native obj]\n  (let [sb (gstring/StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [388 396]},
                                :full-name "cljs.core/pr-str*",
                                :docstring "Support so that collections can implement toString without\nloading all the printing machinery."},
           "cljs.core/letfn*" {:ns "cljs.core",
                               :name "letfn*",
                               :type "special form",
                               :source {:code "(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name]\n  (when-not (and (vector? bindings) (even? (count bindings))) \n    (throw (error env \"bindings must be vector of even number of elements\")))\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-> n meta :tag)\n                        fexpr (no-warn (analyze env (n->fexpr n)))\n                        be (cond->\n                             {:name n\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local true\n                              :shadow (locals n)\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :methods (:methods fexpr)}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n->fexpr name))\n                        be' (assoc be\n                              :init fexpr\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :methods (:methods fexpr))]\n                    [(assoc-in env [:locals name] be')\n                     (conj bes be')]))\n          [meth-env []] bes)\n        expr (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))]\n    {:env env :op :letfn :bindings bes :expr expr :form form\n     :children (conj (vec (map :init bes)) expr)}))",
                                        :title "Parser code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/clj/cljs/analyzer.clj",
                                        :lines [739 783]},
                               :extra-sources ({:code "(defmethod emit* :letfn\n  [{:keys [bindings expr env]}]\n  (let [context (:context env)]\n    (when (= :expr context) (emits \"(function (){\"))\n    (doseq [{:keys [init] :as binding} bindings]\n      (emitln \"var \" (munge binding) \" = \" init \";\"))\n    (emits expr)\n    (when (= :expr context) (emits \"})()\"))))",
                                                :title "Emitting code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/compiler.clj",
                                                :lines [669 676]}),
                               :full-name "cljs.core/letfn*",
                               :full-name-encode "cljs.core/letfnSTAR",
                               :name-encode "letfnSTAR",
                               :history [["+" "0.0-1236"]]},
           "cljs.core/bit-shift-left" {:ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :name-encode "bit-shift-left",
                                       :history [["+" "0.0-927"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1752 1754]},
                                       :extra-sources [{:code "(defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [515
                                                                516]}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :name-encode "reverse",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (.. s (split \"\") (reverse) (join \"\")))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [18 21]},
                                     :full-name "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:return-type number,
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "min",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/min",
                            :source {:code "(defn ^number min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1548 1553]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [470 474]}],
                            :full-name "cljs.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :signature ["[buffer reader]"],
                                      :name-encode "escape-char",
                                      :type "function",
                                      :full-name-encode "cljs.reader/escape-char",
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (cond\n        (identical? ch \\x)\n        (->> (read-2-chars reader)\n          (validate-unicode-escape unicode-2-pattern reader ch)\n          (make-unicode-char))\n\n        (identical? ch \\u)\n        (->> (read-4-chars reader)\n          (validate-unicode-escape unicode-4-pattern reader ch)\n          (make-unicode-char))\n\n        (numeric? ch)\n        (.fromCharCode js/String ch)\n\n        :else\n        (reader-error reader \"Unexpected unicode escape \\\\\" ch )))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [199 220]},
                                      :full-name "cljs.reader/escape-char",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/INext" {:ns "cljs.core",
                              :name "INext",
                              :name-encode "INext",
                              :implementations #{"PersistentArrayMapSeq"
                                                 "EmptyList"
                                                 "ValSeq"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "ChunkedSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "RSeq"
                                                 "List"
                                                 "Cons"
                                                 "LazySeq"},
                              :history [["+" "0.0-1424"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/INext",
                              :source {:code "(defprotocol INext\n  (^clj-or-nil -next [coll]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [250 251]},
                              :methods [{:name "-next",
                                         :signature ["[coll]"],
                                         :docstring nil}],
                              :full-name "cljs.core/INext"},
           "syntax/auto-gensym" {:syntax-equiv {:edn-url nil,
                                                :clj-url nil},
                                 :ns "syntax",
                                 :name "auto-gensym",
                                 :name-encode "auto-gensym",
                                 :type "special character",
                                 :full-name-encode "syntax/auto-gensym",
                                 :full-name "syntax/auto-gensym",
                                 :history [["+" "0.0-927"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-map",
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-map",
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [280 285]},
                                   :full-name "cljs.reader/read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:return-type seq,
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :name-encode "seq",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/seq",
                            :source {:code "(defn ^seq seq\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq ^not-native coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (string? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll \"is not ISeqable\"))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [470 491]},
                            :full-name "cljs.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/defrecord*" {:ns "cljs.core",
                                   :name "defrecord*",
                                   :type "special form",
                                   :source {:code "(defmethod parse 'defrecord*\n  [_ env [_ tsym fields pmasks :as form] _]\n  (let [t (:name (resolve-var (dissoc env :locals) tsym))]\n    (swap! env/*compiler* update-in [::namespaces (-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {})\n                       :name t\n                       :type true\n                       :num-fields (count fields))]\n               (merge m\n                 {:protocols (-> tsym meta :protocols)}\n                 (source-info tsym env)))))\n    {:env env :op :defrecord* :form form :t t :fields fields :pmasks pmasks}))",
                                            :title "Parser code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/analyzer.clj",
                                            :lines [1166 1178]},
                                   :full-name "cljs.core/defrecord*",
                                   :full-name-encode "cljs.core/defrecordSTAR",
                                   :name-encode "defrecordSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/*print-newline*" {:ns "cljs.core",
                                        :name "*print-newline*",
                                        :name-encode "STARprint-newlineSTAR",
                                        :type "dynamic var",
                                        :full-name-encode "cljs.core/STARprint-newlineSTAR",
                                        :source {:code "(def ^:dynamic *print-newline* true)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [33]},
                                        :full-name "cljs.core/*print-newline*",
                                        :history [["+" "0.0-2060"]]},
           "cljs.core/long" {:ns "cljs.core",
                             :name "long",
                             :signature ["[x]"],
                             :name-encode "long",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/long",
                             :source {:code "(defn long\n  [x]\n  (fix x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1662 1665]},
                             :full-name "cljs.core/long",
                             :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.core/not-empty" {:ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :name-encode "not-empty",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2646 2648]},
                                  :full-name "cljs.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :name-encode "println",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6966 6971]},
                                :full-name "cljs.core/println",
                                :docstring "Same as print followed by (newline)"},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :name-encode "connect",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl/connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection (net/xpc-connection\n                         {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n                          :evaluate-javascript\n                          (fn [js]\n                            (net/transmit\n                             repl-connection\n                             :send-result\n                             (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n                 (constantly nil)\n                 (fn [iframe]\n                   (set! (.-display (.-style iframe))\n                         \"none\")))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/browser/repl.cljs",
                                                    :lines [90 109]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "cljs.core/bytes" {:ns "cljs.core",
                              :name "bytes",
                              :signature ["[x]"],
                              :name-encode "bytes",
                              :type "function",
                              :full-name-encode "cljs.core/bytes",
                              :source {:code "(defn bytes [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1673]},
                              :full-name "cljs.core/bytes",
                              :history [["+" "0.0-1798"]]},
           "cljs.core/unchecked-byte" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-byte",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-byte",
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-byte",
                                       :source {:code "(defn ^number unchecked-byte [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1569]},
                                       :extra-sources [{:code "(defmacro unchecked-byte [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [355]}],
                                       :full-name "cljs.core/unchecked-byte"},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :signature ["[parent child index]"],
                                            :name-encode "insert-at",
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/insert-at",
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [104 105]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :name-encode "quot",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1691 1695]},
                             :full-name "cljs.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "cljs.repl.reflect/handle-reflect-query" {:ns "cljs.repl.reflect",
                                                     :name "handle-reflect-query",
                                                     :signature ["[[param _] & _]"],
                                                     :name-encode "handle-reflect-query",
                                                     :history [["+"
                                                                "0.0-1503"]],
                                                     :type "multimethod",
                                                     :full-name-encode "cljs.repl.reflect/handle-reflect-query",
                                                     :source {:code "(defmulti handle-reflect-query (fn [[param _] & _] param))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2199",
                                                              :filename "src/clj/cljs/repl/reflect.clj",
                                                              :lines [60]},
                                                     :extra-sources ({:code "(defmethod handle-reflect-query \"var\"\n  [[_ sym] req conn opts]\n  (let [sym (read-url-string sym)]\n    (compile-and-return conn (get-meta sym))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r2199",
                                                                      :filename "src/clj/cljs/repl/reflect.clj",
                                                                      :lines [62
                                                                              65]}
                                                                     {:code "(defmethod handle-reflect-query \"macroform\"\n  [[_ mform] req conn opts]\n  (let [mform (-> mform read-url-string macroexpand)]\n    (server/send-and-close conn 200 (with-out-str (pprint/pprint mform)))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r2199",
                                                                      :filename "src/clj/cljs/repl/reflect.clj",
                                                                      :lines [67
                                                                              70]}),
                                                     :full-name "cljs.repl.reflect/handle-reflect-query"},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :name-encode "get-listener",
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/get-listener",
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [89]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:ns "cljs.core",
                               :name "filter",
                               :signature ["[pred coll]"],
                               :name-encode "filter",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/filter",
                               :source {:code "(defn filter\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3064 3081]},
                               :full-name "cljs.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "warnings/fn-var" {:ns "warnings",
                              :name "fn-var",
                              :type "warning",
                              :full-name "warnings/fn-var",
                              :full-name-encode "warnings/fn-var",
                              :name-encode "fn-var",
                              :history [["+" "0.0-1835"]]},
           "cljs.core/RSeq" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IEmptyableCollection"
                                          "ICounted"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"},
                             :ns "cljs.core",
                             :name "RSeq",
                             :signature ["[ci i meta]"],
                             :name-encode "RSeq",
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/RSeq",
                             :source {:code "(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (RSeq. ci i new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n  \n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [749 798]},
                             :full-name "cljs.core/RSeq"},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :name-encode "branchQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "cljs.core/ObjMap" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMap"
                                            "IMeta"
                                            "IWithMeta"
                                            "IKVReduce"
                                            "IEditableCollection"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "ILookup"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "IAssociative"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "ObjMap",
                               :signature ["[meta keys strobj update-count __hash]"],
                               :name-encode "ObjMap",
                               :history [["+" "0.0-927"]],
                               :type "type",
                               :full-name-encode "cljs.core/ObjMap",
                               :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj update-count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.ObjMap.EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (aget strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (> update-count cljs.core.ObjMap.HASHMAP_THRESHOLD)\n                (>= (alength keys) cljs.core.ObjMap.HASHMAP_THRESHOLD))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (aset new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (aset new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (aget strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4047 4147]},
                               :full-name "cljs.core/ObjMap"},
           "cljs.core/sequence" {:return-type seq,
                                 :ns "cljs.core",
                                 :name "sequence",
                                 :signature ["[coll]"],
                                 :name-encode "sequence",
                                 :history [["+" "0.0-2120"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/sequence",
                                 :source {:code "(defn ^seq sequence\n  [coll]\n   (if (seq? coll)\n     coll\n     (or (seq coll) ())))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1292 1298]},
                                 :full-name "cljs.core/sequence",
                                 :docstring "Coerces coll to a (possibly empty) sequence, if it is not already\none. Will not force a lazy seq. (sequence nil) yields ()"},
           "cljs.core/zipmap" {:ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :name-encode "zipmap",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6459 6469]},
                               :full-name "cljs.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :signature ["[seed hash]"],
                                     :name-encode "hash-combine",
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-combine",
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed (+ hash 0x9e3779b9\n                   (bit-shift-left seed 6)\n                   (bit-shift-right seed 2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1845 1849]},
                                     :full-name "cljs.core/hash-combine",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/reversible?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reversible?",
                                    :signature ["[coll]"],
                                    :name-encode "reversibleQMARK",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reversibleQMARK",
                                    :source {:code "(defn ^boolean reversible? [coll]\n  (satisfies? IReversible coll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2003 2004]},
                                    :full-name "cljs.core/reversible?"},
           "syntax/arg" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "arg",
                         :name-encode "arg",
                         :type "syntax",
                         :full-name-encode "syntax/arg",
                         :extra-sources ({:code "(defn- read-arg\n  [rdr pct]\n  (if-not (thread-bound? #'arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (identical? ch \\&)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read rdr true nil true)]\n         (if-not (integer? n)\n           (throw (IllegalStateException. \"Arg literal must be %, %& or %integer\"))\n           (register-arg n)))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [391 410]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [578 597]}),
                         :full-name "syntax/arg",
                         :history [["+" "0.0-1853"]]},
           "warnings/dynamic" {:ns "warnings",
                               :name "dynamic",
                               :type "warning",
                               :full-name "warnings/dynamic",
                               :full-name-encode "warnings/dynamic",
                               :name-encode "dynamic",
                               :history [["+" "0.0-1835"]]},
           "warnings/undeclared-ns-form" {:ns "warnings",
                                          :name "undeclared-ns-form",
                                          :type "warning",
                                          :full-name "warnings/undeclared-ns-form",
                                          :full-name-encode "warnings/undeclared-ns-form",
                                          :name-encode "undeclared-ns-form",
                                          :history [["+" "0.0-2014"]]},
           "clojure.core.reducers/flatten" {:ns "clojure.core.reducers",
                                            :name "flatten",
                                            :signature ["[]" "[coll]"],
                                            :name-encode "flatten",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/flatten",
                                            :source {:code "(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [130 143]},
                                            :full-name "clojure.core.reducers/flatten",
                                            :docstring "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."},
           "cljs.core/max-key" {:ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "max-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6471 6476]},
                                :full-name "cljs.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :signature ["[conn path]"],
                                         :name-encode "send-404",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/send-404",
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [92 98]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :name-encode "defrecord",
                                  :type "macro",
                                  :full-name-encode "cljs.core/defrecord",
                                  :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [rsym (vary-meta rsym assoc :internal-ctor true)\n        r    (vary-meta\n               (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n               assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [953 965]},
                                  :full-name "cljs.core/defrecord",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/ex-info" {:ns "cljs.core",
                                :name "ex-info",
                                :signature ["[msg map]"
                                            "[msg map cause]"],
                                :name-encode "ex-info",
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-info",
                                :source {:code "(defn ex-info\n  ([msg map]\n     (ExceptionInfo. msg map nil))\n  ([msg map cause]\n     (ExceptionInfo. msg map cause)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7743 7750]},
                                :full-name "cljs.core/ex-info",
                                :docstring "Alpha - subject to change.\nCreate an instance of ExceptionInfo, an Error type that carries a\nmap of additional data."},
           "closure-warnings/check-variables" {:ns "closure-warnings",
                                               :name "check-variables",
                                               :type "warning",
                                               :full-name "closure-warnings/check-variables",
                                               :full-name-encode "closure-warnings/check-variables",
                                               :name-encode "check-variables",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :name-encode "repl-env",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/repl-env",
                                         :source {:code "(defn repl-env\n  [& {:as opts}]\n  (let [compiler-env (cljs.env/default-compiler-env opts)\n        opts (merge (BrowserEnv.)\n                    {:port          9000\n                     :optimizations :simple\n                     :working-dir   \".repl\"\n                     :serve-static  true\n                     :static-dir    [\".\" \"out/\"]\n                     :preloaded-libs   []\n                     :src           \"src/\"\n                     :cljs.env/compiler compiler-env\n                     :source-map    true}\n                    opts)]\n    (cljs.env/with-compiler-env compiler-env\n      (reset! preloaded-libs (set (concat (always-preload) (map str (:preloaded-libs opts)))))\n        (reset! loaded-libs @preloaded-libs)\n        (swap! browser-state\n               (fn [old] (assoc old :client-js\n                               (future (create-client-js-file\n                                        opts\n                                        (io/file (:working-dir opts) \"client.js\"))))))\n        opts)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [225 266]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :docstring "Create a browser-connected REPL environment.\n\nOptions:\n\nport:           The port on which the REPL server will run. Defaults to 9000.\nworking-dir:    The directory where the compiled REPL client JavaScript will\n                be stored. Defaults to \".repl\".\nserve-static:   Should the REPL server attempt to serve static content?\n                Defaults to true.\nstatic-dir:     List of directories to search for static content. Defaults to\n                [\".\" \"out/\"].\npreloaded-libs: List of namespaces that should not be sent from the REPL server\n                to the browser. This may be required if the browser is already\n                loading code and reloading it would cause a problem.\noptimizations:  The level of optimization to use when compiling the client\n                end of the REPL. Defaults to :simple.\nsrc:            The source directory containing user-defined cljs files. Used to\n                support reflection. Defaults to \"src/\".\n"},
           "compiler-options/optimize-constants" {:ns "compiler-options",
                                                  :name "optimize-constants",
                                                  :name-encode "optimize-constants",
                                                  :type "option",
                                                  :full-name-encode "compiler-options/optimize-constants",
                                                  :full-name "compiler-options/optimize-constants",
                                                  :history [["+"
                                                             "0.0-1877"]]},
           "cljs.core/butlast" {:ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :name-encode "butlast",
                                :type "function",
                                :full-name-encode "cljs.core/butlast",
                                :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6444 6448]},
                                :full-name "cljs.core/butlast",
                                :history [["+" "0.0-927"]]},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :name-encode "print-str",
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6961 6964]},
                                  :full-name "cljs.core/print-str",
                                  :docstring "print to a string, returning it"},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :name-encode "hash",
                             :type "function",
                             :full-name-encode "cljs.core/hash",
                             :source {:code "(defn hash [o]\n  (cond\n    (implements? IHash o)\n    (-hash ^not-native o)\n\n    (number? o)\n    (js-mod (.floor js/Math o) 2147483647)\n\n    (true? o) 1\n\n    (false? o) 0\n\n    (string? o)\n    (check-string-hash-cache o)\n\n    (nil? o) 0\n\n    :else\n    (-hash o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1111 1129]},
                             :full-name "cljs.core/hash",
                             :history [["+" "0.0-927"]]},
           "cljs.core/bit-set" {:ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :name-encode "bit-set",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1742 1745]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [527 528]}],
                                :full-name "cljs.core/bit-set",
                                :docstring "Set bit at index n"},
           "syntax/false" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "false",
                           :name-encode "false",
                           :type "special symbol",
                           :full-name-encode "syntax/false",
                           :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  {:line line :column column\n                   :end-line (get-line-number rdr)\n                   :end-column (int (get-column-number rdr))})))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.3",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [263 285]}),
                           :full-name "syntax/false",
                           :history [["+" "0.0-1853"]]},
           "cljs.core/clj->js" {:ns "cljs.core",
                                :name "clj->js",
                                :signature ["[x]"],
                                :name-encode "clj-GTjs",
                                :history [["+" "0.0-1552"]],
                                :type "function",
                                :full-name-encode "cljs.core/clj-GTjs",
                                :source {:code "(defn clj->js\n   [x]\n   (when-not (nil? x)\n     (if (satisfies? IEncodeJS x)\n       (-clj->js x)\n       (cond\n         (keyword? x) (name x)\n         (symbol? x) (str x)\n         (map? x) (let [m (js-obj)]\n                    (doseq [[k v] x]\n                      (aset m (key->js k) (clj->js v)))\n                    m)\n         (coll? x) (let [arr (array)]\n                     (doseq [x (map clj->js x)]\n                       (.push arr x))\n                     arr)\n         :else x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7329 7348]},
                                :full-name "cljs.core/clj->js",
                                :docstring "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."},
           "repl-options/analyze-path" {:ns "repl-options",
                                        :name "analyze-path",
                                        :name-encode "analyze-path",
                                        :type "option",
                                        :full-name-encode "repl-options/analyze-path",
                                        :full-name "repl-options/analyze-path",
                                        :history [["+" "0.0-1552"]]},
           "cljs.core/concat" {:ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :name-encode "concat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2467 2490]},
                               :full-name "cljs.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.core/conj" {:ns "cljs.core",
                             :name "conj",
                             :signature ["[coll x]" "[coll x & xs]"],
                             :name-encode "conj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/conj",
                             :source {:code "(defn conj\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [837 848]},
                             :full-name "cljs.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "cljs.core/unchecked-short" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-short",
                                        :signature ["[x]"],
                                        :name-encode "unchecked-short",
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-short",
                                        :source {:code "(defn ^number unchecked-short [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1571]},
                                        :extra-sources [{:code "(defmacro unchecked-short [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [357]}],
                                        :full-name "cljs.core/unchecked-short"},
           "clojure.set/difference" {:ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :name-encode "difference",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/byte" {:return-type number,
                             :ns "cljs.core",
                             :name "byte",
                             :signature ["[x]"],
                             :name-encode "byte",
                             :history [["+" "0.0-1798"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/byte",
                             :source {:code "(defn ^number byte [x] x)",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1555]},
                             :extra-sources [{:code "(defmacro byte [x] x)",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [350]}],
                             :full-name "cljs.core/byte"},
           "cljs.core/when-first" {:ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :name-encode "when-first",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
                                            :title "Source code",
                                            :repo "clojure",
                                            :tag "clojure-1.5.1",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4154 4166]},
                                   :full-name "cljs.core/when-first",
                                   :docstring "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"},
           "cljs.reader/*tag-table*" {:ns "cljs.reader",
                                      :name "*tag-table*",
                                      :name-encode "STARtag-tableSTAR",
                                      :type "var",
                                      :full-name-encode "cljs.reader/STARtag-tableSTAR",
                                      :source {:code "(def *tag-table* (atom {\"inst\"  read-date\n                        \"uuid\"  read-uuid\n                        \"queue\" read-queue\n                        \"js\"    read-js}))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [555 558]},
                                      :full-name "cljs.reader/*tag-table*",
                                      :history [["+" "0.0-1236"]]},
           "cljs.core/distinct?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :name-encode "distinctQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/distinctQMARK",
                                  :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1274 1288]},
                                  :full-name "cljs.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "clojure.core.reducers/filter" {:ns "clojure.core.reducers",
                                           :name "filter",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :name-encode "filter",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/filter",
                                           :source {:code "(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [117 128]},
                                           :full-name "clojure.core.reducers/filter",
                                           :docstring "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.core/INamed" {:ns "cljs.core",
                               :name "INamed",
                               :name-encode "INamed",
                               :implementations #{"Symbol" "Keyword"},
                               :history [["+" "0.0-1798"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/INamed",
                               :source {:code "(defprotocol INamed\n  (^string -name [x])\n  (^string -namespace [x]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [377 379]},
                               :methods [{:name "-name",
                                          :signature ["[x]"],
                                          :docstring nil}
                                         {:name "-namespace",
                                          :signature ["[x]"],
                                          :docstring nil}],
                               :full-name "cljs.core/INamed"},
           "syntax/set" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "set",
                         :name-encode "set",
                         :type "syntax",
                         :full-name-encode "syntax/set",
                         :extra-sources ({:code "(defn- read-set\n  [rdr _]\n  (PersistentHashSet/createWithCheck (read-delimited \\} rdr true)))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [344 346]}
                                         {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [599 610]}),
                         :full-name "syntax/set",
                         :history [["+" "0.0-1853"]]},
           "cljs.core/add-to-string-hash-cache" {:ns "cljs.core",
                                                 :name "add-to-string-hash-cache",
                                                 :signature ["[k]"],
                                                 :name-encode "add-to-string-hash-cache",
                                                 :type "function",
                                                 :full-name-encode "cljs.core/add-to-string-hash-cache",
                                                 :source {:code "(defn add-to-string-hash-cache [k]\n  (let [h (goog.string/hashCode k)]\n    (aset string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [1096
                                                                  1100]},
                                                 :full-name "cljs.core/add-to-string-hash-cache",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[]"],
                                       :name-encode "repl-env",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino/repl-env",
                                       :source {:code "(defn repl-env\n  []\n  (let [cx (Context/enter)\n        scope (.initStandardObjects cx)\n        base (io/resource \"goog/base.js\")\n        deps (io/resource \"goog/deps.js\")\n        new-repl-env (merge (RhinoEnv. (atom #{})) {:cx cx :scope scope})]\n    (assert base \"Can't find goog/base.js in classpath\")\n    (assert deps \"Can't find goog/deps.js in classpath\")\n    (swap! current-repl-env (fn [old] new-repl-env))\n    (ScriptableObject/putProperty scope\n                                  \"___repl_env\"\n                                  (Context/javaToJS new-repl-env scope))\n    (with-open [r (io/reader base)]\n      (-eval r new-repl-env \"goog/base.js\" 1))\n    (-eval bootjs new-repl-env \"bootjs\" 1)\n    ;; Load deps.js line-by-line to avoid 64K method limit\n    (with-open [reader (io/reader deps)]\n      (doseq [^String line (line-seq reader)]\n        (-eval line new-repl-env \"goog/deps.js\" 1)))\n    new-repl-env))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/repl/rhino.clj",
                                                :lines [123 145]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/HashCollisionNode" {:ns "cljs.core",
                                          :name "HashCollisionNode",
                                          :signature ["[edit collision-hash cnt arr]"],
                                          :name-encode "HashCollisionNode",
                                          :type "type",
                                          :full-name-encode "cljs.core/HashCollisionNode",
                                          :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr idx) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (aset removed-leaf? 0 true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [4875 4971]},
                                          :full-name "cljs.core/HashCollisionNode",
                                          :history [["+" "0.0-1211"]]},
           "cljs.core/object?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "object?",
                                :signature ["[x]"],
                                :name-encode "objectQMARK",
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :full-name-encode "cljs.core/objectQMARK",
                                :source {:code "(defn ^boolean object? [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [98 101]},
                                :full-name "cljs.core/object?"},
           "cljs.core/pos?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :name-encode "posQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/posQMARK",
                             :source {:code "(defn ^boolean pos?\n  [n] (cljs.core/pos? n))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1788 1790]},
                             :extra-sources [{:code "(defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [458 459]}],
                             :full-name "cljs.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "compiler-options/source-map-path" {:ns "compiler-options",
                                               :name "source-map-path",
                                               :name-encode "source-map-path",
                                               :type "option",
                                               :full-name-encode "compiler-options/source-map-path",
                                               :full-name "compiler-options/source-map-path",
                                               :history [["+"
                                                          "0.0-2060"]]},
           "cljs.core/into-array" {:return-type array,
                                   :ns "cljs.core",
                                   :name "into-array",
                                   :signature ["[aseq]" "[type aseq]"],
                                   :name-encode "into-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/into-array",
                                   :source {:code "(defn ^array into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [191 195]},
                                   :full-name "cljs.core/into-array"},
           "syntax/tagged-literal" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "tagged-literal",
                                    :name-encode "tagged-literal",
                                    :type "syntax",
                                    :full-name-encode "syntax/tagged-literal",
                                    :extra-sources ({:code "(defn- read-tagged [rdr initch]\n  (let [tag (read rdr true nil false)]\n    (if-not (symbol? tag)\n      (reader-error rdr \"Reader tag must be a symbol\"))\n    (if-let [f (or (*data-readers* tag)\n                   (default-data-readers tag))]\n      (read-tagged* rdr tag f)\n      (if (.contains (name tag) \".\")\n        (read-ctor rdr tag)\n        (if-let [f *default-data-reader-fn*]\n          (f tag (read rdr true nil true))\n          (reader-error rdr \"No reader function for tag \" (name tag)))))))",
                                                     :title "Reader code",
                                                     :repo "tools.reader",
                                                     :tag "tools.reader-0.8.3",
                                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                                     :lines [649 660]}),
                                    :full-name "syntax/tagged-literal",
                                    :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentVector" {:protocols #{"IFn"
                                                      "ISeqable"
                                                      "IMeta"
                                                      "IWithMeta"
                                                      "IKVReduce"
                                                      "IReversible"
                                                      "IEditableCollection"
                                                      "IStack"
                                                      "IEmptyableCollection"
                                                      "ICounted"
                                                      "IReduce"
                                                      "ILookup"
                                                      "ISequential"
                                                      "ICollection"
                                                      "IHash"
                                                      "IComparable"
                                                      "IPrintWithWriter"
                                                      "IIndexed"
                                                      "IAssociative"
                                                      "IVector"
                                                      "IEquiv"
                                                      "ICloneable"
                                                      "IMapEntry"},
                                         :ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail __hash]"],
                                         :name-encode "PersistentVector",
                                         :history [["+" "0.0-1006"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta cljs.core.PersistentVector.EMPTY meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) cljs.core.PersistentVector.EMPTY_NODE nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentVector.EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (<= cnt 32) (IndexedSeq. tail 0)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IMapEntry\n  (-key [coll]\n    (-nth coll 0))\n  (-val [coll]\n    (-nth coll 1))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. \"Vector's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (<= 0 n) (< n cnt))\n       (if (<= (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (== n cnt) (-conj coll val)\n       :else (throw (js/Error. (str \"Index \" n \" out of bounds  [0,\" cnt \"]\")))))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f start]\n    (ci-reduce v f start))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (let [step-init (array 0 init)] ; [step 0 init init]\n      (loop [i 0]\n        (if (< i cnt)\n          (let [arr (unchecked-array-for v i)\n                len (alength arr)]\n            (let [init (loop [j 0 init (aget step-init 1)]\n                         (if (< j len)\n                           (let [init (f init (+ j i) (aget arr j))]\n                             (if (reduced? init)\n                               init\n                               (recur (inc j) init)))\n                           (do (aset step-init 0 len)\n                               (aset step-init 1 init)\n                               init)))]\n              (if (reduced? init)\n                @init\n                (recur (+ i (aget step-init 0))))))\n          (aget step-init 1)))))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (RSeq. coll (dec cnt) nil))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3328 3477]},
                                         :full-name "cljs.core/PersistentVector"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :name-encode "IHash",
                              :implementations #{"Subvec"
                                                 "Symbol"
                                                 "PersistentQueue"
                                                 "PersistentHashMap"
                                                 "PersistentTreeSet"
                                                 "PersistentArrayMapSeq"
                                                 "RedNode"
                                                 "EmptyList"
                                                 "ObjMap"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "ValSeq"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ChunkedSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "PersistentTreeMap"
                                                 "PersistentTreeMapSeq"
                                                 "RSeq"
                                                 "PersistentArrayMap"
                                                 "Keyword"
                                                 "PersistentHashSet"
                                                 "NodeSeq"
                                                 "List"
                                                 "Atom"
                                                 "MultiFn"
                                                 "Cons"
                                                 "default"
                                                 "LazySeq"
                                                 "UUID"},
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [300 301]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IHash"},
           "clojure.reflect/doc" {:ns "clojure.reflect",
                                  :name "doc",
                                  :signature ["[sym]"],
                                  :name-encode "doc",
                                  :history [["+" "0.0-1503"]],
                                  :type "function",
                                  :full-name-encode "clojure.reflect/doc",
                                  :source {:code "(defn doc\n  [sym]\n  (meta sym print-doc))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/reflect.cljs",
                                           :lines [44 48]},
                                  :full-name "clojure.reflect/doc",
                                  :docstring "Queries the reflection api with a fully qualified symbol, then prints\ndocumentation information at the repl."},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :signature ["[x]"],
                                  :name-encode "is_proto_",
                                  :type "function",
                                  :full-name-encode "cljs.core/is_proto_",
                                  :source {:code "(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [117 119]},
                                  :full-name "cljs.core/is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/shorts" {:ns "cljs.core",
                               :name "shorts",
                               :signature ["[x]"],
                               :name-encode "shorts",
                               :type "function",
                               :full-name-encode "cljs.core/shorts",
                               :source {:code "(defn shorts [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1675]},
                               :full-name "cljs.core/shorts",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/TransientVector" {:protocols #{"IFn"
                                                     "ITransientCollection"
                                                     "ICounted"
                                                     "ILookup"
                                                     "IIndexed"
                                                     "ITransientAssociative"
                                                     "ITransientVector"},
                                        :ns "cljs.core",
                                        :name "TransientVector",
                                        :signature ["[cnt shift root tail]"],
                                        :name-encode "TransientVector",
                                        :history [["+" "0.0-1211"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/TransientVector",
                                        :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. \"TransientVector's key for assoc! must be a number.\"))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [3758 3887]},
                                        :full-name "cljs.core/TransientVector"},
           "cljs.core/keep-indexed" {:ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f coll]"],
                                     :name-encode "keep-indexed",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2810 2831]},
                                     :full-name "cljs.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects."},
           "cljs.core/bit-shift-right" {:ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :name-encode "bit-shift-right",
                                        :history [["+" "0.0-927"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1756 1758]},
                                        :extra-sources [{:code "(defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [518
                                                                 519]}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "cljs.repl.server/stop" {:ns "cljs.repl.server",
                                    :name "stop",
                                    :signature ["[]"],
                                    :name-encode "stop",
                                    :type "function",
                                    :full-name-encode "cljs.repl.server/stop",
                                    :source {:code "(defn stop\n  []\n  (.close (:socket @state)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/repl/server.clj",
                                             :lines [171 173]},
                                    :full-name "cljs.repl.server/stop",
                                    :history [["+" "0.0-1503"]]},
           "cljs.core/comparator" {:ns "cljs.core",
                                   :name "comparator",
                                   :signature ["[pred]"],
                                   :name-encode "comparator",
                                   :history [["+" "0.0-1586"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/comparator",
                                   :source {:code "(defn comparator\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7777 7781]},
                                   :full-name "cljs.core/comparator",
                                   :docstring "Returns an JavaScript compatible comparator based upon pred."},
           "compiler-options/print-input-delimiter" {:ns "compiler-options",
                                                     :name "print-input-delimiter",
                                                     :name-encode "print-input-delimiter",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/print-input-delimiter",
                                                     :full-name "compiler-options/print-input-delimiter",
                                                     :history [["+"
                                                                "0.0-971"]]},
           "cljs.core/PersistentTreeSet" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IReversible"
                                                       "IEmptyableCollection"
                                                       "ISet"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ISorted"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentTreeSet",
                                          :signature ["[meta tree-map __hash]"],
                                          :name-encode "PersistentTreeSet",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeSet",
                                          :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeSet. meta tree-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentTreeSet.EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-iset __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6301 6372]},
                                          :full-name "cljs.core/PersistentTreeSet"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-right",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :name-encode "make-hierarchy",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [7443 7445]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :name-encode "repeat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3003 3006]},
                               :full-name "cljs.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/destructure-map" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "destructure-map",
                                     :name-encode "destructure-map",
                                     :type "binding",
                                     :full-name-encode "syntax/destructure-map",
                                     :source {:code "(defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n         pb (fn pb [bvec b v]\n              (core/let [pvec\n                     (fn [bvec b val]\n                       (core/let [gvec (gensym \"vec__\")]\n                         (core/loop [ret (-> bvec (conj gvec) (conj val))\n                                     n 0\n                                     bs b\n                                     seen-rest? false]\n                           (if (seq bs)\n                             (core/let [firstb (first bs)]\n                               (core/cond\n                                 (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                      n\n                                                      (nnext bs)\n                                                      true)\n                                 (= firstb :as) (pb ret (second bs) gvec)\n                                 :else (if seen-rest?\n                                         (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                         (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                (core/inc n)\n                                                (next bs)\n                                                seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (core/let [gmap (gensym \"map__\")\n                                  defaults (:or b)]\n                         (core/loop [ret (-> bvec (conj gmap) (conj v)\n                                             (conj gmap) (conj `(if (seq? ~gmap) (apply core/hash-map ~gmap) ~gmap))\n                                             ((fn [ret]\n                                                (if (:as b)\n                                                  (conj ret (:as b) gmap)\n                                                  ret))))\n                                     bes (reduce\n                                          (fn [bes entry]\n                                            (reduce #(assoc %1 %2 ((val entry) %2))\n                                                    (dissoc bes (key entry))\n                                                    ((key entry) bes)))\n                                          (dissoc b :as :or)\n                                          {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                           :strs core/str, :syms #(core/list `quote %)})]\n                           (if (seq bes)\n                             (core/let [bb (key (first bes))\n                                        bk (val (first bes))\n                                        has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (core/list `get gmap bk (defaults bb))\n                                                   (core/list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                    (core/cond\n                      (core/symbol? b) (-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw (new Exception (core/str \"Unsupported binding form: \" b))))))\n         process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n        (if (every? core/symbol? (map first bents))\n          bindings\n          (if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n            (throw (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs))))\n            (reduce process-entry [] bents)))))",
                                              :title "Parser code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [77 140]},
                                     :full-name "syntax/destructure-map",
                                     :history [["+" "0.0-927"]]},
           "syntax/syntax-quote" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :name-encode "syntax-quote",
                                  :type "syntax",
                                  :full-name-encode "syntax/syntax-quote",
                                  :extra-sources ({:code "(defn- read-syntax-quote\n  [rdr backquote]\n  (binding [gensym-env {}]\n    (-> (read rdr true nil true)\n      syntax-quote*)))",
                                                   :title "Reader code",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-0.8.3",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [572 576]}
                                                  {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                   :title "Reader table",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-0.8.3",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [578 597]}),
                                  :full-name "syntax/syntax-quote",
                                  :history [["+" "0.0-1853"]]},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :signature ["[repl-env rule]"],
                                           :name-encode "goog-require",
                                           :type "function",
                                           :full-name-encode "cljs.repl.rhino/goog-require",
                                           :source {:code "(defn goog-require [repl-env rule]\n  (when-not (contains? @(:loaded-libs repl-env) rule)\n    (let [repl-env @current-repl-env\n          path (string/replace (comp/munge rule) \\. java.io.File/separatorChar)\n          cljs-path (str path \".cljs\")\n          js-path (str \"goog/\"\n                       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                              repl-env\n                              \"<cljs repl>\"\n                              1))]\n      (if-let [res (io/resource cljs-path)]\n        (binding [ana/*cljs-ns* 'cljs.user]\n          (repl/load-stream repl-env cljs-path res))\n        (if-let [res (io/resource js-path)]\n          (with-open [reader (io/reader res)]\n            (-eval reader repl-env js-path 1))\n          (throw (Exception. (str \"Cannot find \" cljs-path \" or \" js-path \" in classpath\")))))\n      (swap! (:loaded-libs repl-env) conj rule))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [67 84]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :name-encode "prn-str-with-opts",
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6916 6923]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:protocols #{"IFn" "IMultiFn" "IHash"},
                                :ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :name-encode "MultiFn",
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n\n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n\n  (-dispatch [mf args] (do-dispatch mf name dispatch-fn args))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7627 7676]},
                                :full-name "cljs.core/MultiFn"},
           "cljs.core/Reduced" {:protocols #{"IDeref"},
                                :ns "cljs.core",
                                :name "Reduced",
                                :signature ["[val]"],
                                :name-encode "Reduced",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/Reduced",
                                :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [584 586]},
                                :full-name "cljs.core/Reduced"},
           "cljs.core/not-any?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :name-encode "not-anyQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/not-anyQMARK",
                                 :source {:code "(defn ^boolean not-any?\n  [pred coll] (not (some pred coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2673 2676]},
                                 :full-name "cljs.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :signature ["[rdr ch]"],
                                     :name-encode "read-regex",
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-regex",
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-string* rdr ch) re-pattern))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [373 375]},
                                     :full-name "cljs.reader/read-regex",
                                     :history [["+" "0.0-927"]]},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :name-encode "next",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "syntax/dispatch" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "dispatch",
                              :name-encode "dispatch",
                              :type "syntax",
                              :full-name-encode "syntax/dispatch",
                              :extra-sources ({:code "(defn- read-dispatch\n  [rdr _]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch)\n      (if-let [obj (read-tagged (doto rdr (unread ch)) ch)] ;; ctor reader is implemented as a taggged literal\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))\n    (reader-error rdr \"EOF while reading character\")))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.3",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [53 61]}
                                              {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.3",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [578 597]}),
                              :full-name "syntax/dispatch",
                              :history [["+" "0.0-1853"]]},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :name-encode "IFn",
                            :implementations #{"Subvec"
                                               "Symbol"
                                               "PersistentHashMap"
                                               "PersistentTreeSet"
                                               "RedNode"
                                               "ObjMap"
                                               "BlackNode"
                                               "PersistentVector"
                                               "TransientVector"
                                               "PersistentTreeMap"
                                               "PersistentArrayMap"
                                               "Keyword"
                                               "PersistentHashSet"
                                               "MultiFn"
                                               "TransientHashSet"},
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core/IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q s]\n    [this a b c d e f g h i j k l m n o p q s t]\n    [this a b c d e f g h i j k l m n o p q s t rest]))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [202 224]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q s]"
                                                   "[this a b c d e f g h i j k l m n o p q s t]"
                                                   "[this a b c d e f g h i j k l m n o p q s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn"},
           "cljs.core/aget" {:ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"
                                         "[array i & idxs]"],
                             :name-encode "aget",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aget",
                             :source {:code "(defn aget\n  ([array i]\n     (cljs.core/aget array i))\n  ([array i & idxs]\n     (apply aget (aget array i) idxs)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [170 175]},
                             :extra-sources [{:code "(defmacro aget\n  ([a i]\n     (core/list 'js* \"(~{}[~{}])\" a i))\n  ([a i & idxs]\n     (let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~a ~i ~@idxs))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [329 334]}],
                             :full-name "cljs.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:ns "cljs.core",
                               :name "if-let",
                               :signature ["[bindings then]"
                                           "[bindings then else & oldform]"],
                               :name-encode "if-let",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.5.1",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1684 1702]},
                               :full-name "cljs.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:return-type number,
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "SLASH",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/SLASH",
                          :source {:code "(defn ^number /\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1482 1487]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [414 417]}],
                          :full-name "cljs.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/unchecked-int" {:ns "cljs.core",
                                      :name "unchecked-int",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-int",
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/unchecked-int",
                                      :source {:code "(defn unchecked-int\n  [x]\n  (fix x))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1657 1660]},
                                      :full-name "cljs.core/unchecked-int",
                                      :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl.server/read-get" {:ns "cljs.repl.server",
                                        :name "read-get",
                                        :signature ["[line rdr]"],
                                        :name-encode "read-get",
                                        :type "function",
                                        :full-name-encode "cljs.repl.server/read-get",
                                        :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [88 93]},
                                        :full-name "cljs.repl.server/read-get",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/min-key" {:ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "min-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6478 6483]},
                                :full-name "cljs.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "compiler-options/closure-defines" {:ns "compiler-options",
                                               :name "closure-defines",
                                               :name-encode "closure-defines",
                                               :type "option",
                                               :full-name-encode "compiler-options/closure-defines",
                                               :full-name "compiler-options/closure-defines",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :name-encode "root",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred coll]"],
                                   :name-encode "drop-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/drop-while",
                                   :source {:code "(defn drop-while\n  [pred coll]\n  (let [step (fn [pred coll]\n               (let [s (seq coll)]\n                 (if (and s (pred (first s)))\n                   (recur pred (rest s))\n                   s)))]\n    (lazy-seq (step pred coll))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2981 2990]},
                                   :full-name "cljs.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the first\nitem for which (pred item) returns nil."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :signature ["[request conn opts]"],
                                                      :name-encode "send-repl-client-page",
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/send-repl-client-page",
                                                      :source {:code "(defn send-repl-client-page\n  [request conn opts]\n  (server/send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r2199",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [51
                                                                       62]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :name-encode "evaluate-javascript",
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl/evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch :default e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r2199",
                                                                :filename "src/cljs/clojure/browser/repl.cljs",
                                                                :lines [27
                                                                        36]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "closure-warnings/visiblity" {:ns "closure-warnings",
                                         :name "visiblity",
                                         :type "warning",
                                         :full-name "closure-warnings/visiblity",
                                         :full-name-encode "closure-warnings/visiblity",
                                         :name-encode "visiblity",
                                         :history [["+" "0.0-2120"]]},
           "cljs.core/set-validator!" {:ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[iref val]"],
                                       :name-encode "set-validatorBANG",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [7203 7211]},
                                       :full-name "cljs.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "syntax/queue-literal" {:syntax-equiv {:edn-url nil,
                                                  :clj-url nil},
                                   :ns "syntax",
                                   :name "queue-literal",
                                   :name-encode "queue-literal",
                                   :type "tagged literal",
                                   :full-name-encode "syntax/queue-literal",
                                   :extra-sources ({:code "(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw (RuntimeException. \"Queue literal expects a vector for its elements.\")))\n  (list 'cljs.core/into 'cljs.core.PersistentQueue.EMPTY form))",
                                                    :title "Reader code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/tagged_literals.clj",
                                                    :lines [4 8]}
                                                   {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                    :title "Reader table",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/tagged_literals.clj",
                                                    :lines [44 48]}),
                                   :full-name "syntax/queue-literal",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/<" {:return-type boolean,
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "LT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/LT",
                          :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2199",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1489 1499]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [424 427]}],
                          :full-name "cljs.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.core/catch" {:ns "cljs.core",
                              :name "catch",
                              :type "special form",
                              :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [489 548]},
                              :extra-sources ({:code "(defmethod emit* :try\n  [{:keys [env try catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :constant (:op finally)) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [614 629]}),
                              :full-name "cljs.core/catch",
                              :full-name-encode "cljs.core/catch",
                              :name-encode "catch",
                              :history [["+" "0.0-927"]]},
           "syntax/shebang" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "shebang",
                             :name-encode "shebang",
                             :type "syntax",
                             :full-name-encode "syntax/shebang",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [120 122]}
                                             {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [599 610]}),
                             :full-name "syntax/shebang",
                             :history [["+" "0.0-1853"]]},
           "cljs.repl.reflect/read-url-string" {:ns "cljs.repl.reflect",
                                                :name "read-url-string",
                                                :name-encode "read-url-string",
                                                :type "var",
                                                :full-name-encode "cljs.repl.reflect/read-url-string",
                                                :source {:code "(def read-url-string (comp read-string url-decode))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/clj/cljs/repl/reflect.clj",
                                                         :lines [42]},
                                                :full-name "cljs.repl.reflect/read-url-string",
                                                :history [["+"
                                                           "0.0-1503"]]},
           "cljs.core/deftype*" {:ns "cljs.core",
                                 :name "deftype*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'deftype*\n  [_ env [_ tsym fields pmasks :as form] _]\n  (let [t (:name (resolve-var (dissoc env :locals) tsym))]\n    (swap! env/*compiler* update-in [::namespaces (-> env :ns :name) :defs tsym]\n           (fn [m]\n             (let [m (assoc (or m {})\n                       :name t\n                       :type true\n                       :num-fields (count fields))]\n               (merge m\n                 {:protocols (-> tsym meta :protocols)}\n                 (source-info tsym env)))))\n    {:env env :op :deftype* :form form :t t :fields fields :pmasks pmasks}))",
                                          :title "Parser code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/clj/cljs/analyzer.clj",
                                          :lines [1152 1164]},
                                 :full-name "cljs.core/deftype*",
                                 :full-name-encode "cljs.core/deftypeSTAR",
                                 :name-encode "deftypeSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/fn" {:ns "cljs.core",
                           :name "fn",
                           :signature ["[& sigs]"],
                           :name-encode "fn",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.5.1",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [4067 4127]},
                           :full-name "cljs.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :name-encode "split-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6631 6634]},
                                   :full-name "cljs.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "closure-warnings/internet-explorer-checks" {:ns "closure-warnings",
                                                        :name "internet-explorer-checks",
                                                        :type "warning",
                                                        :full-name "closure-warnings/internet-explorer-checks",
                                                        :full-name-encode "closure-warnings/internet-explorer-checks",
                                                        :name-encode "internet-explorer-checks",
                                                        :history [["+"
                                                                   "0.0-2120"]]},
           "cljs.core/IWriter" {:ns "cljs.core",
                                :name "IWriter",
                                :name-encode "IWriter",
                                :implementations #{"StringBufferWriter"},
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IWriter",
                                :source {:code "(defprotocol IWriter\n  (-write [writer s])\n  (-flush [writer]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [324 326]},
                                :methods [{:name "-write",
                                           :signature ["[writer s]"],
                                           :docstring nil}
                                          {:name "-flush",
                                           :signature ["[writer]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IWriter"},
           "cljs.repl.browser/preloaded-libs" {:ns "cljs.repl.browser",
                                               :name "preloaded-libs",
                                               :name-encode "preloaded-libs",
                                               :type "var",
                                               :full-name-encode "cljs.repl.browser/preloaded-libs",
                                               :source {:code "(def preloaded-libs (atom #{}))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [24]},
                                               :full-name "cljs.repl.browser/preloaded-libs",
                                               :history [["+"
                                                          "0.0-1424"]]},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :name-encode "IReduce",
                                :implementations #{"Subvec"
                                                   "PersistentArrayMapSeq"
                                                   "RedNode"
                                                   "EmptyList"
                                                   "ArrayChunk"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "ValSeq"
                                                   "Range"
                                                   "ChunkedSeq"
                                                   "ArrayNodeSeq"
                                                   "KeySeq"
                                                   "IndexedSeq"
                                                   "PersistentTreeMapSeq"
                                                   "RSeq"
                                                   "NodeSeq"
                                                   "List"
                                                   "Cons"
                                                   "LazySeq"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [291 292]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IReduce"},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :name-encode "symbol-pattern",
                                         :type "var",
                                         :full-name-encode "cljs.reader/symbol-pattern",
                                         :source {:code "(def symbol-pattern (re-pattern \"[:]?([^0-9/].*/)?([^0-9/][^/]*)\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [100]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashSet.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashSet.fromArray",
                                                    :signature ["[items no-clone]"],
                                                    :name-encode "PersistentHashSetDOTfromArray",
                                                    :history [["+"
                                                               "0.0-1443"]],
                                                    :parent-type "PersistentHashSet",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashSetDOTfromArray",
                                                    :source {:code "(set! cljs.core.PersistentHashSet.fromArray\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (<= len cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD)\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient cljs.core.PersistentArrayMap.EMPTY)]\n            (if (< i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (cljs.core.PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient cljs.core.PersistentHashSet.EMPTY)]\n         (if (< i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [6248
                                                                     6262]},
                                                    :full-name "cljs.core/PersistentHashSet.fromArray"},
           "cljs.core/repeatedly" {:ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :name-encode "repeatedly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3012 3017]},
                                   :full-name "cljs.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :signature ["[delim rdr recursive?]"],
                                              :name-encode "read-delimited-list",
                                              :type "function",
                                              :full-name-encode "cljs.reader/read-delimited-list",
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a (transient [])]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF while reading\"))\n      (if (identical? delim ch)\n        (persistent! a)\n        (if-let [macrofn (macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (identical? mret rdr) a (conj! a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (identical? o rdr) a (conj! a o))))))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [231
                                                               244]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/undefined?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :name-encode "undefinedQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/undefinedQMARK",
                                   :source {:code "(defn ^boolean undefined? [x]\n  (cljs.core/undefined? x))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1226 1227]},
                                   :extra-sources [{:code "(defmacro undefined? [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [305 306]}],
                                   :full-name "cljs.core/undefined?"},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :name-encode "prev",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "seq?",
                             :signature ["[s]"],
                             :name-encode "seqQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/seqQMARK",
                             :source {:code "(defn ^boolean seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1229 1234]},
                             :full-name "cljs.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.repl.browser/browser-state" {:ns "cljs.repl.browser",
                                              :name "browser-state",
                                              :name-encode "browser-state",
                                              :type "var",
                                              :full-name-encode "cljs.repl.browser/browser-state",
                                              :source {:code "(defonce browser-state (atom {:return-value-fn nil\n                              :client-js nil}))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [20 21]},
                                              :full-name "cljs.repl.browser/browser-state",
                                              :history [["+"
                                                         "0.0-1503"]]},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :name-encode "prn-str",
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core/prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6941 6944]},
                                :full-name "cljs.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/chunk-buffer" {:ns "cljs.core",
                                     :name "chunk-buffer",
                                     :signature ["[capacity]"],
                                     :name-encode "chunk-buffer",
                                     :type "function",
                                     :full-name-encode "cljs.core/chunk-buffer",
                                     :source {:code "(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2231 2232]},
                                     :full-name "cljs.core/chunk-buffer",
                                     :history [["+" "0.0-1424"]]},
           "cljs.core/odd?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :name-encode "oddQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/oddQMARK",
                             :source {:code "(defn ^boolean odd?\n  [n] (not (even? n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2684 2686]},
                             :full-name "cljs.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :name-encode "cons",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/cons",
                             :source {:code "(defn cons\n  [x coll]\n  (if (or (nil? coll)\n          (implements? ISeq coll))\n    (Cons. nil x coll nil)\n    (Cons. nil x (seq coll) nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2076 2082]},
                             :full-name "cljs.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "syntax/function" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "function",
                              :name-encode "function",
                              :type "syntax",
                              :full-name-encode "syntax/function",
                              :extra-sources ({:code "(defn- read-fn\n  [rdr _]\n  (if (thread-bound? #'arg-env)\n    (throw (IllegalStateException. \"Nested #()s are not allowed\")))\n  (binding [arg-env (sorted-map)]\n    (let [form (read (doto rdr (unread \\()) true nil true) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (key (first rargs))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (> i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args '& (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list 'fn* args form))))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.3",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [359 378]}
                                              {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.3",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [599 610]}),
                              :full-name "syntax/function",
                              :history [["+" "0.0-1853"]]},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-set",
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-set",
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [369 371]},
                                   :full-name "cljs.reader/read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :name-encode "descendants",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7493 7500]},
                                    :full-name "cljs.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
           "syntax/nil" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "nil",
                         :name-encode "nil",
                         :type "special symbol",
                         :full-name-encode "syntax/nil",
                         :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  {:line line :column column\n                   :end-line (get-line-number rdr)\n                   :end-column (int (get-column-number rdr))})))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [263 285]}),
                         :full-name "syntax/nil",
                         :history [["+" "0.0-1853"]]},
           "syntax/map" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "map",
                         :name-encode "map",
                         :type "syntax",
                         :full-name-encode "syntax/map",
                         :extra-sources ({:code "(defn- read-map\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-map (read-delimited \\} rdr true)\n        map-count (count the-map)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when (odd? map-count)\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (with-meta\n      (if (zero? map-count)\n        {}\n        (RT/map (to-array the-map)))\n      (when start-line\n        {:line start-line\n         :column start-column\n         :end-line end-line\n         :end-column end-column}))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [196 214]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [578 597]}),
                         :full-name "syntax/map",
                         :history [["+" "0.0-1853"]]},
           "cljs.core/take-nth" {:ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n coll]"],
                                 :name-encode "take-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/take-nth",
                                 :source {:code "(defn take-nth\n  [n coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (cons (first s) (take-nth n (drop n s))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6624 6629]},
                                 :full-name "cljs.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :signature ["[msg]"],
                                          :name-encode "throwing-reader",
                                          :type "function",
                                          :full-name-encode "cljs.reader/throwing-reader",
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [354 357]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.browser/send-static" {:ns "cljs.repl.browser",
                                            :name "send-static",
                                            :signature ["[{path :path, :as request} conn opts]"],
                                            :name-encode "send-static",
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/send-static",
                                            :source {:code "(defn send-static [{path :path :as request} conn opts]\n  (if (and (:static-dir opts)\n           (not= \"/favicon.ico\" path))\n    (let [path   (if (= \"/\" path) \"/index.html\" path)\n          st-dir (:static-dir opts)\n          local-path (cond->\n                       (seq (for [x (if (string? st-dir) [st-dir] st-dir)\n                                  :when (.exists (io/file (str x path)))]\n                              (str x path)))\n                       (complement nil?) first)\n          local-path (if (nil? local-path)\n                       (cond\n                         (re-find #\".jar\" path)\n                         (io/resource (second (string/split path #\".jar!/\")))\n                         (re-find (Pattern/compile (System/getProperty \"user.dir\")) path)\n                         (io/file (string/replace path (str (System/getProperty \"user.dir\") \"/\") \"\"))\n                         :else nil)\n                       local-path)]\n      (if local-path\n        (server/send-and-close conn 200 (slurp local-path)\n          (condp #(.endsWith %2 %1) path\n            \".html\" \"text/html\"\n            \".css\" \"text/css\"\n            \".html\" \"text/html\"\n            \".jpg\" \"image/jpeg\"\n            \".js\" \"text/javascript\"\n            \".cljs\" \"text/x-clojure\"\n            \".map\" \"application/json\"\n            \".png\" \"image/png\"\n            \"text/plain\"))\n        (server/send-404 conn path)))\n    (server/send-404 conn path)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [64 95]},
                                            :full-name "cljs.repl.browser/send-static",
                                            :history [["+" "0.0-1211"]]},
           "cljs.core/double" {:return-type number,
                               :ns "cljs.core",
                               :name "double",
                               :signature ["[x]"],
                               :name-encode "double",
                               :history [["+" "0.0-1798"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/double",
                               :source {:code "(defn ^number double [x] x)",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1567]},
                               :extra-sources [{:code "(defmacro double [x] x)",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [353]}],
                               :full-name "cljs.core/double"},
           "cljs.core/even?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :name-encode "evenQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/evenQMARK",
                              :source {:code "(defn ^boolean even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2678 2682]},
                              :full-name "cljs.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "compiler-options/foreign-libs" {:ns "compiler-options",
                                            :name "foreign-libs",
                                            :name-encode "foreign-libs",
                                            :type "option",
                                            :full-name-encode "compiler-options/foreign-libs",
                                            :full-name "compiler-options/foreign-libs",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/simple-benchmark" {:ns "cljs.core",
                                         :name "simple-benchmark",
                                         :signature ["[bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]"],
                                         :name-encode "simple-benchmark",
                                         :history [["+" "0.0-1236"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core/simple-benchmark",
                                         :source {:code "(defmacro simple-benchmark\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (let [bs-str   (pr-str bindings)\n        expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                         ~iterations \" runs, \" elapsed# \" msecs\"))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1527 1543]},
                                         :full-name "cljs.core/simple-benchmark",
                                         :docstring "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case."},
           "syntax/number" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "number",
                            :name-encode "number",
                            :type "syntax",
                            :full-name-encode "syntax/number",
                            :extra-sources ({:code "(defn- read-number\n  [reader initch]\n  (loop [sb (doto (StringBuilder.) (.append initch))\n         ch (read-char reader)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread reader ch)\n        (or (match-number s)\n            (reader-error reader \"Invalid number format [\" s \"]\")))\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [216 225]}),
                            :full-name "syntax/number",
                            :history [["+" "0.0-1853"]]},
           "cljs.core/persistent-array-map-seq" {:ns "cljs.core",
                                                 :name "persistent-array-map-seq",
                                                 :signature ["[arr i _meta]"],
                                                 :name-encode "persistent-array-map-seq",
                                                 :type "function",
                                                 :full-name-encode "cljs.core/persistent-array-map-seq",
                                                 :source {:code "(defn persistent-array-map-seq [arr i _meta]\n  (when (<= i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [4283
                                                                  4285]},
                                                 :full-name "cljs.core/persistent-array-map-seq",
                                                 :history [["+"
                                                            "0.0-1820"]]},
           "clojure.set/subset?" {:ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[set1 set2]"],
                                  :name-encode "subsetQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [132 136]},
                                  :full-name "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :name-encode "flush",
                              :type "function",
                              :full-name-encode "cljs.core/flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6802 6803]},
                              :full-name "cljs.core/flush",
                              :history [["+" "0.0-927"]]},
           "cljs.core/long-array" {:ns "cljs.core",
                                   :name "long-array",
                                   :signature ["[size-or-seq]"
                                               "[size init-val-or-seq]"],
                                   :name-encode "long-array",
                                   :type "function",
                                   :full-name-encode "cljs.core/long-array",
                                   :source {:code "(defn long-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2391 2409]},
                                   :full-name "cljs.core/long-array",
                                   :history [["+" "0.0-1211"]]},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :signature ["[rdr & msg]"],
                                       :name-encode "reader-error",
                                       :type "function",
                                       :full-name-encode "cljs.reader/reader-error",
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (js/Error. (apply str msg))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [68 70]},
                                       :full-name "cljs.reader/reader-error",
                                       :history [["+" "0.0-927"]]},
           "compiler-options/externs" {:ns "compiler-options",
                                       :name "externs",
                                       :name-encode "externs",
                                       :type "option",
                                       :full-name-encode "compiler-options/externs",
                                       :full-name "compiler-options/externs",
                                       :history [["+" "0.0-971"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :name-encode "prewalk-replace",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [80 86]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.core/*1" {:ns "cljs.core",
                           :name "*1",
                           :name-encode "STAR1",
                           :type "var",
                           :full-name-encode "cljs.core/STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [57 59]},
                           :full-name "cljs.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.core/subseq" {:ns "cljs.core",
                               :name "subseq",
                               :signature ["[sc test key]"
                                           "[sc start-test start-key end-test end-key]"],
                               :name-encode "subseq",
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :full-name-encode "cljs.core/subseq",
                               :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6510 6523]},
                               :full-name "cljs.core/subseq",
                               :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :name-encode "SetDOTEMPTY",
                                  :history [["+" "0.0-927"]
                                            ["-" "0.0-1211"]],
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core/SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :removed {:in "0.0-1211",
                                            :last-seen "0.0-1011"}},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :signature ["[reader initch]"],
                                            :name-encode "read-unicode-char",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1424"]],
                                            :type "function",
                                            :full-name-encode "cljs.reader/read-unicode-char",
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1236",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [171 173]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :removed {:in "0.0-1424",
                                                      :last-seen "0.0-1236"}},
           "cljs.core/dissoc" {:ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :name-encode "dissoc",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1024 1036]},
                               :full-name "cljs.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.core/exists?" {:ns "cljs.core",
                                :name "exists?",
                                :signature ["[x]"],
                                :name-encode "existsQMARK",
                                :type "macro",
                                :full-name-encode "cljs.core/existsQMARK",
                                :source {:code "(defmacro exists? [x]\n  (bool-expr\n    (core/list 'js* \"typeof ~{} !== 'undefined'\"\n      (vary-meta x assoc :cljs.analyzer/no-resolve true))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [300 303]},
                                :full-name "cljs.core/exists?",
                                :history [["+" "0.0-1798"]]},
           "cljs.core/ffirst" {:ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :name-encode "ffirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [805 808]},
                               :full-name "cljs.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :name-encode "replace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :name-encode "vec",
                            :type "function",
                            :full-name-encode "cljs.core/vec",
                            :source {:code "(defn vec [coll]\n  (-persistent!\n   (reduce -conj!\n           (-as-transient cljs.core.PersistentVector.EMPTY)\n           coll)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [3497 3501]},
                            :full-name "cljs.core/vec",
                            :history [["+" "0.0-927"]]},
           "cljs.core/or" {:ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :name-encode "or",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/or",
                           :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n    (let [forms (concat [x] next)]\n      (if (every? #(simple-test-expr? &env %)\n            (map #(cljs.analyzer/analyze &env %) forms))\n        (let [or-str (->> (repeat (count forms) \"(~{})\")\n                        (interpose \" || \")\n                        (apply core/str))]\n          (bool-expr `(~'js* ~or-str ~@forms)))\n        `(let [or# ~x]\n           (if or# or# (or ~@next)))))))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/clj/cljs/core.clj",
                                    :lines [235 251]},
                           :full-name "cljs.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/doubles" {:ns "cljs.core",
                                :name "doubles",
                                :signature ["[x]"],
                                :name-encode "doubles",
                                :type "function",
                                :full-name-encode "cljs.core/doubles",
                                :source {:code "(defn doubles [x] x)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1678]},
                                :full-name "cljs.core/doubles",
                                :history [["+" "0.0-1798"]]},
           "cljs.core/mod" {:ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :name-encode "mod",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/mod",
                            :source {:code "(defn mod\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1686 1689]},
                            :full-name "cljs.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"
                                         "[array idx idx2 & idxv]"],
                             :name-encode "aset",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aset",
                             :source {:code "(defn aset\n  ([array i val]\n    (cljs.core/aset array i val))\n  ([array idx idx2 & idxv]\n    (apply aset (aget array idx) idx2 idxv)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [177 182]},
                             :extra-sources [{:code "(defmacro aset\n  ([a i v]\n    (core/list 'js* \"(~{}[~{}] = ~{})\" a i v))\n  ([a idx idx2 & idxv]\n    (let [n    (core/dec (count idxv))\n          astr (apply core/str (repeat n \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~a ~idx ~idx2 ~@idxv))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [336 342]}],
                             :full-name "cljs.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.core/second" {:ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :name-encode "second",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [800 803]},
                               :full-name "cljs.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/IChunkedNext" {:ns "cljs.core",
                                     :name "IChunkedNext",
                                     :name-encode "IChunkedNext",
                                     :implementations #{"ChunkedCons"
                                                        "ChunkedSeq"},
                                     :history [["+" "0.0-1424"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IChunkedNext",
                                     :source {:code "(defprotocol IChunkedNext\n  (-chunked-next [coll]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [374 375]},
                                     :methods [{:name "-chunked-next",
                                                :signature ["[coll]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IChunkedNext"},
           "closure-warnings/global-this" {:ns "closure-warnings",
                                           :name "global-this",
                                           :type "warning",
                                           :full-name "closure-warnings/global-this",
                                           :full-name-encode "closure-warnings/global-this",
                                           :name-encode "global-this",
                                           :history [["+" "0.0-2120"]]},
           "cljs.core/set!" {:ns "cljs.core",
                             :name "set!",
                             :type "special form",
                             :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n     (let [enve (assoc env :context :expr)\n           targetexpr (cond\n                       ;; TODO: proper resolve\n                       (= target '*unchecked-if*)\n                       (do\n                         (reset! *unchecked-if* val)\n                         ::set-unchecked-if)\n\n                       (symbol? target)\n                       (do\n                         (let [local (-> env :locals target)]\n                           (when-not (or (nil? local)\n                                         (and (:field local)\n                                              (or (:mutable local)\n                                                  (:unsynchronized-mutable local)\n                                                  (:volatile-mutable local))))\n                             (throw (error env \"Can't set! local var or non-mutable field\"))))\n                         (analyze-symbol enve target))\n\n                       :else\n                       (when (seq? target)\n                         (let [targetexpr (analyze-seq enve target nil)]\n                           (when (:field targetexpr)\n                             targetexpr))))\n           valexpr (analyze enve val)]\n       (when-not targetexpr \n         (throw (error env \"set! target must be a field or a symbol naming a var\")))\n       (cond\n        (= targetexpr ::set-unchecked-if) {:env env :op :no-op}\n        :else {:env env :op :set! :form form :target targetexpr :val valexpr\n               :children [targetexpr valexpr]})))))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [904 941]},
                             :extra-sources ({:code "(defmethod emit* :set!\n  [{:keys [target val env]}]\n  (emit-wrap env (emits target \" = \" val)))",
                                              :title "Emitting code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/compiler.clj",
                                              :lines [771 773]}),
                             :full-name "cljs.core/set!",
                             :full-name-encode "cljs.core/setBANG",
                             :name-encode "setBANG",
                             :history [["+" "0.0-927"]]},
           "cljs.core/bit-count" {:ns "cljs.core",
                                  :name "bit-count",
                                  :signature ["[v]"],
                                  :name-encode "bit-count",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/bit-count",
                                  :source {:code "(defn bit-count\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1768 1773]},
                                  :full-name "cljs.core/bit-count",
                                  :docstring "Counts the number of bits set in n"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :name-encode "rename",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [83 86]},
                                 :full-name "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/assoc!" {:ns "cljs.core",
                               :name "assoc!",
                               :signature ["[tcoll key val]"
                                           "[tcoll key val & kvs]"],
                               :name-encode "assocBANG",
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :full-name-encode "cljs.core/assocBANG",
                               :source {:code "(defn assoc!\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val & kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2528 2538]},
                               :full-name "cljs.core/assoc!",
                               :docstring "When applied to a transient map, adds mapping of key(s) to\nval(s). When applied to a transient vector, sets the val at index.\nNote - index must be <= (count vector). Returns coll."},
           "cljs.core/delay?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :name-encode "delayQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/delayQMARK",
                               :source {:code "(defn ^boolean delay?\n  [x] (instance? cljs.core.Delay x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7296 7298]},
                               :full-name "cljs.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :name-encode "left",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :signature ["[rdr ch]"],
                                          :name-encode "not-implemented",
                                          :type "function",
                                          :full-name-encode "cljs.reader/not-implemented",
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [250 252]},
                                          :full-name "cljs.reader/not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :name-encode "IAssociative",
                                     :implementations #{"Subvec"
                                                        "PersistentHashMap"
                                                        "RedNode"
                                                        "ObjMap"
                                                        "BlackNode"
                                                        "PersistentVector"
                                                        "PersistentTreeMap"
                                                        "PersistentArrayMap"},
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (^boolean -contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [256 259]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring nil}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IAssociative"},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :name-encode "ObjMapDOTEMPTY",
                                     :parent-type "ObjMap",
                                     :type "var",
                                     :full-name-encode "cljs.core/ObjMapDOTEMPTY",
                                     :source {:code "(set! cljs.core.ObjMap.EMPTY (ObjMap. nil (array) (js-obj) 0 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [4149]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :history [["+" "0.0-927"]]},
           "closure-warnings/deprecated" {:ns "closure-warnings",
                                          :name "deprecated",
                                          :type "warning",
                                          :full-name "closure-warnings/deprecated",
                                          :full-name-encode "closure-warnings/deprecated",
                                          :name-encode "deprecated",
                                          :history [["+" "0.0-2120"]]},
           "cljs.core/group-by" {:ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :name-encode "group-by",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (reduce\n   (fn [ret x]\n     (let [k (f x)]\n       (assoc ret k (conj (get ret k []) x))))\n   {} coll))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7432 7441]},
                                 :full-name "cljs.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "compiler-options/language-out" {:ns "compiler-options",
                                            :name "language-out",
                                            :name-encode "language-out",
                                            :type "option",
                                            :full-name-encode "compiler-options/language-out",
                                            :full-name "compiler-options/language-out",
                                            :history [["+" "0.0-2197"]]},
           "cljs.reader/*default-data-reader-fn*" {:ns "cljs.reader",
                                                   :name "*default-data-reader-fn*",
                                                   :name-encode "STARdefault-data-reader-fnSTAR",
                                                   :type "var",
                                                   :full-name-encode "cljs.reader/STARdefault-data-reader-fnSTAR",
                                                   :source {:code "(def *default-data-reader-fn*\n  (atom nil))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [560
                                                                    561]},
                                                   :full-name "cljs.reader/*default-data-reader-fn*",
                                                   :history [["+"
                                                              "0.0-1576"]]},
           "cljs.core/sorted-map-by" {:ns "cljs.core",
                                      :name "sorted-map-by",
                                      :signature ["[comparator & keyvals]"],
                                      :name-encode "sorted-map-by",
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/sorted-map-by",
                                      :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (cljs.core.PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6006 6014]},
                                      :full-name "cljs.core/sorted-map-by",
                                      :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :name-encode "symbol",
                               :type "function",
                               :full-name-encode "cljs.core/symbol",
                               :source {:code "(defn symbol\n  ([name]\n     (if (symbol? name)\n       name\n       (symbol nil name)))\n  ([ns name]\n     (let [sym-str (if-not (nil? ns)\n                     (str ns \"/\" name)\n                     name)]\n       (Symbol. ns name sym-str nil nil))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [449 458]},
                               :full-name "cljs.core/symbol",
                               :history [["+" "0.0-927"]]},
           "cljs.core/Delay" {:protocols #{"IDeref" "IPending"},
                              :ns "cljs.core",
                              :name "Delay",
                              :signature ["[state f]"],
                              :name-encode "Delay",
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Delay",
                              :source {:code "(deftype Delay [state f]\n  IDeref\n  (-deref [_]\n    (:value (swap! state (fn [{:keys [done] :as curr-state}]\n                           (if done\n                             curr-state,\n                             {:done true :value (f)})))))\n\n  IPending\n  (-realized? [d]\n    (:done @state)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7284 7294]},
                              :full-name "cljs.core/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :name-encode "methods",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7704 7706]},
                                :full-name "cljs.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.core/lazy-cat" {:ns "cljs.core",
                                 :name "lazy-cat",
                                 :signature ["[& colls]"],
                                 :name-encode "lazy-cat",
                                 :history [["+" "0.0-1803"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-cat",
                                 :source {:code "(defmacro lazy-cat\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1582 1589]},
                                 :full-name "cljs.core/lazy-cat",
                                 :docstring "Expands to code which yields a lazy sequence of the concatenation\nof the supplied colls.  Each coll expr is not evaluated until it is\nneeded. \n\n(lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"},
           "cljs.core/vector" {:ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :name-encode "vector",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/vector",
                               :source {:code "(defn vector [& args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (cljs.core.PersistentVector.fromArray (.-arr args) true)\n    (vec args)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3503 3506]},
                               :extra-sources [{:code "(defmacro vector\n  ([] `cljs.core.PersistentVector.EMPTY)\n  ([& xs]\n    (let [cnt (count xs)]\n      (if (core/< cnt 32)\n        `(cljs.core.PersistentVector. nil ~cnt 5\n           cljs.core.PersistentVector.EMPTY_NODE (array ~@xs) nil)\n        (vary-meta\n          `(cljs.core.PersistentVector.fromArray (array ~@xs) true)\n          assoc :tag 'cljs.core/PersistentVector)))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [1338 1347]}],
                               :full-name "cljs.core/vector"},
           "cljs.core/rand-int" {:ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :name-encode "rand-int",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-int",
                                 :source {:code "(defn rand-int\n  [n] (Math/floor (* (Math/random) n)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7421 7423]},
                                 :full-name "cljs.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/throw" {:ns "cljs.core",
                              :name "throw",
                              :type "special form",
                              :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [482 487]},
                              :extra-sources ({:code "(defmethod emit* :throw\n  [{:keys [throw env]}]\n  (if (= :expr (:context env))\n    (emits \"(function(){throw \" throw \"})()\")\n    (emitln \"throw \" throw \";\")))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [390 394]}),
                              :full-name "cljs.core/throw",
                              :full-name-encode "cljs.core/throw",
                              :name-encode "throw",
                              :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :name-encode "PersistentQueueDOTEMPTY",
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core/PersistentQueueDOTEMPTY",
                                              :source {:code "(set! cljs.core.PersistentQueue.EMPTY (PersistentQueue. nil 0 nil [] 0))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [3979]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/unchecked-float" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-float",
                                        :signature ["[x]"],
                                        :name-encode "unchecked-float",
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-float",
                                        :source {:code "(defn ^number unchecked-float [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1572]},
                                        :extra-sources [{:code "(defmacro unchecked-float [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [358]}],
                                        :full-name "cljs.core/unchecked-float"},
           "clojure.core.reducers/append!" {:ns "clojure.core.reducers",
                                            :name "append!",
                                            :signature ["[acc x]"],
                                            :name-encode "appendBANG",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/appendBANG",
                                            :source {:code "(defn append!\n  [acc x]\n  (doto acc (.push x)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [232 235]},
                                            :full-name "clojure.core.reducers/append!",
                                            :docstring ".adds x to acc and returns acc"},
           "syntax/js-literal" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "js-literal",
                                :name-encode "js-literal",
                                :type "tagged literal",
                                :full-name-encode "syntax/js-literal",
                                :extra-sources ({:code "(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw (RuntimeException. \"JavaScript literal must use map or vector notation\")))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw (RuntimeException. \"JavaScript literal keys must be strings or unqualified keywords\")))\n  (JSValue. form))",
                                                 :title "Reader code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/tagged_literals.clj",
                                                 :lines [35 42]}
                                                {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                 :title "Reader table",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/tagged_literals.clj",
                                                 :lines [44 48]}),
                                :full-name "syntax/js-literal",
                                :history [["+" "0.0-2120"]]},
           "cljs.core/NodeSeq" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "NodeSeq",
                                :signature ["[meta nodes i s __hash]"],
                                :name-encode "NodeSeq",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/NodeSeq",
                                :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (NodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      [(aget nodes i) (aget nodes (inc i))]\n      (first s)))\n\n  (-rest [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4991 5037]},
                                :full-name "cljs.core/NodeSeq"},
           "cljs.core/letfn" {:ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :name-encode "letfn",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.5.1",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5922 5933]},
                              :full-name "cljs.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.core/recur" {:ns "cljs.core",
                              :name "recur",
                              :type "special form",
                              :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame \n      (throw (error env \"Can't recur here\")))\n    (when-not (= (count exprs) (count (:params frame))) \n      (throw (error env \"recur argument count mismatch\")))\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children exprs)))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [861 874]},
                              :extra-sources ({:code "(defmethod emit* :recur\n  [{:keys [frame exprs env]}]\n  (let [temps (vec (take (count exprs) (repeatedly gensym)))\n        params (:params frame)]\n    (emitln \"{\")\n    (dotimes [i (count exprs)]\n      (emitln \"var \" (temps i) \" = \" (exprs i) \";\"))\n    (dotimes [i (count exprs)]\n      (emitln (munge (params i)) \" = \" (temps i) \";\"))\n    (emitln \"continue;\")\n    (emitln \"}\")))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [657 667]}),
                              :full-name "cljs.core/recur",
                              :full-name-encode "cljs.core/recur",
                              :name-encode "recur",
                              :history [["+" "0.0-927"]]},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :signature ["[rdr _]"],
                                       :name-encode "read-discard",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-discard",
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [377 380]},
                                       :full-name "cljs.reader/read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.server/read-headers" {:ns "cljs.repl.server",
                                            :name "read-headers",
                                            :signature ["[rdr]"],
                                            :name-encode "read-headers",
                                            :type "function",
                                            :full-name-encode "cljs.repl.server/read-headers",
                                            :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/server.clj",
                                                     :lines [70 75]},
                                            :full-name "cljs.repl.server/read-headers",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/gen-apply-to" {:ns "cljs.core",
                                     :name "gen-apply-to",
                                     :signature ["[]"],
                                     :name-encode "gen-apply-to",
                                     :type "macro",
                                     :full-name-encode "cljs.core/gen-apply-to",
                                     :source {:code "(defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1562 1570]},
                                     :full-name "cljs.core/gen-apply-to",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/inc" {:ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :name-encode "inc",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [578 580]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [452 453]}],
                            :full-name "cljs.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/name" {:ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :name-encode "name",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/name",
                             :source {:code "(defn name\n  [x]\n  (if (implements? INamed x)\n    (-name ^not-native x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str \"Doesn't support name: \" x))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [6450 6457]},
                             :full-name "cljs.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.core/cycle" {:ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :name-encode "cycle",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2992 2996]},
                              :full-name "cljs.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "warnings/unprovided" {:ns "warnings",
                                  :name "unprovided",
                                  :type "warning",
                                  :full-name "warnings/unprovided",
                                  :full-name-encode "warnings/unprovided",
                                  :name-encode "unprovided",
                                  :history [["+" "0.0-2173"]]},
           "cljs.core/rsubseq" {:ns "cljs.core",
                                :name "rsubseq",
                                :signature ["[sc test key]"
                                            "[sc start-test start-key end-test end-key]"],
                                :name-encode "rsubseq",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/rsubseq",
                                :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6525 6538]},
                                :full-name "cljs.core/rsubseq",
                                :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/divide" {:ns "cljs.core",
                               :name "divide",
                               :signature ["[x]"
                                           "[x y]"
                                           "[x y & more]"],
                               :name-encode "divide",
                               :type "macro",
                               :full-name-encode "cljs.core/divide",
                               :source {:code "(defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [419 422]},
                               :full-name "cljs.core/divide",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/fn*" {:ns "cljs.core",
                            :name "fn*",
                            :type "special form",
                            :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name]\n  (let [[name meths] (if (symbol? (first args))\n                       [(first args) (next args)]\n                       [name (seq args)])\n        ;;turn (fn [] ...) into (fn ([]...))\n        meths (if (vector? (first meths)) (list meths) meths)\n        locals (:locals env)\n        name-var (if name\n                   (merge\n                     {:name name\n                      :info {:shadow (or (locals name)\n                                       (get-in env [:js-globals name]))}}\n                     (when-let [tag (-> name meta :tag)]\n                       {:ret-tag tag}))) \n        locals (if (and locals name) (assoc locals name name-var) locals)\n        type (-> form meta ::type)\n        fields (-> form meta ::fields)\n        protocol-impl (-> form meta :protocol-impl)\n        protocol-inline (-> form meta :protocol-inline)\n        locals (reduce (fn [m fld]\n                         (assoc m fld\n                                {:name fld\n                                 :line (get-line fld env)\n                                 :column (get-col fld env)\n                                 :field true\n                                 :mutable (-> fld meta :mutable)\n                                 :unsynchronized-mutable (-> fld meta :unsynchronized-mutable)\n                                 :volatile-mutable (-> fld meta :volatile-mutable)\n                                 :tag (-> fld meta :tag)\n                                 :shadow (m fld)}))\n                       locals fields)\n\n        menv (if (> (count meths) 1) (assoc env :context :expr) env)\n        menv (merge menv\n               {:protocol-impl protocol-impl\n                :protocol-inline protocol-inline})\n        methods (map #(analyze-fn-method menv locals % type) meths)\n        max-fixed-arity (apply max (map :max-fixed-arity methods))\n        variadic (boolean (some :variadic methods))\n        locals (if name\n                 (update-in locals [name] assoc\n                   ;; TODO: can we simplify? - David\n                   :fn-var true\n                   :variadic variadic\n                   :max-fixed-arity max-fixed-arity\n                   :method-params (map :params methods)\n                   :methods methods)\n                 locals)\n        methods (if name\n                  ;; a second pass with knowledge of our function-ness/arity\n                  ;; lets us optimize self calls\n                  (no-warn (doall (map #(analyze-fn-method menv locals % type) meths)))\n                  methods)]\n    (let [variadic-methods (filter :variadic methods)\n          variadic-params (count (:params (first variadic-methods)))\n          param-counts (map (comp count :params) methods)]\n      (when (< 1 (count variadic-methods))\n        (warning :multiple-variadic-overloads env {:name name-var}))\n      (when (not (or (zero? variadic-params) (= variadic-params (+ 1 max-fixed-arity))))\n        (warning :variadic-max-arity env {:name name-var}))\n      (when (not= (distinct param-counts) param-counts)\n        (warning :overload-arity env {:name name-var})))\n    {:env env :op :fn :form form :name name-var :methods methods :variadic variadic\n     :tag 'function\n     :recur-frames *recur-frames* :loop-lets *loop-lets*\n     :jsdoc [(when variadic \"@param {...*} var_args\")]\n     :max-fixed-arity max-fixed-arity\n     :protocol-impl protocol-impl\n     :protocol-inline protocol-inline\n     :children (mapv :expr methods)}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [667 737]},
                            :extra-sources ({:code "(defmethod emit* :fn\n  [{:keys [name env methods max-fixed-arity variadic recur-frames loop-lets]}]\n  ;;fn statements get erased, serve no purpose and can pollute scope if named\n  (when-not (= :statement (:context env))\n    (let [loop-locals (->> (concat (mapcat :params (filter #(and % @(:flag %)) recur-frames))\n                                   (mapcat :params loop-lets))\n                           (map munge)\n                           seq)]\n      (when loop-locals\n        (when (= :return (:context env))\n            (emits \"return \"))\n        (emitln \"((function (\" (comma-sep (map munge loop-locals)) \"){\")\n        (when-not (= :return (:context env))\n            (emits \"return \")))\n      (if (= 1 (count methods))\n        (if variadic\n          (emit-variadic-fn-method (assoc (first methods) :name name))\n          (emit-fn-method (assoc (first methods) :name name)))\n        (let [has-name? (and name true)\n              name (or name (gensym))\n              mname (munge name)\n              maxparams (apply max-key count (map :params methods))\n              mmap (into {}\n                     (map (fn [method]\n                            [(munge (symbol (str mname \"__\" (count (:params method)))))\n                             method])\n                          methods))\n              ms (sort-by #(-> % second :params count) (seq mmap))]\n          (when (= :return (:context env))\n            (emits \"return \"))\n          (emitln \"(function() {\")\n          (emitln \"var \" mname \" = null;\")\n          (doseq [[n meth] ms]\n            (emits \"var \" n \" = \")\n            (if (:variadic meth)\n              (emit-variadic-fn-method meth)\n              (emit-fn-method meth))\n            (emitln \";\"))\n            (emitln mname \" = function(\" (comma-sep (if variadic\n                                                      (concat (butlast maxparams) ['var_args])\n                                                      maxparams)) \"){\")\n          (when variadic\n            (emits \"var \")\n            (emit (last maxparams))\n            (emitln \" = var_args;\"))\n          (emitln \"switch(arguments.length){\")\n          (doseq [[n meth] ms]\n            (if (:variadic meth)\n              (do (emitln \"default:\")\n                  (emitln \"return \" n \".cljs$core$IFn$_invoke$arity$variadic(\"\n                          (comma-sep (butlast maxparams))\n                          (when (> (count maxparams) 1) \", \")\n                          \"cljs.core.array_seq(arguments, \" max-fixed-arity \"));\"))\n              (let [pcnt (count (:params meth))]\n                (emitln \"case \" pcnt \":\")\n                (emitln \"return \" n \".call(this\" (if (zero? pcnt) nil\n                                                     (list \",\" (comma-sep (take pcnt maxparams)))) \");\"))))\n          (emitln \"}\")\n          (emitln \"throw(new Error('Invalid arity: ' + arguments.length));\")\n          (emitln \"};\")\n          (when variadic\n            (emitln mname \".cljs$lang$maxFixedArity = \" max-fixed-arity \";\")\n            (emitln mname \".cljs$lang$applyTo = \" (some #(let [[n m] %] (when (:variadic m) n)) ms) \".cljs$lang$applyTo;\"))\n          (when has-name?\n            (doseq [[n meth] ms]\n              (let [c (count (:params meth))]\n                (if (:variadic meth)\n                  (emitln mname \".cljs$core$IFn$_invoke$arity$variadic = \" n \".cljs$core$IFn$_invoke$arity$variadic;\")\n                  (emitln mname \".cljs$core$IFn$_invoke$arity$\" c \" = \" n \";\")))))\n          (emitln \"return \" mname \";\")\n          (emitln \"})()\")))\n      (when loop-locals\n        (emitln \";})(\" (comma-sep loop-locals) \"))\")))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [531 603]}),
                            :full-name "cljs.core/fn*",
                            :full-name-encode "cljs.core/fnSTAR",
                            :name-encode "fnSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/map" {:ns "cljs.core",
                            :name "map",
                            :signature ["[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :name-encode "map",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/map",
                            :source {:code "(defn map\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2911 2946]},
                            :full-name "cljs.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/ChunkBuffer" {:protocols #{"ICounted"},
                                    :ns "cljs.core",
                                    :name "ChunkBuffer",
                                    :signature ["[buf end]"],
                                    :name-encode "ChunkBuffer",
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkBuffer",
                                    :source {:code "(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_ o]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2217 2229]},
                                    :full-name "cljs.core/ChunkBuffer"},
           "syntax/list" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "list",
                          :name-encode "list",
                          :type "syntax",
                          :full-name-encode "syntax/list",
                          :extra-sources ({:code "(defn- read-list\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-list (read-delimited \\) rdr true)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (if (empty? the-list)\n      '()\n      (with-meta (clojure.lang.PersistentList/create the-list)\n        (when start-line\n          {:line start-line\n           :column start-column\n           :end-line end-line\n           :end-column end-column})))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [166 180]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.3",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [578 597]}),
                          :full-name "syntax/list",
                          :history [["+" "0.0-1853"]]},
           "cljs.core/amap" {:ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :name-encode "amap",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/amap",
                             :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1421 1434]},
                             :full-name "cljs.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret."},
           "syntax/uuid-literal" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "uuid-literal",
                                  :name-encode "uuid-literal",
                                  :type "tagged literal",
                                  :full-name-encode "syntax/uuid-literal",
                                  :extra-sources ({:code "(defn read-uuid\n  [form]\n  (when-not (string? form)\n    (throw (RuntimeException. \"UUID literal expects a string as its representation.\")))\n  (try\n    (java.util.UUID/fromString form)\n    (catch Throwable e\n      (throw (RuntimeException. (.getMessage e))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [10 17]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [44 48]}),
                                  :full-name "syntax/uuid-literal",
                                  :history [["+" "0.0-1424"]]},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :name-encode "children",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "cljs.core/when-not" {:ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :name-encode "when-not",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.5.1",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [477 481]},
                                 :full-name "cljs.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :name-encode "index",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [88 96]},
                                :full-name "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :name-encode "send-and-close",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-1503"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1450",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [69 90]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response.",
                                               :removed {:in "0.0-1503",
                                                         :last-seen "0.0-1450"}},
           "cljs.core/chunked-seq?" {:return-type boolean,
                                     :ns "cljs.core",
                                     :name "chunked-seq?",
                                     :signature ["[x]"],
                                     :name-encode "chunked-seqQMARK",
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/chunked-seqQMARK",
                                     :source {:code "(defn ^boolean chunked-seq?\n  [x] (implements? IChunkedSeq x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1180 1181]},
                                     :full-name "cljs.core/chunked-seq?"},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :signature ["[& args]"],
                                      :name-encode "log",
                                      :type "function",
                                      :full-name-encode "clojure.browser.dom/log",
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/clojure/browser/dom.cljs",
                                               :lines [20 21]},
                                      :full-name "clojure.browser.dom/log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :name-encode "VectorDOTfromArray",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1798"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core/VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs nil)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1586",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2861]},
                                         :full-name "cljs.core/Vector.fromArray",
                                         :removed {:in "0.0-1798",
                                                   :last-seen "0.0-1586"}},
           "cljs.core/make-array" {:return-type array,
                                   :ns "cljs.core",
                                   :name "make-array",
                                   :signature ["[size]" "[type size]"],
                                   :name-encode "make-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/make-array",
                                   :source {:code "(defn ^array make-array\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size)))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [147 151]},
                                   :extra-sources [{:code "(defmacro make-array\n  [size]\n  (vary-meta\n    (if (core/number? size)\n      `(array ~@(take size (repeat nil)))\n      `(js/Array. ~size))\n    assoc :tag 'array))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [1325 1331]}],
                                   :full-name "cljs.core/make-array"},
           "cljs.core/sorted-set-by" {:ns "cljs.core",
                                      :name "sorted-set-by",
                                      :signature ["[comparator & keys]"],
                                      :name-encode "sorted-set-by",
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/sorted-set-by",
                                      :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (cljs.core.PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6409 6414]},
                                      :full-name "cljs.core/sorted-set-by",
                                      :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
           "syntax/impure" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "impure",
                            :name-encode "impure",
                            :type "convention",
                            :full-name-encode "syntax/impure",
                            :full-name "syntax/impure",
                            :history [["+" "0.0-927"]]},
           "warnings/fn-deprecated" {:ns "warnings",
                                     :name "fn-deprecated",
                                     :type "warning",
                                     :full-name "warnings/fn-deprecated",
                                     :full-name-encode "warnings/fn-deprecated",
                                     :name-encode "fn-deprecated",
                                     :history [["+" "0.0-1835"]]},
           "cljs.core/partition-by" {:ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f coll]"],
                                     :name-encode "partition-by",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/partition-by",
                                     :source {:code "(defn partition-by\n  [f coll]\n  (lazy-seq\n   (when-let [s (seq coll)]\n     (let [fst (first s)\n           fv (f fst)\n           run (cons fst (take-while #(= fv (f %)) (next s)))]\n       (cons run (partition-by f (seq (drop (count run) s))))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6636 6645]},
                                     :full-name "cljs.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns\na new value.  Returns a lazy seq of partitions."},
           "cljs.core/sort-by" {:ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :name-encode "sort-by",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1366 1374]},
                                :full-name "cljs.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[o meta]"],
                                  :name-encode "with-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (if (and (fn? o) (not (satisfies? IWithMeta o)))\n    (with-meta\n      (reify\n        Fn\n        IFn\n        (-invoke [_ & args]\n          (apply o args)))\n      meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1041 1054]},
                                  :full-name "cljs.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:protocols #{"IEquiv"},
                                   :ns "cljs.core",
                                   :name "NeverEquiv",
                                   :signature ["[]"],
                                   :name-encode "NeverEquiv",
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/NeverEquiv",
                                   :source {:code "(deftype NeverEquiv []\n  IEquiv\n  (-equiv [o other] false))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3981 3983]},
                                   :full-name "cljs.core/NeverEquiv"},
           "cljs.core/select-keys" {:ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keyseq]"],
                                    :name-encode "select-keys",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        ret)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [6168 6180]},
                                    :full-name "cljs.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :name-encode "ISeq",
                             :implementations #{"PersistentQueue"
                                                "PersistentArrayMapSeq"
                                                "EmptyList"
                                                "ValSeq"
                                                "ChunkedCons"
                                                "Range"
                                                "PersistentQueueSeq"
                                                "ChunkedSeq"
                                                "ArrayNodeSeq"
                                                "KeySeq"
                                                "IndexedSeq"
                                                "PersistentTreeMapSeq"
                                                "RSeq"
                                                "NodeSeq"
                                                "List"
                                                "Cons"
                                                "LazySeq"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (^clj -rest [coll]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [246 248]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring nil}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISeq"},
           "cljs.core/disj!" {:ns "cljs.core",
                              :name "disj!",
                              :signature ["[tcoll val]"
                                          "[tcoll val & vals]"],
                              :name-encode "disjBANG",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/disjBANG",
                              :source {:code "(defn disj!\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2556 2565]},
                              :full-name "cljs.core/disj!",
                              :docstring "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.core/type->str" {:ns "cljs.core",
                                  :name "type->str",
                                  :signature ["[ty]"],
                                  :name-encode "type-GTstr",
                                  :type "function",
                                  :full-name-encode "cljs.core/type-GTstr",
                                  :source {:code "(defn type->str [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [140 143]},
                                  :full-name "cljs.core/type->str",
                                  :history [["+" "0.0-1859"]]},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :name-encode "postwalk-replace",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk/postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/walk.cljs",
                                                     :lines [88 94]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :name-encode "pr-with-opts",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (doseq [string (pr-seq (first objs) opts)]\n    (string-print string))\n  (doseq [obj (next objs)]\n    (string-print \" \")\n    (doseq [string (pr-seq obj opts)]\n      (string-print string))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1450",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6171 6180]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                     :removed {:in "0.0-1503",
                                               :last-seen "0.0-1450"}},
           "cljs.core/->>" {:ns "cljs.core",
                            :name "->>",
                            :signature ["[x form]" "[x form & more]"],
                            :name-encode "-GTGT",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/-GTGT",
                            :source {:code "(defmacro ->>\n  ([x form] (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x)))\n  ([x form & more] `(->> (->> ~x ~form) ~@more)))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.5.1",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1557 1566]},
                            :full-name "cljs.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.core/defonce" {:ns "cljs.core",
                                :name "defonce",
                                :signature ["[x init]"],
                                :name-encode "defonce",
                                :type "macro",
                                :full-name-encode "cljs.core/defonce",
                                :source {:code "(defmacro defonce [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [65 67]},
                                :full-name "cljs.core/defonce",
                                :history [["+" "0.0-2156"]]},
           "cljs.core/nil?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :name-encode "nilQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/nilQMARK",
                             :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [83 86]},
                             :extra-sources [{:code "(defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [253 254]}],
                             :full-name "cljs.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:return-type String,
                                     :ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :name-encode "bootjs",
                                     :type "var",
                                     :full-name-encode "cljs.repl.rhino/bootjs",
                                     :source {:code "(def ^String bootjs (str \"goog.require = function(rule){\"\n                         \"Packages.clojure.lang.RT[\\\"var\\\"](\\\"cljs.repl.rhino\\\",\\\"goog-require\\\")\"\n                         \".invoke(___repl_env, rule);}\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/repl/rhino.clj",
                                              :lines [21 23]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/load-namespace" {:ns "cljs.core",
                                       :name "load-namespace",
                                       :name-encode "load-namespace",
                                       :type "special form (repl)",
                                       :full-name-encode "cljs.core/load-namespace",
                                       :source {:code "(def default-special-fns\n  (let [load-file-fn (fn [repl-env file] (load-file repl-env file))]\n    {'in-ns (fn [_ quoted-ns]\n              (let [ns-name (second quoted-ns)]\n                (when-not (ana/get-namespace ns-name)\n                  (swap! env/*compiler* update-in [::ana/namespaces ns-name] {:name ns-name}))\n                (set! ana/*cljs-ns* ns-name)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace (fn [repl-env ns] (load-namespace repl-env ns))}))",
                                                :title "repl specials table",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [162 171]},
                                       :full-name "cljs.core/load-namespace",
                                       :repl-only? true,
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :name-encode "stringify-keys",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk/stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/clojure/walk.cljs",
                                                   :lines [72 78]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :name-encode "order",
                                         :type "var",
                                         :full-name-encode "clojure.browser.repl/order",
                                         :source {:code "(def order (atom 0))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/clojure/browser/repl.cljs",
                                                  :lines [55]},
                                         :full-name "clojure.browser.repl/order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :name-encode "memoize",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (if-let [v (get @mem args)]\n        v\n        (let [ret (apply f args)]\n          (swap! mem assoc args ret)\n          ret)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7385 7397]},
                                :full-name "cljs.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "warnings/undeclared" {:ns "warnings",
                                  :name "undeclared",
                                  :type "warning",
                                  :full-name "warnings/undeclared",
                                  :full-name-encode "warnings/undeclared",
                                  :name-encode "undeclared",
                                  :history [["+" "0.0-1835"]
                                            ["-" "0.0-2014"]],
                                  :removed {:in "0.0-2014",
                                            :last-seen "0.0-1978"}},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :name-encode "pr-sequential",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-sequential",
                                      :source {:code "(defn ^:deprecated pr-sequential\n  [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6210 6217]},
                                      :full-name "cljs.core/pr-sequential",
                                      :docstring "Do not use this.  It is kept for backwards compatibility with the\nold IPrintable protocol.",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "warnings/undeclared-ns" {:ns "warnings",
                                     :name "undeclared-ns",
                                     :type "warning",
                                     :full-name "warnings/undeclared-ns",
                                     :full-name-encode "warnings/undeclared-ns",
                                     :name-encode "undeclared-ns",
                                     :history [["+" "0.0-2014"]]},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :name-encode "make-node",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "deref",
                           :name-encode "deref",
                           :type "syntax",
                           :full-name-encode "syntax/deref",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.3",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [578 597]}),
                           :full-name "syntax/deref",
                           :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :name-encode "PersistentVectorDOTEMPTY",
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core/PersistentVectorDOTEMPTY",
                                               :source {:code "(set! cljs.core.PersistentVector.EMPTY\n  (PersistentVector. nil 0 5 cljs.core.PersistentVector.EMPTY_NODE (array) 0))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [3481
                                                                3482]},
                                               :full-name "cljs.core/PersistentVector.EMPTY",
                                               :history [["+"
                                                          "0.0-1006"]]},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :name-encode "float-pattern",
                                        :type "var",
                                        :full-name-encode "cljs.reader/float-pattern",
                                        :source {:code "(def float-pattern (re-pattern \"([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [99]},
                                        :full-name "cljs.reader/float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :name-encode "ancestors",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7485 7491]},
                                  :full-name "cljs.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/integer?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :name-encode "integerQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/integerQMARK",
                                 :source {:code "(defn ^boolean integer?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1247 1253]},
                                 :full-name "cljs.core/integer?",
                                 :docstring "Returns true if n is an integer."},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :name-encode "HashMapDOTEMPTY",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :parent-type "HashMap",
                                      :type "var",
                                      :full-name-encode "cljs.core/HashMapDOTEMPTY",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj) 0))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3830]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :name-encode "VectorDOTEMPTY",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1798"]],
                                     :parent-type "Vector",
                                     :type "var",
                                     :full-name-encode "cljs.core/VectorDOTEMPTY",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1586",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2859]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :removed {:in "0.0-1798",
                                               :last-seen "0.0-1586"}},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :name-encode "xml-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :name-encode "walk",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk/walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/walk.cljs",
                                         :lines [37 48]},
                                :full-name "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/ifn?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "ifn?",
                             :signature ["[f]"],
                             :name-encode "ifnQMARK",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/ifnQMARK",
                             :source {:code "(defn ^boolean ifn? [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1244 1245]},
                             :full-name "cljs.core/ifn?"},
           "cljs.core/bit-xor" {:ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]"],
                                :name-encode "bit-xor",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-xor",
                                :source {:code "(defn bit-xor\n  [x y] (cljs.core/bit-xor x y))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1712 1714]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [498 500]}],
                                :full-name "cljs.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :name-encode "union",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.core/case" {:ns "cljs.core",
                             :name "case",
                             :signature ["[e & clauses]"],
                             :name-encode "case",
                             :type "macro",
                             :full-name-encode "cljs.core/case",
                             :source {:code "(defmacro case [e & clauses]\n  (let [default (if (odd? (count clauses))\n                  (last clauses)\n                  `(throw (js/Error. (core/str \"No matching clause: \" ~e))))\n        assoc-test (fn assoc-test [m test expr]\n                         (if (contains? m test)\n                           (throw (clojure.core/IllegalArgumentException.\n                                   (core/str \"Duplicate case test constant '\"\n                                             test \"'\"\n                                             (when (:line &env)\n                                               (core/str \" on line \" (:line &env) \" \"\n                                                         cljs.analyzer/*cljs-file*)))))\n                           (assoc m test expr)))\n        pairs (reduce (fn [m [test expr]]\n                        (core/cond\n                         (seq? test) (reduce (fn [m test]\n                                               (let [test (if (core/symbol? test)\n                                                            (core/list 'quote test)\n                                                            test)]\n                                                 (assoc-test m test expr)))\n                                             m test)\n                         (core/symbol? test) (assoc-test m (core/list 'quote test) expr)\n                         :else (assoc-test m test expr)))\n                      {} (partition 2 clauses))\n        esym (gensym)]\n   `(let [~esym ~e]\n      (cond\n        ~@(mapcat (fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n        :else ~default))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1129 1157]},
                             :full-name "cljs.core/case",
                             :history [["+" "0.0-1211"]]},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :name-encode "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl/IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [this] \"initialize the environment\")\n  (-evaluate [this filename line js] \"evaluate a javascript string\")\n  (-load [this ns url] \"load code at url into the environment\")\n  (-tear-down [this] \"dispose of the environment\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [26 30]},
                                       :methods [{:name "-setup",
                                                  :signature ["[this]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[this filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[this ns url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[this]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :name-encode "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader/PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [12 15]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/isa?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :name-encode "isaQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/isaQMARK",
                             :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7457 7475]},
                             :full-name "cljs.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :name-encode "xhr-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (goog.net.XhrIo.))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [83
                                                                  86]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/as->" {:ns "cljs.core",
                             :name "as->",
                             :signature ["[expr name & forms]"],
                             :name-encode "as-GT",
                             :history [["+" "0.0-1798"]],
                             :type "macro",
                             :full-name-encode "cljs.core/as-GT",
                             :source {:code "(defmacro as->\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.5.1",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [6803 6811]},
                             :full-name "cljs.core/as->",
                             :docstring "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form."},
           "clojure.core.reducers/reducer" {:ns "clojure.core.reducers",
                                            :name "reducer",
                                            :signature ["[coll xf]"],
                                            :name-encode "reducer",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/reducer",
                                            :source {:code "(defn reducer\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [66 77]},
                                            :full-name "clojure.core.reducers/reducer",
                                            :docstring "Given a reducible collection, and a transformation function xf,\nreturns a reducible collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/subs" {:ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :name-encode "subs",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1825 1829]},
                             :full-name "cljs.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "unquote",
                             :name-encode "unquote",
                             :type "syntax",
                             :full-name-encode "syntax/unquote",
                             :extra-sources ({:code "(defn- read-unquote\n  [rdr comma]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [444 449]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.3",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [578 597]}),
                             :full-name "syntax/unquote",
                             :history [["+" "0.0-1853"]]},
           "cljs.core/symbol?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :name-encode "symbolQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/symbolQMARK",
                                :source {:code "(defn ^boolean symbol? [x]\n  (instance? Symbol x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [405 406]},
                                :extra-sources [{:code "(defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [323 324]}],
                                :full-name "cljs.core/symbol?"},
           "compiler-options/language-in" {:ns "compiler-options",
                                           :name "language-in",
                                           :name-encode "language-in",
                                           :type "option",
                                           :full-name-encode "compiler-options/language-in",
                                           :full-name "compiler-options/language-in",
                                           :history [["+" "0.0-2197"]]},
           "clojure.data/Diff" {:ns "clojure.data",
                                :name "Diff",
                                :name-encode "Diff",
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "clojure.data/Diff",
                                :source {:code "(defprotocol Diff\n  \"Implementation detail. Subject to change.\"\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/data.cljs",
                                         :lines [79 81]},
                                :methods [{:name "diff-similar",
                                           :signature ["[a b]"],
                                           :docstring "Implementation detail. Subject to change."}],
                                :full-name "clojure.data/Diff",
                                :docstring "Implementation detail. Subject to change."},
           "clojure.string/replace" {:ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :name-encode "replace",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [23 34]},
                                     :full-name "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :name-encode "stringQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/stringQMARK",
                                :source {:code "(defn ^boolean string? [x]\n  (goog/isString x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [103 104]},
                                :extra-sources [{:code "(defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [296 297]}],
                                :full-name "cljs.core/string?"},
           "cljs.core/partition-all" {:ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n coll]"
                                                  "[n step coll]"],
                                      :name-encode "partition-all",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/partition-all",
                                      :source {:code "(defn partition-all\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6485 6493]},
                                      :full-name "cljs.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end."},
           "cljs.core/RedNode" {:protocols #{"IFn"
                                             "ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IStack"
                                             "IEmptyableCollection"
                                             "ICounted"
                                             "IReduce"
                                             "ILookup"
                                             "ISequential"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IIndexed"
                                             "IAssociative"
                                             "IVector"
                                             "IEquiv"
                                             "IMapEntry"},
                                :ns "cljs.core",
                                :name "RedNode",
                                :signature ["[key val left right __hash]"],
                                :name-encode "RedNode",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/RedNode",
                                :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [5595 5734]},
                                :full-name "cljs.core/RedNode"},
           "cljs.core/ExceptionInfo" {:ns "cljs.core",
                                      :name "ExceptionInfo",
                                      :signature ["[message data cause]"],
                                      :name-encode "ExceptionInfo",
                                      :type "type",
                                      :full-name-encode "cljs.core/ExceptionInfo",
                                      :source {:code "(deftype ExceptionInfo [message data cause])",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7737]},
                                      :full-name "cljs.core/ExceptionInfo",
                                      :history [["+" "0.0-1576"]]},
           "cljs.core/merge-with" {:ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :name-encode "merge-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6152 6166]},
                                   :full-name "cljs.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "cljs.core/key" {:ns "cljs.core",
                            :name "key",
                            :signature ["[map-entry]"],
                            :name-encode "key",
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :full-name-encode "cljs.core/key",
                            :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [6075 6078]},
                            :full-name "cljs.core/key",
                            :docstring "Returns the key of the map entry."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :name-encode "set-properties",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [136
                                                                  140]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "clojure.data/diff" {:ns "clojure.data",
                                :name "diff",
                                :signature ["[a b]"],
                                :name-encode "diff",
                                :history [["+" "0.0-1503"]],
                                :type "function",
                                :full-name-encode "clojure.data/diff",
                                :source {:code "(defn diff\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/data.cljs",
                                         :lines [144 161]},
                                :full-name "clojure.data/diff",
                                :docstring "Recursively compares a and b, returning a tuple of\n[things-only-in-a things-only-in-b things-in-both].\nComparison rules:\n\n* For equal a and b, return [nil nil a].\n* Maps are subdiffed where keys match and values differ.\n* Sets are never subdiffed.\n* All sequential things are treated as associative collections\n  by their indexes, with results returned as vectors.\n* Everything else (including strings!) is treated as\n  an atom and compared for equality."},
           "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                              :name "ITransientAssociative",
                                              :name-encode "ITransientAssociative",
                                              :implementations #{"TransientArrayMap"
                                                                 "TransientVector"
                                                                 "TransientHashMap"},
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "protocol",
                                              :full-name-encode "cljs.core/ITransientAssociative",
                                              :source {:code "(defprotocol ITransientAssociative\n  (^clj -assoc! [tcoll key val]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [351
                                                               352]},
                                              :methods [{:name "-assoc!",
                                                         :signature ["[tcoll key val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ITransientAssociative"},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :name-encode "trampoline",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7399 7413]},
                                   :full-name "cljs.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.core/implements?" {:ns "cljs.core",
                                    :name "implements?",
                                    :signature ["[psym x]"],
                                    :name-encode "implementsQMARK",
                                    :history [["+" "0.0-2014"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/implementsQMARK",
                                    :source {:code "(defmacro implements?\n  [psym x]\n  (let [p          (:name\n                    (cljs.analyzer/resolve-var\n                      (dissoc &env :locals) psym))\n        prefix     (protocol-prefix p)\n        xsym       (bool-expr (gensym))\n        [part bit] (fast-path-protocols p)\n        msym       (symbol\n                      (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if ~xsym\n         (let [bit# ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))]\n           (if (or bit#\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false))\n         false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1000 1018]},
                                    :full-name "cljs.core/implements?",
                                    :docstring "EXPERIMENTAL"},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :signature ["[opts conn]"],
                                                  :name-encode "handle-connection",
                                                  :history [["+"
                                                             "0.0-927"]
                                                            ["-"
                                                             "0.0-1503"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/handle-connection",
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1450",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [248
                                                                   256]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :removed {:in "0.0-1503",
                                                            :last-seen "0.0-1450"}},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :name-encode "send-print",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [41 53]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :name-encode "ICounted",
                                 :implementations #{"Subvec"
                                                    "PersistentQueue"
                                                    "PersistentHashMap"
                                                    "PersistentTreeSet"
                                                    "PersistentArrayMapSeq"
                                                    "RedNode"
                                                    "TransientArrayMap"
                                                    "EmptyList"
                                                    "ObjMap"
                                                    "ArrayChunk"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "ChunkBuffer"
                                                    "Range"
                                                    "TransientVector"
                                                    "IndexedSeq"
                                                    "PersistentTreeMap"
                                                    "PersistentTreeMapSeq"
                                                    "RSeq"
                                                    "PersistentArrayMap"
                                                    "PersistentHashSet"
                                                    "List"
                                                    "TransientHashMap"
                                                    "nil"
                                                    "TransientHashSet"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ICounted",
                                 :source {:code "(defprotocol ICounted\n  (^number -count [coll] \"constant time count\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [229 230]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "constant time count"}],
                                 :full-name "cljs.core/ICounted"},
           "cljs.core/quote" {:ns "cljs.core",
                              :name "quote",
                              :type "special form",
                              :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _]\n  (analyze (assoc env :quoted? true) x))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [876 878]},
                              :full-name "cljs.core/quote",
                              :full-name-encode "cljs.core/quote",
                              :name-encode "quote",
                              :history [["+" "0.0-927"]]},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :name-encode "IEquiv",
                               :implementations #{"Subvec"
                                                  "Symbol"
                                                  "PersistentQueue"
                                                  "PersistentHashMap"
                                                  "PersistentTreeSet"
                                                  "js/Date"
                                                  "PersistentArrayMapSeq"
                                                  "RedNode"
                                                  "EmptyList"
                                                  "ObjMap"
                                                  "BlackNode"
                                                  "PersistentVector"
                                                  "ValSeq"
                                                  "ChunkedCons"
                                                  "Range"
                                                  "PersistentQueueSeq"
                                                  "ChunkedSeq"
                                                  "ArrayNodeSeq"
                                                  "KeySeq"
                                                  "IndexedSeq"
                                                  "number"
                                                  "PersistentTreeMap"
                                                  "PersistentTreeMapSeq"
                                                  "RSeq"
                                                  "PersistentArrayMap"
                                                  "Keyword"
                                                  "PersistentHashSet"
                                                  "NodeSeq"
                                                  "List"
                                                  "Atom"
                                                  "Cons"
                                                  "default"
                                                  "LazySeq"
                                                  "NeverEquiv"
                                                  "UUID"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (^boolean -equiv [o other]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [297 298]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IEquiv"},
           "cljs.core/reduce-kv" {:ns "cljs.core",
                                  :name "reduce-kv",
                                  :signature ["[f init coll]"],
                                  :name-encode "reduce-kv",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/reduce-kv",
                                  :source {:code "(defn reduce-kv\n  ([f init coll]\n    (if-not (nil? coll)\n      (-kv-reduce coll f init)\n      init)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1443 1453]},
                                  :full-name "cljs.core/reduce-kv",
                                  :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
           "cljs.core/js-delete" {:ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :name-encode "js-delete",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/js-delete",
                                  :source {:code "(defn js-delete [obj key]\n  (cljs.core/js-delete obj key))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1195 1196]},
                                  :extra-sources [{:code "(defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [282 283]}],
                                  :full-name "cljs.core/js-delete"},
           "cljs.core/PersistentTreeSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeSet.EMPTY",
                                                :name-encode "PersistentTreeSetDOTEMPTY",
                                                :parent-type "PersistentTreeSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeSetDOTEMPTY",
                                                :source {:code "(set! cljs.core.PersistentTreeSet.EMPTY\n  (PersistentTreeSet. nil cljs.core.PersistentTreeMap.EMPTY 0))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [6374
                                                                 6375]},
                                                :full-name "cljs.core/PersistentTreeSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/comment" {:ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :name-encode "comment",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.5.1",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4265 4268]},
                                :full-name "cljs.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :signature ["[t not-found]"],
                                          :name-encode "special-symbols",
                                          :type "function",
                                          :full-name-encode "cljs.reader/special-symbols",
                                          :source {:code "(defn special-symbols [t not-found]\n  (cond\n   (identical? t \"nil\") nil\n   (identical? t \"true\") true\n   (identical? t \"false\") false\n   :else not-found))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [310 315]},
                                          :full-name "cljs.reader/special-symbols",
                                          :history [["+" "0.0-927"]]},
           "compiler-options/output-wrapper" {:ns "compiler-options",
                                              :name "output-wrapper",
                                              :name-encode "output-wrapper",
                                              :type "option",
                                              :full-name-encode "compiler-options/output-wrapper",
                                              :full-name "compiler-options/output-wrapper",
                                              :history [["+"
                                                         "0.0-1513"]]},
           "cljs.core/js*" {:ns "cljs.core",
                            :name "js*",
                            :type "special form",
                            :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _]\n  (when-not (string? jsform)\n    (throw (error env \"Invalid js* form\")))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (lazy-seq\n                         (cons (subs s 0 idx)\n                           (seg (subs s (inc end)))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       (when (-> form meta :numeric)\n         (let [types (map #(infer-tag env %) argexprs)]\n           (when-not (every?\n                       (fn [t]\n                         (or (nil? t)\n                             (and (symbol? t) ('#{any number} t))\n                             ;; TODO: type inference is not strong enough to detect that\n                             ;; when functions like first won't return nil, so variadic\n                             ;; numeric functions like cljs.core/< would produce a spurious\n                             ;; warning without this - David\n                             (and (set? t) (set/subset? t '#{any number nil clj-nil}))))\n                       types)\n             (warning :invalid-arithmetic env\n               {:js-op (-> form meta :js-op)\n                :types (into [] types)}))))\n       {:env env :op :js :segs (seg jsform) :args argexprs\n        :tag (or (-> form meta :tag)\n                 (and (-> form meta :numeric) 'number)\n                 nil)\n        :form form :children argexprs\n        :js-op (-> form meta :js-op)\n        :numeric (-> form meta :numeric)}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (lazy-seq\n                           (cons (subs s 0 idx)\n                             (cons inner\n                               (interp (subs s (inc end))))))))))]\n      {:env env :op :js :form form :code (apply str (interp jsform))\n       :tag (or (-> form meta :tag)\n                (and (-> form meta :numeric) 'number)\n                nil)\n       :js-op (-> form meta :js-op)\n       :numeric (-> form meta :numeric)})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [1256 1309]},
                            :extra-sources ({:code "(defmethod emit* :js\n  [{:keys [env code segs args]}]\n  (emit-wrap env\n             (if code\n               (emits code)\n               (emits (interleave (concat segs (repeat nil))\n                                  (concat args [nil]))))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [835 841]}),
                            :full-name "cljs.core/js*",
                            :full-name-encode "cljs.core/jsSTAR",
                            :name-encode "jsSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.core/BitmapIndexedNode.EMPTY" {:ns "cljs.core",
                                                :name "BitmapIndexedNode.EMPTY",
                                                :name-encode "BitmapIndexedNodeDOTEMPTY",
                                                :parent-type "BitmapIndexedNode",
                                                :type "var",
                                                :full-name-encode "cljs.core/BitmapIndexedNodeDOTEMPTY",
                                                :source {:code "(set! cljs.core.BitmapIndexedNode.EMPTY (BitmapIndexedNode. nil 0 (make-array 0)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [4754]},
                                                :full-name "cljs.core/BitmapIndexedNode.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.reader/register-default-tag-parser!" {:ns "cljs.reader",
                                                       :name "register-default-tag-parser!",
                                                       :signature ["[f]"],
                                                       :name-encode "register-default-tag-parserBANG",
                                                       :type "function",
                                                       :full-name-encode "cljs.reader/register-default-tag-parserBANG",
                                                       :source {:code "(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r2199",
                                                                :filename "src/cljs/cljs/reader.cljs",
                                                                :lines [589
                                                                        593]},
                                                       :full-name "cljs.reader/register-default-tag-parser!",
                                                       :history [["+"
                                                                  "0.0-1576"]]},
           "cljs.core/alength" {:return-type number,
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[array]"],
                                :name-encode "alength",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/alength",
                                :source {:code "(defn ^number alength\n  [array]\n  (cljs.core/alength array))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [184 187]},
                                :extra-sources [{:code "(defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [1416 1419]}],
                                :full-name "cljs.core/alength",
                                :docstring "Returns the length of the array. Works on arrays of all types."},
           "cljs.core/mk-bound-fn" {:ns "cljs.core",
                                    :name "mk-bound-fn",
                                    :signature ["[sc test key]"],
                                    :name-encode "mk-bound-fn",
                                    :type "function",
                                    :full-name-encode "cljs.core/mk-bound-fn",
                                    :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [6504 6508]},
                                    :full-name "cljs.core/mk-bound-fn",
                                    :history [["+" "0.0-1211"]]},
           "cljs.reader/validate-unicode-escape" {:ns "cljs.reader",
                                                  :name "validate-unicode-escape",
                                                  :signature ["[unicode-pattern reader escape-char unicode-str]"],
                                                  :name-encode "validate-unicode-escape",
                                                  :type "function",
                                                  :full-name-encode "cljs.reader/validate-unicode-escape",
                                                  :source {:code "(defn validate-unicode-escape [unicode-pattern reader escape-char unicode-str]\n  (if (re-matches unicode-pattern unicode-str)\n    unicode-str\n    (reader-error reader \"Unexpected unicode escape \\\\\" escape-char unicode-str)))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/cljs/cljs/reader.cljs",
                                                           :lines [190
                                                                   193]},
                                                  :full-name "cljs.reader/validate-unicode-escape",
                                                  :history [["+"
                                                             "0.0-1424"]]},
           "repl-options/static-dir" {:ns "repl-options",
                                      :name "static-dir",
                                      :name-encode "static-dir",
                                      :type "option",
                                      :full-name-encode "repl-options/static-dir",
                                      :full-name "repl-options/static-dir",
                                      :history [["+" "0.0-1211"]]},
           "cljs.core/VectorNode" {:ns "cljs.core",
                                   :name "VectorNode",
                                   :signature ["[edit arr]"],
                                   :name-encode "VectorNode",
                                   :type "type",
                                   :full-name-encode "cljs.core/VectorNode",
                                   :source {:code "(deftype VectorNode [edit arr])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3228]},
                                   :full-name "cljs.core/VectorNode",
                                   :history [["+" "0.0-1211"]]},
           "cljs.core/string-hash-cache-count" {:ns "cljs.core",
                                                :name "string-hash-cache-count",
                                                :name-encode "string-hash-cache-count",
                                                :type "var",
                                                :full-name-encode "cljs.core/string-hash-cache-count",
                                                :source {:code "(def string-hash-cache-count 0)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1094]},
                                                :full-name "cljs.core/string-hash-cache-count",
                                                :history [["+"
                                                           "0.0-1424"]]},
           "cljs.core/tree-seq" {:ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :name-encode "tree-seq",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3089 3102]},
                                 :full-name "cljs.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :signature ["[rdr ch]"],
                                                   :name-encode "read-unmatched-delimiter",
                                                   :type "function",
                                                   :full-name-encode "cljs.reader/read-unmatched-delimiter",
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmached delimiter \" ch))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [266
                                                                    268]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.core.reducers/take-while" {:ns "clojure.core.reducers",
                                               :name "take-while",
                                               :signature ["[pred]"
                                                           "[pred coll]"],
                                               :name-encode "take-while",
                                               :history [["+"
                                                          "0.0-1236"]],
                                               :type "function",
                                               :full-name-encode "clojure.core.reducers/take-while",
                                               :source {:code "(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/clojure/core/reducers.cljs",
                                                        :lines [152
                                                                162]},
                                               :full-name "clojure.core.reducers/take-while",
                                               :docstring "Ends the reduction of coll when (pred val) returns logical false."},
           "cljs.reader/register-tag-parser!" {:ns "cljs.reader",
                                               :name "register-tag-parser!",
                                               :signature ["[tag f]"],
                                               :name-encode "register-tag-parserBANG",
                                               :type "function",
                                               :full-name-encode "cljs.reader/register-tag-parserBANG",
                                               :source {:code "(defn register-tag-parser!\n  [tag f]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [575
                                                                580]},
                                               :full-name "cljs.reader/register-tag-parser!",
                                               :history [["+"
                                                          "0.0-1236"]]},
           "cljs.core/every-pred" {:ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :name-encode "every-pred",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2833 2870]},
                                   :full-name "cljs.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "cljs.core/PersistentHashSet" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IEditableCollection"
                                                       "IEmptyableCollection"
                                                       "ISet"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentHashSet",
                                          :signature ["[meta hash-map __hash]"],
                                          :name-encode "PersistentHashSet",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashSet",
                                          :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashSet. meta hash-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentHashSet.EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-iset __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6186 6243]},
                                          :full-name "cljs.core/PersistentHashSet"},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :name-encode "rename-keys",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set/rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce \n     (fn [m [old new]]\n       (if (and (not= old new)\n                (contains? m old))\n         (-> m (assoc new (get m old)) (dissoc old))\n         m)) \n     map kmap))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/clojure/set.cljs",
                                               :lines [72 81]},
                                      :full-name "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :name-encode "peek",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/peek",
                             :source {:code "(defn peek\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1063 1068]},
                             :full-name "cljs.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :name-encode "pr-str-with-opts",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [6908 6914]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/IChunk" {:ns "cljs.core",
                               :name "IChunk",
                               :name-encode "IChunk",
                               :implementations #{"ArrayChunk"},
                               :history [["+" "0.0-1424"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IChunk",
                               :source {:code "(defprotocol IChunk\n  (-drop-first [coll]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [367 368]},
                               :methods [{:name "-drop-first",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IChunk"},
           "cljs.core/ITransientVector" {:ns "cljs.core",
                                         :name "ITransientVector",
                                         :name-encode "ITransientVector",
                                         :implementations #{"TransientVector"},
                                         :history [["+" "0.0-1211"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/ITransientVector",
                                         :source {:code "(defprotocol ITransientVector\n  (^clj -assoc-n! [tcoll n val])\n  (^clj -pop! [tcoll]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [357 359]},
                                         :methods [{:name "-assoc-n!",
                                                    :signature ["[tcoll n val]"],
                                                    :docstring nil}
                                                   {:name "-pop!",
                                                    :signature ["[tcoll]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/ITransientVector"},
           "cljs.core/IPrintWithWriter" {:ns "cljs.core",
                                         :name "IPrintWithWriter",
                                         :name-encode "IPrintWithWriter",
                                         :implementations #{"Subvec"
                                                            "Symbol"
                                                            "PersistentQueue"
                                                            "PersistentHashMap"
                                                            "PersistentTreeSet"
                                                            "PersistentArrayMapSeq"
                                                            "RedNode"
                                                            "EmptyList"
                                                            "ObjMap"
                                                            "BlackNode"
                                                            "PersistentVector"
                                                            "ValSeq"
                                                            "ChunkedCons"
                                                            "Range"
                                                            "ChunkedSeq"
                                                            "ArrayNodeSeq"
                                                            "KeySeq"
                                                            "IndexedSeq"
                                                            "PersistentTreeMap"
                                                            "PersistentTreeMapSeq"
                                                            "RSeq"
                                                            "PersistentArrayMap"
                                                            "Keyword"
                                                            "PersistentHashSet"
                                                            "NodeSeq"
                                                            "List"
                                                            "Atom"
                                                            "Cons"
                                                            "LazySeq"
                                                            "UUID"},
                                         :history [["+" "0.0-1503"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/IPrintWithWriter",
                                         :source {:code "(defprotocol IPrintWithWriter\n  \"The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.\"\n  (-pr-writer [o writer opts]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [328 334]},
                                         :methods [{:name "-pr-writer",
                                                    :signature ["[o writer opts]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/IPrintWithWriter",
                                         :docstring "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."},
           "cljs.core/map?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :name-encode "mapQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapQMARK",
                             :source {:code "(defn ^boolean map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1167 1172]},
                             :full-name "cljs.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "compiler-options/elide-asserts" {:ns "compiler-options",
                                             :name "elide-asserts",
                                             :name-encode "elide-asserts",
                                             :type "option",
                                             :full-name-encode "compiler-options/elide-asserts",
                                             :full-name "compiler-options/elide-asserts",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "syntax/predicate" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "predicate",
                               :name-encode "predicate",
                               :type "convention",
                               :full-name-encode "syntax/predicate",
                               :full-name "syntax/predicate",
                               :history [["+" "0.0-927"]]},
           "cljs.reader/StringPushbackReader" {:protocols #{"PushbackReader"},
                                               :ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :signature ["[s buffer idx]"],
                                               :name-encode "StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "type",
                                               :full-name-encode "cljs.reader/StringPushbackReader",
                                               :source {:code "(deftype StringPushbackReader [s buffer ^:mutable idx]\n  PushbackReader\n  (read-char [reader]\n    (if (zero? (alength buffer))\n      (do\n        (set! idx (inc idx))\n        (aget s idx))\n      (.pop buffer)))\n  (unread [reader ch]\n    (.push buffer ch)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [17 26]},
                                               :full-name "cljs.reader/StringPushbackReader"},
           "cljs.core/PersistentTreeMap" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMap"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IKVReduce"
                                                       "IReversible"
                                                       "IEmptyableCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ISorted"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IAssociative"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentTreeMap",
                                          :signature ["[comp tree cnt meta __hash]"],
                                          :name-encode "PersistentTreeMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeMap",
                                          :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.PersistentTreeMap.EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (tree-map-kv-reduce tree f init)\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5843 5965]},
                                          :full-name "cljs.core/PersistentTreeMap"},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :name-encode "HashMapDOTfromArrays",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1798"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core/HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (alength ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1586",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3832 3837]},
                                           :full-name "cljs.core/HashMap.fromArrays",
                                           :removed {:in "0.0-1798",
                                                     :last-seen "0.0-1586"}},
           "cljs.core/deref" {:ns "cljs.core",
                              :name "deref",
                              :signature ["[o]"],
                              :name-encode "deref",
                              :type "function",
                              :full-name-encode "cljs.core/deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7168 7170]},
                              :full-name "cljs.core/deref",
                              :history [["+" "0.0-927"]]},
           "cljs.core/reductions" {:ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :name-encode "reductions",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [6656 6668]},
                                   :full-name "cljs.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :name-encode "falseQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/falseQMARK",
                               :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1218 1220]},
                               :extra-sources [{:code "(defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [288 289]}],
                               :full-name "cljs.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "warnings/undeclared-protocol-symbol" {:ns "warnings",
                                                  :name "undeclared-protocol-symbol",
                                                  :type "warning",
                                                  :full-name "warnings/undeclared-protocol-symbol",
                                                  :full-name-encode "warnings/undeclared-protocol-symbol",
                                                  :name-encode "undeclared-protocol-symbol",
                                                  :history [["+"
                                                             "0.0-2014"]]},
           "cljs.core/bit-flip" {:ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :name-encode "bit-flip",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1733 1736]},
                                 :extra-sources [{:code "(defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [509 510]}],
                                 :full-name "cljs.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :name-encode "ISet",
                             :implementations #{"PersistentTreeSet"
                                                "PersistentHashSet"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISet",
                             :source {:code "(defprotocol ISet\n  (^clj -disjoin [coll v]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [269 270]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISet"},
           "repl-options/working-dir" {:ns "repl-options",
                                       :name "working-dir",
                                       :name-encode "working-dir",
                                       :type "option",
                                       :full-name-encode "repl-options/working-dir",
                                       :full-name "repl-options/working-dir",
                                       :history [["+" "0.0-971"]]},
           "cljs.core/LazySeq" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "INext"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta fn s __hash]"],
                                :name-encode "LazySeq",
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/LazySeq",
                                :source {:code "(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta fn s __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n            (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2152 2213]},
                                :full-name "cljs.core/LazySeq"},
           "cljs.core/pop!" {:ns "cljs.core",
                             :name "pop!",
                             :signature ["[tcoll]"],
                             :name-encode "popBANG",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/popBANG",
                             :source {:code "(defn pop!\n  [tcoll]\n  (-pop! tcoll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2550 2554]},
                             :full-name "cljs.core/pop!",
                             :docstring "Removes the last item from a transient vector. If\nthe collection is empty, throws an exception. Returns coll"},
           "cljs.reader/parse-timestamp" {:ns "cljs.reader",
                                          :name "parse-timestamp",
                                          :signature ["[ts]"],
                                          :name-encode "parse-timestamp",
                                          :type "function",
                                          :full-name-encode "cljs.reader/parse-timestamp",
                                          :source {:code "(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n     (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (reader-error nil (str \"Unrecognized date/time syntax: \" ts))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [505 512]},
                                          :full-name "cljs.reader/parse-timestamp",
                                          :history [["+" "0.0-1424"]]},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :name-encode "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino/IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/repl/rhino.clj",
                                             :lines [25 26]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/chunk-first" {:ns "cljs.core",
                                    :name "chunk-first",
                                    :signature ["[s]"],
                                    :name-encode "chunk-first",
                                    :type "function",
                                    :full-name-encode "cljs.core/chunk-first",
                                    :source {:code "(defn chunk-first [s]\n  (-chunked-first s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2337 2338]},
                                    :full-name "cljs.core/chunk-first",
                                    :history [["+" "0.0-1424"]]},
           "cljs.core/ChunkedSeq" {:protocols #{"IChunkedNext"
                                                "ISeqable"
                                                "IWithMeta"
                                                "IEmptyableCollection"
                                                "IReduce"
                                                "ISequential"
                                                "ISeq"
                                                "ICollection"
                                                "IHash"
                                                "ASeq"
                                                "IPrintWithWriter"
                                                "IChunkedSeq"
                                                "INext"
                                                "IEquiv"},
                                   :ns "cljs.core",
                                   :name "ChunkedSeq",
                                   :signature ["[vec node i off meta __hash]"],
                                   :name-encode "ChunkedSeq",
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ChunkedSeq",
                                   :source {:code "(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n\n  IWithMeta\n  (-with-meta [coll m]\n    (chunked-seq vec node i off m))\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta cljs.core.PersistentVector.EMPTY meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f))\n\n  (-reduce [coll f start]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f start)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3510 3579]},
                                   :full-name "cljs.core/ChunkedSeq"},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :name-encode "start-server",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [265 270]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port.",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/*2" {:ns "cljs.core",
                           :name "*2",
                           :name-encode "STAR2",
                           :type "var",
                           :full-name-encode "cljs.core/STAR2",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [61 63]},
                           :full-name "cljs.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.repl.server/send-and-close" {:ns "cljs.repl.server",
                                              :name "send-and-close",
                                              :signature ["[conn status form]"
                                                          "[conn status form content-type]"],
                                              :name-encode "send-and-close",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/send-and-close",
                                              :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/clj/cljs/repl/server.clj",
                                                       :lines [107
                                                               128]},
                                              :full-name "cljs.repl.server/send-and-close",
                                              :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :signature ["[]"],
                                                         :name-encode "total-listener-count",
                                                         :type "function",
                                                         :full-name-encode "clojure.browser.event/total-listener-count",
                                                         :source {:code "(defn total-listener-count []\n  (goog.events/getTotalListenerCount))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2199",
                                                                  :filename "src/cljs/clojure/browser/event.cljs",
                                                                  :lines [85
                                                                          86]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/alter-meta!" {:ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[iref f & args]"],
                                    :name-encode "alter-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7218 7225]},
                                    :full-name "cljs.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :signature ["[e]"],
                                                :name-encode "click-element",
                                                :type "function",
                                                :full-name-encode "clojure.browser.dom/click-element",
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/clojure/browser/dom.cljs",
                                                         :lines [147
                                                                 149]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "closure-warnings/constant-property" {:ns "closure-warnings",
                                                 :name "constant-property",
                                                 :type "warning",
                                                 :full-name "closure-warnings/constant-property",
                                                 :full-name-encode "closure-warnings/constant-property",
                                                 :name-encode "constant-property",
                                                 :history [["+"
                                                            "0.0-2120"]]},
           "cljs.core/unchecked-remainder-int" {:ns "cljs.core",
                                                :name "unchecked-remainder-int",
                                                :signature ["[x n]"],
                                                :name-encode "unchecked-remainder-int",
                                                :history [["+"
                                                           "0.0-1798"]],
                                                :type "function/macro",
                                                :full-name-encode "cljs.core/unchecked-remainder-int",
                                                :source {:code "(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))",
                                                         :title "Function code",
                                                         :repo "clojurescript",
                                                         :tag "r2199",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1630
                                                                 1631]},
                                                :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(mod ~x ~n)))",
                                                                 :title "Macro code",
                                                                 :repo "clojurescript",
                                                                 :tag "r2199",
                                                                 :filename "src/clj/cljs/core.clj",
                                                                 :lines [394
                                                                         395]}],
                                                :full-name "cljs.core/unchecked-remainder-int"},
           "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                  :name "bit-shift-right-zero-fill",
                                                  :signature ["[x n]"],
                                                  :name-encode "bit-shift-right-zero-fill",
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function/macro",
                                                  :full-name-encode "cljs.core/bit-shift-right-zero-fill",
                                                  :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                           :title "Function code",
                                                           :repo "clojurescript",
                                                           :tag "r2199",
                                                           :filename "src/cljs/cljs/core.cljs",
                                                           :lines [1760
                                                                   1762]},
                                                  :extra-sources [{:code "(defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                   :title "Macro code",
                                                                   :repo "clojurescript",
                                                                   :tag "r2199",
                                                                   :filename "src/clj/cljs/core.clj",
                                                                   :lines [521
                                                                           522]}],
                                                  :full-name "cljs.core/bit-shift-right-zero-fill",
                                                  :docstring "DEPRECATED: Bitwise shift right with zero fill"},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :signature ["[opts server-socket]"],
                                            :name-encode "server-loop",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/server-loop",
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [258 263]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-meta",
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-meta",
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [359 367]},
                                    :full-name "cljs.reader/read-meta",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.server/send-404" {:ns "cljs.repl.server",
                                        :name "send-404",
                                        :signature ["[conn path]"],
                                        :name-encode "send-404",
                                        :type "function",
                                        :full-name-encode "cljs.repl.server/send-404",
                                        :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [130 136]},
                                        :full-name "cljs.repl.server/send-404",
                                        :history [["+" "0.0-1503"]]},
           "syntax/ignore" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "ignore",
                            :name-encode "ignore",
                            :type "syntax",
                            :full-name-encode "syntax/ignore",
                            :extra-sources ({:code "(defn- read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [348 351]}
                                            {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.3",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [599 610]}),
                            :full-name "syntax/ignore",
                            :history [["+" "0.0-1853"]]},
           "syntax/destructure-vector" {:syntax-equiv {:edn-url nil,
                                                       :clj-url nil},
                                        :ns "syntax",
                                        :name "destructure-vector",
                                        :name-encode "destructure-vector",
                                        :type "binding",
                                        :full-name-encode "syntax/destructure-vector",
                                        :source {:code "(defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n         pb (fn pb [bvec b v]\n              (core/let [pvec\n                     (fn [bvec b val]\n                       (core/let [gvec (gensym \"vec__\")]\n                         (core/loop [ret (-> bvec (conj gvec) (conj val))\n                                     n 0\n                                     bs b\n                                     seen-rest? false]\n                           (if (seq bs)\n                             (core/let [firstb (first bs)]\n                               (core/cond\n                                 (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                      n\n                                                      (nnext bs)\n                                                      true)\n                                 (= firstb :as) (pb ret (second bs) gvec)\n                                 :else (if seen-rest?\n                                         (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                         (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                (core/inc n)\n                                                (next bs)\n                                                seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (core/let [gmap (gensym \"map__\")\n                                  defaults (:or b)]\n                         (core/loop [ret (-> bvec (conj gmap) (conj v)\n                                             (conj gmap) (conj `(if (seq? ~gmap) (apply core/hash-map ~gmap) ~gmap))\n                                             ((fn [ret]\n                                                (if (:as b)\n                                                  (conj ret (:as b) gmap)\n                                                  ret))))\n                                     bes (reduce\n                                          (fn [bes entry]\n                                            (reduce #(assoc %1 %2 ((val entry) %2))\n                                                    (dissoc bes (key entry))\n                                                    ((key entry) bes)))\n                                          (dissoc b :as :or)\n                                          {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                           :strs core/str, :syms #(core/list `quote %)})]\n                           (if (seq bes)\n                             (core/let [bb (key (first bes))\n                                        bk (val (first bes))\n                                        has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (core/list `get gmap bk (defaults bb))\n                                                   (core/list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                    (core/cond\n                      (core/symbol? b) (-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw (new Exception (core/str \"Unsupported binding form: \" b))))))\n         process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n        (if (every? core/symbol? (map first bents))\n          bindings\n          (if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n            (throw (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs))))\n            (reduce process-entry [] bents)))))",
                                                 :title "Parser code",
                                                 :repo "clojurescript",
                                                 :tag "r2199",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [77 140]},
                                        :full-name "syntax/destructure-vector",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/range" {:ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :name-encode "range",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/range",
                              :source {:code "(defn range\n  ([] (range 0 js/Number.MAX_VALUE 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step nil)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6615 6622]},
                              :full-name "cljs.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :signature ["[line rdr]"],
                                          :name-encode "read-post",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser/read-post",
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1450",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [143 152]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :removed {:in "0.0-1503",
                                                    :last-seen "0.0-1450"}},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :name-encode "reify",
                              :type "macro",
                              :full-name-encode "cljs.core/reify",
                              :source {:code "(defmacro reify [& impls]\n  (let [t      (gensym \"t\")\n        meta-sym (gensym \"meta\")\n        this-sym (gensym \"_\")\n        locals (keys (:locals &env))\n        ns     (-> &env :ns :name)\n        munge  cljs.compiler/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals nil))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [602 618]},
                              :full-name "cljs.core/reify",
                              :history [["+" "0.0-927"]]},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :name-encode "satisfiesQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/satisfiesQMARK",
                                   :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p          (:name\n                     (cljs.analyzer/resolve-var\n                       (dissoc &env :locals) psym))\n         prefix     (protocol-prefix p)\n         xsym       (bool-expr (gensym))\n         [part bit] (fast-path-protocols p)\n         msym       (symbol\n                      (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if ~xsym\n         (let [bit# ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))]\n           (if (or bit#\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false)))\n         (cljs.core/native-satisfies? ~psym ~xsym)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1020 1040]},
                                   :full-name "cljs.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :name-encode "nth",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/nth",
                            :source {:code "(defn nth\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number\"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n)\n\n      (array? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (string? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      (satisfies? ISeq coll)\n      (linear-traversal-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number.\"))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n not-found)\n\n      (array? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (string? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      (satisfies? ISeq coll)\n      (linear-traversal-nth coll n not-found)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [903 965]},
                            :full-name "cljs.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:ns "cljs.core",
                             :name "list",
                             :signature ["[& xs]"],
                             :name-encode "list",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/list",
                             :source {:code "(defn list [& xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) ^not-native r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2016 2029]},
                             :extra-sources [{:code "(defmacro list\n  ([] `cljs.core.List.EMPTY)\n  ([x & xs]\n    `(-conj (list ~@xs) ~x)))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1333 1336]}],
                             :full-name "cljs.core/list"},
           "cljs.core/defn" {:ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                         "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                             :name-encode "defn",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/defn",
                             :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n        (if (instance? clojure.lang.Symbol name)\n          nil\n          (throw (IllegalArgumentException. \"First argument to defn must be a symbol\")))\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.5.1",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [266 316]},
                             :full-name "cljs.core/defn",
                             :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
           "cljs.core/rand-nth" {:ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :name-encode "rand-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7425 7430]},
                                 :full-name "cljs.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/ex-cause" {:ns "cljs.core",
                                 :name "ex-cause",
                                 :signature ["[ex]"],
                                 :name-encode "ex-cause",
                                 :history [["+" "0.0-1576"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/ex-cause",
                                 :source {:code "(defn ex-cause\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7768 7775]},
                                 :full-name "cljs.core/ex-cause",
                                 :docstring "Alpha - subject to change.\nReturns exception cause (an Error / ExceptionInfo) if ex is an\nExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/def" {:ns "cljs.core",
                            :name "def",
                            :type "special form",
                            :source {:code "(defmethod parse 'def\n  [op env form name]\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)]\n    (when (namespace sym)\n      (throw (error env \"Can't def ns-qualified name\")))\n    (when-let [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env \"Too many arguments to def\"))))\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (get-in @env/*compiler* [::namespaces ns-name :uses sym]))\n                (let [ev (resolve-existing-var (dissoc env :locals) sym)]\n                  (warning :redef env {:ev ev :sym sym :ns-name ns-name})\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes] conj sym)\n                  (update-in env [:ns :excludes] conj sym))\n                env)\n          name (:name (resolve-var (dissoc env :locals) sym))\n          var-expr (assoc (analyze (-> env (dissoc :locals)\n                                       (assoc :context :expr)\n                                       (assoc :def-var true))\n                                   sym)\n                     :op :var)\n          init-expr (when (contains? args :init)\n                      (disallowing-recur\n                        (analyze (assoc env :context :expr) (:init args) sym)))\n          fn-var? (and init-expr (= (:op init-expr) :fn))\n          tag (if fn-var?\n                (or (:ret-tag init-expr) tag)\n                tag)\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-> sym meta :declared))\n                   (and (:fn-var v) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n        (merge \n          {:name name}\n          sym-meta\n          (when doc {:doc doc})\n          (when dynamic {:dynamic true})\n          (source-info name env)\n          ;; the protocol a protocol fn belongs to\n          (when protocol\n            {:protocol protocol})\n          ;; symbol for reified protocol\n          (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n            {:protocol-symbol protocol-symbol\n              :impls #{}})\n          (when fn-var?\n            {:fn-var true\n             ;; protocol implementation context\n             :protocol-impl (:protocol-impl init-expr)\n             ;; inline protocol implementation context\n             :protocol-inline (:protocol-inline init-expr)\n             :variadic (:variadic init-expr)\n             :max-fixed-arity (:max-fixed-arity init-expr)\n             :method-params (map :params (:methods init-expr))\n             :methods (map (fn [method]\n                             (let [tag (infer-tag env (assoc method :op :method))]\n                               (cond-> (select-keys method\n                                         [:max-fixed-arity :variadic])\n                                 tag (assoc :tag tag))))\n                        (:methods init-expr))})\n          (when (and fn-var? tag)\n            {:ret-tag tag})))\n      (merge {:env env :op :def :form form\n              :name name :var var-expr :doc doc :init init-expr}\n        (when tag\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when dynamic {:dynamic true})\n        (when export-as {:export export-as})\n        (when init-expr {:children [init-expr]})))))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2199",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [550 635]},
                            :extra-sources ({:code "(defmethod emit* :def\n  [{:keys [name var init env doc export]}]\n  (let [mname (munge name)]\n    (when init\n      (emit-comment doc (:jsdoc init))\n      (emits var)\n      (emits \" = \" init)\n      ;; NOTE: JavaScriptCore does not like this under advanced compilation\n      ;; this change was primarily for REPL interactions - David\n      ;(emits \" = (typeof \" mname \" != 'undefined') ? \" mname \" : undefined\")\n      (when-not (= :expr (:context env)) (emitln \";\"))\n      (when export\n        (emitln \"goog.exportSymbol('\" (munge export) \"', \" mname \");\")))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [411 423]}),
                            :full-name "cljs.core/def",
                            :full-name-encode "cljs.core/def",
                            :name-encode "def",
                            :history [["+" "0.0-927"]]},
           "cljs.core/atom" {:ns "cljs.core",
                             :name "atom",
                             :signature ["[x]"
                                         "[x & {:keys [meta validator]}]"],
                             :name-encode "atom",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7134 7149]},
                             :full-name "cljs.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :signature ["[reader initch]"],
                                       :name-encode "read-keyword",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-keyword",
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        a (re-matches* symbol-pattern token)\n        token (aget a 0)\n        ns (aget a 1)\n        name (aget a 2)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if (and (not (nil? ns)) (> (.-length ns) 0))\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [325 339]},
                                       :full-name "cljs.reader/read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IStack"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "IReduce"
                                            "ILookup"
                                            "ISequential"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "IIndexed"
                                            "IAssociative"
                                            "IVector"
                                            "IPrintable"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Vector",
                               :signature ["[meta array __hash]"],
                               :name-encode "Vector",
                               :history [["+" "0.0-927"]
                                         ["-" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Vector",
                               :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (alength array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (alength array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (alength array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (alength array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (alength array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (alength array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1586",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2772 2857]},
                               :full-name "cljs.core/Vector",
                               :removed {:in "0.0-1798",
                                         :last-seen "0.0-1586"}},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :name-encode "skip-line",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\newline) (identical? ch \\return) (nil? ch))\n        reader\n        (recur)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [88 95]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :name-encode "namespace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (implements? INamed x)\n    (-namespace ^not-native x)\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2130 2135]},
                                  :full-name "cljs.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :name-encode "require",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/require",
                                  :source {:code "(def require (js* \"require\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [7]},
                                  :full-name "cljs.nodejs/require",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/chunk-rest" {:ns "cljs.core",
                                   :name "chunk-rest",
                                   :signature ["[s]"],
                                   :name-encode "chunk-rest",
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-rest",
                                   :source {:code "(defn chunk-rest [s]\n  (-chunked-rest s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2340 2341]},
                                   :full-name "cljs.core/chunk-rest",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/unchecked-long" {:ns "cljs.core",
                                       :name "unchecked-long",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-long",
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/unchecked-long",
                                       :source {:code "(defn unchecked-long\n  [x]\n  (fix x))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1667 1670]},
                                       :full-name "cljs.core/unchecked-long",
                                       :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.repl.server/connection" {:ns "cljs.repl.server",
                                          :name "connection",
                                          :signature ["[]"],
                                          :name-encode "connection",
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.server/connection",
                                          :source {:code "(defn connection\n  []\n  (let [p (promise)\n        conn (:connection @state)]\n    (if (and conn (not (.isClosed conn)))\n      (do (deliver p conn)\n          p)\n      (do (swap! state (fn [old] (assoc old :promised-conn p)))\n          p))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/repl/server.clj",
                                                   :lines [20 30]},
                                          :full-name "cljs.repl.server/connection",
                                          :docstring "Promise to return a connection when one is available. If a\nconnection is not available, store the promise in server/state."},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :name-encode "EventType",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event/EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2199",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :signature ["[repl-env]"],
                                          :name-encode "rhino-setup",
                                          :type "function",
                                          :full-name-encode "cljs.repl.rhino/rhino-setup",
                                          :source {:code "(defn rhino-setup [repl-env]\n  (let [env (ana/empty-env)\n        scope (:scope repl-env)]\n    (repl/load-file repl-env \"cljs/core.cljs\")\n    (swap! (:loaded-libs repl-env) conj \"cljs.core\")\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(ns cljs.user))\n    (ScriptableObject/putProperty scope\n                                  \"out\"\n                                  (Context/javaToJS *out* scope))\n    (repl/evaluate-form repl-env\n                        env\n                        \"<cljs repl>\"\n                        '(set! *print-fn* (fn [x] (.write js/out x))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [96 111]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/merge" {:ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :name-encode "merge",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [6144 6150]},
                              :full-name "cljs.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.core.reducers/remove" {:ns "clojure.core.reducers",
                                           :name "remove",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :name-encode "remove",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/remove",
                                           :source {:code "(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [145 150]},
                                           :full-name "clojure.core.reducers/remove",
                                           :docstring "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :signature ["[connection url data]"],
                                               :name-encode "send-result",
                                               :type "function",
                                               :full-name-encode "clojure.browser.repl/send-result",
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/clojure/browser/repl.cljs",
                                                        :lines [38 39]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :name-encode "keywordize-keys",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [64 70]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "closure-warnings/unknown-defines" {:ns "closure-warnings",
                                               :name "unknown-defines",
                                               :type "warning",
                                               :full-name "closure-warnings/unknown-defines",
                                               :full-name-encode "closure-warnings/unknown-defines",
                                               :name-encode "unknown-defines",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/reduced" {:ns "cljs.core",
                                :name "reduced",
                                :signature ["[x]"],
                                :name-encode "reduced",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/reduced",
                                :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [588 591]},
                                :full-name "cljs.core/reduced",
                                :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
           "cljs.reader/read-string*" {:ns "cljs.reader",
                                       :name "read-string*",
                                       :signature ["[reader _]"],
                                       :name-encode "read-stringSTAR",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-stringSTAR",
                                       :source {:code "(defn read-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [299 308]},
                                       :full-name "cljs.reader/read-string*",
                                       :history [["+" "0.0-1236"]]},
           "cljs.core/ChunkedCons" {:protocols #{"IChunkedNext"
                                                 "ISeqable"
                                                 "IMeta"
                                                 "IWithMeta"
                                                 "IEmptyableCollection"
                                                 "ISequential"
                                                 "ISeq"
                                                 "ICollection"
                                                 "IHash"
                                                 "ASeq"
                                                 "IPrintWithWriter"
                                                 "IChunkedSeq"
                                                 "INext"
                                                 "IEquiv"},
                                    :ns "cljs.core",
                                    :name "ChunkedCons",
                                    :signature ["[chunk more meta __hash]"],
                                    :name-encode "ChunkedCons",
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkedCons",
                                    :source {:code "(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  \n  IWithMeta\n  (-with-meta [coll m]\n    (ChunkedCons. chunk more m __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (let [more (-seq more)]\n        (when-not (nil? more)\n          more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.List.EMPTY meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2266 2324]},
                                    :full-name "cljs.core/ChunkedCons"},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :name-encode "derive",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7502 7534]},
                               :full-name "cljs.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :name-encode "zipper",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "clojure.core.reducers/mapcat" {:ns "clojure.core.reducers",
                                           :name "mapcat",
                                           :signature ["[f]"
                                                       "[f coll]"],
                                           :name-encode "mapcat",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/mapcat",
                                           :source {:code "(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [106 115]},
                                           :full-name "clojure.core.reducers/mapcat",
                                           :docstring "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :name-encode "remove",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "var",
                         :name-encode "var",
                         :type "syntax",
                         :full-name-encode "syntax/var",
                         :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.3",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [599 610]}),
                         :full-name "syntax/var",
                         :history [["+" "0.0-1853"]]},
           "cljs.repl.browser/handle-post" {:ns "cljs.repl.browser",
                                            :name "handle-post",
                                            :signature ["[m _ _]"],
                                            :name-encode "handle-post",
                                            :history [["+" "0.0-927"]],
                                            :type "multimethod",
                                            :full-name-encode "cljs.repl.browser/handle-post",
                                            :source {:code "(defmulti handle-post (fn [m _ _ ] (:type m)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2199",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [109]},
                                            :extra-sources ({:code "(defmethod handle-post :ready [_ conn _]\n  (do (reset! loaded-libs @preloaded-libs)\n      (send ordering (fn [_] {:expecting nil :fns {}}))\n      (send-for-eval conn\n                     (cljsc/-compile\n                      '[(ns cljs.user)\n                        (set! *print-fn* clojure.browser.repl/repl-print)] {})\n                     identity)))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [115
                                                                     122]}
                                                            {:code "(defmethod handle-post :print [{:keys [content order]} conn _ ]\n  (do (constrain-order order (fn [] (do (print (read-string content))\n                                       (.flush *out*))))\n      (server/send-and-close conn 200 \"ignore__\")))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [142
                                                                     145]}
                                                            {:code "(defmethod handle-post :result [{:keys [content order]} conn _ ]\n  (constrain-order order (fn [] (do (return-value content)\n                                   (server/set-connection conn)))))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r2199",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [147
                                                                     149]}),
                                            :full-name "cljs.repl.browser/handle-post"},
           "cljs.core/find" {:ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :name-encode "find",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and (not (nil? coll))\n             (associative? coll)\n             (contains? coll k))\n    [k (get coll k)]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1266 1272]},
                             :full-name "cljs.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.core/hash-set" {:ns "cljs.core",
                                 :name "hash-set",
                                 :signature ["[]" "[& keys]"],
                                 :name-encode "hash-set",
                                 :history [["+" "0.0-1443"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/hash-set",
                                 :source {:code "(defn hash-set\n  ([] #{})\n  ([& keys] (set keys)))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [6400 6402]},
                                 :extra-sources [{:code "(defmacro hash-set\n  ([] `cljs.core.PersistentHashSet.EMPTY)\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op %) :constant)\n                    (map #(cljs.analyzer/analyze &env %) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core.PersistentHashSet. nil\n         (cljs.core.PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(cljs.core.PersistentHashSet.fromArray (array ~@xs) true)\n        assoc :tag 'cljs.core/PersistentHashSet))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1375 1387]}],
                                 :full-name "cljs.core/hash-set"},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :name-encode "STARprint-dupSTAR",
                                    :type "dynamic var",
                                    :full-name-encode "cljs.core/STARprint-dupSTAR",
                                    :source {:code "(def ^:dynamic *print-dup* false)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2199",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [36]},
                                    :full-name "cljs.core/*print-dup*",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/set-from-indexed-seq" {:ns "cljs.core",
                                             :name "set-from-indexed-seq",
                                             :signature ["[iseq]"],
                                             :name-encode "set-from-indexed-seq",
                                             :type "function",
                                             :full-name-encode "cljs.core/set-from-indexed-seq",
                                             :source {:code "(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2199",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [6377
                                                              6381]},
                                             :full-name "cljs.core/set-from-indexed-seq",
                                             :history [["+"
                                                        "0.0-1877"]]},
           "cljs.core/object-array" {:ns "cljs.core",
                                     :name "object-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :name-encode "object-array",
                                     :type "function",
                                     :full-name-encode "cljs.core/object-array",
                                     :source {:code "(defn object-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2431 2449]},
                                     :full-name "cljs.core/object-array",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/indexed?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "indexed?",
                                 :signature ["[x]"],
                                 :name-encode "indexedQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/indexedQMARK",
                                 :source {:code "(defn ^boolean indexed?\n  [x] (satisfies? IIndexed x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [668 670]},
                                 :full-name "cljs.core/indexed?",
                                 :docstring "Returns true if coll implements nth in constant time"},
           "cljs.core/partial" {:ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :name-encode "partial",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/partial",
                                :source {:code "(defn partial\n  ([f] f)\n  ([f arg1]\n   (fn [& args] (apply f arg1 args)))\n  ([f arg1 arg2]\n   (fn [& args] (apply f arg1 arg2 args)))\n  ([f arg1 arg2 arg3]\n   (fn [& args] (apply f arg1 arg2 arg3 args)))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2733 2745]},
                                :full-name "cljs.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "closure-warnings/invalid-casts" {:ns "closure-warnings",
                                             :name "invalid-casts",
                                             :type "warning",
                                             :full-name "closure-warnings/invalid-casts",
                                             :full-name-encode "closure-warnings/invalid-casts",
                                             :name-encode "invalid-casts",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.core/keyword?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :name-encode "keywordQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/keywordQMARK",
                                 :source {:code "(defn ^boolean keyword? [x]\n  (instance? Keyword x))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2119 2120]},
                                 :extra-sources [{:code "(defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [326 327]}],
                                 :full-name "cljs.core/keyword?"},
           "cljs.repl.rhino/stacktrace" {:ns "cljs.repl.rhino",
                                         :name "stacktrace",
                                         :name-encode "stacktrace",
                                         :type "multimethod",
                                         :full-name-encode "cljs.repl.rhino/stacktrace",
                                         :source {:code "(defmulti stacktrace class)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [39]},
                                         :full-name "cljs.repl.rhino/stacktrace",
                                         :extra-sources ({:code "(defmethod stacktrace :default [e]\n  (apply str (interpose \"\\n\" (map #(str \"        \" (.toString %)) (.getStackTrace e)))))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/clj/cljs/repl/rhino.clj",
                                                          :lines [41
                                                                  42]}
                                                         {:code "(defmethod stacktrace org.mozilla.javascript.RhinoException [e]\n  (.getScriptStackTrace e))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r2199",
                                                          :filename "src/clj/cljs/repl/rhino.clj",
                                                          :lines [44
                                                                  45]}),
                                         :history [["+" "0.0-927"]]},
           "compiler-options/output-to" {:ns "compiler-options",
                                         :name "output-to",
                                         :name-encode "output-to",
                                         :type "option",
                                         :full-name-encode "compiler-options/output-to",
                                         :full-name "compiler-options/output-to",
                                         :history [["+" "0.0-971"]]},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :signature ["[obj type capture event]"],
                                                   :name-encode "fire-listeners",
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/fire-listeners",
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2199",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [82
                                                                    83]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/interleave" {:ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :name-encode "interleave",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3024 3036]},
                                   :full-name "cljs.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/TransientHashSet" {:protocols #{"IFn"
                                                      "ITransientCollection"
                                                      "ICounted"
                                                      "ITransientSet"
                                                      "ILookup"},
                                         :ns "cljs.core",
                                         :name "TransientHashSet",
                                         :signature ["[transient-map]"],
                                         :name-encode "TransientHashSet",
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashSet",
                                         :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [6264 6299]},
                                         :full-name "cljs.core/TransientHashSet"},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :name-encode "STARflush-on-newlineSTAR",
                                           :type "dynamic var",
                                           :full-name-encode "cljs.core/STARflush-on-newlineSTAR",
                                           :source {:code "(def ^:dynamic *flush-on-newline* true)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [32]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/get-in" {:ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :name-encode "get-in",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (get-in m ks nil))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (if (not (satisfies? ILookup m))\n           not-found\n           (let [m (get m (first ks) sentinel)]\n             (if (identical? sentinel m)\n               not-found\n               (recur sentinel m (next ks)))))\n         m))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2199",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3169 3188]},
                               :full-name "cljs.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of keys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :name-encode "element",
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/element",
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2199",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [81 90]},
                                          :full-name "clojure.browser.dom/element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :signature ["[prim]" "[prim i]"],
                                 :name-encode "prim-seq",
                                 :type "function",
                                 :full-name-encode "cljs.core/prim-seq",
                                 :source {:code "(defn prim-seq\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [734 739]},
                                 :full-name "cljs.core/prim-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/<=" {:return-type boolean,
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "LTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/LTEQ",
                           :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1501 1511]},
                           :extra-sources [{:code "(defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [429 432]}],
                           :full-name "cljs.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :name-encode "map-invert",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [98 100]},
                                     :full-name "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :name-encode "listen",
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/listen",
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (goog.events/listen src\n                         (get (event-types src) type type)\n                         fn\n                         capture?)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2199",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [44 51]},
                                           :full-name "clojure.browser.event/listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[x]"],
                             :name-encode "negQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/negQMARK",
                             :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1795 1797]},
                             :extra-sources [{:code "(defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [461 462]}],
                             :full-name "cljs.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :name-encode "replace-node",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom/replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2199",
                                                        :filename "src/cljs/clojure/browser/dom.cljs",
                                                        :lines [114
                                                                122]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "cljs.core/reverse" {:ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :name-encode "reverse",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (if (reversible? coll)\n    (rseq coll)\n    (reduce conj () coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2009 2014]},
                                :full-name "cljs.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :name-encode "ordering",
                                         :type "var",
                                         :full-name-encode "cljs.repl.browser/ordering",
                                         :source {:code "(def ordering (agent {:expecting nil :fns {}}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2199",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [113]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/realized?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[d]"],
                                  :name-encode "realizedQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/realizedQMARK",
                                  :source {:code "(defn ^boolean realized?\n  [d]\n  (-realized? d))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7307 7310]},
                                  :full-name "cljs.core/realized?",
                                  :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."}},
 :namespaces {"cljs.repl.server" {:ns "cljs.repl.server",
                                  :name-encode "cljs.repl.server",
                                  :type "namespace",
                                  :full-name-encode "cljs.repl.server",
                                  :source {:code "(ns cljs.repl.server\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.string :as str]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.closure :as cljsc]\n            [cljs.repl :as repl])\n  (:import java.io.BufferedReader\n           java.io.BufferedWriter\n           java.io.InputStreamReader\n           java.io.OutputStreamWriter\n           java.net.Socket\n           java.net.ServerSocket\n           cljs.repl.IJavaScriptEnv))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2199",
                                           :filename "src/clj/cljs/repl/server.clj",
                                           :lines [1 14]},
                                  :full-name "cljs.repl.server",
                                  :history [["+" "0.0-1503"]]},
              "clojure.zip" {:ns "clojure.zip",
                             :name-encode "clojure.zip",
                             :type "namespace",
                             :full-name-encode "clojure.zip",
                             :source {:code "(ns ^{:doc \"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet\"\n       :author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [12 16]},
                             :author "Rich Hickey",
                             :full-name "clojure.zip",
                             :docstring "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet",
                             :history [["+" "0.0-927"]]},
              "clojure.reflect" {:ns "clojure.reflect",
                                 :name-encode "clojure.reflect",
                                 :type "namespace",
                                 :full-name-encode "clojure.reflect",
                                 :source {:code "(ns clojure.reflect\n  (:refer-clojure :exclude [meta])\n  (:require [clojure.browser.net :as net]\n            [clojure.browser.event :as event]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/cljs/clojure/reflect.cljs",
                                          :lines [1 4]},
                                 :full-name "clojure.reflect",
                                 :history [["+" "0.0-1503"]]},
              "cljs.repl.browser" {:ns "cljs.repl.browser",
                                   :name-encode "cljs.repl.browser",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.browser",
                                   :source {:code "(ns cljs.repl.browser\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [cljs.compiler :as comp]\n            [cljs.closure :as cljsc]\n            [cljs.repl :as repl]\n            [cljs.repl.server :as server])\n  (:import cljs.repl.IJavaScriptEnv\n           [java.util.regex Pattern]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/repl/browser.clj",
                                            :lines [9 18]},
                                   :full-name "cljs.repl.browser",
                                   :history [["+" "0.0-927"]]},
              "cljs.repl.rhino" {:ns "cljs.repl.rhino",
                                 :name-encode "cljs.repl.rhino",
                                 :type "namespace",
                                 :full-name-encode "cljs.repl.rhino",
                                 :source {:code "(ns cljs.repl.rhino\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.repl :as repl])\n  (:import cljs.repl.IJavaScriptEnv\n           [org.mozilla.javascript Context ScriptableObject]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2199",
                                          :filename "src/clj/cljs/repl/rhino.clj",
                                          :lines [9 16]},
                                 :full-name "cljs.repl.rhino",
                                 :history [["+" "0.0-927"]]},
              "clojure.browser.dom" {:ns "clojure.browser.dom",
                                     :name-encode "clojure.browser.dom",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.dom",
                                     :source {:code "(ns clojure.browser.dom\n  (:require [goog.dom :as gdom]\n            [goog.object :as gobject]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/browser/dom.cljs",
                                              :lines [9 11]},
                                     :full-name "clojure.browser.dom",
                                     :history [["+" "0.0-927"]]},
              "clojure.set" {:ns "clojure.set",
                             :name-encode "clojure.set",
                             :type "namespace",
                             :full-name-encode "clojure.set",
                             :source {:code "(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/clojure/set.cljs",
                                      :lines [9 11]},
                             :author "Rich Hickey",
                             :full-name "clojure.set",
                             :docstring "Set operations such as union/intersection.",
                             :history [["+" "0.0-927"]]},
              "cljs.nodejs" {:ns "cljs.nodejs",
                             :name-encode "cljs.nodejs",
                             :type "namespace",
                             :full-name-encode "cljs.nodejs",
                             :source {:code "(ns cljs.nodejs)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/nodejs.cljs",
                                      :lines [4]},
                             :full-name "cljs.nodejs",
                             :history [["+" "0.0-927"]]},
              "cljs.repl.reflect" {:ns "cljs.repl.reflect",
                                   :name-encode "cljs.repl.reflect",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.reflect",
                                   :source {:code "(ns cljs.repl.reflect\n  (:refer-clojure :exclude [macroexpand])\n  (:require [cljs.repl.server :as server]\n            [cljs.analyzer :as analyzer]\n            [cljs.compiler :as compiler]\n            [clojure.string :as str]\n            [clojure.pprint :as pprint]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2199",
                                            :filename "src/clj/cljs/repl/reflect.clj",
                                            :lines [1 7]},
                                   :full-name "cljs.repl.reflect",
                                   :history [["+" "0.0-1503"]]},
              "clojure.walk" {:ns "clojure.walk",
                              :name-encode "clojure.walk",
                              :type "namespace",
                              :full-name-encode "clojure.walk",
                              :source {:code "(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/clojure/walk.cljs",
                                       :lines [23 35]},
                              :author "Stuart Sierra",
                              :full-name "clojure.walk",
                              :docstring "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.",
                              :history [["+" "0.0-927"]]},
              "closure-warnings" {:pseudo-ns? true,
                                  :sub-options-sym "compiler-options/closure-warnings",
                                  :ns "closure-warnings",
                                  :type "namespace",
                                  :full-name-encode "closure-warnings",
                                  :full-name "closure-warnings",
                                  :history [["+" "0.0-2120"]]},
              "clojure.browser.event" {:ns "clojure.browser.event",
                                       :name-encode "clojure.browser.event",
                                       :type "namespace",
                                       :full-name-encode "clojure.browser.event",
                                       :source {:code "(ns ^{:doc \"This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.\"\n      :author \"Bobby Calderwood\"}\n  clojure.browser.event\n  (:require [goog.events :as events]\n            [goog.events.EventTarget :as gevent-target]\n            [goog.events.EventType   :as gevent-type]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/clojure/browser/event.cljs",
                                                :lines [9 15]},
                                       :author "Bobby Calderwood",
                                       :full-name "clojure.browser.event",
                                       :docstring "This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.",
                                       :history [["+" "0.0-927"]]},
              "cljs.reader" {:ns "cljs.reader",
                             :name-encode "cljs.reader",
                             :type "namespace",
                             :full-name-encode "cljs.reader",
                             :source {:code "(ns cljs.reader\n  (:require [goog.string :as gstring]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2199",
                                      :filename "src/cljs/cljs/reader.cljs",
                                      :lines [9 10]},
                             :full-name "cljs.reader",
                             :history [["+" "0.0-927"]]},
              "clojure.string" {:ns "clojure.string",
                                :name-encode "clojure.string",
                                :type "namespace",
                                :full-name-encode "clojure.string",
                                :source {:code "(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring]\n            [goog.string.StringBuffer :as gstringbuf]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2199",
                                         :filename "src/cljs/clojure/string.cljs",
                                         :lines [9 12]},
                                :full-name "clojure.string",
                                :history [["+" "0.0-927"]]},
              "cljs.repl" {:ns "cljs.repl",
                           :name-encode "cljs.repl",
                           :type "namespace",
                           :full-name-encode "cljs.repl",
                           :source {:code "(ns cljs.repl\n  (:refer-clojure :exclude [load-file])\n  (:import java.io.File\n           javax.xml.bind.DatatypeConverter)\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.tagged-literals :as tags]\n            [cljs.closure :as cljsc]\n            [cljs.source-map :as sm]\n            [clojure.tools.reader :as reader]\n            [clojure.tools.reader.reader-types :as readers]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/clj/cljs/repl.clj",
                                    :lines [9 22]},
                           :full-name "cljs.repl",
                           :history [["+" "0.0-927"]]},
              "clojure.browser.net" {:ns "clojure.browser.net",
                                     :name-encode "clojure.browser.net",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.net",
                                     :source {:code "(ns ^{:doc \"Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.\"\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.net\n  (:require [clojure.browser.event :as event]\n            [goog.net.XhrIo :as gxhrio]\n            [goog.net.EventType :as gnet-event-type]\n            [goog.net.xpc.CfgFields :as gxpc-config-fields]\n            [goog.net.xpc.CrossPageChannel :as xpc]\n            #_[goog.net.WebSocket :as gwebsocket]\n            [goog.json :as gjson]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2199",
                                              :filename "src/cljs/clojure/browser/net.cljs",
                                              :lines [9 19]},
                                     :author "Bobby Calderwood and Alex Redington",
                                     :full-name "clojure.browser.net",
                                     :docstring "Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.",
                                     :history [["+" "0.0-927"]]},
              "syntax" {:ns "syntax",
                        :pseudo-ns? true,
                        :type "namespace",
                        :full-name "syntax",
                        :full-name-encode "syntax",
                        :history [["+" "0.0-927"]]},
              "repl-options" {:ns "repl-options",
                              :pseudo-ns? true,
                              :type "namespace",
                              :full-name "repl-options",
                              :full-name-encode "repl-options",
                              :history [["+" "0.0-971"]]},
              "warnings" {:pseudo-ns? true,
                          :sub-options-sym "compiler-options/warnings",
                          :ns "warnings",
                          :type "namespace",
                          :full-name-encode "warnings",
                          :full-name "warnings",
                          :history [["+" "0.0-1835"]]},
              "cljs.core" {:ns "cljs.core",
                           :name-encode "cljs.core",
                           :type "namespace",
                           :full-name-encode "cljs.core",
                           :source {:code "(ns cljs.core\n  (:require [goog.string :as gstring]\n            [goog.string.StringBuffer :as gstringbuf]\n            [goog.object :as gobject]\n            [goog.array :as garray]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2199",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [9 13]},
                           :full-name "cljs.core",
                           :history [["+" "0.0-927"]]},
              "clojure.data" {:ns "clojure.data",
                              :name-encode "clojure.data",
                              :type "namespace",
                              :full-name-encode "clojure.data",
                              :source {:code "(ns \n  ^{:author \"Stuart Halloway\",\n    :doc \"Non-core data functions.\"}\n  clojure.data\n  (:require [clojure.set :as set]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2199",
                                       :filename "src/cljs/clojure/data.cljs",
                                       :lines [9 13]},
                              :author "Stuart Halloway",
                              :full-name "clojure.data",
                              :docstring "Non-core data functions.",
                              :history [["+" "0.0-1503"]]},
              "clojure.core.reducers" {:ns "clojure.core.reducers",
                                       :name-encode "clojure.core.reducers",
                                       :type "namespace",
                                       :full-name-encode "clojure.core.reducers",
                                       :source {:code "(ns ^{:doc\n      \"A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.\"\n      :author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten])\n  (:require [cljs.core :as core]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2199",
                                                :filename "src/cljs/clojure/core/reducers.cljs",
                                                :lines [9 17]},
                                       :author "Rich Hickey",
                                       :full-name "clojure.core.reducers",
                                       :docstring "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.",
                                       :history [["+" "0.0-1236"]]},
              "compiler-options" {:ns "compiler-options",
                                  :pseudo-ns? true,
                                  :type "namespace",
                                  :full-name "compiler-options",
                                  :full-name-encode "compiler-options",
                                  :history [["+" "0.0-971"]]},
              "clojure.browser.repl" {:ns "clojure.browser.repl",
                                      :name-encode "clojure.browser.repl",
                                      :type "namespace",
                                      :full-name-encode "clojure.browser.repl",
                                      :source {:code "(ns ^{:doc \"Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!\"\n\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.repl\n  (:require [clojure.browser.net   :as net]\n            [clojure.browser.event :as event]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2199",
                                               :filename "src/cljs/clojure/browser/repl.cljs",
                                               :lines [9 19]},
                                      :author "Bobby Calderwood and Alex Redington",
                                      :full-name "clojure.browser.repl",
                                      :docstring "Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!",
                                      :history [["+" "0.0-927"]]}},
 :api {:syntax {:changes {"0.0-2030" {},
                          "0.0-2067" {},
                          "0.0-2134" {},
                          "0.0-1803" {},
                          "0.0-1886" {},
                          "0.0-2138" {},
                          "0.0-2127" {},
                          "0.0-2199" {},
                          "0.0-2120" {:added #{"syntax/js-literal"}},
                          "0.0-1878" {},
                          "0.0-1236" {},
                          "0.0-2060" {},
                          "0.0-1424" {:added #{"syntax/inst-literal"
                                               "syntax/queue-literal"
                                               "syntax/uuid-literal"}},
                          "0.0-1885" {},
                          "0.0-1535" {},
                          "0.0-1859" {},
                          "0.0-1853" {:added #{"syntax/symbol"
                                               "syntax/vector"
                                               "syntax/string"
                                               "syntax/comment"
                                               "syntax/quote"
                                               "syntax/keyword-qualify"
                                               "syntax/meta"
                                               "syntax/regex"
                                               "syntax/eval"
                                               "syntax/unquote-splicing"
                                               "syntax/true"
                                               "syntax/keyword"
                                               "syntax/character"
                                               "syntax/unreadable"
                                               "syntax/arg"
                                               "syntax/false"
                                               "syntax/set"
                                               "syntax/tagged-literal"
                                               "syntax/syntax-quote"
                                               "syntax/dispatch"
                                               "syntax/shebang"
                                               "syntax/function"
                                               "syntax/nil"
                                               "syntax/map"
                                               "syntax/number"
                                               "syntax/list"
                                               "syntax/deref"
                                               "syntax/unquote"
                                               "syntax/ignore"
                                               "syntax/var"}},
                          "0.0-2197" {},
                          "0.0-2075" {},
                          "0.0-1909" {},
                          "0.0-1552" {},
                          "0.0-2080" {},
                          "0.0-1806" {},
                          "0.0-1576" {},
                          "0.0-1844" {},
                          "0.0-1586" {},
                          "0.0-1443" {},
                          "0.0-1006" {},
                          "0.0-1913" {},
                          "0.0-2069" {},
                          "0.0-1513" {},
                          "0.0-1503" {},
                          "0.0-1933" {},
                          "0.0-1895" {},
                          "0.0-971" {},
                          "0.0-2027" {},
                          "0.0-1978" {},
                          "0.0-1843" {},
                          "0.0-1835" {},
                          "0.0-1450" {},
                          "0.0-2173" {},
                          "0.0-1798" {},
                          "0.0-1877" {},
                          "0.0-1211" {},
                          "0.0-1449" {},
                          "0.0-993" {},
                          "0.0-1011" {},
                          "0.0-2156" {},
                          "0.0-1847" {},
                          "0.0-927" {:added #{"syntax/whitespace"
                                              "syntax/earmuffs"
                                              "syntax/Math-namespace"
                                              "syntax/comma"
                                              "syntax/js-namespace"
                                              "syntax/namespace"
                                              "syntax/dot"
                                              "syntax/unused"
                                              "syntax/rest"
                                              "syntax/auto-gensym"
                                              "syntax/destructure-map"
                                              "syntax/impure"
                                              "syntax/predicate"
                                              "syntax/destructure-vector"}},
                          "0.0-1934" {},
                          "0.0-1820" {},
                          "0.0-2024" {},
                          "0.0-1889" {},
                          "0.0-1896" {},
                          "0.0-2014" {}},
                :symbol-names #{"syntax/symbol"
                                "syntax/vector"
                                "syntax/inst-literal"
                                "syntax/whitespace"
                                "syntax/earmuffs"
                                "syntax/Math-namespace"
                                "syntax/comma"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/js-namespace"
                                "syntax/quote"
                                "syntax/namespace"
                                "syntax/keyword-qualify"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/dot"
                                "syntax/unused"
                                "syntax/unquote-splicing"
                                "syntax/true"
                                "syntax/rest"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/auto-gensym"
                                "syntax/arg"
                                "syntax/false"
                                "syntax/set"
                                "syntax/tagged-literal"
                                "syntax/destructure-map"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/queue-literal"
                                "syntax/shebang"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/js-literal"
                                "syntax/list"
                                "syntax/uuid-literal"
                                "syntax/impure"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/predicate"
                                "syntax/ignore"
                                "syntax/destructure-vector"
                                "syntax/var"},
                :namespace-names #{"syntax"}},
       :options {:changes {"0.0-2030" {},
                           "0.0-2067" {:added #{"warnings/invalid-arithmetic"}},
                           "0.0-2134" {},
                           "0.0-1803" {},
                           "0.0-1886" {},
                           "0.0-2138" {},
                           "0.0-2127" {:added #{"compiler-options/preamble"}},
                           "0.0-2199" {},
                           "0.0-2120" {:added #{"closure-warnings/externs-validation"
                                                "closure-warnings/duplicate-message"
                                                "closure-warnings/tweaks"
                                                "closure-warnings/es5-strict"
                                                "closure-warnings/check-types"
                                                "closure-warnings/undefined-variables"
                                                "closure-warnings/const"
                                                "closure-warnings/access-controls"
                                                "closure-warnings/fileoverview-jsdoc"
                                                "closure-warnings/debugger-statement-present"
                                                "closure-warnings/undefined-names"
                                                "closure-warnings/missing-properties"
                                                "closure-warnings/ambiguous-function-decl"
                                                "closure-warnings/check-regexp"
                                                "compiler-options/closure-warnings"
                                                "closure-warnings/check-useless-code"
                                                "closure-warnings/strict-module-dep-check"
                                                "closure-warnings/non-standard-jsdoc"
                                                "closure-warnings/check-variables"
                                                "compiler-options/closure-defines"
                                                "closure-warnings/visiblity"
                                                "closure-warnings/internet-explorer-checks"
                                                "closure-warnings/global-this"
                                                "closure-warnings/deprecated"
                                                "closure-warnings/constant-property"
                                                "closure-warnings/unknown-defines"
                                                "closure-warnings/invalid-casts"}},
                           "0.0-1878" {},
                           "0.0-1236" {},
                           "0.0-2060" {:added #{"warnings/invoke-ctor"
                                                "compiler-options/source-map-path"}},
                           "0.0-1424" {:added #{"compiler-options/static-fns"}},
                           "0.0-1885" {},
                           "0.0-1535" {},
                           "0.0-1859" {},
                           "0.0-1853" {:added #{"warnings/fn-arity"}},
                           "0.0-2197" {:added #{"compiler-options/hashbang"
                                                "compiler-options/language-out"
                                                "compiler-options/language-in"}},
                           "0.0-2075" {},
                           "0.0-1909" {},
                           "0.0-1552" {:added #{"repl-options/analyze-path"}},
                           "0.0-2080" {},
                           "0.0-1806" {},
                           "0.0-1576" {},
                           "0.0-1844" {},
                           "0.0-1586" {},
                           "0.0-1443" {:added #{"compiler-options/warnings"}},
                           "0.0-1006" {},
                           "0.0-1913" {},
                           "0.0-2069" {},
                           "0.0-1513" {:added #{"compiler-options/output-wrapper"}},
                           "0.0-1503" {:added #{"repl-options/src"}},
                           "0.0-1933" {},
                           "0.0-1895" {},
                           "0.0-971" {:added #{"compiler-options/verbose"
                                               "compiler-options/libs"
                                               "repl-options/warn-on-undeclared"
                                               "compiler-options/optimizations"
                                               "compiler-options/pretty-print"
                                               "compiler-options/target"
                                               "compiler-options/use-only-custom-externs"
                                               "compiler-options/main"
                                               "compiler-options/output-dir"
                                               "compiler-options/print-input-delimiter"
                                               "compiler-options/foreign-libs"
                                               "compiler-options/externs"
                                               "repl-options/working-dir"
                                               "compiler-options/output-to"}},
                           "0.0-2027" {},
                           "0.0-1978" {},
                           "0.0-1843" {},
                           "0.0-1835" {:added #{"warnings/redef"
                                                "warnings/protocol-deprecated"
                                                "warnings/fn-var"
                                                "warnings/dynamic"
                                                "warnings/fn-deprecated"
                                                "warnings/undeclared"}},
                           "0.0-1450" {},
                           "0.0-2173" {:added #{"warnings/unprovided"}},
                           "0.0-1798" {:added #{"compiler-options/source-map"}},
                           "0.0-1877" {:added #{"compiler-options/optimize-constants"}},
                           "0.0-1211" {:added #{"repl-options/static-dir"}},
                           "0.0-1449" {},
                           "0.0-993" {},
                           "0.0-1011" {},
                           "0.0-2156" {:added #{"compiler-options/elide-asserts"}},
                           "0.0-1847" {},
                           "0.0-927" {},
                           "0.0-1934" {},
                           "0.0-1820" {},
                           "0.0-2024" {:added #{"warnings/extending-base-js-type"}},
                           "0.0-1889" {},
                           "0.0-1896" {},
                           "0.0-2014" {:added #{"warnings/undeclared-var"
                                                "warnings/variadic-max-arity"
                                                "warnings/invalid-protocol-symbol"
                                                "warnings/multiple-variadic-overloads"
                                                "warnings/overload-arity"
                                                "warnings/undeclared-ns-form"
                                                "warnings/undeclared-ns"
                                                "warnings/undeclared-protocol-symbol"},
                                       :removed #{"warnings/undeclared"}}},
                 :symbol-names #{"warnings/invoke-ctor"
                                 "closure-warnings/externs-validation"
                                 "warnings/redef"
                                 "closure-warnings/duplicate-message"
                                 "closure-warnings/tweaks"
                                 "closure-warnings/es5-strict"
                                 "warnings/protocol-deprecated"
                                 "closure-warnings/check-types"
                                 "compiler-options/verbose"
                                 "closure-warnings/undefined-variables"
                                 "compiler-options/libs"
                                 "closure-warnings/const"
                                 "repl-options/warn-on-undeclared"
                                 "compiler-options/optimizations"
                                 "compiler-options/static-fns"
                                 "compiler-options/pretty-print"
                                 "compiler-options/target"
                                 "closure-warnings/access-controls"
                                 "warnings/undeclared-var"
                                 "repl-options/src"
                                 "closure-warnings/fileoverview-jsdoc"
                                 "warnings/extending-base-js-type"
                                 "closure-warnings/debugger-statement-present"
                                 "closure-warnings/undefined-names"
                                 "closure-warnings/missing-properties"
                                 "closure-warnings/ambiguous-function-decl"
                                 "warnings/variadic-max-arity"
                                 "compiler-options/preamble"
                                 "closure-warnings/check-regexp"
                                 "compiler-options/closure-warnings"
                                 "warnings/invalid-protocol-symbol"
                                 "warnings/fn-arity"
                                 "compiler-options/use-only-custom-externs"
                                 "closure-warnings/check-useless-code"
                                 "warnings/multiple-variadic-overloads"
                                 "compiler-options/hashbang"
                                 "closure-warnings/strict-module-dep-check"
                                 "compiler-options/warnings"
                                 "compiler-options/main"
                                 "closure-warnings/non-standard-jsdoc"
                                 "warnings/invalid-arithmetic"
                                 "compiler-options/output-dir"
                                 "warnings/overload-arity"
                                 "compiler-options/source-map"
                                 "warnings/fn-var"
                                 "warnings/dynamic"
                                 "warnings/undeclared-ns-form"
                                 "closure-warnings/check-variables"
                                 "compiler-options/optimize-constants"
                                 "repl-options/analyze-path"
                                 "compiler-options/source-map-path"
                                 "compiler-options/print-input-delimiter"
                                 "compiler-options/closure-defines"
                                 "closure-warnings/visiblity"
                                 "closure-warnings/internet-explorer-checks"
                                 "compiler-options/foreign-libs"
                                 "compiler-options/externs"
                                 "closure-warnings/global-this"
                                 "closure-warnings/deprecated"
                                 "compiler-options/language-out"
                                 "warnings/unprovided"
                                 "warnings/fn-deprecated"
                                 "warnings/undeclared"
                                 "warnings/undeclared-ns"
                                 "compiler-options/language-in"
                                 "compiler-options/output-wrapper"
                                 "repl-options/static-dir"
                                 "compiler-options/elide-asserts"
                                 "warnings/undeclared-protocol-symbol"
                                 "repl-options/working-dir"
                                 "closure-warnings/constant-property"
                                 "closure-warnings/unknown-defines"
                                 "closure-warnings/invalid-casts"
                                 "compiler-options/output-to"},
                 :namespace-names #{"closure-warnings"
                                    "repl-options"
                                    "warnings"
                                    "compiler-options"}},
       :library {:changes {"0.0-2030" {},
                           "0.0-2067" {},
                           "0.0-2134" {:added #{"cljs.core/clone"
                                                "cljs.core/ICloneable"}},
                           "0.0-1803" {:added #{"cljs.core/special-symbol?"
                                                "cljs.core/lazy-cat"}},
                           "0.0-1886" {},
                           "0.0-2138" {:added #{"cljs.core/specify"}},
                           "0.0-2127" {},
                           "0.0-2199" {},
                           "0.0-2120" {:added #{"cljs.core/print-map"
                                                "cljs.core/sorted?"
                                                "cljs.core/*print-level*"
                                                "clojure.core.reducers/CollFold"
                                                "cljs.core/sequence"
                                                "cljs.core/object?"}},
                           "0.0-1878" {},
                           "0.0-1236" {:added #{"clojure.core.reducers/drop"
                                                "clojure.core.reducers/folder"
                                                "clojure.core.reducers/Cat"
                                                "clojure.core.reducers/foldcat"
                                                "clojure.core.reducers/fold"
                                                "clojure.core.reducers/monoid"
                                                "clojure.core.reducers/map"
                                                "clojure.core.reducers/cat"
                                                "clojure.core.reducers/take"
                                                "cljs.reader/maybe-read-tagged-type"
                                                "clojure.core.reducers/reduce"
                                                "cljs.core/letfn*"
                                                "clojure.core.reducers/flatten"
                                                "cljs.reader/*tag-table*"
                                                "clojure.core.reducers/filter"
                                                "cljs.core/simple-benchmark"
                                                "clojure.core.reducers/append!"
                                                "clojure.core.reducers/reducer"
                                                "clojure.core.reducers/take-while"
                                                "cljs.reader/register-tag-parser!"
                                                "clojure.core.reducers/remove"
                                                "cljs.reader/read-string*"
                                                "clojure.core.reducers/mapcat"}},
                           "0.0-2060" {:added #{"cljs.core/enable-console-print!"
                                                "cljs.core/*print-length*"
                                                "cljs.core/*print-newline*"}},
                           "0.0-1424" {:added #{"cljs.core/Box"
                                                "cljs.core/array-chunk"
                                                "cljs.core/string-hash-cache"
                                                "cljs.reader/read-2-chars"
                                                "cljs.core/chunk"
                                                "cljs.core/chunk-next"
                                                "cljs.reader/make-unicode-char"
                                                "cljs.core/shuffle"
                                                "cljs.core/ArrayChunk"
                                                "cljs.core/chunk-cons"
                                                "cljs.core/chunked-seq"
                                                "cljs.reader/unicode-4-pattern"
                                                "cljs.core/IComparable"
                                                "cljs.reader/unicode-2-pattern"
                                                "cljs.core/check-string-hash-cache"
                                                "cljs.core/Keyword"
                                                "cljs.core/key-test"
                                                "cljs.core/IChunkedSeq"
                                                "cljs.core/chunk-append"
                                                "cljs.core/regexp?"
                                                "cljs.reader/read-4-chars"
                                                "cljs.core/UUID"
                                                "cljs.reader/deregister-tag-parser!"
                                                "cljs.core/INext"
                                                "cljs.core/RSeq"
                                                "cljs.core/add-to-string-hash-cache"
                                                "cljs.core/chunk-buffer"
                                                "cljs.core/IChunkedNext"
                                                "cljs.core/ChunkBuffer"
                                                "cljs.core/chunked-seq?"
                                                "cljs.reader/validate-unicode-escape"
                                                "cljs.core/string-hash-cache-count"
                                                "cljs.core/IChunk"
                                                "cljs.reader/parse-timestamp"
                                                "cljs.core/chunk-first"
                                                "cljs.core/ChunkedSeq"
                                                "cljs.core/chunk-rest"
                                                "cljs.core/ChunkedCons"},
                                       :removed #{"cljs.core/vector-seq"
                                                  "cljs.reader/read-unicode-char"}},
                           "0.0-1885" {:removed #{"cljs.core/printf"
                                                  "cljs.core/format"}},
                           "0.0-1535" {:added #{"cljs.core/with-out-str"}},
                           "0.0-1859" {:added #{"cljs.core/type->str"}},
                           "0.0-1853" {:added #{"cljs.reader/parse-and-validate-timestamp"}},
                           "0.0-2197" {},
                           "0.0-2075" {},
                           "0.0-1909" {},
                           "0.0-1552" {:added #{"cljs.core/Fn"
                                                "cljs.core/IEncodeJS"
                                                "cljs.core/js-mod"
                                                "cljs.core/IEncodeClojure"
                                                "cljs.core/clj->js"}},
                           "0.0-2080" {:added #{"cljs.core/unsigned-bit-shift-right"}},
                           "0.0-1806" {:added #{"cljs.core/with-redefs"
                                                "cljs.core/pr-str*"}},
                           "0.0-1576" {:added #{"cljs.core/ex-message"
                                                "cljs.reader/deregister-default-tag-parser!"
                                                "cljs.core/ex-data"
                                                "cljs.core/ex-info"
                                                "cljs.reader/*default-data-reader-fn*"
                                                "cljs.core/ExceptionInfo"
                                                "cljs.reader/register-default-tag-parser!"
                                                "cljs.core/ex-cause"}},
                           "0.0-1844" {},
                           "0.0-1586" {:added #{"cljs.core/comparator"}},
                           "0.0-1443" {:added #{"cljs.core/printf"
                                                "cljs.core/format"
                                                "cljs.core/obj-map"
                                                "cljs.core/memfn"
                                                "cljs.core/PersistentHashSet.fromArray"
                                                "cljs.core/hash-set"}},
                           "0.0-1006" {:added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                                "cljs.core/PersistentVector.fromArray"
                                                "cljs.core/PersistentVector"
                                                "cljs.core/PersistentVector.EMPTY"}},
                           "0.0-1913" {},
                           "0.0-2069" {},
                           "0.0-1513" {},
                           "0.0-1503" {:added #{"clojure.data/EqualityPartition"
                                                "clojure.reflect/meta"
                                                "cljs.core/write-all"
                                                "cljs.core/pr-sequential-writer"
                                                "cljs.core/StringBufferWriter"
                                                "clojure.reflect/macroexpand"
                                                "cljs.core/pr-seq-writer"
                                                "clojure.reflect/print-doc"
                                                "clojure.reflect/doc"
                                                "cljs.core/IWriter"
                                                "clojure.data/Diff"
                                                "clojure.data/diff"
                                                "cljs.core/IPrintWithWriter"},
                                       :removed #{"cljs.core/pr-with-opts"}},
                           "0.0-1933" {:removed #{"cljs.core/try*"}},
                           "0.0-1895" {},
                           "0.0-971" {:added #{"cljs.core/type"
                                               "cljs.core/IFn"}},
                           "0.0-2027" {},
                           "0.0-1978" {},
                           "0.0-1843" {},
                           "0.0-1835" {},
                           "0.0-1450" {},
                           "0.0-2173" {:added #{"cljs.core/IReset"
                                                "cljs.core/IAtom"
                                                "cljs.core/ISwap"}},
                           "0.0-1798" {:added #{"cljs.core/unchecked-negate"
                                                "cljs.core/float"
                                                "cljs.core/int-array"
                                                "cljs.core/unchecked-multiply-int"
                                                "cljs.core/cond->"
                                                "cljs.core/unchecked-add"
                                                "cljs.core/Symbol"
                                                "cljs.core/chars"
                                                "cljs.core/short"
                                                "cljs.core/longs"
                                                "cljs.core/unchecked-multiply"
                                                "cljs.core/some->"
                                                "cljs.core/unchecked-negate-int"
                                                "cljs.core/unchecked-substract-int"
                                                "cljs.core/unchecked-double"
                                                "cljs.core/set-print-fn!"
                                                "cljs.core/unchecked-inc-int"
                                                "cljs.core/unchecked-subtract"
                                                "cljs.core/unchecked-add-int"
                                                "cljs.core/some->>"
                                                "cljs.core/unchecked-inc"
                                                "cljs.core/unchecked-subtract-int"
                                                "cljs.core/unchecked-substract"
                                                "cljs.core/unchecked-dec"
                                                "cljs.core/unchecked-divide-int"
                                                "cljs.core/ints"
                                                "cljs.core/PersistentArrayMap.fromArray"
                                                "cljs.core/unchecked-dec-int"
                                                "cljs.core/array?"
                                                "cljs.core/unchecked-char"
                                                "cljs.core/key->js"
                                                "cljs.core/char"
                                                "cljs.core/floats"
                                                "cljs.core/cond->>"
                                                "cljs.core/booleans"
                                                "cljs.core/not-native"
                                                "cljs.core/bytes"
                                                "cljs.core/unchecked-byte"
                                                "cljs.core/unchecked-short"
                                                "cljs.core/byte"
                                                "cljs.core/INamed"
                                                "cljs.core/shorts"
                                                "cljs.core/unchecked-int"
                                                "cljs.core/double"
                                                "cljs.core/exists?"
                                                "cljs.core/doubles"
                                                "cljs.core/unchecked-float"
                                                "cljs.core/divide"
                                                "cljs.core/as->"
                                                "cljs.core/unchecked-remainder-int"
                                                "cljs.core/unchecked-long"},
                                       :removed #{"cljs.core/PersistentArrayMap.fromArrays"
                                                  "cljs.core/HashMap"
                                                  "cljs.core/IPrintable"
                                                  "cljs.core/Vector.fromArray"
                                                  "cljs.core/pr-sequential"
                                                  "cljs.core/HashMap.EMPTY"
                                                  "cljs.core/Vector.EMPTY"
                                                  "cljs.core/HashMap.fromArrays"
                                                  "cljs.core/Vector"}},
                           "0.0-1877" {:added #{"cljs.core/keyword-identical?"
                                                "cljs.core/set-from-indexed-seq"}},
                           "0.0-1211" {:added #{"cljs.core/ITransientCollection"
                                                "cljs.core/transient"
                                                "cljs.core/dissoc!"
                                                "cljs.core/PersistentArrayMap.fromArrays"
                                                "cljs.core/ITransientSet"
                                                "cljs.core/array-map"
                                                "cljs.core/rseq"
                                                "cljs.core/ITransientMap"
                                                "cljs.core/ArrayNodeSeq"
                                                "cljs.core/list?"
                                                "cljs.core/val"
                                                "cljs.core/BitmapIndexedNode"
                                                "cljs.core/IMapEntry"
                                                "cljs.core/*unchecked-if*"
                                                "cljs.core/seqable?"
                                                "cljs.core/sorted-map"
                                                "cljs.core/ASeq"
                                                "cljs.core/reduceable?"
                                                "cljs.core/vector-seq"
                                                "cljs.core/conj!"
                                                "cljs.core/PersistentHashMap"
                                                "cljs.core/IReversible"
                                                "cljs.core/IKVReduce"
                                                "cljs.core/BlackNode"
                                                "cljs.core/PersistentHashSet.EMPTY"
                                                "cljs.core/PersistentArrayMap"
                                                "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                                "cljs.core/int"
                                                "cljs.core/ISorted"
                                                "cljs.core/double-array"
                                                "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                                "cljs.core/PersistentArrayMap.EMPTY"
                                                "cljs.core/reduced?"
                                                "cljs.core/PersistentTreeMapSeq"
                                                "cljs.core/persistent!"
                                                "cljs.core/PersistentHashMap.fromArrays"
                                                "cljs.core/sorted-set"
                                                "cljs.core/PersistentTreeMap.EMPTY"
                                                "cljs.core/IList"
                                                "cljs.core/PersistentHashMap.EMPTY"
                                                "cljs.core/to-array-2d"
                                                "cljs.core/filterv"
                                                "cljs.core/IEditableCollection"
                                                "cljs.core/ArrayNode"
                                                "cljs.core/TransientHashMap"
                                                "cljs.core/TransientArrayMap"
                                                "cljs.core/mapv"
                                                "cljs.core/long"
                                                "cljs.core/reversible?"
                                                "cljs.core/HashCollisionNode"
                                                "cljs.core/into-array"
                                                "cljs.core/TransientVector"
                                                "cljs.core/PersistentTreeSet"
                                                "cljs.core/Reduced"
                                                "cljs.core/long-array"
                                                "cljs.core/subseq"
                                                "cljs.core/bit-count"
                                                "cljs.core/assoc!"
                                                "cljs.core/sorted-map-by"
                                                "cljs.core/NodeSeq"
                                                "cljs.core/gen-apply-to"
                                                "cljs.core/rsubseq"
                                                "cljs.core/make-array"
                                                "cljs.core/sorted-set-by"
                                                "cljs.core/disj!"
                                                "cljs.core/ifn?"
                                                "cljs.core/case"
                                                "cljs.core/RedNode"
                                                "cljs.core/key"
                                                "cljs.core/ITransientAssociative"
                                                "cljs.core/reduce-kv"
                                                "cljs.core/PersistentTreeSet.EMPTY"
                                                "cljs.core/BitmapIndexedNode.EMPTY"
                                                "cljs.core/mk-bound-fn"
                                                "cljs.core/VectorNode"
                                                "cljs.core/PersistentHashSet"
                                                "cljs.core/ITransientVector"
                                                "cljs.core/PersistentTreeMap"
                                                "cljs.core/pop!"
                                                "cljs.core/bit-shift-right-zero-fill"
                                                "cljs.core/reduced"
                                                "cljs.core/object-array"
                                                "cljs.core/indexed?"
                                                "cljs.core/TransientHashSet"},
                                       :removed #{"cljs.core/Set"
                                                  "cljs.core/Set.EMPTY"}},
                           "0.0-1449" {},
                           "0.0-993" {},
                           "0.0-1011" {:added #{"cljs.core/println-str"
                                                "cljs.core/print-str"
                                                "cljs.core/prn-str-with-opts"
                                                "cljs.core/prn-str"}},
                           "0.0-2156" {:added #{"cljs.nodejs/enable-util-print!"
                                                "cljs.core/cloneable?"
                                                "cljs.core/specify!"
                                                "cljs.core/defonce"}},
                           "0.0-1847" {},
                           "0.0-927" {:added #{"cljs.core/keys"
                                               "cljs.core/reset!"
                                               "clojure.set/select"
                                               "cljs.core/delay"
                                               "cljs.core/bit-not"
                                               "cljs.core/partition"
                                               "cljs.core/parents"
                                               "cljs.core/aclone"
                                               "cljs.core/reset-meta!"
                                               "cljs.reader/dispatch-macros"
                                               "cljs.core/ICollection"
                                               "cljs.core/every?"
                                               "clojure.zip/node"
                                               "cljs.core/IEmptyableCollection"
                                               "clojure.zip/right"
                                               "cljs.core/=="
                                               "clojure.browser.net/*timeout*"
                                               "cljs.core/let*"
                                               "cljs.core/remove-method"
                                               "cljs.core/frequencies"
                                               "cljs.core/pop"
                                               "cljs.core/not-every?"
                                               "cljs.core/some-fn"
                                               "clojure.browser.event/remove-all"
                                               "cljs.core/doto"
                                               "cljs.core/take-while"
                                               "cljs.reader/escape-char-map"
                                               "clojure.browser.event/all-listeners"
                                               "cljs.core/vals"
                                               "cljs.core/IDeref"
                                               "clojure.browser.dom/log-obj"
                                               "cljs.core/for"
                                               "cljs.core/instance?"
                                               "cljs.reader/read-comment"
                                               "cljs.reader/read-number"
                                               "cljs.core/ILookup"
                                               "cljs.core/when"
                                               "clojure.browser.dom/set-value"
                                               "cljs.reader/read-past"
                                               "cljs.core/to-array"
                                               "cljs.core/interpose"
                                               "clojure.browser.net/ICrossPageChannel"
                                               "cljs.core/Cons"
                                               "cljs.core/re-find"
                                               "cljs.core/IMeta"
                                               "cljs.core/assoc-in"
                                               "clojure.string/join"
                                               "clojure.zip/rights"
                                               "cljs.core/split-at"
                                               "clojure.zip/append-child"
                                               "cljs.core/binding"
                                               "cljs.core/Set"
                                               "cljs.reader/macro-terminating?"
                                               "cljs.core/prefers"
                                               "cljs.core/vary-meta"
                                               "cljs.core/when-let"
                                               "cljs.core/drop"
                                               "cljs.core/while"
                                               "cljs.core/import-macros"
                                               "cljs.core/string-print"
                                               "cljs.core/-"
                                               "cljs.core/loop*"
                                               "clojure.zip/vector-zip"
                                               "cljs.core/js->clj"
                                               "cljs.core/List"
                                               "cljs.core/identical?"
                                               "cljs.core/*main-cli-fn*"
                                               "clojure.browser.dom/html->dom"
                                               "cljs.core/some"
                                               "cljs.core/if"
                                               "cljs.core/doall"
                                               "cljs.core/condp"
                                               "clojure.zip/down"
                                               "cljs.core/IPending"
                                               "cljs.core/count"
                                               "cljs.core/bit-test"
                                               "cljs.core/loop"
                                               "cljs.core/subvec"
                                               "cljs.core/bit-clear"
                                               "cljs.core/gensym"
                                               "cljs.core/in-ns"
                                               "cljs.core/+"
                                               "cljs.core/comp"
                                               "cljs.reader/desugar-meta"
                                               "cljs.core/pr"
                                               "clojure.string/upper-case"
                                               "clojure.browser.event/expose"
                                               "clojure.browser.event/listen-once"
                                               "cljs.core/empty?"
                                               "cljs.core/newline"
                                               "cljs.core/replace"
                                               "cljs.core/rand"
                                               "cljs.core/add-watch"
                                               "clojure.string/capitalize"
                                               "cljs.core/replicate"
                                               "cljs.core/sequential?"
                                               "cljs.core/underive"
                                               "cljs.core/get-method"
                                               "cljs.core/="
                                               "cljs.core/defn-"
                                               "cljs.reader/read-symbol"
                                               "cljs.reader/push-back-reader"
                                               "cljs.core/deftype"
                                               "cljs.core/Subvec"
                                               "cljs.core/."
                                               "cljs.core/extend-protocol"
                                               "cljs.reader/read"
                                               "cljs.core/EmptyList"
                                               "clojure.walk/postwalk"
                                               "clojure.zip/edit"
                                               "cljs.core/re-seq"
                                               "cljs.reader/read-list"
                                               "cljs.core/Atom"
                                               "cljs.core/IMap"
                                               "cljs.reader/read-vector"
                                               "clojure.set/join"
                                               "cljs.core/HashMap"
                                               "cljs.reader/int-pattern"
                                               "cljs.core/swap!"
                                               "cljs.core/finally"
                                               "cljs.core/dec"
                                               "clojure.browser.dom/remove-children"
                                               "cljs.core/get-validator"
                                               "cljs.core/coll?"
                                               "cljs.core/bit-or"
                                               "cljs.core/nfirst"
                                               "cljs.core/keep"
                                               "cljs.core/take"
                                               "cljs.core/cond"
                                               "cljs.core/bit-and"
                                               "cljs.core/ObjMap.fromObject"
                                               "clojure.browser.event/unique-event-id"
                                               "clojure.set/project"
                                               "clojure.string/trim-newline"
                                               "clojure.zip/insert-left"
                                               "cljs.core/true?"
                                               "clojure.browser.net/xpc-connection"
                                               "cljs.core/not"
                                               "cljs.core/js-obj"
                                               "cljs.core/complement"
                                               "cljs.core/spread"
                                               "cljs.core/keyword"
                                               "cljs.core/sort"
                                               "clojure.string/trim"
                                               "cljs.core/meta"
                                               "cljs.core/time"
                                               "cljs.core/boolean"
                                               "cljs.reader/read-token"
                                               "cljs.core/update-in"
                                               "cljs.core/map-indexed"
                                               "cljs.core/IStack"
                                               "cljs.core/IIndexed"
                                               "clojure.browser.repl/repl-print"
                                               "clojure.browser.net/xpc-config-fields"
                                               "cljs.core/nnext"
                                               "cljs.core/*print-meta*"
                                               "cljs.reader/read-dispatch"
                                               "cljs.core/distinct"
                                               "cljs.reader/wrapping-reader"
                                               "cljs.core/prn"
                                               "clojure.zip/leftmost"
                                               "cljs.core/>="
                                               "cljs.reader/macros"
                                               "cljs.core/doseq"
                                               "cljs.core/*"
                                               "cljs.core/into"
                                               "cljs.core/defmethod"
                                               "cljs.core/rest"
                                               "cljs.core/dotimes"
                                               "clojure.zip/lefts"
                                               "clojure.browser.dom/ensure-element"
                                               "cljs.core/defmacro"
                                               "cljs.core/remove"
                                               "cljs.core/ns"
                                               "cljs.core/if-not"
                                               "clojure.zip/path"
                                               "cljs.core/mapcat"
                                               "cljs.core/IWatchable"
                                               "clojure.zip/rightmost"
                                               "cljs.core/->"
                                               "cljs.core/remove-all-methods"
                                               "clojure.string/replace-first"
                                               "clojure.browser.dom/get-value"
                                               "cljs.nodejs/process"
                                               "cljs.core/not="
                                               "cljs.core/js-keys"
                                               "clojure.zip/seq-zip"
                                               "cljs.core/IVector"
                                               "cljs.core/empty"
                                               "cljs.core/re-matches"
                                               "clojure.browser.dom/DOMBuilder"
                                               "cljs.core/extend-type"
                                               "cljs.core/ISeqable"
                                               "cljs.core/assoc"
                                               "clojure.browser.repl/xpc-connection"
                                               "cljs.core/IDerefWithTimeout"
                                               "clojure.browser.repl/start-evaluator"
                                               "clojure.browser.event/unlisten"
                                               "cljs.core/do"
                                               "cljs.core/fnil"
                                               "cljs.core/this-as"
                                               "cljs.core/PersistentQueueSeq"
                                               "cljs.core/counted?"
                                               "clojure.string/trimr"
                                               "cljs.core/force"
                                               "cljs.core/compare-and-set!"
                                               "cljs.core/set?"
                                               "cljs.core/load-file"
                                               "clojure.string/escape"
                                               "cljs.core/remove-watch"
                                               "cljs.core/IMultiFn"
                                               "clojure.zip/end?"
                                               "clojure.set/superset?"
                                               "clojure.browser.net/IConnection"
                                               "cljs.core/let"
                                               "cljs.core/dorun"
                                               "cljs.core/pr-str"
                                               "cljs.core/IPrintable"
                                               "cljs.core/defprotocol"
                                               "cljs.core/assert"
                                               "cljs.core/declare"
                                               "cljs.core/fn?"
                                               "cljs.core/associative?"
                                               "cljs.core/list*"
                                               "cljs.core/reduce"
                                               "clojure.browser.event/has-listener"
                                               "cljs.core/compare"
                                               "cljs.core/contains?"
                                               "cljs.core/prefer-method"
                                               "cljs.core/array-seq"
                                               "cljs.core/PersistentQueue"
                                               "cljs.core/drop-last"
                                               "cljs.reader/read-string"
                                               "cljs.core/vector?"
                                               "cljs.core/defmulti"
                                               "cljs.core/List.EMPTY"
                                               "clojure.browser.event/dispatch-event"
                                               "clojure.string/split-lines"
                                               "cljs.core/areduce"
                                               "cljs.core/disj"
                                               "clojure.browser.net/event-types"
                                               "clojure.string/lower-case"
                                               "cljs.core/*print-fn*"
                                               "cljs.core/str"
                                               "cljs.core/ISequential"
                                               "cljs.core/try*"
                                               "cljs.core/set"
                                               "cljs.core/print"
                                               "clojure.string/blank?"
                                               "clojure.browser.dom/append"
                                               "cljs.core/take-last"
                                               "clojure.set/intersection"
                                               "cljs.core/fnext"
                                               "cljs.core/apply"
                                               "clojure.walk/prewalk"
                                               "cljs.core/flatten"
                                               "cljs.core/get"
                                               "cljs.core/.."
                                               "cljs.core/Range"
                                               "cljs.core/zero?"
                                               "cljs.core/identity"
                                               "cljs.core/first"
                                               "cljs.reader/ratio-pattern"
                                               "cljs.core/>"
                                               "cljs.core/juxt"
                                               "cljs.core/max"
                                               "cljs.core/*3"
                                               "cljs.core/number?"
                                               "cljs.core/array"
                                               "cljs.core/nthnext"
                                               "cljs.core/re-pattern"
                                               "cljs.core/missing-protocol"
                                               "clojure.browser.dom/set-text"
                                               "clojure.zip/up"
                                               "cljs.core/IWithMeta"
                                               "cljs.core/bit-and-not"
                                               "clojure.string/triml"
                                               "clojure.string/split"
                                               "cljs.core/hash-map"
                                               "cljs.core/rem"
                                               "cljs.core/IRecord"
                                               "cljs.core/constantly"
                                               "clojure.browser.dom/get-element"
                                               "cljs.core/and"
                                               "clojure.browser.repl/wrap-message"
                                               "clojure.browser.event/unlisten-by-key"
                                               "cljs.core/new"
                                               "cljs.core/try"
                                               "cljs.core/iterate"
                                               "cljs.core/lazy-seq"
                                               "cljs.core/IndexedSeq"
                                               "cljs.core/next"
                                               "cljs.core/*print-readably*"
                                               "cljs.core/last"
                                               "cljs.core/bit-shift-left"
                                               "clojure.string/reverse"
                                               "cljs.core/min"
                                               "cljs.reader/escape-char"
                                               "cljs.reader/read-map"
                                               "cljs.core/seq"
                                               "cljs.core/defrecord*"
                                               "cljs.core/not-empty"
                                               "cljs.core/println"
                                               "clojure.browser.repl/connect"
                                               "clojure.browser.dom/insert-at"
                                               "cljs.core/quot"
                                               "clojure.browser.event/get-listener"
                                               "cljs.core/filter"
                                               "clojure.zip/branch?"
                                               "cljs.core/ObjMap"
                                               "cljs.core/zipmap"
                                               "cljs.core/hash-combine"
                                               "cljs.core/max-key"
                                               "clojure.zip/insert-child"
                                               "cljs.core/defrecord"
                                               "cljs.core/butlast"
                                               "cljs.core/hash"
                                               "cljs.core/bit-set"
                                               "cljs.core/concat"
                                               "cljs.core/conj"
                                               "clojure.set/difference"
                                               "cljs.core/when-first"
                                               "cljs.core/distinct?"
                                               "cljs.core/pos?"
                                               "cljs.core/IHash"
                                               "cljs.core/is_proto_"
                                               "cljs.core/keep-indexed"
                                               "cljs.core/bit-shift-right"
                                               "clojure.zip/insert-right"
                                               "cljs.core/make-hierarchy"
                                               "cljs.core/repeat"
                                               "cljs.core/MultiFn"
                                               "cljs.core/not-any?"
                                               "cljs.reader/read-regex"
                                               "clojure.zip/next"
                                               "cljs.core/aget"
                                               "cljs.core/if-let"
                                               "cljs.core//"
                                               "cljs.core/min-key"
                                               "clojure.zip/root"
                                               "cljs.core/drop-while"
                                               "clojure.browser.repl/evaluate-javascript"
                                               "cljs.core/set-validator!"
                                               "cljs.core/<"
                                               "cljs.core/catch"
                                               "cljs.core/deftype*"
                                               "cljs.core/fn"
                                               "cljs.core/split-with"
                                               "cljs.core/IReduce"
                                               "cljs.reader/symbol-pattern"
                                               "cljs.core/repeatedly"
                                               "cljs.reader/read-delimited-list"
                                               "cljs.core/undefined?"
                                               "clojure.zip/prev"
                                               "cljs.core/seq?"
                                               "cljs.core/odd?"
                                               "cljs.core/cons"
                                               "cljs.reader/read-set"
                                               "cljs.core/descendants"
                                               "cljs.core/take-nth"
                                               "cljs.reader/throwing-reader"
                                               "cljs.core/even?"
                                               "clojure.set/subset?"
                                               "cljs.core/flush"
                                               "cljs.reader/reader-error"
                                               "clojure.walk/prewalk-replace"
                                               "cljs.core/*1"
                                               "cljs.core/Set.EMPTY"
                                               "cljs.reader/read-unicode-char"
                                               "cljs.core/dissoc"
                                               "cljs.core/ffirst"
                                               "clojure.zip/replace"
                                               "cljs.core/vec"
                                               "cljs.core/or"
                                               "cljs.core/mod"
                                               "cljs.core/aset"
                                               "cljs.core/second"
                                               "cljs.core/set!"
                                               "clojure.set/rename"
                                               "cljs.core/delay?"
                                               "clojure.zip/left"
                                               "cljs.reader/not-implemented"
                                               "cljs.core/IAssociative"
                                               "cljs.core/ObjMap.EMPTY"
                                               "cljs.core/group-by"
                                               "cljs.core/symbol"
                                               "cljs.core/Delay"
                                               "cljs.core/methods"
                                               "cljs.core/vector"
                                               "cljs.core/rand-int"
                                               "cljs.core/throw"
                                               "cljs.core/PersistentQueue.EMPTY"
                                               "cljs.core/letfn"
                                               "cljs.core/recur"
                                               "cljs.reader/read-discard"
                                               "cljs.core/inc"
                                               "cljs.core/name"
                                               "cljs.core/cycle"
                                               "cljs.core/fn*"
                                               "cljs.core/map"
                                               "cljs.core/amap"
                                               "clojure.zip/children"
                                               "cljs.core/when-not"
                                               "clojure.set/index"
                                               "clojure.browser.dom/log"
                                               "cljs.core/Vector.fromArray"
                                               "cljs.core/partition-by"
                                               "cljs.core/sort-by"
                                               "cljs.core/with-meta"
                                               "cljs.core/NeverEquiv"
                                               "cljs.core/select-keys"
                                               "cljs.core/ISeq"
                                               "clojure.walk/postwalk-replace"
                                               "cljs.core/pr-with-opts"
                                               "cljs.core/->>"
                                               "cljs.core/nil?"
                                               "cljs.core/load-namespace"
                                               "clojure.walk/stringify-keys"
                                               "clojure.browser.repl/order"
                                               "cljs.core/memoize"
                                               "cljs.core/pr-sequential"
                                               "clojure.zip/make-node"
                                               "cljs.reader/float-pattern"
                                               "cljs.core/ancestors"
                                               "cljs.core/integer?"
                                               "cljs.core/HashMap.EMPTY"
                                               "cljs.core/Vector.EMPTY"
                                               "clojure.zip/xml-zip"
                                               "clojure.walk/walk"
                                               "cljs.core/bit-xor"
                                               "clojure.set/union"
                                               "cljs.reader/PushbackReader"
                                               "cljs.core/isa?"
                                               "clojure.browser.net/xhr-connection"
                                               "cljs.core/subs"
                                               "cljs.core/symbol?"
                                               "clojure.string/replace"
                                               "cljs.core/string?"
                                               "cljs.core/partition-all"
                                               "cljs.core/merge-with"
                                               "clojure.browser.dom/set-properties"
                                               "cljs.core/trampoline"
                                               "clojure.browser.repl/send-print"
                                               "cljs.core/ICounted"
                                               "cljs.core/quote"
                                               "cljs.core/IEquiv"
                                               "cljs.core/js-delete"
                                               "cljs.core/comment"
                                               "cljs.reader/special-symbols"
                                               "cljs.core/js*"
                                               "cljs.core/alength"
                                               "cljs.core/tree-seq"
                                               "cljs.reader/read-unmatched-delimiter"
                                               "cljs.core/every-pred"
                                               "clojure.set/rename-keys"
                                               "cljs.core/peek"
                                               "cljs.core/pr-str-with-opts"
                                               "cljs.core/map?"
                                               "cljs.reader/StringPushbackReader"
                                               "cljs.core/HashMap.fromArrays"
                                               "cljs.core/deref"
                                               "cljs.core/reductions"
                                               "cljs.core/false?"
                                               "cljs.core/bit-flip"
                                               "cljs.core/ISet"
                                               "cljs.core/LazySeq"
                                               "cljs.core/*2"
                                               "clojure.browser.event/total-listener-count"
                                               "cljs.core/alter-meta!"
                                               "clojure.browser.dom/click-element"
                                               "cljs.reader/read-meta"
                                               "cljs.core/range"
                                               "cljs.core/reify"
                                               "cljs.core/satisfies?"
                                               "cljs.core/nth"
                                               "cljs.core/list"
                                               "cljs.core/defn"
                                               "cljs.core/rand-nth"
                                               "cljs.core/def"
                                               "cljs.core/atom"
                                               "cljs.reader/read-keyword"
                                               "cljs.core/Vector"
                                               "cljs.reader/skip-line"
                                               "cljs.core/namespace"
                                               "cljs.nodejs/require"
                                               "clojure.browser.event/EventType"
                                               "cljs.core/merge"
                                               "clojure.browser.repl/send-result"
                                               "clojure.walk/keywordize-keys"
                                               "cljs.core/derive"
                                               "clojure.zip/zipper"
                                               "clojure.zip/remove"
                                               "cljs.core/find"
                                               "cljs.core/*print-dup*"
                                               "cljs.core/partial"
                                               "cljs.core/keyword?"
                                               "clojure.browser.event/fire-listeners"
                                               "cljs.core/interleave"
                                               "cljs.core/*flush-on-newline*"
                                               "cljs.core/get-in"
                                               "clojure.browser.dom/element"
                                               "cljs.core/prim-seq"
                                               "cljs.core/<="
                                               "clojure.set/map-invert"
                                               "clojure.browser.event/listen"
                                               "cljs.core/neg?"
                                               "clojure.browser.dom/replace-node"
                                               "cljs.core/reverse"
                                               "cljs.core/realized?"}},
                           "0.0-1934" {},
                           "0.0-1820" {:added #{"cljs.core/ValSeq"
                                                "cljs.core/PersistentArrayMapSeq"
                                                "cljs.core/KeySeq"
                                                "cljs.core/persistent-array-map-seq"}},
                           "0.0-2024" {},
                           "0.0-1889" {},
                           "0.0-1896" {},
                           "0.0-2014" {:added #{"cljs.core/*clojurescript-version*"
                                                "cljs.core/implements?"}}},
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/unchecked-negate"
                                 "cljs.core/reset!"
                                 "cljs.core/ITransientCollection"
                                 "cljs.core/transient"
                                 "cljs.core/Fn"
                                 "clojure.data/EqualityPartition"
                                 "cljs.core/ex-message"
                                 "clojure.set/select"
                                 "cljs.core/delay"
                                 "cljs.core/float"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/IEncodeJS"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "cljs.core/IReset"
                                 "cljs.core/Box"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/int-array"
                                 "cljs.core/=="
                                 "cljs.core/dissoc!"
                                 "clojure.reflect/meta"
                                 "clojure.browser.net/*timeout*"
                                 "cljs.core/let*"
                                 "cljs.core/remove-method"
                                 "cljs.core/array-chunk"
                                 "clojure.core.reducers/drop"
                                 "cljs.core/PersistentArrayMap.fromArrays"
                                 "cljs.core/frequencies"
                                 "cljs.core/pop"
                                 "cljs.core/not-every?"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/ITransientSet"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "cljs.core/string-hash-cache"
                                 "cljs.core/array-map"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.nodejs/enable-util-print!"
                                 "cljs.core/for"
                                 "cljs.core/unchecked-multiply-int"
                                 "cljs.core/cond->"
                                 "cljs.core/instance?"
                                 "cljs.core/ValSeq"
                                 "cljs.core/rseq"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.reader/read-comment"
                                 "cljs.core/ITransientMap"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "cljs.core/ArrayNodeSeq"
                                 "cljs.core/list?"
                                 "cljs.core/val"
                                 "clojure.browser.dom/set-value"
                                 "cljs.core/BitmapIndexedNode"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "cljs.core/IMapEntry"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/assoc-in"
                                 "clojure.string/join"
                                 "cljs.core/*unchecked-if*"
                                 "cljs.core/seqable?"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.core/Set"
                                 "cljs.core/sorted-map"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.core/prefers"
                                 "cljs.core/vary-meta"
                                 "cljs.core/unchecked-add"
                                 "cljs.core/when-let"
                                 "clojure.core.reducers/folder"
                                 "cljs.core/ASeq"
                                 "cljs.core/drop"
                                 "cljs.core/IAtom"
                                 "cljs.core/reduceable?"
                                 "cljs.core/while"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/-"
                                 "cljs.core/loop*"
                                 "cljs.core/vector-seq"
                                 "clojure.zip/vector-zip"
                                 "cljs.reader/read-2-chars"
                                 "cljs.core/chunk"
                                 "cljs.core/conj!"
                                 "cljs.core/print-map"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/chunk-next"
                                 "cljs.core/enable-console-print!"
                                 "cljs.core/sorted?"
                                 "cljs.core/some"
                                 "cljs.core/PersistentArrayMapSeq"
                                 "cljs.reader/make-unicode-char"
                                 "cljs.core/if"
                                 "clojure.core.reducers/Cat"
                                 "cljs.core/write-all"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/js-mod"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.core/gensym"
                                 "cljs.core/in-ns"
                                 "cljs.core/Symbol"
                                 "cljs.core/shuffle"
                                 "cljs.core/+"
                                 "cljs.core/clone"
                                 "cljs.core/comp"
                                 "cljs.reader/desugar-meta"
                                 "cljs.core/pr"
                                 "clojure.string/upper-case"
                                 "cljs.core/chars"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/empty?"
                                 "cljs.core/newline"
                                 "cljs.core/PersistentHashMap"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "cljs.core/cloneable?"
                                 "clojure.string/capitalize"
                                 "cljs.core/short"
                                 "cljs.core/replicate"
                                 "cljs.core/ArrayChunk"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.reader/deregister-default-tag-parser!"
                                 "cljs.core/defn-"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.core/longs"
                                 "cljs.core/Subvec"
                                 "cljs.core/."
                                 "cljs.core/IReversible"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "cljs.core/specify!"
                                 "clojure.walk/postwalk"
                                 "clojure.zip/edit"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/IKVReduce"
                                 "cljs.core/Atom"
                                 "clojure.core.reducers/foldcat"
                                 "cljs.core/specify"
                                 "cljs.core/IMap"
                                 "cljs.core/pr-sequential-writer"
                                 "cljs.core/unchecked-multiply"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/finally"
                                 "cljs.core/dec"
                                 "cljs.core/*clojurescript-version*"
                                 "clojure.core.reducers/fold"
                                 "cljs.core/StringBufferWriter"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/BlackNode"
                                 "cljs.core/some->"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/unchecked-negate-int"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/PersistentHashSet.EMPTY"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/ObjMap.fromObject"
                                 "cljs.core/PersistentArrayMap"
                                 "clojure.browser.event/unique-event-id"
                                 "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                 "clojure.set/project"
                                 "cljs.core/int"
                                 "clojure.reflect/macroexpand"
                                 "clojure.string/trim-newline"
                                 "cljs.core/pr-seq-writer"
                                 "cljs.core/chunk-cons"
                                 "clojure.zip/insert-left"
                                 "cljs.core/*print-level*"
                                 "cljs.core/true?"
                                 "cljs.core/unchecked-substract-int"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/unchecked-double"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "clojure.core.reducers/monoid"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/printf"
                                 "clojure.core.reducers/map"
                                 "cljs.core/IStack"
                                 "cljs.reader/parse-and-validate-timestamp"
                                 "cljs.core/ISorted"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.core/ISwap"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/double-array"
                                 "cljs.core/prn"
                                 "cljs.core/chunked-seq"
                                 "clojure.zip/leftmost"
                                 "cljs.core/>="
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.reader/unicode-4-pattern"
                                 "cljs.core/dotimes"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.core/set-print-fn!"
                                 "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                 "cljs.core/ns"
                                 "cljs.core/if-not"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/IWatchable"
                                 "cljs.core/unchecked-inc-int"
                                 "clojure.zip/rightmost"
                                 "cljs.core/PersistentArrayMap.EMPTY"
                                 "cljs.core/unchecked-subtract"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "cljs.core/unchecked-add-int"
                                 "clojure.string/replace-first"
                                 "cljs.core/reduced?"
                                 "clojure.browser.dom/get-value"
                                 "clojure.core.reducers/CollFold"
                                 "cljs.nodejs/process"
                                 "cljs.core/some->>"
                                 "cljs.core/unchecked-inc"
                                 "cljs.core/not="
                                 "cljs.core/unchecked-subtract-int"
                                 "cljs.core/ex-data"
                                 "cljs.core/PersistentTreeMapSeq"
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/IVector"
                                 "cljs.core/persistent!"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "clojure.core.reducers/cat"
                                 "cljs.core/unchecked-substract"
                                 "clojure.browser.repl/start-evaluator"
                                 "clojure.browser.event/unlisten"
                                 "cljs.core/do"
                                 "cljs.core/PersistentHashMap.fromArrays"
                                 "cljs.core/special-symbol?"
                                 "cljs.core/format"
                                 "cljs.core/sorted-set"
                                 "cljs.core/fnil"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "clojure.core.reducers/take"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "cljs.core/load-file"
                                 "cljs.core/unchecked-dec"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/IMultiFn"
                                 "clojure.zip/end?"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/unchecked-divide-int"
                                 "cljs.core/dorun"
                                 "cljs.core/with-redefs"
                                 "cljs.core/unsigned-bit-shift-right"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/ints"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/PersistentTreeMap.EMPTY"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/IList"
                                 "cljs.core/list*"
                                 "cljs.core/PersistentArrayMap.fromArray"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/unchecked-dec-int"
                                 "cljs.core/PersistentHashMap.EMPTY"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/to-array-2d"
                                 "cljs.core/ICloneable"
                                 "cljs.core/*print-length*"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.core/array?"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.core/filterv"
                                 "cljs.core/IComparable"
                                 "cljs.reader/read-string"
                                 "cljs.reader/unicode-2-pattern"
                                 "cljs.core/check-string-hash-cache"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/Keyword"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "clojure.string/split-lines"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "cljs.core/IEditableCollection"
                                 "cljs.core/unchecked-char"
                                 "cljs.core/keyword-identical?"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/try*"
                                 "cljs.core/key-test"
                                 "cljs.core/set"
                                 "cljs.core/obj-map"
                                 "cljs.core/print"
                                 "cljs.core/ArrayNode"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "cljs.reader/maybe-read-tagged-type"
                                 "cljs.core/IChunkedSeq"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "cljs.core/key->js"
                                 "cljs.core/TransientHashMap"
                                 "clojure.set/intersection"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.core/get"
                                 "cljs.core/char"
                                 "cljs.core/.."
                                 "cljs.core/floats"
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.core/max"
                                 "cljs.core/with-out-str"
                                 "cljs.core/*3"
                                 "cljs.core/memfn"
                                 "cljs.core/IEncodeClojure"
                                 "cljs.core/TransientArrayMap"
                                 "cljs.core/cond->>"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "cljs.core/chunk-append"
                                 "cljs.core/regexp?"
                                 "clojure.string/split"
                                 "cljs.reader/read-4-chars"
                                 "cljs.core/hash-map"
                                 "cljs.core/mapv"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/constantly"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/UUID"
                                 "clojure.core.reducers/reduce"
                                 "cljs.core/and"
                                 "clojure.browser.repl/wrap-message"
                                 "cljs.reader/deregister-tag-parser!"
                                 "clojure.reflect/print-doc"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/new"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/KeySeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/booleans"
                                 "cljs.core/not-native"
                                 "cljs.core/last"
                                 "cljs.core/pr-str*"
                                 "cljs.core/letfn*"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.core/INext"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/defrecord*"
                                 "cljs.core/*print-newline*"
                                 "cljs.core/long"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "clojure.browser.repl/connect"
                                 "cljs.core/bytes"
                                 "cljs.core/unchecked-byte"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "cljs.core/RSeq"
                                 "clojure.zip/branch?"
                                 "cljs.core/ObjMap"
                                 "cljs.core/sequence"
                                 "cljs.core/zipmap"
                                 "cljs.core/hash-combine"
                                 "cljs.core/reversible?"
                                 "clojure.core.reducers/flatten"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/ex-info"
                                 "cljs.core/butlast"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/clj->js"
                                 "cljs.core/concat"
                                 "cljs.core/conj"
                                 "cljs.core/unchecked-short"
                                 "clojure.set/difference"
                                 "cljs.core/byte"
                                 "cljs.core/when-first"
                                 "cljs.reader/*tag-table*"
                                 "cljs.core/distinct?"
                                 "clojure.core.reducers/filter"
                                 "cljs.core/INamed"
                                 "cljs.core/add-to-string-hash-cache"
                                 "cljs.core/HashCollisionNode"
                                 "cljs.core/object?"
                                 "cljs.core/pos?"
                                 "cljs.core/into-array"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "clojure.reflect/doc"
                                 "cljs.core/is_proto_"
                                 "cljs.core/shorts"
                                 "cljs.core/TransientVector"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "cljs.core/comparator"
                                 "cljs.core/PersistentTreeSet"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.core/Reduced"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/unchecked-int"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/catch"
                                 "cljs.core/deftype*"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.core/IWriter"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/PersistentHashSet.fromArray"
                                 "cljs.core/repeatedly"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.core/prn-str"
                                 "cljs.core/chunk-buffer"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/double"
                                 "cljs.core/even?"
                                 "cljs.core/simple-benchmark"
                                 "cljs.core/persistent-array-map-seq"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.core/long-array"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/subseq"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.core/exists?"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/doubles"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.core/second"
                                 "cljs.core/IChunkedNext"
                                 "cljs.core/set!"
                                 "cljs.core/bit-count"
                                 "clojure.set/rename"
                                 "cljs.core/assoc!"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "cljs.reader/*default-data-reader-fn*"
                                 "cljs.core/sorted-map-by"
                                 "cljs.core/symbol"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.core/lazy-cat"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/throw"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/unchecked-float"
                                 "clojure.core.reducers/append!"
                                 "cljs.core/NodeSeq"
                                 "cljs.core/letfn"
                                 "cljs.core/recur"
                                 "cljs.reader/read-discard"
                                 "cljs.core/gen-apply-to"
                                 "cljs.core/inc"
                                 "cljs.core/name"
                                 "cljs.core/cycle"
                                 "cljs.core/rsubseq"
                                 "cljs.core/divide"
                                 "cljs.core/fn*"
                                 "cljs.core/map"
                                 "cljs.core/ChunkBuffer"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "cljs.core/chunked-seq?"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/make-array"
                                 "cljs.core/sorted-set-by"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "cljs.core/ISeq"
                                 "cljs.core/disj!"
                                 "cljs.core/type->str"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/defonce"
                                 "cljs.core/nil?"
                                 "cljs.core/load-namespace"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "clojure.zip/make-node"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/ancestors"
                                 "cljs.core/integer?"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/ifn?"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.core/case"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/as->"
                                 "clojure.core.reducers/reducer"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.data/Diff"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/partition-all"
                                 "cljs.core/RedNode"
                                 "cljs.core/ExceptionInfo"
                                 "cljs.core/merge-with"
                                 "cljs.core/key"
                                 "clojure.browser.dom/set-properties"
                                 "clojure.data/diff"
                                 "cljs.core/ITransientAssociative"
                                 "cljs.core/trampoline"
                                 "cljs.core/implements?"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/quote"
                                 "cljs.core/IEquiv"
                                 "cljs.core/reduce-kv"
                                 "cljs.core/js-delete"
                                 "cljs.core/PersistentTreeSet.EMPTY"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.core/js*"
                                 "cljs.core/BitmapIndexedNode.EMPTY"
                                 "cljs.reader/register-default-tag-parser!"
                                 "cljs.core/alength"
                                 "cljs.core/mk-bound-fn"
                                 "cljs.reader/validate-unicode-escape"
                                 "cljs.core/VectorNode"
                                 "cljs.core/string-hash-cache-count"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "clojure.core.reducers/take-while"
                                 "cljs.reader/register-tag-parser!"
                                 "cljs.core/every-pred"
                                 "cljs.core/PersistentHashSet"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/IChunk"
                                 "cljs.core/ITransientVector"
                                 "cljs.core/IPrintWithWriter"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.core/PersistentTreeMap"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.core/ISet"
                                 "cljs.core/LazySeq"
                                 "cljs.core/pop!"
                                 "cljs.reader/parse-timestamp"
                                 "cljs.core/chunk-first"
                                 "cljs.core/ChunkedSeq"
                                 "cljs.core/*2"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.core/unchecked-remainder-int"
                                 "cljs.core/bit-shift-right-zero-fill"
                                 "cljs.reader/read-meta"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/ex-cause"
                                 "cljs.core/def"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.nodejs/require"
                                 "cljs.core/chunk-rest"
                                 "cljs.core/unchecked-long"
                                 "clojure.browser.event/EventType"
                                 "cljs.core/merge"
                                 "clojure.core.reducers/remove"
                                 "clojure.browser.repl/send-result"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.core/reduced"
                                 "cljs.reader/read-string*"
                                 "cljs.core/ChunkedCons"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "clojure.core.reducers/mapcat"
                                 "clojure.zip/remove"
                                 "cljs.core/find"
                                 "cljs.core/hash-set"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/set-from-indexed-seq"
                                 "cljs.core/object-array"
                                 "cljs.core/indexed?"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/interleave"
                                 "cljs.core/TransientHashSet"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "clojure.browser.dom/replace-node"
                                 "cljs.core/reverse"
                                 "cljs.core/realized?"},
                 :namespace-names #{"clojure.zip"
                                    "clojure.reflect"
                                    "clojure.browser.dom"
                                    "clojure.set"
                                    "cljs.nodejs"
                                    "clojure.walk"
                                    "clojure.browser.event"
                                    "cljs.reader"
                                    "clojure.string"
                                    "clojure.browser.net"
                                    "cljs.core"
                                    "clojure.data"
                                    "clojure.core.reducers"
                                    "clojure.browser.repl"}},
       :compiler {:changes {"0.0-2030" {},
                            "0.0-2067" {},
                            "0.0-2134" {},
                            "0.0-1803" {},
                            "0.0-1886" {},
                            "0.0-2138" {},
                            "0.0-2127" {},
                            "0.0-2199" {},
                            "0.0-2120" {},
                            "0.0-1878" {},
                            "0.0-1236" {},
                            "0.0-2060" {},
                            "0.0-1424" {:added #{"cljs.repl.browser/preloaded-libs"}},
                            "0.0-1885" {},
                            "0.0-1535" {},
                            "0.0-1859" {},
                            "0.0-1853" {},
                            "0.0-2197" {},
                            "0.0-2075" {},
                            "0.0-1909" {},
                            "0.0-1552" {},
                            "0.0-2080" {},
                            "0.0-1806" {},
                            "0.0-1576" {:removed #{"cljs.repl.rhino/loaded-libs"}},
                            "0.0-1844" {},
                            "0.0-1586" {},
                            "0.0-1443" {},
                            "0.0-1006" {},
                            "0.0-1913" {},
                            "0.0-2069" {},
                            "0.0-1513" {},
                            "0.0-1503" {:added #{"cljs.repl.server/handlers"
                                                 "cljs.repl.server/dispatch-on"
                                                 "cljs.repl.server/start"
                                                 "cljs.repl.reflect/parse-param"
                                                 "cljs.repl/analyze-source"
                                                 "cljs.repl.server/state"
                                                 "cljs.repl.reflect/macroexpand"
                                                 "cljs.repl.server/read-request"
                                                 "cljs.repl.server/set-connection"
                                                 "cljs.repl.server/read-post"
                                                 "cljs.repl.server/parse-headers"
                                                 "cljs.repl.reflect/handle-reflect-query"
                                                 "cljs.repl.server/stop"
                                                 "cljs.repl.server/read-get"
                                                 "cljs.repl.reflect/read-url-string"
                                                 "cljs.repl.browser/browser-state"
                                                 "cljs.repl.server/read-headers"
                                                 "cljs.repl.server/send-and-close"
                                                 "cljs.repl.server/send-404"
                                                 "cljs.repl.server/connection"},
                                        :removed #{"cljs.repl.browser/read-get"
                                                   "cljs.repl.browser/handle-get"
                                                   "cljs.repl.browser/stop-server"
                                                   "cljs.repl.browser/read-request"
                                                   "cljs.repl.browser/server-state"
                                                   "cljs.repl.browser/read-headers"
                                                   "cljs.repl.browser/parse-headers"
                                                   "cljs.repl.browser/send-404"
                                                   "cljs.repl.browser/send-and-close"
                                                   "cljs.repl.browser/handle-connection"
                                                   "cljs.repl.browser/start-server"
                                                   "cljs.repl.browser/server-loop"
                                                   "cljs.repl.browser/read-post"}},
                            "0.0-1933" {},
                            "0.0-1895" {},
                            "0.0-971" {},
                            "0.0-2027" {},
                            "0.0-1978" {},
                            "0.0-1843" {},
                            "0.0-1835" {},
                            "0.0-1450" {},
                            "0.0-2173" {},
                            "0.0-1798" {},
                            "0.0-1877" {},
                            "0.0-1211" {:added #{"cljs.repl.browser/send-static"}},
                            "0.0-1449" {},
                            "0.0-993" {:added #{"cljs.repl/default-special-fns"}},
                            "0.0-1011" {},
                            "0.0-2156" {},
                            "0.0-1847" {},
                            "0.0-927" {:added #{"cljs.repl.rhino/current-repl-env"
                                                "cljs.repl/evaluate-form"
                                                "cljs.repl/load-stream"
                                                "cljs.repl.rhino/eval-result"
                                                "cljs.repl.browser/read-get"
                                                "cljs.repl.browser/load-javascript"
                                                "cljs.repl.browser/add-in-order"
                                                "cljs.repl/load-namespace"
                                                "cljs.repl.rhino/loaded-libs"
                                                "cljs.repl.browser/run-in-order"
                                                "cljs.repl.browser/compile-client-js"
                                                "cljs.repl.browser/handle-get"
                                                "cljs.repl.browser/stop-server"
                                                "cljs.repl.browser/read-request"
                                                "cljs.repl/load-file"
                                                "cljs.repl.browser/browser-eval"
                                                "cljs.repl.browser/server-state"
                                                "cljs.repl.browser/send-for-eval"
                                                "cljs.repl.browser/constrain-order"
                                                "cljs.repl.rhino/rhino-eval"
                                                "cljs.repl.browser/read-headers"
                                                "cljs.repl/repl"
                                                "cljs.repl.rhino/load-javascript"
                                                "cljs.repl.browser/create-client-js-file"
                                                "cljs.repl/*cljs-verbose*"
                                                "cljs.repl.browser/loaded-libs"
                                                "cljs.repl.browser/repl-client-js"
                                                "cljs.repl.browser/parse-headers"
                                                "cljs.repl.browser/send-404"
                                                "cljs.repl.browser/repl-env"
                                                "cljs.repl.rhino/repl-env"
                                                "cljs.repl.rhino/goog-require"
                                                "cljs.repl.browser/send-repl-client-page"
                                                "cljs.repl.browser/send-and-close"
                                                "cljs.repl.rhino/bootjs"
                                                "cljs.repl/IJavaScriptEnv"
                                                "cljs.repl.browser/handle-connection"
                                                "cljs.repl.rhino/IEval"
                                                "cljs.repl.browser/start-server"
                                                "cljs.repl.browser/server-loop"
                                                "cljs.repl.browser/read-post"
                                                "cljs.repl.rhino/rhino-setup"
                                                "cljs.repl.browser/handle-post"
                                                "cljs.repl.rhino/stacktrace"
                                                "cljs.repl.browser/ordering"}},
                            "0.0-1934" {},
                            "0.0-1820" {},
                            "0.0-2024" {},
                            "0.0-1889" {},
                            "0.0-1896" {},
                            "0.0-2014" {}},
                  :symbol-names #{"cljs.repl.rhino/current-repl-env"
                                  "cljs.repl/evaluate-form"
                                  "cljs.repl/load-stream"
                                  "cljs.repl.rhino/eval-result"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl.server/handlers"
                                  "cljs.repl/load-namespace"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.server/dispatch-on"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.server/start"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.reflect/parse-param"
                                  "cljs.repl/analyze-source"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl.browser/read-request"
                                  "cljs.repl.server/state"
                                  "cljs.repl.reflect/macroexpand"
                                  "cljs.repl.server/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.repl.server/set-connection"
                                  "cljs.repl/repl"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.server/read-post"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.repl.server/parse-headers"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.reflect/handle-reflect-query"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.server/stop"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl.server/read-get"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.reflect/read-url-string"
                                  "cljs.repl.browser/preloaded-libs"
                                  "cljs.repl.browser/browser-state"
                                  "cljs.repl.browser/send-static"
                                  "cljs.repl.server/read-headers"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.server/send-and-close"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.server/send-404"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl.server/connection"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.repl.browser/handle-post"
                                  "cljs.repl.rhino/stacktrace"
                                  "cljs.repl.browser/ordering"},
                  :namespace-names #{"cljs.repl.server"
                                     "cljs.repl.browser"
                                     "cljs.repl.rhino"
                                     "cljs.repl.reflect"
                                     "cljs.repl"}}}}
