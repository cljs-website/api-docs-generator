{:version "0.0-2760",
 :history {:versions ("0.0-2760"
                      "0.0-2758"
                      "0.0-2755"
                      "0.0-2740"
                      "0.0-2727"
                      "0.0-2725"
                      "0.0-2723"
                      "0.0-2719"
                      "0.0-2665"
                      "0.0-2657"
                      "0.0-2655"
                      "0.0-2644"
                      "0.0-2629"
                      "0.0-2511"
                      "0.0-2505"
                      "0.0-2498"
                      "0.0-2496"
                      "0.0-2411"
                      "0.0-2371"
                      "0.0-2356"
                      "0.0-2342"
                      "0.0-2341"
                      "0.0-2322"
                      "0.0-2311"
                      "0.0-2307"
                      "0.0-2301"
                      "0.0-2280"
                      "0.0-2277"
                      "0.0-2268"
                      "0.0-2261"
                      "0.0-2234"
                      "0.0-2227"
                      "0.0-2202"
                      "0.0-2199"
                      "0.0-2197"
                      "0.0-2173"
                      "0.0-2156"
                      "0.0-2138"
                      "0.0-2134"
                      "0.0-2127"
                      "0.0-2120"
                      "0.0-2080"
                      "0.0-2075"
                      "0.0-2069"
                      "0.0-2067"
                      "0.0-2060"
                      "0.0-2030"
                      "0.0-2027"
                      "0.0-2024"
                      "0.0-2014"
                      "0.0-1978"
                      "0.0-1934"
                      "0.0-1933"
                      "0.0-1913"
                      "0.0-1909"
                      "0.0-1896"
                      "0.0-1895"
                      "0.0-1889"
                      "0.0-1886"
                      "0.0-1885"
                      "0.0-1878"
                      "0.0-1877"
                      "0.0-1859"
                      "0.0-1853"
                      "0.0-1847"
                      "0.0-1844"
                      "0.0-1843"
                      "0.0-1835"
                      "0.0-1820"
                      "0.0-1806"
                      "0.0-1803"
                      "0.0-1798"
                      "0.0-1586"
                      "0.0-1576"
                      "0.0-1552"
                      "0.0-1535"
                      "0.0-1513"
                      "0.0-1503"
                      "0.0-1450"
                      "0.0-1449"
                      "0.0-1443"
                      "0.0-1424"
                      "0.0-1236"
                      "0.0-1211"
                      "0.0-1011"
                      "0.0-1006"
                      "0.0-993"
                      "0.0-971"
                      "0.0-927"),
           :details {"0.0-2030" {:tag "r2030",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2067" {:tag "r2067",
                                 :date "2013-11-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2134" {:tag "r2134",
                                 :date "2013-12-30",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2322" {:tag "r2322",
                                 :date "2014-08-27",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1803" {:tag "r1803",
                                 :date "2013-05-06",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2371" {:tag "r2371",
                                 :date "2014-10-10",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.9",
                                 :treader-tag "tools.reader-0.8.9",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2307" {:tag "r2307",
                                 :date "2014-08-07",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1886" {:tag "r1886",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2138" {:tag "r2138",
                                 :date "2013-12-31",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2505" {:tag "r2505",
                                 :date "2014-12-21",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2311" {:tag "r2311",
                                 :date "2014-08-09",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2740" {:tag "r2740",
                                 :date "2015-01-28",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2725" {:tag "r2725",
                                 :date "2015-01-24",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2127" {:tag "r2127",
                                 :date "2013-12-20",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2280" {:tag "r2280",
                                 :date "2014-08-01",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2199" {:tag "r2199",
                                 :date "2014-04-01",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2120" {:tag "r2120",
                                 :date "2013-12-13",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1878" {:tag "r1878",
                                 :date "2013-09-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1236" {:tag "r1236",
                                 :date "2012-05-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2060" {:tag "r2060",
                                 :date "2013-11-21",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1424" {:tag "r1424",
                                 :date "2012-06-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2342" {:tag "r2342",
                                 :date "2014-09-18",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.9",
                                 :treader-tag "tools.reader-0.8.9",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1885" {:tag "r1885",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1535" {:tag "r1535",
                                 :date "2012-11-08",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-1859" {:tag "r1859",
                                 :date "2013-08-19",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2755" {:tag "r2755",
                                 :date "2015-02-01",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1853" {:tag "r1853",
                                 :date "2013-08-05",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2197" {:tag "r2197",
                                 :date "2014-03-26",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2075" {:tag "r2075",
                                 :date "2013-11-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2277" {:tag "r2277",
                                 :date "2014-07-25",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2301" {:tag "r2301",
                                 :date "2014-08-07",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1909" {:tag "r1909",
                                 :date "2013-09-27",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.8",
                                 :treader-tag "tools.reader-0.7.8",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2723" {:tag "r2723",
                                 :date "2015-01-24",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2727" {:tag "r2727",
                                 :date "2015-01-25",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1552" {:tag "r1552",
                                 :date "2012-12-03",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-2080" {:tag "r2080",
                                 :date "2013-11-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2234" {:tag "r2234",
                                 :date "2014-06-13",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2644" {:tag "r2644",
                                 :date "2015-01-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2268" {:tag "r2268",
                                 :date "2014-07-06",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2511" {:tag "r2511",
                                 :date "2014-12-22",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1806" {:tag "r1806",
                                 :date "2013-05-10",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2341" {:tag "r2341",
                                 :date "2014-09-18",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2629" {:tag "r2629",
                                 :date "2015-01-01",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2719" {:tag "r2719",
                                 :date "2015-01-24",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2227" {:tag "r2227",
                                 :date "2014-05-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-1576" {:tag "r1576",
                                 :date "2013-01-27",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029",
                                 :gclosure-com nil},
                     "0.0-1844" {:tag "r1844",
                                 :date "2013-07-19",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1586" {:tag "r1586",
                                 :date "2013-02-16",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2498" {:tag "r2498",
                                 :date "2014-12-19",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-1443" {:tag "r1443",
                                 :date "2012-07-06",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-1006" {:tag "r1006",
                                 :date "2012-03-30",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-1913" {:tag "r1913",
                                 :date "2013-10-05",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.8",
                                 :treader-tag "tools.reader-0.7.8",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2069" {:tag "r2069",
                                 :date "2013-11-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.0",
                                 :treader-tag "tools.reader-0.8.0",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2655" {:tag "r2655",
                                 :date "2015-01-03",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1513" {:tag "r1513",
                                 :date "2012-10-19",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376-2",
                                 :gclosure-com nil},
                     "0.0-1503" {:tag "r1503",
                                 :date "2012-10-12",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376-2",
                                 :gclosure-com nil},
                     "0.0-1933" {:tag "r1933",
                                 :date "2013-10-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.9",
                                 :treader-tag "tools.reader-0.7.9",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1895" {:tag "r1895",
                                 :date "2013-09-24",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-971" {:tag "r971",
                                :date "2012-01-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-2027" {:tag "r2027",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1978" {:tag "r1978",
                                 :date "2013-10-28",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1843" {:tag "r1843",
                                 :date "2013-07-16",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2758" {:tag "r2758",
                                 :date "2015-02-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1835" {:tag "r1835",
                                 :date "2013-06-21",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1450" {:tag "r1450",
                                 :date "2012-07-25",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-2173" {:tag "r2173",
                                 :date "2014-02-22",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1798" {:tag "r1798",
                                 :date "2013-05-03",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-1877" {:tag "r1877",
                                 :date "2013-09-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1211" {:tag "r1211",
                                 :date "2012-05-09",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-1449" {:tag "r1449",
                                 :date "2012-07-24",
                                 :clj-version "1.4.0",
                                 :clj-tag "clojure-1.4.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-1376",
                                 :gclosure-com nil},
                     "0.0-993" {:tag "r993",
                                :date "2012-02-27",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "0.0-790",
                                :gclosure-com nil},
                     "0.0-1011" {:tag "r1011",
                                 :date "2012-04-02",
                                 :clj-version "1.3.0",
                                 :clj-tag "clojure-1.3.0",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-790",
                                 :gclosure-com nil},
                     "0.0-2356" {:tag "r2356",
                                 :date "2014-09-26",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.9",
                                 :treader-tag "tools.reader-0.8.9",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2156" {:tag "r2156",
                                 :date "2014-01-29",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1847" {:tag "r1847",
                                 :date "2013-07-23",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2496" {:tag "r2496",
                                 :date "2014-12-17",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-927" {:tag "r927",
                                :date "2012-01-20",
                                :clj-version "1.3.0",
                                :clj-tag "clojure-1.3.0",
                                :treader-version nil,
                                :treader-tag nil,
                                :gclosure-lib "20110323-r790",
                                :gclosure-com nil},
                     "0.0-1934" {:tag "r1934",
                                 :date "2013-10-11",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.9",
                                 :treader-tag "tools.reader-0.7.9",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2202" {:tag "r2202",
                                 :date "2014-04-02",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.8.3",
                                 :treader-tag "tools.reader-0.8.3",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-1820" {:tag "r1820",
                                 :date "2013-06-07",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version nil,
                                 :treader-tag nil,
                                 :gclosure-lib "0.0-2029-2",
                                 :gclosure-com nil},
                     "0.0-2261" {:tag "r2261",
                                 :date "2014-07-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.4",
                                 :treader-tag "tools.reader-0.8.4",
                                 :gclosure-lib "0.0-20140226-71326067",
                                 :gclosure-com nil},
                     "0.0-2024" {:tag "r2024",
                                 :date "2013-11-08",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-1889" {:tag "r1889",
                                 :date "2013-09-15",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2657" {:tag "r2657",
                                 :date "2015-01-03",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-1896" {:tag "r1896",
                                 :date "2013-09-24",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.5",
                                 :treader-tag "tools.reader-0.7.5",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2014" {:tag "r2014",
                                 :date "2013-11-06",
                                 :clj-version "1.5.1",
                                 :clj-tag "clojure-1.5.1",
                                 :treader-version "0.7.10",
                                 :treader-tag "tools.reader-0.7.10",
                                 :gclosure-lib "0.0-20130212-95c19e7f0f5f",
                                 :gclosure-com nil},
                     "0.0-2411" {:tag "r2411",
                                 :date "2014-12-05",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com nil},
                     "0.0-2665" {:tag "r2665",
                                 :date "2015-01-04",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"},
                     "0.0-2760" {:tag "r2760",
                                 :date "2015-02-02",
                                 :clj-version "1.6.0",
                                 :clj-tag "clojure-1.6.0",
                                 :treader-version "0.8.10",
                                 :treader-tag "tools.reader-0.8.10",
                                 :gclosure-lib "0.0-20140718-946a7d39",
                                 :gclosure-com "20140625"}}},
 :clj-not-cljs #{"clojure.core/the-ns"
                 "clojure.core/create-struct"
                 "clojure.data/diff-similar"
                 "clojure.core/*in*"
                 "clojure.main/demunge"
                 "clojure.core.protocols/kv-reduce"
                 "clojure.core/release-pending-sends"
                 "clojure.reflect/flag-descriptors"
                 "clojure.core/shutdown-agents"
                 "clojure.core/restart-agent"
                 "clojure.java.io/input-stream"
                 "clojure.stacktrace/print-cause-trace"
                 "clojure.java.io/file"
                 "clojure.test/*load-tests*"
                 "clojure.core/->Vec"
                 "clojure.test/deftest-"
                 "clojure.inspector/inspect-tree"
                 "clojure.core/remove-ns"
                 "clojure.repl/thread-stopper"
                 "clojure.core/+'"
                 "clojure.core/rationalize"
                 "clojure.main/repl"
                 "clojure.pprint/simple-dispatch"
                 "clojure.repl/dir-fn"
                 "clojure.pprint/write-out"
                 "clojure.core/proxy-super"
                 "clojure.core/refer"
                 "clojure.core/record?"
                 "clojure.repl/apropos"
                 "clojure.stacktrace/print-trace-element"
                 "clojure.core.protocols/CollReduce"
                 "clojure.core/future-call"
                 "clojure.pprint/print-table"
                 "clojure.core/var?"
                 "clojure.core.protocols/InternalReduce"
                 "clojure.core/loaded-libs"
                 "clojure.core/commute"
                 "clojure.core/agent-errors"
                 "clojure.main/repl-caught"
                 "clojure.core/printf"
                 "clojure.core/ArrayChunk"
                 "clojure.pprint/*print-base*"
                 "clojure.core/load-string"
                 "clojure.core/pmap"
                 "clojure.test/file-position"
                 "clojure.core.protocols/IKVReduce"
                 "clojure.core/send"
                 "clojure.core/ref-history-count"
                 "clojure.core/iterator-seq"
                 "clojure.pprint/pprint-indent"
                 "clojure.reflect/map->Field"
                 "clojure.core/find-var"
                 "clojure.core/defstruct"
                 "clojure.core/-'"
                 "clojure.core/agent-error"
                 "clojure.core/ns-refers"
                 "clojure.core/num"
                 "clojure.reflect/do-reflect"
                 "clojure.core/future-cancelled?"
                 "clojure.java.io/make-writer"
                 "clojure.stacktrace/print-stack-trace"
                 "clojure.core/init-proxy"
                 "clojure.walk/postwalk-demo"
                 "clojure.core/read-line"
                 "clojure.core/alter-var-root"
                 "clojure.core/bases"
                 "clojure.repl/source-fn"
                 "clojure.core/class"
                 "clojure.reflect/ClassResolver"
                 "clojure.reflect/type-reflect"
                 "clojure.core/default-data-readers"
                 "clojure.core/byte-array"
                 "clojure.pprint/print-length-loop"
                 "clojure.java.shell/with-sh-dir"
                 "clojure.core/*err*"
                 "clojure.pprint/*print-pretty*"
                 "clojure.core/await"
                 "clojure.core/supers"
                 "clojure.reflect/Field"
                 "clojure.core/vector-of"
                 "clojure.core/accessor"
                 "clojure.inspector/inspect-table"
                 "clojure.core/class?"
                 "clojure.core/ns-map"
                 "clojure.instant/parse-timestamp"
                 "clojure.java.io/make-output-stream"
                 "clojure.core/import"
                 "clojure.pprint/fresh-line"
                 "clojure.core/aset-boolean"
                 "clojure.reflect/typename"
                 "clojure.walk/prewalk-demo"
                 "clojure.pprint/pprint-tab"
                 "clojure.reflect/reflect"
                 "clojure.core/with-bindings"
                 "clojure.core/sync"
                 "clojure.pprint/pprint-logical-block"
                 "clojure.java.javadoc/javadoc"
                 "clojure.repl/find-doc"
                 "clojure.reflect/->AsmReflector"
                 "clojure.core/ref-set"
                 "clojure.reflect/->Method"
                 "clojure.core/->ArrayChunk"
                 "clojure.test.tap/with-tap-output"
                 "clojure.java.io/copy"
                 "clojure.pprint/write"
                 "clojure.core/*data-readers*"
                 "clojure.core/use"
                 "clojure.test.junit/with-junit-output"
                 "clojure.pprint/*print-right-margin*"
                 "clojure.core/future?"
                 "clojure.core/proxy-mappings"
                 "clojure.core/*read-eval*"
                 "clojure.template/do-template"
                 "clojure.core/spit"
                 "clojure.core/Vec"
                 "clojure.core/monitor-enter"
                 "clojure.core/alter"
                 "clojure.core/char?"
                 "clojure.java.io/resource"
                 "clojure.repl/root-cause"
                 "clojure.core/inc'"
                 "clojure.pprint/formatter"
                 "clojure.java.io/make-parents"
                 "clojure.reflect/->Constructor"
                 "clojure.core/ref-min-history"
                 "clojure.core/get-proxy-class"
                 "clojure.main/repl-requires"
                 "clojure.core/aset-double"
                 "clojure.pprint/formatter-out"
                 "clojure.pprint/*print-miser-width*"
                 "clojure.test/set-test"
                 "clojure.core/ref"
                 "clojure.core/future-cancel"
                 "clojure.core/with-local-vars"
                 "clojure.core/agent"
                 "clojure.core/ns-name"
                 "clojure.pprint/pprint-newline"
                 "clojure.core/bean"
                 "clojure.core/aset-float"
                 "clojure.core/*file*"
                 "clojure.core/*out*"
                 "clojure.core/clojure-version"
                 "clojure.core/with-in-str"
                 "clojure.repl/pst"
                 "clojure.xml/parse"
                 "clojure.core/with-bindings*"
                 "clojure.test/assert-predicate"
                 "clojure.instant/read-instant-timestamp"
                 "clojure.reflect/->Field"
                 "clojure.core/*default-data-reader-fn*"
                 "clojure.core/update-proxy"
                 "clojure.java.io/make-input-stream"
                 "clojure.core/promise"
                 "clojure.instant/validated"
                 "clojure.core/*compile-files*"
                 "clojure.pprint/set-pprint-dispatch"
                 "clojure.core/float?"
                 "clojure.core/eval"
                 "clojure.core/*compile-path*"
                 "clojure.core/gen-class"
                 "clojure.core/macroexpand-1"
                 "clojure.test.tap/print-tap-diagnostic"
                 "clojure.core/find-keyword"
                 "clojure.core/bound-fn*"
                 "clojure.core/find-ns"
                 "clojure.reflect/Constructor"
                 "clojure.test/*stack-trace-depth*"
                 "clojure.reflect/resolve-class"
                 "clojure.edn/read"
                 "clojure.java.io/as-file"
                 "clojure.core/ns-aliases"
                 "clojure.main/stack-element-str"
                 "clojure.core/extend"
                 "clojure.core/char-name-string"
                 "clojure.reflect/JavaReflector"
                 "clojure.inspector/inspect"
                 "clojure.core/send-via"
                 "clojure.core/set-agent-send-executor!"
                 "clojure.core/*e"
                 "clojure.core/create-ns"
                 "clojure.core/aset-int"
                 "clojure.edn/read-string"
                 "clojure.stacktrace/print-throwable"
                 "clojure.pprint/*print-suppress-namespaces*"
                 "clojure.reflect/map->Method"
                 "clojure.pprint/code-dispatch"
                 "clojure.pprint/*print-radix*"
                 "clojure.main/repl-prompt"
                 "clojure.test/with-test"
                 "clojure.pprint/pp"
                 "clojure.core/struct-map"
                 "clojure.template/apply-template"
                 "clojure.core/set-agent-send-off-executor!"
                 "clojure.core/cast"
                 "clojure.core/load"
                 "clojure.java.shell/with-sh-env"
                 "clojure.main/repl-read"
                 "clojure.core/io!"
                 "clojure.repl/dir"
                 "clojure.core/ensure"
                 "clojure.string/re-quote-replacement"
                 "clojure.core/re-groups"
                 "clojure.core/pvalues"
                 "clojure.core/deliver"
                 "clojure.main/load-script"
                 "clojure.core/numerator"
                 "clojure.core/VecNode"
                 "clojure.core/VecSeq"
                 "clojure.core/var-get"
                 "clojure.core/clear-agent-errors"
                 "clojure.core/var-set"
                 "clojure.core/slurp"
                 "clojure.core/bound-fn"
                 "clojure.core/push-thread-bindings"
                 "clojure.core/*unchecked-math*"
                 "clojure.core/aset-short"
                 "clojure.java.io/make-reader"
                 "clojure.core/ns-resolve"
                 "clojure.core/locking"
                 "clojure.core.protocols/coll-reduce"
                 "clojure.core/char-array"
                 "clojure.stacktrace/root-cause"
                 "clojure.core/ratio?"
                 "clojure.core/rational?"
                 "clojure.java.io/as-url"
                 "clojure.core/future"
                 "clojure.core/aset-byte"
                 "clojure.core/send-off"
                 "clojure.java.io/IOFactory"
                 "clojure.reflect/Method"
                 "clojure.core/float-array"
                 "clojure.core/thread-bound?"
                 "clojure.core/with-precision"
                 "clojure.core/proxy"
                 "clojure.core/macroexpand"
                 "clojure.core/aset-char"
                 "clojure.java.io/output-stream"
                 "clojure.test/inc-report-counter"
                 "clojure.java.io/delete-file"
                 "clojure.core/compile"
                 "clojure.repl/stack-element-str"
                 "clojure.core/->VecSeq"
                 "clojure.core/resolve"
                 "clojure.core/->VecNode"
                 "clojure.core/xml-seq"
                 "clojure.test/with-test-out"
                 "clojure.core/file-seq"
                 "clojure.core/short-array"
                 "clojure.core/future-done?"
                 "clojure.core.reducers/->Cat"
                 "clojure.core/get-thread-bindings"
                 "clojure.stacktrace/e"
                 "clojure.pprint/cl-format"
                 "clojure.core/ns-unmap"
                 "clojure.core/struct"
                 "clojure.repl/set-break-handler!"
                 "clojure.core/&"
                 "clojure.instant/read-instant-date"
                 "clojure.java.javadoc/add-remote-javadoc"
                 "clojure.reflect/map->Constructor"
                 "clojure.test.tap/print-tap-pass"
                 "clojure.main/root-cause"
                 "clojure.core/extenders"
                 "clojure.core/construct-proxy"
                 "clojure.core/intern"
                 "clojure.pprint/with-pprint-dispatch"
                 "clojure.core/error-mode"
                 "clojure.core/all-ns"
                 "clojure.walk/macroexpand-all"
                 "clojure.core/*ns*"
                 "clojure.core/char-escape-string"
                 "clojure.repl/demunge"
                 "clojure.core/line-seq"
                 "clojure.core/enumeration-seq"
                 "clojure.core/bigdec"
                 "clojure.java.javadoc/add-local-javadoc"
                 "clojure.core/decimal?"
                 "clojure.core/definterface"
                 "clojure.core/pcalls"
                 "clojure.core/ns-unalias"
                 "clojure.core/error-handler"
                 "clojure.core/biginteger"
                 "clojure.pprint/get-pretty-writer"
                 "clojure.core/ref-max-history"
                 "clojure.reflect/TypeReference"
                 "clojure.test/function?"
                 "clojure.pprint/pprint"
                 "clojure.core/definline"
                 "clojure.core/namespace-munge"
                 "clojure.core/pop-thread-bindings"
                 "clojure.main/main"
                 "clojure.core/ns-imports"
                 "clojure.core/aset-long"
                 "clojure.core/dosync"
                 "clojure.core/*'"
                 "clojure.core/seque"
                 "clojure.main/skip-whitespace"
                 "clojure.main/with-bindings"
                 "clojure.core/load-reader"
                 "clojure.core/await-for"
                 "clojure.test.tap/print-tap-plan"
                 "clojure.core/*command-line-args*"
                 "clojure.java.browse/browse-url"
                 "clojure.core/monitor-exit"
                 "clojure.core/re-matcher"
                 "clojure.java.io/as-relative-path"
                 "clojure.test/assert-any"
                 "clojure.core/gen-interface"
                 "clojure.core/with-redefs-fn"
                 "clojure.core/extends?"
                 "clojure.java.io/Coercions"
                 "clojure.core/set-error-mode!"
                 "clojure.core/format"
                 "clojure.core/*agent*"
                 "clojure.core/alias"
                 "clojure.core/ns-publics"
                 "clojure.core/bound?"
                 "clojure.instant/read-instant-calendar"
                 "clojure.java.io/writer"
                 "clojure.pprint/*print-pprint-dispatch*"
                 "clojure.core/with-open"
                 "clojure.core/set-error-handler!"
                 "clojure.repl/source"
                 "clojure.java.shell/sh"
                 "clojure.reflect/->JavaReflector"
                 "clojure.core/*compiler-options*"
                 "clojure.core/denominator"
                 "clojure.main/skip-if-eol"
                 "clojure.core/dec'"
                 "clojure.data/equality-partition"
                 "clojure.core/refer-clojure"
                 "clojure.main/with-read-known"
                 "clojure.java.io/reader"
                 "clojure.reflect/Reflector"
                 "clojure.main/repl-exception"
                 "clojure.test.tap/print-tap-fail"
                 "clojure.core/bigint"
                 "clojure.core/resultset-seq"
                 "clojure.test/get-possibly-unbound-var"
                 "clojure.core.protocols/internal-reduce"
                 "clojure.reflect/AsmReflector"
                 "clojure.core/boolean-array"
                 "clojure.core/add-classpath"
                 "clojure.core/*warn-on-reflection*"},
 :symbols {"cljs.core/keys" {:ns "cljs.core",
                             :name "keys",
                             :signature ["[hash-map]"],
                             :name-encode "keys",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keys",
                             :source {:code "(defn keys\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (KeySeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7230 7234]},
                             :full-name "cljs.core/keys",
                             :docstring "Returns a sequence of the map's keys."},
           "cljs.core/unchecked-negate" {:ns "cljs.core",
                                         :name "unchecked-negate",
                                         :signature ["[x]"],
                                         :name-encode "unchecked-negate",
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-negate",
                                         :source {:code "(defn unchecked-negate [x]\n  (cljs.core/unchecked-negate x))",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2002 2003]},
                                         :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-negate\n  ([x] `(- ~x)))",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/clj/cljs/core.clj",
                                                          :lines [399
                                                                  400]}],
                                         :full-name "cljs.core/unchecked-negate"},
           "cljs.core/reset!" {:ns "cljs.core",
                               :name "reset!",
                               :signature ["[a new-value]"],
                               :name-encode "resetBANG",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/resetBANG",
                               :source {:code "(defn reset!\n  [a new-value]\n  (if (instance? Atom a)\n    (let [validate (.-validator a)]\n      (when-not (nil? validate)\n        (assert (validate new-value) \"Validator rejected reference state\"))\n      (let [old-value (.-state a)]\n        (set! (.-state a) new-value)\n        (when-not (nil? (.-watches a))\n          (-notify-watches a old-value new-value))\n        new-value))\n    (-reset! a new-value)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3535 3548]},
                               :full-name "cljs.core/reset!",
                               :docstring "Sets the value of atom to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/ITransientCollection" {:ns "cljs.core",
                                             :name "ITransientCollection",
                                             :name-encode "ITransientCollection",
                                             :implementations #{"TransientArrayMap"
                                                                "TransientVector"
                                                                "TransientHashMap"
                                                                "TransientHashSet"},
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/ITransientCollection",
                                             :source {:code "(defprotocol ITransientCollection\n  (^clj -conj! [tcoll val])\n  (^clj -persistent! [tcoll]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [376 378]},
                                             :methods [{:name "-conj!",
                                                        :signature ["[tcoll val]"],
                                                        :docstring nil}
                                                       {:name "-persistent!",
                                                        :signature ["[tcoll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/ITransientCollection"},
           "cljs.core/transient" {:ns "cljs.core",
                                  :name "transient",
                                  :signature ["[coll]"],
                                  :name-encode "transient",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transient",
                                  :source {:code "(defn transient\n  [coll]\n  (-as-transient coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2911 2914]},
                                  :full-name "cljs.core/transient",
                                  :docstring "Returns a new, transient version of the collection, in constant time."},
           "cljs.core/Fn" {:ns "cljs.core",
                           :name "Fn",
                           :name-encode "Fn",
                           :implementations #{"MetaFn"
                                              "function"
                                              "Var"},
                           :history [["+" "0.0-1552"]],
                           :type "protocol",
                           :full-name-encode "cljs.core/Fn",
                           :source {:code "(defprotocol Fn\n  \"Marker protocol\")",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [227 228]},
                           :full-name "cljs.core/Fn",
                           :docstring "Marker protocol"},
           "clojure.data/EqualityPartition" {:ns "clojure.data",
                                             :name "EqualityPartition",
                                             :name-encode "EqualityPartition",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "protocol",
                                             :full-name-encode "clojure.data/EqualityPartition",
                                             :source {:code "(defprotocol EqualityPartition\n  \"Implementation detail. Subject to change.\"\n  (equality-partition [x] \"Implementation detail. Subject to change.\"))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/clojure/data.cljs",
                                                      :lines [75 77]},
                                             :methods [{:name "equality-partition",
                                                        :signature ["[x]"],
                                                        :docstring "Implementation detail. Subject to change."}],
                                             :full-name "clojure.data/EqualityPartition",
                                             :docstring "Implementation detail. Subject to change."},
           "cljs.core/ex-message" {:ns "cljs.core",
                                   :name "ex-message",
                                   :signature ["[ex]"],
                                   :name-encode "ex-message",
                                   :history [["+" "0.0-1576"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/ex-message",
                                   :source {:code "(defn ex-message\n  [ex]\n  (when (instance? js/Error ex)\n    (.-message ex)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [9208 9214]},
                                   :full-name "cljs.core/ex-message",
                                   :docstring "Alpha - subject to change.\nReturns the message attached to the given Error / ExceptionInfo object.\nFor non-Errors returns nil."},
           "clojure.set/select" {:ns "clojure.set",
                                 :name "select",
                                 :signature ["[pred xset]"],
                                 :name-encode "select",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/select",
                                 :source {:code "(defn select\n  [pred xset]\n    (reduce (fn [s k] (if (pred k) s (disj s k)))\n            xset xset))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [61 65]},
                                 :full-name "clojure.set/select",
                                 :docstring "Returns a set of the elements for which pred is true"},
           "cljs.core/hash-unordered-coll" {:return-type number,
                                            :ns "cljs.core",
                                            :name "hash-unordered-coll",
                                            :signature ["[coll]"],
                                            :name-encode "hash-unordered-coll",
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/hash-unordered-coll",
                                            :source {:code "(defn ^number hash-unordered-coll\n  [coll]\n  (loop [n 0 hash-code 0 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ hash-code (hash (first coll))) 0) (next coll))\n      (mix-collection-hash hash-code n))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [835 845]},
                                            :full-name "cljs.core/hash-unordered-coll",
                                            :docstring "Returns the hash code, consistent with =, for an external unordered\ncollection implementing Iterable. For maps, the iterator should\nreturn map entries whose hash is computed as\n  (hash-ordered-coll [k v]).\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/delay" {:ns "cljs.core",
                              :name "delay",
                              :signature ["[& body]"],
                              :name-encode "delay",
                              :type "macro",
                              :full-name-encode "cljs.core/delay",
                              :source {:code "(defmacro delay [& body]\n  \"Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.\"\n  `(new cljs.core/Delay (fn [] ~@body) nil))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1097 1102]},
                              :full-name "cljs.core/delay",
                              :history [["+" "0.0-927"]]},
           "cljs.core/float" {:return-type number,
                              :ns "cljs.core",
                              :name "float",
                              :signature ["[x]"],
                              :name-encode "float",
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/float",
                              :source {:code "(defn ^number float [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1946]},
                              :extra-sources [{:code "(defmacro float [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [363]}],
                              :full-name "cljs.core/float"},
           "cljs.core/bit-not" {:ns "cljs.core",
                                :name "bit-not",
                                :signature ["[x]"],
                                :name-encode "bit-not",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-not",
                                :source {:code "(defn bit-not\n  [x] (cljs.core/bit-not x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2117 2119]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-not [x]\n  (core/list 'js* \"(~ ~{})\" x))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [490 491]}],
                                :full-name "cljs.core/bit-not",
                                :docstring "Bitwise complement"},
           "cljs.core/partition" {:ns "cljs.core",
                                  :name "partition",
                                  :signature ["[n coll]"
                                              "[n step coll]"
                                              "[n step pad coll]"],
                                  :name-encode "partition",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/partition",
                                  :source {:code "(defn partition\n  ([n coll]\n     (partition n n coll))\n  ([n step coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (when (== n (count p))\n             (cons p (partition n step (drop step s))))))))\n  ([n step pad coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [p (take n s)]\n           (if (== n (count p))\n             (cons p (partition n step pad (drop step s)))\n             (list (take n (concat p pad)))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4056 4076]},
                                  :full-name "cljs.core/partition",
                                  :docstring "Returns a lazy sequence of lists of n items each, at offsets step\napart. If step is not supplied, defaults to n, i.e. the partitions\ndo not overlap. If a pad collection is supplied, use its elements as\nnecessary to complete last partition up to n items. In case there are\nnot enough padding elements, return a partition with less than n items."},
           "cljs.core/IEncodeJS" {:ns "cljs.core",
                                  :name "IEncodeJS",
                                  :name-encode "IEncodeJS",
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IEncodeJS",
                                  :source {:code "(defprotocol IEncodeJS\n  (-clj->js [x] \"Recursively transforms clj values to JavaScript\")\n  (-key->js [x] \"Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8621 8624]},
                                  :methods [{:name "-clj->js",
                                             :signature ["[x]"],
                                             :docstring "Recursively transforms clj values to JavaScript"}
                                            {:name "-key->js",
                                             :signature ["[x]"],
                                             :docstring "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)"}],
                                  :full-name "cljs.core/IEncodeJS",
                                  :history [["+" "0.0-1552"]]},
           "cljs.core/parents" {:ns "cljs.core",
                                :name "parents",
                                :signature ["[tag]" "[h tag]"],
                                :name-encode "parents",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/parents",
                                :source {:code "(defn parents\n  ([tag] (parents @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:parents h) tag))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8786 8792]},
                                :full-name "cljs.core/parents",
                                :docstring "Returns the immediate parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/aclone" {:ns "cljs.core",
                               :name "aclone",
                               :signature ["[arr]"],
                               :name-encode "aclone",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/aclone",
                               :source {:code "(defn aclone\n  [arr]\n  (let [len (alength arr)\n        new-arr (make-array len)]\n    (dotimes [i len]\n      (aset new-arr i (aget arr i)))\n    new-arr))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [169 176]},
                               :full-name "cljs.core/aclone",
                               :docstring "Returns a javascript array, cloned from the passed in array"},
           "cljs.core/reset-meta!" {:ns "cljs.core",
                                    :name "reset-meta!",
                                    :signature ["[iref m]"],
                                    :name-encode "reset-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reset-metaBANG",
                                    :source {:code "(defn reset-meta!\n  [iref m]\n  (set! (.-meta iref) m))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8460 8463]},
                                    :full-name "cljs.core/reset-meta!",
                                    :docstring "Atomically resets the metadata for an atom"},
           "cljs.core/IReset" {:ns "cljs.core",
                               :name "IReset",
                               :name-encode "IReset",
                               :type "protocol",
                               :full-name-encode "cljs.core/IReset",
                               :source {:code "(defprotocol IReset\n  (-reset! [o new-value]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [412 413]},
                               :methods [{:name "-reset!",
                                          :signature ["[o new-value]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IReset",
                               :history [["+" "0.0-2173"]]},
           "warnings/invoke-ctor" {:ns "warnings",
                                   :name "invoke-ctor",
                                   :type "warning",
                                   :full-name "warnings/invoke-ctor",
                                   :full-name-encode "warnings/invoke-ctor",
                                   :name-encode "invoke-ctor",
                                   :history [["+" "0.0-2060"]]},
           "cljs.core/Box" {:ns "cljs.core",
                            :name "Box",
                            :signature ["[val]"],
                            :name-encode "Box",
                            :type "type",
                            :full-name-encode "cljs.core/Box",
                            :source {:code "(deftype Box [^:mutable val])",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [5588]},
                            :full-name "cljs.core/Box",
                            :history [["+" "0.0-1424"]]},
           "cljs.reader/dispatch-macros" {:ns "cljs.reader",
                                          :name "dispatch-macros",
                                          :signature ["[s]"],
                                          :name-encode "dispatch-macros",
                                          :type "function",
                                          :full-name-encode "cljs.reader/dispatch-macros",
                                          :source {:code "(defn dispatch-macros [s]\n  (cond\n   (identical? s \"{\") read-set\n   (identical? s \"<\") (throwing-reader \"Unreadable form\")\n   (identical? s \"\\\"\") read-regex\n   (identical? s\"!\") read-comment\n   (identical? s \"_\") read-discard\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [415 422]},
                                          :full-name "cljs.reader/dispatch-macros",
                                          :history [["+" "0.0-927"]]},
           "closure-warnings/externs-validation" {:ns "closure-warnings",
                                                  :name "externs-validation",
                                                  :type "warning",
                                                  :full-name "closure-warnings/externs-validation",
                                                  :full-name-encode "closure-warnings/externs-validation",
                                                  :name-encode "externs-validation",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.repl.rhino/current-repl-env" {:ns "cljs.repl.rhino",
                                               :name "current-repl-env",
                                               :name-encode "current-repl-env",
                                               :type "var",
                                               :full-name-encode "cljs.repl.rhino/current-repl-env",
                                               :source {:code "(def current-repl-env (atom nil))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2511",
                                                        :filename "src/clj/cljs/repl/rhino.clj",
                                                        :lines [18]},
                                               :full-name "cljs.repl.rhino/current-repl-env",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-2629"]],
                                               :removed {:in "0.0-2629",
                                                         :last-seen "0.0-2511"}},
           "cljs.core/int-rotate-left" {:return-type number,
                                        :ns "cljs.core",
                                        :name "int-rotate-left",
                                        :signature ["[x n]"],
                                        :name-encode "int-rotate-left",
                                        :history [["+" "0.0-2261"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/int-rotate-left",
                                        :source {:code "(defn ^number int-rotate-left [x n]\n  (bit-or\n    (bit-shift-left x n)\n    (unsigned-bit-shift-right x (- n))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [444 447]},
                                        :full-name "cljs.core/int-rotate-left"},
           "cljs.core/ICollection" {:ns "cljs.core",
                                    :name "ICollection",
                                    :name-encode "ICollection",
                                    :implementations #{"Subvec"
                                                       "PersistentQueue"
                                                       "PersistentHashMap"
                                                       "PersistentTreeSet"
                                                       "PersistentArrayMapSeq"
                                                       "RedNode"
                                                       "EmptyList"
                                                       "LazyTransformer"
                                                       "ObjMap"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "ValSeq"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "PersistentQueueSeq"
                                                       "ChunkedSeq"
                                                       "ArrayNodeSeq"
                                                       "KeySeq"
                                                       "IndexedSeq"
                                                       "PersistentTreeMap"
                                                       "PersistentTreeMapSeq"
                                                       "RSeq"
                                                       "PersistentArrayMap"
                                                       "PersistentHashSet"
                                                       "NodeSeq"
                                                       "List"
                                                       "Cons"
                                                       "LazySeq"},
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ICollection",
                                    :source {:code "(defprotocol ICollection\n  (^clj -conj [coll o]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [264 265]},
                                    :methods [{:name "-conj",
                                               :signature ["[coll o]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/ICollection"},
           "cljs.build.api/cljs-dependents-for-macro-namespaces" {:ns "cljs.build.api",
                                                                  :name "cljs-dependents-for-macro-namespaces",
                                                                  :signature ["[namespaces]"],
                                                                  :name-encode "cljs-dependents-for-macro-namespaces",
                                                                  :history [["+"
                                                                             "0.0-2496"]],
                                                                  :type "function",
                                                                  :full-name-encode "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :source {:code "(defn cljs-dependents-for-macro-namespaces\n  [namespaces]\n  (map :name\n       (let [namespaces-set (set namespaces)]\n         (filter (fn [x] (not-empty\n                         (intersection namespaces-set (-> x :require-macros vals set))))\n                 (vals (:cljs.analyzer/namespaces @env/*compiler*))))))",
                                                                           :title "Source code",
                                                                           :repo "clojurescript",
                                                                           :tag "r2760",
                                                                           :filename "src/clj/cljs/build/api.clj",
                                                                           :lines [45
                                                                                   64]},
                                                                  :full-name "cljs.build.api/cljs-dependents-for-macro-namespaces",
                                                                  :docstring "Takes a list of Clojure (.clj) namespaces that define macros and\nreturns a list ClojureScript (.cljs) namespaces that depend on those macro\nnamespaces.\n\nFor example where example.macros is defined in the clojure file\n\"example/macros.clj\" and both 'example.core and 'example.util are\nClojureScript namespaces that require and use the macros from\n'example.macros :\n(cljs-dependents-for-macro-namespaces 'example.macros) ->\n('example.core 'example.util)\n\nThis must be called when cljs.env/*compiler* is bound to the\ncompile env that you are inspecting. See cljs.env/with-compile-env."},
           "warnings/redef" {:ns "warnings",
                             :name "redef",
                             :type "warning",
                             :full-name "warnings/redef",
                             :full-name-encode "warnings/redef",
                             :name-encode "redef",
                             :history [["+" "0.0-1835"]]},
           "cljs.core/every?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "every?",
                               :signature ["[pred coll]"],
                               :name-encode "everyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/everyQMARK",
                               :source {:code "(defn ^boolean every?\n  [pred coll]\n  (cond\n   (nil? (seq coll)) true\n   (pred (first coll)) (recur pred (next coll))\n   :else false))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3291 3298]},
                               :full-name "cljs.core/every?",
                               :docstring "Returns true if (pred x) is logical true for every x in coll, else\nfalse."},
           "clojure.zip/node" {:ns "clojure.zip",
                               :name "node",
                               :signature ["[loc]"],
                               :name-encode "node",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/node",
                               :source {:code "(defn node\n  [loc] (loc 0))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [60 62]},
                               :full-name "clojure.zip/node",
                               :docstring "Returns the node at loc"},
           "cljs.core/IEmptyableCollection" {:ns "cljs.core",
                                             :name "IEmptyableCollection",
                                             :name-encode "IEmptyableCollection",
                                             :implementations #{"Subvec"
                                                                "PersistentQueue"
                                                                "PersistentHashMap"
                                                                "PersistentTreeSet"
                                                                "PersistentArrayMapSeq"
                                                                "RedNode"
                                                                "EmptyList"
                                                                "LazyTransformer"
                                                                "ObjMap"
                                                                "BlackNode"
                                                                "PersistentVector"
                                                                "ValSeq"
                                                                "ChunkedCons"
                                                                "Range"
                                                                "PersistentQueueSeq"
                                                                "ChunkedSeq"
                                                                "ArrayNodeSeq"
                                                                "KeySeq"
                                                                "IndexedSeq"
                                                                "PersistentTreeMap"
                                                                "PersistentTreeMapSeq"
                                                                "RSeq"
                                                                "PersistentArrayMap"
                                                                "PersistentHashSet"
                                                                "NodeSeq"
                                                                "List"
                                                                "Cons"
                                                                "LazySeq"},
                                             :history [["+" "0.0-927"]],
                                             :type "protocol",
                                             :full-name-encode "cljs.core/IEmptyableCollection",
                                             :source {:code "(defprotocol IEmptyableCollection\n  (-empty [coll]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [261 262]},
                                             :methods [{:name "-empty",
                                                        :signature ["[coll]"],
                                                        :docstring nil}],
                                             :full-name "cljs.core/IEmptyableCollection"},
           "clojure.zip/right" {:ns "clojure.zip",
                                :name "right",
                                :signature ["[loc]"],
                                :name-encode "right",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/right",
                                :source {:code "(defn right\n  [loc]\n    (let [[node {l :l  [r & rnext :as rs] :r :as path}] loc]\n      (when (and path rs)\n        (with-meta [r (assoc path :l (conj l node) :r rnext)] (meta loc)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [135 140]},
                                :full-name "clojure.zip/right",
                                :docstring "Returns the loc of the right sibling of the node at this loc, or nil"},
           "warnings/preamble-missing" {:ns "warnings",
                                        :name "preamble-missing",
                                        :type "warning",
                                        :full-name "warnings/preamble-missing",
                                        :full-name-encode "warnings/preamble-missing",
                                        :name-encode "preamble-missing",
                                        :history [["+" "0.0-2371"]]},
           "cljs.core/int-array" {:ns "cljs.core",
                                  :name "int-array",
                                  :signature ["[size-or-seq]"
                                              "[size init-val-or-seq]"],
                                  :name-encode "int-array",
                                  :type "function",
                                  :full-name-encode "cljs.core/int-array",
                                  :source {:code "(defn int-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (int-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2777 2795]},
                                  :full-name "cljs.core/int-array",
                                  :history [["+" "0.0-1798"]]},
           "cljs.core/LazyTransformer.createMulti" {:ns "cljs.core",
                                                    :name "LazyTransformer.createMulti",
                                                    :signature ["[xform colls]"],
                                                    :name-encode "LazyTransformerDOTcreateMulti",
                                                    :history [["+"
                                                               "0.0-2301"]],
                                                    :parent-type "LazyTransformer",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/LazyTransformerDOTcreateMulti",
                                                    :source {:code "(set! (.-createMulti LazyTransformer)\n  (fn [xform colls]\n    (let [iters (array)]\n      (doseq [coll colls]\n        (.push iters (iter coll)))\n      (LazyTransformer.\n        (multi-stepper xform iters (make-array (alength iters)))\n        nil nil nil))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3264
                                                                     3271]},
                                                    :full-name "cljs.core/LazyTransformer.createMulti"},
           "cljs.core/==" {:return-type boolean,
                           :ns "cljs.core",
                           :name "==",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "EQEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/EQEQ",
                           :source {:code "(defn ^boolean ==\n  ([x] true)\n  ([x y] (-equiv x y))\n  ([x y & more]\n   (if (== x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (== y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [2154 2165]},
                           :extra-sources [{:code "(defmacro ^::ana/numeric ==\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} === ~{})\" x y)))\n  ([x y & more] `(and (== ~x ~y) (== ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [455 458]}],
                           :full-name "cljs.core/==",
                           :docstring "Returns non-nil if nums all have the equivalent\nvalue, otherwise false. Behavior on non nums is\nundefined."},
           "cljs.core/dissoc!" {:ns "cljs.core",
                                :name "dissoc!",
                                :signature ["[tcoll key]"
                                            "[tcoll key & ks]"],
                                :name-encode "dissocBANG",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/dissocBANG",
                                :source {:code "(defn dissoc!\n  ([tcoll key]\n    (-dissoc! tcoll key))\n  ([tcoll key & ks]\n    (let [ntcoll (-dissoc! tcoll key)]\n      (if ks\n        (recur ntcoll (first ks) (next ks))\n        ntcoll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2948 2956]},
                                :full-name "cljs.core/dissoc!",
                                :docstring "Returns a transient map that doesn't contain a mapping for key(s)."},
           "clojure.reflect/meta" {:ns "clojure.reflect",
                                   :name "meta",
                                   :signature ["[sym cb]"],
                                   :name-encode "meta",
                                   :history [["+" "0.0-1503"]],
                                   :type "function",
                                   :full-name-encode "clojure.reflect/meta",
                                   :source {:code "(defn meta\n  [sym cb]\n  (query-reflection (str \"var=\" (js/encodeURIComponent (str sym)))\n                    #(cb (evaluate-javascript %))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/reflect.cljs",
                                            :lines [24 30]},
                                   :full-name "clojure.reflect/meta",
                                   :docstring "Queries the reflection api with a fully qualified symbol, then calls\ncallback fn cb with the evaluated cljs map containing that symbol's\nmeta information."},
           "clojure.browser.net/*timeout*" {:ns "clojure.browser.net",
                                            :name "*timeout*",
                                            :name-encode "STARtimeoutSTAR",
                                            :type "var",
                                            :full-name-encode "clojure.browser.net/STARtimeoutSTAR",
                                            :source {:code "(def *timeout* 10000)",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/browser/net.cljs",
                                                     :lines [19]},
                                            :full-name "clojure.browser.net/*timeout*",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/let*" {:ns "cljs.core",
                             :name "let*",
                             :type "special form",
                             :source {:code "(defmethod parse 'let*\n  [op encl-env form _ _]\n  (analyze-let encl-env form false))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [980 982]},
                             :extra-sources ({:code "(defmethod emit* :let [ast]\n  (emit-let ast false))",
                                              :title "Emitting code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/compiler.clj",
                                              :lines [685 686]}),
                             :full-name "cljs.core/let*",
                             :full-name-encode "cljs.core/letSTAR",
                             :name-encode "letSTAR",
                             :history [["+" "0.0-927"]]},
           "cljs.core/remove-method" {:ns "cljs.core",
                                      :name "remove-method",
                                      :signature ["[multifn dispatch-val]"],
                                      :name-encode "remove-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/remove-method",
                                      :source {:code "(defn remove-method\n [multifn dispatch-val]\n (-remove-method multifn dispatch-val))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [9120 9123]},
                                      :full-name "cljs.core/remove-method",
                                      :docstring "Removes the method of multimethod associated with dispatch-value."},
           "cljs.core/array-chunk" {:ns "cljs.core",
                                    :name "array-chunk",
                                    :signature ["[arr]"
                                                "[arr off]"
                                                "[arr off end]"],
                                    :name-encode "array-chunk",
                                    :type "function",
                                    :full-name-encode "cljs.core/array-chunk",
                                    :source {:code "(defn array-chunk\n  ([arr]\n     (ArrayChunk. arr 0 (alength arr)))\n  ([arr off]\n     (ArrayChunk. arr off (alength arr)))\n  ([arr off end]\n     (ArrayChunk. arr off end)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2660 2666]},
                                    :full-name "cljs.core/array-chunk",
                                    :history [["+" "0.0-1424"]]},
           "clojure.core.reducers/drop" {:ns "clojure.core.reducers",
                                         :name "drop",
                                         :signature ["[n]" "[n coll]"],
                                         :name-encode "drop",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/drop",
                                         :source {:code "(defcurried drop\n  \"Elides the first n values from the reduction of coll.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (f1 ret k v)\n              ret)))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [178 190]},
                                         :full-name "clojure.core.reducers/drop",
                                         :docstring "Elides the first n values from the reduction of coll."},
           "syntax/symbol" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "symbol",
                            :name-encode "symbol",
                            :type "syntax",
                            :full-name-encode "syntax/symbol",
                            :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [275 301]}),
                            :full-name "syntax/symbol",
                            :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentArrayMap.fromArrays" {:ns "cljs.core",
                                                      :name "PersistentArrayMap.fromArrays",
                                                      :signature ["[ks vs]"],
                                                      :name-encode "PersistentArrayMapDOTfromArrays",
                                                      :history [["+"
                                                                 "0.0-1211"]
                                                                ["-"
                                                                 "0.0-1798"]],
                                                      :parent-type "PersistentArrayMap",
                                                      :type "function",
                                                      :full-name-encode "cljs.core/PersistentArrayMapDOTfromArrays",
                                                      :source {:code "(set! cljs.core.PersistentArrayMap/fromArrays\n      (fn [ks vs]\n        (let [len (count ks)]\n          (loop [i   0\n                 out (transient cljs.core.PersistentArrayMap/EMPTY)]\n            (if (< i len)\n              (recur (inc i) (assoc! out (aget ks i) (aget vs i)))\n              (persistent! out))))))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r1586",
                                                               :filename "src/cljs/cljs/core.cljs",
                                                               :lines [3976
                                                                       3983]},
                                                      :full-name "cljs.core/PersistentArrayMap.fromArrays",
                                                      :removed {:in "0.0-1798",
                                                                :last-seen "0.0-1586"}},
           "cljs.core/frequencies" {:ns "cljs.core",
                                    :name "frequencies",
                                    :signature ["[coll]"],
                                    :name-encode "frequencies",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/frequencies",
                                    :source {:code "(defn frequencies\n  [coll]\n  (persistent!\n   (reduce (fn [counts x]\n             (assoc! counts x (inc (get counts x 0))))\n           (transient {}) coll)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7970 7977]},
                                    :full-name "cljs.core/frequencies",
                                    :docstring "Returns a map from distinct items in coll to the number of times\nthey appear."},
           "cljs.core/require-macros" {:ns "cljs.core",
                                       :name "require-macros",
                                       :name-encode "require-macros",
                                       :type "special form (repl)",
                                       :full-name-encode "cljs.core/require-macros",
                                       :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n         (when-not (and (= quote 'quote) (symbol? ns-name))\n           (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n         (when-not (ana/get-namespace ns-name)\n           (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n           (-evaluate repl-env \"<cljs repl>\" 1\n             (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n         (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require-macros\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n         (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))}))",
                                                :title "repl specials table",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [275 336]},
                                       :full-name "cljs.core/require-macros",
                                       :repl-only? true,
                                       :history [["+" "0.0-2657"]]},
           "cljs.core/pop" {:ns "cljs.core",
                            :name "pop",
                            :signature ["[coll]"],
                            :name-encode "pop",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/pop",
                            :source {:code "(defn pop\n  [coll]\n  (when-not (nil? coll)\n    (-pop coll)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1472 1478]},
                            :full-name "cljs.core/pop",
                            :docstring "For a list or queue, returns a new list/queue without the first\nitem, for a vector, returns a new vector without the last item.\nNote - not the same as next/butlast."},
           "cljs.repl/with-read-known" {:ns "cljs.repl",
                                        :name "with-read-known",
                                        :signature ["[& body]"],
                                        :name-encode "with-read-known",
                                        :history [["+" "0.0-2719"]],
                                        :type "macro",
                                        :full-name-encode "cljs.repl/with-read-known",
                                        :source {:code "(defmacro with-read-known\n  [& body]\n  `(binding [*read-eval* (if (= :unknown *read-eval*) true *read-eval*)]\n     ~@body))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [80 85]},
                                        :full-name "cljs.repl/with-read-known",
                                        :docstring "Evaluates body with *read-eval* set to a \"known\" value,\ni.e. substituting true for :unknown if necessary."},
           "cljs.core/flatmap" {:ns "cljs.core",
                                :name "flatmap",
                                :signature ["[f]" "[f coll]"],
                                :name-encode "flatmap",
                                :history [["+" "0.0-2301"]
                                          ["-" "0.0-2341"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatmap",
                                :source {:code "(defn flatmap\n  ([f]\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([result] (f1 result))\n       ([result input]\n          (reduce (preserving-reduced f1) result (f input))))))\n  ([f coll] (sequence (flatmap f) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2322",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8139 8150]},
                                :full-name "cljs.core/flatmap",
                                :docstring "maps f over coll and concatenates the results.  Thus function f\nshould return a collection.  Returns a transducer when no collection\nis provided.",
                                :removed {:in "0.0-2341",
                                          :last-seen "0.0-2322"}},
           "cljs.core/not-every?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "not-every?",
                                   :signature ["[pred coll]"],
                                   :name-encode "not-everyQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/not-everyQMARK",
                                   :source {:code "(defn ^boolean not-every?\n  [pred coll] (not (every? pred coll)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3300 3303]},
                                   :full-name "cljs.core/not-every?",
                                   :docstring "Returns false if (pred x) is logical true for every x in\ncoll, else true."},
           "cljs.core/js-invoke" {:ns "cljs.core",
                                  :name "js-invoke",
                                  :signature ["[obj s & args]"],
                                  :name-encode "js-invoke",
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/js-invoke",
                                  :source {:code "(defn js-invoke\n  [obj s & args]\n  (.apply (aget obj s) obj (into-array args)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [219 223]},
                                  :full-name "cljs.core/js-invoke",
                                  :docstring "Invoke JavaScript object method via string. Needed when the\nstring is not a valid unquoted property name."},
           "cljs.core/some-fn" {:ns "cljs.core",
                                :name "some-fn",
                                :signature ["[p]"
                                            "[p1 p2]"
                                            "[p1 p2 p3]"
                                            "[p1 p2 p3 & ps]"],
                                :name-encode "some-fn",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/some-fn",
                                :source {:code "(defn some-fn\n  ([p]\n     (fn sp1\n       ([] nil)\n       ([x] (p x))\n       ([x y] (or (p x) (p y)))\n       ([x y z] (or (p x) (p y) (p z)))\n       ([x y z & args] (or (sp1 x y z)\n                           (some p args)))))\n  ([p1 p2]\n     (fn sp2\n       ([] nil)\n       ([x] (or (p1 x) (p2 x)))\n       ([x y] (or (p1 x) (p1 y) (p2 x) (p2 y)))\n       ([x y z] (or (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z)))\n       ([x y z & args] (or (sp2 x y z)\n                           (some #(or (p1 %) (p2 %)) args)))))\n  ([p1 p2 p3]\n     (fn sp3\n       ([] nil)\n       ([x] (or (p1 x) (p2 x) (p3 x)))\n       ([x y] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y)))\n       ([x y z] (or (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z)))\n       ([x y z & args] (or (sp3 x y z)\n                           (some #(or (p1 %) (p2 %) (p3 %)) args)))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn spn\n         ([] nil)\n         ([x] (some #(% x) ps))\n         ([x y] (some #(or (% x) (% y)) ps))\n         ([x y z] (some #(or (% x) (% y) (% z)) ps))\n         ([x y z & args] (or (spn x y z)\n                             (some #(some % args) ps)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3693 3730]},
                                :full-name "cljs.core/some-fn",
                                :docstring "Takes a set of predicates and returns a function f that returns the first logical true value\nreturned by one of its composing predicates against any of its arguments, else it returns\nlogical false. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical true result against the original predicates."},
           "syntax/vector" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "vector",
                            :name-encode "vector",
                            :type "syntax",
                            :full-name-encode "syntax/vector",
                            :extra-sources ({:code "(defn- read-vector\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-vector (read-delimited \\] rdr true)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta the-vector\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [188 203]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [591 610]}),
                            :full-name "syntax/vector",
                            :history [["+" "0.0-1853"]]},
           "clojure.browser.event/remove-all" {:ns "clojure.browser.event",
                                               :name "remove-all",
                                               :signature ["[opt_obj opt_type opt_capt]"],
                                               :name-encode "remove-all",
                                               :type "function",
                                               :full-name-encode "clojure.browser.event/remove-all",
                                               :source {:code "(defn remove-all [opt_obj opt_type opt_capt])",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [100]},
                                               :full-name "clojure.browser.event/remove-all",
                                               :history [["+"
                                                          "0.0-927"]]},
           "cljs.core/doto" {:ns "cljs.core",
                             :name "doto",
                             :signature ["[x & forms]"],
                             :name-encode "doto",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/doto",
                             :source {:code "(defmacro doto\n  [x & forms]\n    (let [gx (gensym)]\n      `(let [~gx ~x]\n         ~@(map (fn [f]\n                  (if (seq? f)\n                    `(~(first f) ~gx ~@(next f))\n                    `(~f ~gx)))\n                forms)\n         ~gx)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [3533 3548]},
                             :full-name "cljs.core/doto",
                             :docstring "Evaluates x then calls all of the methods and functions with the\nvalue of x supplied at the front of the given arguments.  The forms\nare evaluated in order.  Returns x.\n\n(doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))"},
           "cljs.core/take-while" {:ns "cljs.core",
                                   :name "take-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :name-encode "take-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/take-while",
                                   :source {:code "(defn take-while\n  ([pred]\n     (fn [rf]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (if (pred input)\n              (rf result input)\n              (reduced result))))))\n  ([pred coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (when (pred (first s))\n           (cons (first s) (take-while pred (rest s))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7740 7757]},
                                   :full-name "cljs.core/take-while",
                                   :docstring "Returns a lazy sequence of successive items from coll while\n(pred item) returns true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "closure-warnings/duplicate-message" {:ns "closure-warnings",
                                                 :name "duplicate-message",
                                                 :type "warning",
                                                 :full-name "closure-warnings/duplicate-message",
                                                 :full-name-encode "closure-warnings/duplicate-message",
                                                 :name-encode "duplicate-message",
                                                 :history [["+"
                                                            "0.0-2120"]]},
           "cljs.repl/evaluate-form" {:ns "cljs.repl",
                                      :name "evaluate-form",
                                      :signature ["[repl-env env filename form]"
                                                  "[repl-env env filename form wrap]"
                                                  "[repl-env env filename form wrap opts]"],
                                      :name-encode "evaluate-form",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/evaluate-form",
                                      :source {:code "(defn evaluate-form\n  ([repl-env env filename form]\n    (evaluate-form repl-env env filename form identity))\n  ([repl-env env filename form wrap]\n    (evaluate-form repl-env env filename form wrap nil))\n  ([repl-env env filename form wrap opts]\n    (try\n      (binding [ana/*cljs-file* filename]\n        (let [ast (ana/analyze env form opts)\n              js (comp/emit-str ast)\n              wrap-js\n              ;; TODO: check opts as well - David\n              (if (:source-map repl-env)\n                (binding [comp/*source-map-data*\n                          (atom {:source-map (sorted-map)\n                                 :gen-col 0\n                                 :gen-line 0})]\n                  (let [js (comp/emit-str (ana/no-warn (ana/analyze env (wrap form) opts)))\n                        t (System/currentTimeMillis)]\n                    (str js\n                      \"\\n//# sourceURL=repl-\" t \".js\"\n                      \"\\n//# sourceMappingURL=data:application/json;base64,\"\n                      (DatatypeConverter/printBase64Binary\n                        (.getBytes\n                          (sm/encode\n                            {(str \"repl-\" t \".cljs\")\n                             (:source-map @comp/*source-map-data*)}\n                            {:lines (+ (:gen-line @comp/*source-map-data*) 3)\n                             :file  (str \"repl-\" t \".js\")\n                             :sources-content\n                                    [(or (:source (meta form))\n                                       ;; handle strings / primitives without metadata\n                                       (with-out-str (pr form)))]})\n                          \"UTF-8\")))))\n                (comp/emit-str (ana/no-warn (ana/analyze env (wrap form) opts))))]\n          (when (= (:op ast) :ns)\n            (load-dependencies repl-env\n              (into (vals (:requires ast))\n                (distinct (vals (:uses ast))))\n              opts))\n          (when *cljs-verbose*\n            (print js))\n          (let [ret (-evaluate repl-env filename (:line (meta form)) wrap-js)]\n            (case (:status ret)\n              :error (display-error ret form)\n              :exception (display-error ret form\n                           (if (:repl-verbose opts)\n                             #(prn \"Error evaluating:\" form :as js)\n                             (constantly nil)))\n              :success (:value ret)))))\n      (catch Throwable ex\n        (.printStackTrace ex)\n        (println (str ex))\n        (flush)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [160 216]},
                                      :full-name "cljs.repl/evaluate-form",
                                      :docstring "Evaluate a ClojureScript form in the JavaScript environment. Returns a\nstring which is the ClojureScript return value. This string may or may\nnot be readable by the Clojure reader."},
           "cljs.reader/escape-char-map" {:ns "cljs.reader",
                                          :name "escape-char-map",
                                          :signature ["[c]"],
                                          :name-encode "escape-char-map",
                                          :type "function",
                                          :full-name-encode "cljs.reader/escape-char-map",
                                          :source {:code "(defn escape-char-map [c]\n  (cond\n   (identical? c \\t) \"\\t\"\n   (identical? c \\r) \"\\r\"\n   (identical? c \\n) \"\\n\"\n   (identical? c \\\\) \\\\\n   (identical? c \\\") \\\"\n   (identical? c \\b) \"\\b\"\n   (identical? c \\f) \"\\f\"\n   :else nil))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [152 161]},
                                          :full-name "cljs.reader/escape-char-map",
                                          :history [["+" "0.0-927"]]},
           "closure-warnings/tweaks" {:ns "closure-warnings",
                                      :name "tweaks",
                                      :type "warning",
                                      :full-name "closure-warnings/tweaks",
                                      :full-name-encode "closure-warnings/tweaks",
                                      :name-encode "tweaks",
                                      :history [["+" "0.0-2120"]]},
           "clojure.browser.event/all-listeners" {:ns "clojure.browser.event",
                                                  :name "all-listeners",
                                                  :signature ["[obj type capture]"],
                                                  :name-encode "all-listeners",
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.event/all-listeners",
                                                  :source {:code "(defn all-listeners [obj type capture])",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/cljs/clojure/browser/event.cljs",
                                                           :lines [92]},
                                                  :full-name "clojure.browser.event/all-listeners",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/ITransientSet" {:ns "cljs.core",
                                      :name "ITransientSet",
                                      :name-encode "ITransientSet",
                                      :implementations #{"TransientHashSet"},
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientSet",
                                      :source {:code "(defprotocol ITransientSet\n  (^clj -disjoin! [tcoll v]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [390 391]},
                                      :methods [{:name "-disjoin!",
                                                 :signature ["[tcoll v]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientSet"},
           "closure-warnings/es5-strict" {:ns "closure-warnings",
                                          :name "es5-strict",
                                          :type "warning",
                                          :full-name "closure-warnings/es5-strict",
                                          :full-name-encode "closure-warnings/es5-strict",
                                          :name-encode "es5-strict",
                                          :history [["+" "0.0-2120"]]},
           "cljs.core/vals" {:ns "cljs.core",
                             :name "vals",
                             :signature ["[hash-map]"],
                             :name-encode "vals",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/vals",
                             :source {:code "(defn vals\n  [hash-map]\n  (when-let [mseq (seq hash-map)]\n    (ValSeq. mseq nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7298 7302]},
                             :full-name "cljs.core/vals",
                             :docstring "Returns a sequence of the map's values."},
           "cljs.core/IDeref" {:ns "cljs.core",
                               :name "IDeref",
                               :name-encode "IDeref",
                               :implementations #{"Reduced"
                                                  "Delay"
                                                  "Atom"
                                                  "Var"
                                                  "Volatile"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IDeref",
                               :source {:code "(defprotocol IDeref\n (-deref [o]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [308 309]},
                               :methods [{:name "-deref",
                                          :signature ["[o]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IDeref"},
           "cljs.build.api/parse-js-ns" {:ns "cljs.build.api",
                                         :name "parse-js-ns",
                                         :signature ["[f]"],
                                         :name-encode "parse-js-ns",
                                         :history [["+" "0.0-2629"]],
                                         :type "function",
                                         :full-name-encode "cljs.build.api/parse-js-ns",
                                         :source {:code "(defn parse-js-ns\n  [f]\n  (closure/parse-js-ns f))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/build/api.clj",
                                                  :lines [73 78]},
                                         :full-name "cljs.build.api/parse-js-ns",
                                         :docstring "Given a Google Closure style JavaScript file or resource return the namespace\ninformation for the given file. Only returns the value extracted from the\nfirst provide statement."},
           "cljs.core/string-hash-cache" {:ns "cljs.core",
                                          :name "string-hash-cache",
                                          :name-encode "string-hash-cache",
                                          :type "var",
                                          :full-name-encode "cljs.core/string-hash-cache",
                                          :source {:code "(def string-hash-cache (js-obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [509]},
                                          :full-name "cljs.core/string-hash-cache",
                                          :history [["+" "0.0-1424"]]},
           "warnings/protocol-deprecated" {:ns "warnings",
                                           :name "protocol-deprecated",
                                           :type "warning",
                                           :full-name "warnings/protocol-deprecated",
                                           :full-name-encode "warnings/protocol-deprecated",
                                           :name-encode "protocol-deprecated",
                                           :history [["+" "0.0-1835"]]},
           "cljs.core/array-map" {:ns "cljs.core",
                                  :name "array-map",
                                  :signature ["[& keyvals]"],
                                  :name-encode "array-map",
                                  :history [["+" "0.0-1211"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/array-map",
                                  :source {:code "(defn array-map\n  [& keyvals]\n  (.fromArray cljs.core/PersistentArrayMap (apply array keyvals) true false))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7135 7139]},
                                  :extra-sources [{:code "(defmacro array-map\n  ([] '(.-EMPTY cljs.core/PersistentArrayMap))\n  ([& kvs]\n     (let [keys (map first (partition 2 kvs))]\n       (if (core/and (every? #(= (:op %) :constant)\n                       (map #(cljs.analyzer/analyze &env %) keys))\n                     (= (count (into #{} keys)) (count keys)))\n         `(cljs.core/PersistentArrayMap. nil ~(clojure.core// (count kvs) 2) (array ~@kvs) nil)\n         `(.fromArray cljs.core/PersistentArrayMap (array ~@kvs) true false)))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [1430 1438]}],
                                  :full-name "cljs.core/array-map",
                                  :docstring "keyval => key val\nReturns a new array map with supplied mappings."},
           "cljs.test/report" {:ns "cljs.test",
                               :name "report",
                               :name-encode "report",
                               :history [["+" "0.0-2496"]],
                               :type "multimethod",
                               :full-name-encode "cljs.test/report",
                               :source {:code "(defmulti\n  ^{:doc \"Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.\"\n     :dynamic true}\n  report (fn [m] [(:reporter (get-current-env)) (:type m)]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/test.cljs",
                                        :lines [261 267]},
                               :extra-sources ({:code "(defmethod report :default [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [269]}
                                               {:code "(defmethod report [::default :pass] [m]\n  (inc-report-counter! :pass))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [271 272]}
                                               {:code "(defmethod report [::default :fail] [m]\n  (inc-report-counter! :fail)\n  (println \"\\nFAIL in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (println \"expected:\" (pr-str (:expected m)))\n  (println \"  actual:\" (pr-str (:actual m))))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [274 281]}
                                               {:code "(defmethod report [::default :error] [m]\n  (inc-report-counter! :error)\n  (println \"\\nERROR in\" (testing-vars-str m))\n  (when (seq (:testing-contexts (get-current-env)))\n    (println (testing-contexts-str)))\n  (when-let [message (:message m)] (println message))\n  (println \"expected:\" (pr-str (:expected m)))\n  (print \"  actual: \") (prn (:actual m)))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [283 290]}
                                               {:code "(defmethod report [::default :summary] [m]\n  (println \"\\nRan\" (:test m) \"tests containing\"\n    (+ (:pass m) (:fail m) (:error m)) \"assertions.\")\n  (println (:fail m) \"failures,\" (:error m) \"errors.\"))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [292 295]}
                                               {:code "(defmethod report [::default :begin-test-ns] [m]\n  (println \"\\nTesting\" (name (:ns m))))",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [297 298]}
                                               {:code "(defmethod report [::default :end-test-ns] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [301]}
                                               {:code "(defmethod report [::default :begin-test-var] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [302]}
                                               {:code "(defmethod report [::default :end-test-var] [m])",
                                                :title "Dispatch method",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/test.cljs",
                                                :lines [303]}),
                               :full-name "cljs.test/report",
                               :docstring "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key."},
           "clojure.browser.dom/log-obj" {:ns "clojure.browser.dom",
                                          :name "log-obj",
                                          :signature ["[obj]"],
                                          :name-encode "log-obj",
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/log-obj",
                                          :source {:code "(defn log-obj [obj]\n  (.log js/console obj))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [23 24]},
                                          :full-name "clojure.browser.dom/log-obj",
                                          :history [["+" "0.0-927"]]},
           "cljs.nodejs/enable-util-print!" {:ns "cljs.nodejs",
                                             :name "enable-util-print!",
                                             :signature ["[]"],
                                             :name-encode "enable-util-printBANG",
                                             :type "function",
                                             :full-name-encode "cljs.nodejs/enable-util-printBANG",
                                             :source {:code "(defn enable-util-print! []\n  (set! *print-fn* (.-print (require \"util\"))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/nodejs.cljs",
                                                      :lines [19 20]},
                                             :full-name "cljs.nodejs/enable-util-print!",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "cljs.core/for" {:ns "cljs.core",
                            :name "for",
                            :signature ["[seq-exprs body-expr]"],
                            :name-encode "for",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/for",
                            :source {:code "(defmacro for\n  [seq-exprs body-expr]\n  (assert-args for\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [to-groups (fn [seq-exprs]\n                    (reduce (fn [groups [k v]]\n                              (if (core/keyword? k)\n                                (conj (pop groups) (conj (peek groups) [k v]))\n                                (conj groups [k v])))\n                            [] (partition 2 seq-exprs)))\n        err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        emit-bind (fn emit-bind [[[bind expr & mod-pairs]\n                                  & [[_ next-expr] :as next-groups]]]\n                    (let [giter (gensym \"iter__\")\n                          gxs (gensym \"s__\")\n                          do-mod (fn do-mod [[[k v :as pair] & etc]]\n                                   (core/cond\n                                     (= k :let) `(let ~v ~(do-mod etc))\n                                     (= k :while) `(when ~v ~(do-mod etc))\n                                     (= k :when) `(if ~v\n                                                    ~(do-mod etc)\n                                                    (recur (rest ~gxs)))\n                                     (core/keyword? k) (err \"Invalid 'for' keyword \" k)\n                                     next-groups\n                                      `(let [iterys# ~(emit-bind next-groups)\n                                             fs# (seq (iterys# ~next-expr))]\n                                         (if fs#\n                                           (concat fs# (~giter (rest ~gxs)))\n                                           (recur (rest ~gxs))))\n                                     :else `(cons ~body-expr\n                                                  (~giter (rest ~gxs)))))]\n                      (if next-groups\n                        #_ \"not the inner-most loop\"\n                        `(fn ~giter [~gxs]\n                           (lazy-seq\n                            (loop [~gxs ~gxs]\n                              (when-first [~bind ~gxs]\n                                ~(do-mod mod-pairs)))))\n                        #_\"inner-most loop\"\n                        (let [gi (gensym \"i__\")\n                              gb (gensym \"b__\")\n                              do-cmod (fn do-cmod [[[k v :as pair] & etc]]\n                                        (core/cond\n                                          (= k :let) `(let ~v ~(do-cmod etc))\n                                          (= k :while) `(when ~v ~(do-cmod etc))\n                                          (= k :when) `(if ~v\n                                                         ~(do-cmod etc)\n                                                         (recur\n                                                           (unchecked-inc ~gi)))\n                                          (core/keyword? k)\n                                            (err \"Invalid 'for' keyword \" k)\n                                          :else\n                                            `(do (chunk-append ~gb ~body-expr)\n                                                 (recur (unchecked-inc ~gi)))))]\n                          `(fn ~giter [~gxs]\n                             (lazy-seq\n                               (loop [~gxs ~gxs]\n                                 (when-let [~gxs (seq ~gxs)]\n                                   (if (chunked-seq? ~gxs)\n                                     (let [c# ^not-native (chunk-first ~gxs)\n                                           size# (count c#)\n                                           ~gb (chunk-buffer size#)]\n                                       (if (coercive-boolean\n                                            (loop [~gi 0]\n                                              (if (< ~gi size#)\n                                                (let [~bind (-nth c# ~gi)]\n                                                  ~(do-cmod mod-pairs))\n                                                true)))\n                                         (chunk-cons\n                                           (chunk ~gb)\n                                           (~giter (chunk-rest ~gxs)))\n                                         (chunk-cons (chunk ~gb) nil)))\n                                     (let [~bind (first ~gxs)]\n                                       ~(do-mod mod-pairs)))))))))))]\n    `(let [iter# ~(emit-bind (to-groups seq-exprs))]\n       (iter# ~(second seq-exprs)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [1254 1339]},
                            :full-name "cljs.core/for",
                            :docstring "List comprehension. Takes a vector of one or more\n binding-form/collection-expr pairs, each followed by zero or more\n modifiers, and yields a lazy sequence of evaluations of expr.\n Collections are iterated in a nested fashion, rightmost fastest,\n and nested coll-exprs can refer to bindings created in prior\n binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n :while test, :when test.\n\n(take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))"},
           "syntax/inst-literal" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "inst-literal",
                                  :name-encode "inst-literal",
                                  :type "tagged literal",
                                  :full-name-encode "syntax/inst-literal",
                                  :extra-sources ({:code "(defn read-inst\n  [form]\n  (when-not (string? form)\n    (throw (RuntimeException. \"Instance literal expects a string for its timestamp.\")))\n  (try\n    (inst/read-instant-date form)\n    (catch Throwable e\n      (throw (RuntimeException. (.getMessage e))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [19 26]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [44 48]}),
                                  :full-name "syntax/inst-literal",
                                  :history [["+" "0.0-1424"]]},
           "cljs.core/unchecked-multiply-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-multiply-int",
                                               :signature ["[]"
                                                           "[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :name-encode "unchecked-multiply-int",
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-multiply-int",
                                               :source {:code "(defn ^number unchecked-multiply-int\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply-int x y))\n  ([x y & more] (reduce unchecked-multiply-int (cljs.core/unchecked-multiply-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [1995
                                                                2000]},
                                               :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-multiply-int\n  ([& xs] `(* ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r2760",
                                                                :filename "src/clj/cljs/core.clj",
                                                                :lines [396
                                                                        397]}],
                                               :full-name "cljs.core/unchecked-multiply-int",
                                               :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/cond->" {:ns "cljs.core",
                               :name "cond->",
                               :signature ["[expr & clauses]"],
                               :name-encode "cond-GT",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/cond-GT",
                               :source {:code "(defmacro cond->\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (-> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [6885 6897]},
                               :full-name "cljs.core/cond->",
                               :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->)\nthrough each form for which the corresponding test\nexpression is true. Note that, unlike cond branching, cond-> threading does\nnot short circuit after the first true test expression."},
           "cljs.repl/load-stream" {:ns "cljs.repl",
                                    :name "load-stream",
                                    :signature ["[repl-env filename res]"],
                                    :name-encode "load-stream",
                                    :type "function",
                                    :full-name-encode "cljs.repl/load-stream",
                                    :source {:code "(defn load-stream [repl-env filename res]\n  (let [env (ana/empty-env)]\n    (doseq [form (ana/forms-seq res filename)]\n      (let [env (assoc env :ns (ana/get-namespace ana/*cljs-ns*))]\n        (evaluate-form repl-env env filename form)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [218 222]},
                                    :full-name "cljs.repl/load-stream",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/instance?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "instance?",
                                  :signature ["[t o]"],
                                  :name-encode "instanceQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/instanceQMARK",
                                  :source {:code "(defn ^boolean instance? [t o]\n  (cljs.core/instance? t o))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [569 570]},
                                  :extra-sources [{:code "(defmacro instance? [t o]\n  ;; Google Closure warns about some references to RegExp, so\n  ;; (instance? RegExp ...) needs to be inlined, but the expansion\n  ;; should preserve the order of argument evaluation.\n  (bool-expr (if (clojure.core/symbol? t)\n               (core/list 'js* \"(~{} instanceof ~{})\" o t)\n               `(let [t# ~t o# ~o]\n                  (~'js* \"(~{} instanceof ~{})\" o# t#)))))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [322 329]}],
                                  :full-name "cljs.core/instance?"},
           "cljs.core/ValSeq" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "ValSeq",
                               :signature ["[mseq _meta]"],
                               :name-encode "ValSeq",
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/ValSeq",
                               :source {:code "(deftype ValSeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (ValSeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-val me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (ValSeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (ValSeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7241 7294]},
                               :full-name "cljs.core/ValSeq"},
           "cljs.core/rseq" {:return-type seq,
                             :ns "cljs.core",
                             :name "rseq",
                             :signature ["[coll]"],
                             :name-encode "rseq",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/rseq",
                             :source {:code "(defn ^seq rseq [coll]\n  (-rseq coll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2390 2391]},
                             :full-name "cljs.core/rseq"},
           "cljs.core/PersistentVector.EMPTY_NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY_NODE",
                                                    :name-encode "PersistentVectorDOTEMPTY_NODE",
                                                    :history [["+"
                                                               "0.0-1006"]
                                                              ["-"
                                                               "0.0-2301"]],
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY_NODE",
                                                    :source {:code "(set! cljs.core.PersistentVector.EMPTY_NODE (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2280",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [3667]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY_NODE",
                                                    :removed {:in "0.0-2301",
                                                              :last-seen "0.0-2280"}},
           "cljs.reader/read-comment" {:ns "cljs.reader",
                                       :name "read-comment",
                                       :name-encode "read-comment",
                                       :type "var",
                                       :full-name-encode "cljs.reader/read-comment",
                                       :source {:code "(def read-comment skip-line)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [268]},
                                       :full-name "cljs.reader/read-comment",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.rhino/eval-result" {:ns "cljs.repl.rhino",
                                          :name "eval-result",
                                          :name-encode "eval-result",
                                          :type "multimethod",
                                          :full-name-encode "cljs.repl.rhino/eval-result",
                                          :source {:code "(defmulti eval-result class)",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [56]},
                                          :full-name "cljs.repl.rhino/eval-result",
                                          :extra-sources ({:code "(defmethod eval-result :default [r]\n  (.toString r))",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [58
                                                                   59]}
                                                          {:code "(defmethod eval-result nil [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [61]}
                                                          {:code "(defmethod eval-result Undefined [_] \"\")",
                                                           :title "Dispatch method",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/repl/rhino.clj",
                                                           :lines [63]}),
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.node/socket" {:ns "cljs.repl.node",
                                    :name "socket",
                                    :signature ["[host port]"],
                                    :name-encode "socket",
                                    :type "function",
                                    :full-name-encode "cljs.repl.node/socket",
                                    :source {:code "(defn socket [host port]\n  (let [socket (Socket. host port)\n        in     (io/reader socket)\n        out    (io/writer socket)]\n    {:socket socket :in in :out out}))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/repl/node.clj",
                                             :lines [22 26]},
                                    :full-name "cljs.repl.node/socket",
                                    :history [["+" "0.0-2629"]]},
           "cljs.core/ITransientMap" {:ns "cljs.core",
                                      :name "ITransientMap",
                                      :name-encode "ITransientMap",
                                      :implementations #{"TransientArrayMap"
                                                         "TransientHashMap"},
                                      :history [["+" "0.0-1211"]],
                                      :type "protocol",
                                      :full-name-encode "cljs.core/ITransientMap",
                                      :source {:code "(defprotocol ITransientMap\n  (^clj -dissoc! [tcoll key]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [383 384]},
                                      :methods [{:name "-dissoc!",
                                                 :signature ["[tcoll key]"],
                                                 :docstring nil}],
                                      :full-name "cljs.core/ITransientMap"},
           "closure-warnings/check-types" {:ns "closure-warnings",
                                           :name "check-types",
                                           :type "warning",
                                           :full-name "closure-warnings/check-types",
                                           :full-name-encode "closure-warnings/check-types",
                                           :name-encode "check-types",
                                           :history [["+" "0.0-2120"]]},
           "cljs.core/*loaded-libs*" {:ns "cljs.core",
                                      :name "*loaded-libs*",
                                      :name-encode "STARloaded-libsSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARloaded-libsSTAR",
                                      :source {:code "(defonce ^:dynamic *loaded-libs* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [40]},
                                      :full-name "cljs.core/*loaded-libs*",
                                      :history [["+" "0.0-2655"]]},
           "syntax/whitespace" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "whitespace",
                                :name-encode "whitespace",
                                :type "special character",
                                :full-name-encode "syntax/whitespace",
                                :full-name "syntax/whitespace",
                                :history [["+" "0.0-927"]]},
           "cljs.reader/read-number" {:ns "cljs.reader",
                                      :name "read-number",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-number",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-number",
                                      :source {:code "(defn read-number\n  [reader initch]\n  (loop [buffer (gstring/StringBuffer. initch)\n         ch (read-char reader)]\n    (if (or (nil? ch) (whitespace? ch) (macros ch))\n      (do\n        (unread reader ch)\n        (let [s (.toString buffer)]\n          (or (match-number s)\n              (reader-error reader \"Invalid number format [\" s \"]\"))))\n      (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [281 291]},
                                      :full-name "cljs.reader/read-number",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/ILookup" {:ns "cljs.core",
                                :name "ILookup",
                                :name-encode "ILookup",
                                :implementations #{"Subvec"
                                                   "PersistentHashMap"
                                                   "PersistentTreeSet"
                                                   "RedNode"
                                                   "TransientArrayMap"
                                                   "ObjMap"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "TransientVector"
                                                   "PersistentTreeMap"
                                                   "PersistentArrayMap"
                                                   "PersistentHashSet"
                                                   "TransientHashMap"
                                                   "TransientHashSet"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ILookup",
                                :source {:code "(defprotocol ILookup\n  (-lookup [o k] [o k not-found]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [282 283]},
                                :methods [{:name "-lookup",
                                           :signature ["[o k]"
                                                       "[o k not-found]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ILookup"},
           "cljs.core/when" {:ns "cljs.core",
                             :name "when",
                             :signature ["[test & body]"],
                             :name-encode "when",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/when",
                             :source {:code "(defmacro when\n  [test & body]\n  (list 'if test (cons 'do body)))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [471 475]},
                             :full-name "cljs.core/when",
                             :docstring "Evaluates test. If logical true, evaluates body in an implicit do."},
           "cljs.core/ArrayNodeSeq" {:protocols #{"ISeqable"
                                                  "IMeta"
                                                  "IWithMeta"
                                                  "IEmptyableCollection"
                                                  "IReduce"
                                                  "ISequential"
                                                  "ISeq"
                                                  "ICollection"
                                                  "IHash"
                                                  "IPrintWithWriter"
                                                  "IEquiv"},
                                     :ns "cljs.core",
                                     :name "ArrayNodeSeq",
                                     :signature ["[meta nodes i s __hash]"],
                                     :name-encode "ArrayNodeSeq",
                                     :history [["+" "0.0-1211"]],
                                     :type "type",
                                     :full-name-encode "cljs.core/ArrayNodeSeq",
                                     :source {:code "(deftype ArrayNodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (ArrayNodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  ISeq\n  (-first [coll] (first s))\n  (-rest  [coll] (create-array-node-seq nil nodes i (next s)))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6147 6182]},
                                     :full-name "cljs.core/ArrayNodeSeq"},
           "cljs.core/list?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "list?",
                              :signature ["[x]"],
                              :name-encode "listQMARK",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/listQMARK",
                              :source {:code "(defn ^boolean list? [x]\n  (satisfies? IList x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2472 2473]},
                              :full-name "cljs.core/list?"},
           "cljs.core/val" {:ns "cljs.core",
                            :name "val",
                            :signature ["[map-entry]"],
                            :name-encode "val",
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :full-name-encode "cljs.core/val",
                            :source {:code "(defn val\n  [map-entry]\n  (-val map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [7304 7307]},
                            :full-name "cljs.core/val",
                            :docstring "Returns the value in the map entry."},
           "clojure.browser.dom/set-value" {:ns "clojure.browser.dom",
                                            :name "set-value",
                                            :signature ["[e v]"],
                                            :name-encode "set-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/set-value",
                                            :source {:code "(defn set-value\n  [e v]\n  (set-properties e {\"value\" v}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [142 145]},
                                            :full-name "clojure.browser.dom/set-value",
                                            :docstring "Set the value property for an element."},
           "cljs.repl.browser/read-get" {:ns "cljs.repl.browser",
                                         :name "read-get",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-get",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/read-get",
                                         :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [154 159]},
                                         :full-name "cljs.repl.browser/read-get",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/BitmapIndexedNode" {:ns "cljs.core",
                                          :name "BitmapIndexedNode",
                                          :signature ["[edit bitmap arr]"],
                                          :name-encode "BitmapIndexedNode",
                                          :type "type",
                                          :full-name-encode "cljs.core/BitmapIndexedNode",
                                          :source {:code "(deftype BitmapIndexedNode [edit ^:mutable bitmap ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (if (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc (.-EMPTY BitmapIndexedNode)\n                                              (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. nil (inc n) nodes))\n            (let [new-arr (make-array (* 2 (inc n)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (BitmapIndexedNode. nil (bit-or bitmap bit) new-arr))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc val-or-node (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) val)))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (BitmapIndexedNode. nil bitmap\n                                        (clone-and-set arr (* 2 idx) nil (inc (* 2 idx))\n                                                       (create-node (+ shift 5) key-or-nil val-or-node hash key val)))))))))\n\n  (inode-without [inode shift hash key]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without val-or-node (+ shift 5) hash key)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (BitmapIndexedNode. nil bitmap (clone-and-set arr (inc (* 2 idx)) n))\n                        (== bitmap bit) nil\n                        :else (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))))\n                (key-test key key-or-nil)\n                (BitmapIndexedNode. nil (bit-xor bitmap bit) (remove-pair arr idx))\n                :else inode)))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)  (.inode-lookup val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil) val-or-node\n                :else not-found)))))\n\n  (inode-find [inode shift hash key not-found]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        not-found\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil) (.inode-find val-or-node (+ shift 5) hash key not-found)\n                (key-test key key-or-nil)          [key-or-nil val-or-node]\n                :else not-found)))))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [n       (bit-count bitmap)\n            new-arr (make-array (if (neg? n) 4 (* 2 (inc n))))]\n        (array-copy arr 0 new-arr 0 (* 2 n))\n        (BitmapIndexedNode. e bitmap new-arr))))\n\n  (edit-and-remove-pair [inode e bit i]\n    (if (== bitmap bit)\n      nil\n      (let [editable (.ensure-editable inode e)\n            earr     (.-arr editable)\n            len      (alength earr)]\n        (set! (.-bitmap editable) (bit-xor bit (.-bitmap editable)))\n        (array-copy earr (* 2 (inc i))\n                    earr (* 2 i)\n                    (- len (* 2 (inc i))))\n        (aset earr (- len 2) nil)\n        (aset earr (dec len) nil)\n        editable)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [bit (bitpos hash shift)\n          idx (bitmap-indexed-node-index bitmap bit)]\n      (if (zero? (bit-and bitmap bit))\n        (let [n (bit-count bitmap)]\n          (cond\n            (< (* 2 n) (alength arr))\n            (let [editable (.ensure-editable inode edit)\n                  earr     (.-arr editable)]\n              (set! (.-val added-leaf?) true)\n              (array-copy-downward earr (* 2 idx)\n                                   earr (* 2 (inc idx))\n                                   (* 2 (- n idx)))\n              (aset earr (* 2 idx) key)\n              (aset earr (inc (* 2 idx)) val)\n              (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n              editable)\n\n            (>= n 16)\n            (let [nodes (make-array 32)\n                  jdx   (mask hash shift)]\n              (aset nodes jdx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))\n              (loop [i 0 j 0]\n                (if (< i 32)\n                  (if (zero? (bit-and (bit-shift-right-zero-fill bitmap i) 1))\n                    (recur (inc i) j)\n                    (do (aset nodes i\n                              (if-not (nil? (aget arr j))\n                                (.inode-assoc! (.-EMPTY BitmapIndexedNode)\n                                               edit (+ shift 5) (cljs.core/hash (aget arr j)) (aget arr j) (aget arr (inc j)) added-leaf?)\n                                (aget arr (inc j))))\n                        (recur (inc i) (+ j 2))))))\n              (ArrayNode. edit (inc n) nodes))\n\n            :else\n            (let [new-arr (make-array (* 2 (+ n 4)))]\n              (array-copy arr 0 new-arr 0 (* 2 idx))\n              (aset new-arr (* 2 idx) key)\n              (aset new-arr (inc (* 2 idx)) val)\n              (array-copy arr (* 2 idx) new-arr (* 2 (inc idx)) (* 2 (- n idx)))\n              (set! (.-val added-leaf?) true)\n              (let [editable (.ensure-editable inode edit)]\n                (set! (.-arr editable) new-arr)\n                (set! (.-bitmap editable) (bit-or (.-bitmap editable) bit))\n                editable))))\n        (let [key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-assoc! val-or-node edit (+ shift 5) hash key val added-leaf?)]\n                  (if (identical? n val-or-node)\n                    inode\n                    (edit-and-set inode edit (inc (* 2 idx)) n)))\n\n                (key-test key key-or-nil)\n                (if (identical? val val-or-node)\n                  inode\n                  (edit-and-set inode edit (inc (* 2 idx)) val))\n\n                :else\n                (do (set! (.-val added-leaf?) true)\n                    (edit-and-set inode edit (* 2 idx) nil (inc (* 2 idx))\n                                  (create-node edit (+ shift 5) key-or-nil val-or-node hash key val))))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [bit (bitpos hash shift)]\n      (if (zero? (bit-and bitmap bit))\n        inode\n        (let [idx         (bitmap-indexed-node-index bitmap bit)\n              key-or-nil  (aget arr (* 2 idx))\n              val-or-node (aget arr (inc (* 2 idx)))]\n          (cond (nil? key-or-nil)\n                (let [n (.inode-without! val-or-node edit (+ shift 5) hash key removed-leaf?)]\n                  (cond (identical? n val-or-node) inode\n                        (not (nil? n)) (edit-and-set inode edit (inc (* 2 idx)) n)\n                        (== bitmap bit) nil\n                        :else (.edit-and-remove-pair inode edit bit idx)))\n                (key-test key key-or-nil)\n                (do (aset removed-leaf? 0 true)\n                    (.edit-and-remove-pair inode edit bit idx))\n                :else inode)))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5651 5845]},
                                          :full-name "cljs.core/BitmapIndexedNode",
                                          :history [["+" "0.0-1211"]]},
           "warnings/protocol-multiple-impls" {:ns "warnings",
                                               :name "protocol-multiple-impls",
                                               :type "warning",
                                               :full-name "warnings/protocol-multiple-impls",
                                               :full-name-encode "warnings/protocol-multiple-impls",
                                               :name-encode "protocol-multiple-impls",
                                               :history [["+"
                                                          "0.0-2341"]]},
           "cljs.repl.node/close-socket" {:ns "cljs.repl.node",
                                          :name "close-socket",
                                          :signature ["[s]"],
                                          :name-encode "close-socket",
                                          :type "function",
                                          :full-name-encode "cljs.repl.node/close-socket",
                                          :source {:code "(defn close-socket [s]\n  (.close (:in s))\n  (.close (:out s))\n  (.close (:socket s)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/repl/node.clj",
                                                   :lines [28 31]},
                                          :full-name "cljs.repl.node/close-socket",
                                          :history [["+" "0.0-2629"]]},
           "cljs.reader/read-past" {:ns "cljs.reader",
                                    :name "read-past",
                                    :signature ["[pred rdr]"],
                                    :name-encode "read-past",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-past",
                                    :source {:code "(defn read-past\n  [pred rdr]\n  (loop [ch (read-char rdr)]\n    (if (pred ch)\n      (recur (read-char rdr))\n      ch)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [216 223]},
                                    :full-name "cljs.reader/read-past",
                                    :docstring "Read until first character that doesn't match pred, returning\nchar."},
           "cljs.repl.browser/load-javascript" {:ns "cljs.repl.browser",
                                                :name "load-javascript",
                                                :signature ["[repl-env provides url]"],
                                                :name-encode "load-javascript",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/load-javascript",
                                                :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (let [missing (remove #(contains? @loaded-libs %) provides)]\n    (when (seq missing)\n      (browser-eval (slurp url))\n      (swap! loaded-libs (partial apply conj) missing))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [182
                                                                 192]},
                                                :full-name "cljs.repl.browser/load-javascript",
                                                :docstring "Accepts a REPL environment, a list of namespaces, and a URL for a\nJavaScript file which contains the implementation for the list of\nnamespaces. Will load the JavaScript file into the REPL environment\nif any of the namespaces have not already been loaded from the\nClojureScript REPL."},
           "cljs.core/to-array" {:ns "cljs.core",
                                 :name "to-array",
                                 :signature ["[s]"],
                                 :name-encode "to-array",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/to-array",
                                 :source {:code "(defn to-array\n  [s]\n  (let [ary (array)]\n    (loop [s s]\n      (if (seq s)\n        (do (. ary push (first s))\n            (recur (next s)))\n        ary))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2756 2764]},
                                 :full-name "cljs.core/to-array",
                                 :docstring "Naive impl of to-array as a start."},
           "cljs.core/interpose" {:ns "cljs.core",
                                  :name "interpose",
                                  :signature ["[sep]" "[sep coll]"],
                                  :name-encode "interpose",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/interpose",
                                  :source {:code "(defn interpose\n  ([sep]\n    (fn [rf]\n      (let [started (volatile! false)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if @started\n              (let [sepr (rf result sep)]\n                (if (reduced? sepr)\n                  sepr\n                  (rf sepr input)))\n              (do\n                (vreset! started true)\n                (rf result input))))))))\n  ([sep coll] (drop 1 (interleave (repeat sep) coll))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3912 3929]},
                                  :full-name "cljs.core/interpose",
                                  :docstring "Returns a lazy seq of the elements of coll separated by sep"},
           "cljs.core/IMapEntry" {:ns "cljs.core",
                                  :name "IMapEntry",
                                  :name-encode "IMapEntry",
                                  :implementations #{"RedNode"
                                                     "BlackNode"
                                                     "PersistentVector"},
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IMapEntry",
                                  :source {:code "(defprotocol IMapEntry\n  (-key [coll])\n  (-val [coll]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [294 296]},
                                  :methods [{:name "-key",
                                             :signature ["[coll]"],
                                             :docstring nil}
                                            {:name "-val",
                                             :signature ["[coll]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IMapEntry"},
           "clojure.browser.net/ICrossPageChannel" {:ns "clojure.browser.net",
                                                    :name "ICrossPageChannel",
                                                    :name-encode "ICrossPageChannel",
                                                    :type "protocol",
                                                    :full-name-encode "clojure.browser.net/ICrossPageChannel",
                                                    :source {:code "(defprotocol ICrossPageChannel\n  (register-service [this service-name fn] [this service-name fn encode-json?]))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [86
                                                                     87]},
                                                    :methods [{:name "register-service",
                                                               :signature ["[this service-name fn]"
                                                                           "[this service-name fn encode-json?]"],
                                                               :docstring nil}],
                                                    :full-name "clojure.browser.net/ICrossPageChannel",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/Cons" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IEmptyableCollection"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "ASeq"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"
                                          "IList"},
                             :ns "cljs.core",
                             :name "Cons",
                             :signature ["[meta first rest __hash]"],
                             :name-encode "Cons",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Cons",
                             :source {:code "(deftype Cons [meta first rest ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (Cons. meta first rest __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (Cons. meta first rest __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll] (if (nil? rest) () rest))\n\n  INext\n  (-next [coll]\n    (if (nil? rest) nil (seq rest)))\n\n  ICollection\n  (-conj [coll o] (Cons. nil o coll __hash))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n  \n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2415 2460]},
                             :full-name "cljs.core/Cons"},
           "cljs.core/re-find" {:ns "cljs.core",
                                :name "re-find",
                                :signature ["[re s]"],
                                :name-encode "re-find",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/re-find",
                                :source {:code "(defn re-find\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when-not (nil? matches)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-find must match against a string.\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8073 8085]},
                                :full-name "cljs.core/re-find",
                                :docstring "Returns the first regex match, if any, of s to re, using\nre.exec(s). Returns a vector, containing first the matching\nsubstring, then any capturing groups if the regular expression contains\ncapturing groups."},
           "cljs.core/IMeta" {:ns "cljs.core",
                              :name "IMeta",
                              :name-encode "IMeta",
                              :implementations #{"Subvec"
                                                 "Symbol"
                                                 "PersistentQueue"
                                                 "PersistentHashMap"
                                                 "PersistentTreeSet"
                                                 "PersistentArrayMapSeq"
                                                 "RedNode"
                                                 "EmptyList"
                                                 "ObjMap"
                                                 "MetaFn"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "ValSeq"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ChunkedSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "PersistentTreeMap"
                                                 "PersistentTreeMapSeq"
                                                 "RSeq"
                                                 "function"
                                                 "PersistentArrayMap"
                                                 "PersistentHashSet"
                                                 "NodeSeq"
                                                 "List"
                                                 "Atom"
                                                 "Cons"
                                                 "Var"
                                                 "LazySeq"},
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IMeta",
                              :source {:code "(defprotocol IMeta\n  (^clj-or-nil -meta [o]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [314 315]},
                              :methods [{:name "-meta",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IMeta"},
           "cljs.core/js-str" {:ns "cljs.core",
                               :name "js-str",
                               :signature ["[s]"],
                               :name-encode "js-str",
                               :type "macro",
                               :full-name-encode "cljs.core/js-str",
                               :source {:code "(defmacro js-str [s]\n  (core/list 'js* \"''+~{}\" s))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1667 1668]},
                               :full-name "cljs.core/js-str",
                               :history [["+" "0.0-2341"]]},
           "cljs.repl/repl*" {:ns "cljs.repl",
                              :name "repl*",
                              :signature ["[repl-env opts]"],
                              :name-encode "replSTAR",
                              :type "function",
                              :full-name-encode "cljs.repl/replSTAR",
                              :source {:code "(defn repl*\n  [repl-env opts]\n  (print \"To quit, type: \")\n  (prn :cljs/quit)\n  (let [ups-deps (cljsc/get-upstream-deps)\n        {:keys [analyze-path repl-verbose warn-on-undeclared special-fns static-fns] :as opts\n         :or   {warn-on-undeclared true}}\n        (assoc (merge (-repl-options repl-env) opts)\n          :ups-libs (:libs ups-deps)\n          :ups-foreign-libs (:foreign-libs ups-deps))]\n    (env/with-compiler-env\n     (or (::env/compiler repl-env) (env/default-compiler-env opts))\n     (binding [ana/*cljs-ns* 'cljs.user\n               *cljs-verbose* repl-verbose\n               ana/*cljs-warnings* (assoc ana/*cljs-warnings*\n                                     :unprovided warn-on-undeclared\n                                     :undeclared-var warn-on-undeclared\n                                     :undeclared-ns warn-on-undeclared\n                                     :undeclared-ns-form warn-on-undeclared)\n               ana/*cljs-static-fns* static-fns]\n       ;; TODO: the follow should become dead code when the REPL is\n       ;; sufficiently enhanced to understand :cache-analysis - David\n       (when analyze-path\n         (analyze-source analyze-path))\n       (let [env {:context :expr :locals {}}\n             special-fns (merge default-special-fns special-fns)\n             is-special-fn? (set (keys special-fns))\n             request-prompt (Object.)\n             request-exit (Object.)\n             read-error (Object.)]\n         (-setup repl-env opts)\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             '(ns cljs.user\n                (:require [cljs.repl :refer-macros [doc]]))\n             {:line 1 :column 1})\n           identity opts)\n         (loop []\n           ;; try to let things flush before printing prompt\n           (Thread/sleep 10)\n           (print (str \"ClojureScript:\" ana/*cljs-ns* \"> \"))\n           (flush)\n           (let [rdr (readers/source-logging-push-back-reader\n                       (PushbackReader. (io/reader *in*))\n                       1\n                       \"NO_SOURCE_FILE\")\n                 form (try\n                        (binding [*ns* (create-ns ana/*cljs-ns*)\n                                  reader/*data-readers* tags/*cljs-data-readers*\n                                  reader/*alias-map*\n                                  (apply merge\n                                    ((juxt :requires :require-macros)\n                                      (ana/get-namespace ana/*cljs-ns*)))]\n                          (reader/read rdr nil read-error))\n                        (catch Exception e\n                          (println (.getMessage e))\n                          read-error))]\n             ;; TODO: need to catch errors here too - David\n             (cond\n               (identical? form read-error) (recur)\n               (= form :cljs/quit) :quit\n\n               (and (seq? form) (is-special-fn? (first form)))\n               (do\n                 (try\n                   ((get special-fns (first form)) repl-env env form opts)\n                   (catch Throwable ex\n                     (println \"Failed to execute special function:\" (pr-str (first form)))\n                     (trace/print-cause-trace ex 12)))\n                 ;; flush output which could include stack traces\n                 (flush)\n                 (newline)\n                 (recur))\n\n               :else\n               (do (eval-and-print repl-env env form)\n                   (recur)))))\n         (-tear-down repl-env))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/repl.clj",
                                       :lines [347 424]},
                              :full-name "cljs.repl/repl*",
                              :history [["+" "0.0-2629"]]},
           "cljs.test/are" {:ns "cljs.test",
                            :name "are",
                            :signature ["[argv expr & args]"],
                            :name-encode "are",
                            :history [["+" "0.0-2629"]],
                            :type "macro",
                            :full-name-encode "cljs.test/are",
                            :source {:code "(defmacro are\n  [argv expr & args]\n  (if (or\n        ;; (are [] true) is meaningless but ok\n        (and (empty? argv) (empty? args))\n        ;; Catch wrong number of args\n        (and (pos? (count argv))\n          (pos? (count args))\n          (zero? (mod (count args) (count argv)))))\n    `(clojure.template/do-template ~argv (is ~expr) ~@args)\n    (throw (IllegalArgumentException. \"The number of args doesn't match are's argv.\"))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/test.clj",
                                     :lines [167 189]},
                            :full-name "cljs.test/are",
                            :docstring "Checks multiple assertions with a template expression.\nSee clojure.template/do-template for an explanation of\ntemplates.\n\nExample: (are [x y] (= x y)  \n              2 (+ 1 1)\n              4 (* 2 2))\nExpands to: \n         (do (is (= 2 (+ 1 1)))\n             (is (= 4 (* 2 2))))\n\nNote: This breaks some reporting features, such as line numbers."},
           "cljs.core/RangeIterator" {:ns "cljs.core",
                                      :name "RangeIterator",
                                      :signature ["[i end step]"],
                                      :name-encode "RangeIterator",
                                      :type "type",
                                      :full-name-encode "cljs.core/RangeIterator",
                                      :source {:code "(deftype RangeIterator [^:mutable i end step]\n  Object\n  (hasNext [_]\n    (if (pos? step)\n      (< i end)\n      (> i end)))\n  (next [_]\n    (let [ret i]\n      (set! i (+ i step))\n      ret)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7795 7804]},
                                      :full-name "cljs.core/RangeIterator",
                                      :history [["+" "0.0-2371"]]},
           "cljs.core/iterator" {:ns "cljs.core",
                                 :name "iterator",
                                 :signature ["[coll]"],
                                 :name-encode "iterator",
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/iterator",
                                 :source {:code "(defn iterator [coll]\n  (Iterator. (seq coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4870 4871]},
                                 :full-name "cljs.core/iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/assoc-in" {:ns "cljs.core",
                                 :name "assoc-in",
                                 :signature ["[m [k & ks] v]"],
                                 :name-encode "assoc-in",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/assoc-in",
                                 :source {:code "(defn assoc-in\n  [m [k & ks] v]\n  (if ks\n    (assoc m k (assoc-in (get m k) ks v))\n    (assoc m k v)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4099 4106]},
                                 :full-name "cljs.core/assoc-in",
                                 :docstring "Associates a value in a nested associative structure, where ks is a\nsequence of keys and v is the new value and returns a new nested structure.\nIf any levels do not exist, hash-maps will be created."},
           "compiler-options/verbose" {:ns "compiler-options",
                                       :name "verbose",
                                       :name-encode "verbose",
                                       :type "option",
                                       :full-name-encode "compiler-options/verbose",
                                       :full-name "compiler-options/verbose",
                                       :history [["+" "0.0-971"]]},
           "closure-warnings/undefined-variables" {:ns "closure-warnings",
                                                   :name "undefined-variables",
                                                   :type "warning",
                                                   :full-name "closure-warnings/undefined-variables",
                                                   :full-name-encode "closure-warnings/undefined-variables",
                                                   :name-encode "undefined-variables",
                                                   :history [["+"
                                                              "0.0-2120"]]},
           "clojure.string/join" {:ns "clojure.string",
                                  :name "join",
                                  :signature ["[coll]"
                                              "[separator coll]"],
                                  :name-encode "join",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/join",
                                  :source {:code "(defn join\n  ([coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if coll\n       (recur (. sb (append (str (first coll)))) (next coll))\n       (.toString sb))))\n  ([separator coll]\n   (loop [sb (StringBuffer.) coll (seq coll)]\n     (if coll\n       (do\n         (. sb (append (str (first coll))))\n         (let [coll (next coll)]\n           (when-not (nil? coll)\n             (. sb (append separator)))\n           (recur sb coll)))\n       (.toString sb)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [49 66]},
                                  :full-name "clojure.string/join",
                                  :docstring "Returns a string of all elements in coll, as returned by (seq coll),\nseparated by an optional separator."},
           "cljs.core/*unchecked-if*" {:ns "cljs.core",
                                       :name "*unchecked-if*",
                                       :name-encode "STARunchecked-ifSTAR",
                                       :type "var",
                                       :full-name-encode "cljs.core/STARunchecked-ifSTAR",
                                       :source {:code "(def *unchecked-if* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [18]},
                                       :full-name "cljs.core/*unchecked-if*",
                                       :history [["+" "0.0-1211"]]},
           "cljs.core/some?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "some?",
                              :signature ["[x]"],
                              :name-encode "someQMARK",
                              :history [["+" "0.0-2261"]],
                              :type "function",
                              :full-name-encode "cljs.core/someQMARK",
                              :source {:code "(defn ^boolean some?\n  [x] (not (nil? x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [100 102]},
                              :full-name "cljs.core/some?",
                              :docstring "Returns true if x is not nil, false otherwise."},
           "cljs.core/seqable?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "seqable?",
                                 :signature ["[s]"],
                                 :name-encode "seqableQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/seqableQMARK",
                                 :source {:code "(defn ^boolean seqable?\n  [s]\n  (satisfies? ISeqable s))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1599 1602]},
                                 :full-name "cljs.core/seqable?",
                                 :docstring "Return true if s satisfies ISeqable"},
           "clojure.zip/rights" {:ns "clojure.zip",
                                 :name "rights",
                                 :signature ["[loc]"],
                                 :name-encode "rights",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/rights",
                                 :source {:code "(defn rights\n  [loc]\n    (:r (loc 1)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [92 95]},
                                 :full-name "clojure.zip/rights",
                                 :docstring "Returns a seq of the right siblings of this loc"},
           "cljs.core/split-at" {:ns "cljs.core",
                                 :name "split-at",
                                 :signature ["[n coll]"],
                                 :name-encode "split-at",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/split-at",
                                 :source {:code "(defn split-at\n  [n coll]\n  [(take n coll) (drop n coll)])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3872 3875]},
                                 :full-name "cljs.core/split-at",
                                 :docstring "Returns a vector of [(take n coll) (drop n coll)]"},
           "clojure.zip/append-child" {:ns "clojure.zip",
                                       :name "append-child",
                                       :signature ["[loc item]"],
                                       :name-encode "append-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/append-child",
                                       :source {:code "(defn append-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (concat (children loc) [item]))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [200 204]},
                                       :full-name "clojure.zip/append-child",
                                       :docstring "Inserts the item as the rightmost child of the node at this loc,\nwithout moving"},
           "cljs.core/binding" {:ns "cljs.core",
                                :name "binding",
                                :signature ["[bindings & body]"],
                                :name-encode "binding",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/binding",
                                :source {:code "(defmacro binding\n  [bindings & body]\n  (let [names (take-nth 2 bindings)]\n    (cljs.analyzer/confirm-bindings &env names)\n    `(with-redefs ~bindings ~@body)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1126 1137]},
                                :full-name "cljs.core/binding",
                                :docstring "binding => var-symbol init-expr\n\nCreates new bindings for the (already-existing) vars, with the\nsupplied initial values, executes the exprs in an implicit do, then\nre-establishes the bindings that existed before.  The new bindings\nare made in parallel (unlike let); all init-exprs are evaluated\nbefore the vars are bound to their new values."},
           "compiler-options/libs" {:ns "compiler-options",
                                    :name "libs",
                                    :name-encode "libs",
                                    :type "option",
                                    :full-name-encode "compiler-options/libs",
                                    :full-name "compiler-options/libs",
                                    :history [["+" "0.0-971"]]},
           "cljs.test/get-current-env" {:ns "cljs.test",
                                        :name "get-current-env",
                                        :signature ["[]"],
                                        :name-encode "get-current-env",
                                        :type "function",
                                        :full-name-encode "cljs.test/get-current-env",
                                        :source {:code "(defn get-current-env []\n  (or *current-env* (empty-env)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/test.cljs",
                                                 :lines [226 227]},
                                        :full-name "cljs.test/get-current-env",
                                        :history [["+" "0.0-2496"]]},
           "cljs.core/Set" {:protocols #{"IFn"
                                         "ISeqable"
                                         "IMeta"
                                         "IWithMeta"
                                         "IEmptyableCollection"
                                         "ISet"
                                         "ICounted"
                                         "ILookup"
                                         "ICollection"
                                         "IHash"
                                         "IPrintable"
                                         "IEquiv"},
                            :ns "cljs.core",
                            :name "Set",
                            :signature ["[meta hash-map]"],
                            :name-encode "Set",
                            :history [["+" "0.0-927"]
                                      ["-" "0.0-1211"]],
                            :type "type",
                            :full-name-encode "cljs.core/Set",
                            :source {:code "(deftype Set [meta hash-map]\n  IWithMeta\n  (-with-meta [coll meta] (Set. meta hash-map))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (Set. meta (assoc hash-map o nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Set/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (= (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (hash-coll coll))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (count (seq coll)))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (Set. meta (dissoc hash-map v)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r1011",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2659 2706]},
                            :full-name "cljs.core/Set",
                            :removed {:in "0.0-1211",
                                      :last-seen "0.0-1011"}},
           "cljs.core/sorted-map" {:ns "cljs.core",
                                   :name "sorted-map",
                                   :signature ["[& keyvals]"],
                                   :name-encode "sorted-map",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/sorted-map",
                                   :source {:code "(defn sorted-map\n  ([& keyvals]\n     (loop [in (seq keyvals) out (.-EMPTY PersistentTreeMap)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7154 7161]},
                                   :full-name "cljs.core/sorted-map",
                                   :docstring "keyval => key val\nReturns a new sorted map with supplied mappings."},
           "cljs.reader/macro-terminating?" {:return-type boolean,
                                             :ns "cljs.reader",
                                             :name "macro-terminating?",
                                             :signature ["[ch]"],
                                             :name-encode "macro-terminatingQMARK",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.reader/macro-terminatingQMARK",
                                             :source {:code "(defn ^boolean macro-terminating? [ch]\n  (and (not (identical? ch \"#\"))\n       (not (identical? ch \\'))\n       (not (identical? ch \":\"))\n       (macros ch)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/reader.cljs",
                                                      :lines [73 77]},
                                             :full-name "cljs.reader/macro-terminating?"},
           "cljs.test/join-fixtures" {:ns "cljs.test",
                                      :name "join-fixtures",
                                      :signature ["[fixtures]"],
                                      :name-encode "join-fixtures",
                                      :history [["+" "0.0-2496"]],
                                      :type "function",
                                      :full-name-encode "cljs.test/join-fixtures",
                                      :source {:code "(defn join-fixtures\n  [fixtures]\n  (reduce compose-fixtures default-fixture fixtures))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/test.cljs",
                                               :lines [389 393]},
                                      :full-name "cljs.test/join-fixtures",
                                      :docstring "Composes a collection of fixtures, in order.  Always returns a valid\nfixture function, even if the collection is empty."},
           "cljs.core/prefers" {:ns "cljs.core",
                                :name "prefers",
                                :signature ["[multifn]"],
                                :name-encode "prefers",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/prefers",
                                :source {:code "(defn prefers\n  [multifn] (-prefers multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9140 9142]},
                                :full-name "cljs.core/prefers",
                                :docstring "Given a multimethod, returns a map of preferred value -> set of other values"},
           "cljs.core/vary-meta" {:ns "cljs.core",
                                  :name "vary-meta",
                                  :signature ["[obj f]"
                                              "[obj f a]"
                                              "[obj f a b]"
                                              "[obj f a b c]"
                                              "[obj f a b c d]"
                                              "[obj f a b c d & args]"],
                                  :name-encode "vary-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/vary-meta",
                                  :source {:code "(defn vary-meta\n  ([obj f]\n   (with-meta obj (f (meta obj))))\n  ([obj f a]\n   (with-meta obj (f (meta obj) a)))\n  ([obj f a b]\n   (with-meta obj (f (meta obj) a b)))\n  ([obj f a b c]\n   (with-meta obj (f (meta obj) a b c)))\n  ([obj f a b c d]\n   (with-meta obj (f (meta obj) a b c d)))\n  ([obj f a b c d & args]\n   (with-meta obj (apply f (meta obj) a b c d args))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3031 3045]},
                                  :full-name "cljs.core/vary-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\n(apply f (meta obj) args) as its metadata."},
           "cljs.core/unchecked-add" {:return-type number,
                                      :ns "cljs.core",
                                      :name "unchecked-add",
                                      :signature ["[]"
                                                  "[x]"
                                                  "[x y]"
                                                  "[x y & more]"],
                                      :name-encode "unchecked-add",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-add",
                                      :source {:code "(defn ^number unchecked-add\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add x y))\n  ([x y & more] (reduce unchecked-add (cljs.core/unchecked-add x y) more)))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1955 1960]},
                                      :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-add\n  ([& xs] `(+ ~@xs)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [372
                                                               373]}],
                                      :full-name "cljs.core/unchecked-add",
                                      :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/when-let" {:ns "cljs.core",
                                 :name "when-let",
                                 :signature ["[bindings & body]"],
                                 :name-encode "when-let",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-let",
                                 :source {:code "(defmacro when-let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (when temp#\n         (let [~form temp#]\n           ~@body)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.6.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [1741 1754]},
                                 :full-name "cljs.core/when-let",
                                 :docstring "bindings => binding-form test\n\nWhen test is true, evaluates body with binding-form bound to the value of test"},
           "clojure.core.reducers/folder" {:ns "clojure.core.reducers",
                                           :name "folder",
                                           :signature ["[coll xf]"],
                                           :name-encode "folder",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/folder",
                                           :source {:code "(defn folder\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [_ f1]\n         (-reduce coll (xf f1) (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init))\n\n       CollFold\n       (coll-fold [_ n combinef reducef]\n         (coll-fold coll n combinef (xf reducef))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [79 94]},
                                           :full-name "clojure.core.reducers/folder",
                                           :docstring "Given a foldable collection, and a transformation function xf,\nreturns a foldable collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "cljs.core/ASeq" {:ns "cljs.core",
                             :name "ASeq",
                             :name-encode "ASeq",
                             :implementations #{"ChunkedCons"
                                                "ChunkedSeq"
                                                "IndexedSeq"
                                                "List"
                                                "Cons"},
                             :type "protocol",
                             :full-name-encode "cljs.core/ASeq",
                             :source {:code "(defprotocol ASeq)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [273]},
                             :full-name "cljs.core/ASeq",
                             :history [["+" "0.0-1211"]]},
           "cljs.core/drop" {:ns "cljs.core",
                             :name "drop",
                             :signature ["[n]" "[n coll]"],
                             :name-encode "drop",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/drop",
                             :source {:code "(defn drop\n  ([n]\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na]\n                (vswap! na dec)\n                (if (pos? n)\n                  result\n                  (rf result input))))))))\n  ([n coll]\n     (let [step (fn [n coll]\n                  (let [s (seq coll)]\n                    (if (and (pos? n) s)\n                      (recur (dec n) (rest s))\n                      s)))]\n       (lazy-seq (step n coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3804 3825]},
                             :full-name "cljs.core/drop",
                             :docstring "Returns a lazy sequence of all but the first n items in coll.\nReturns a stateful transducer when no collection is provided."},
           "cljs.core/var" {:ns "cljs.core",
                            :name "var",
                            :type "special form",
                            :source {:code "(defmethod parse 'var\n  [op env [_ sym :as form] _ _]\n  (let [var (resolve-var env sym (confirm-var-exists-throw))]\n    {:env env :op :var-special :form form\n     :var (analyze env sym)\n     :sym (analyze env `(quote ~(symbol (name (:ns var)) (name (:name var)))))\n     :meta (let [ks [:ns :doc :file :line :column]\n                 m (assoc (zipmap ks (map #(list 'quote (get var %)) ks))\n                     :name `(quote ~(symbol (name (:name var))))\n                     :test `(when ~sym (.-cljs$lang$test ~sym))\n                     :arglists (map with-meta (:arglists var) (:arglists-meta var)))]\n            (analyze env m))}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [550 561]},
                            :full-name "cljs.core/var",
                            :full-name-encode "cljs.core/var",
                            :name-encode "var",
                            :history [["+" "0.0-2496"]]},
           "cljs.core/ArrayList" {:ns "cljs.core",
                                  :name "ArrayList",
                                  :signature ["[arr]"],
                                  :name-encode "ArrayList",
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayList",
                                  :source {:code "(deftype ArrayList [^:mutable arr]\n  Object\n  (add [_ x] (.push arr x))\n  (size [_] (alength arr))\n  (clear [_] (set! arr (array)))\n  (isEmpty [_] (zero? (alength arr)))\n  (toArray [_] arr))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [7698 7704]},
                                  :full-name "cljs.core/ArrayList",
                                  :history [["+" "0.0-2301"]]},
           "compiler-options/pseudo-names" {:ns "compiler-options",
                                            :name "pseudo-names",
                                            :name-encode "pseudo-names",
                                            :type "option",
                                            :full-name-encode "compiler-options/pseudo-names",
                                            :full-name "compiler-options/pseudo-names",
                                            :history [["+" "0.0-2227"]]},
           "cljs.core/stepper" {:ns "cljs.core",
                                :name "stepper",
                                :signature ["[xform iter]"],
                                :name-encode "stepper",
                                :type "function",
                                :full-name-encode "cljs.core/stepper",
                                :source {:code "(defn stepper [xform iter]\n  (letfn [(stepfn\n            ([result]\n               (let [lt (if (reduced? result)\n                          @result\n                          result)]\n                 (set! (.-stepper lt) nil)\n                 result))\n            ([result input]\n               (let [lt result]\n                 (set! (.-first lt) input)\n                 (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                 (set! (.-stepper lt) nil)\n                 (.-rest lt))))]\n   (Stepper. (xform stepfn) iter)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3140 3154]},
                                :full-name "cljs.core/stepper",
                                :history [["+" "0.0-2301"]]},
           "cljs.core/IAtom" {:ns "cljs.core",
                              :name "IAtom",
                              :name-encode "IAtom",
                              :implementations #{"Atom"},
                              :type "protocol",
                              :full-name-encode "cljs.core/IAtom",
                              :source {:code "(defprotocol IAtom)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [410]},
                              :full-name "cljs.core/IAtom",
                              :history [["+" "0.0-2173"]]},
           "cljs.core/reduceable?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reduceable?",
                                    :signature ["[x]"],
                                    :name-encode "reduceableQMARK",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reduceableQMARK",
                                    :source {:code "(defn ^boolean reduceable?\n  [x] (satisfies? IReduce x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1526 1528]},
                                    :full-name "cljs.core/reduceable?",
                                    :docstring "Returns true if coll satisfies IReduce"},
           "cljs.core/while" {:ns "cljs.core",
                              :name "while",
                              :signature ["[test & body]"],
                              :name-encode "while",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/while",
                              :source {:code "(defmacro while\n  [test & body]\n  `(loop []\n     (when ~test\n       ~@body\n       (recur))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [5824 5832]},
                              :full-name "cljs.core/while",
                              :docstring "Repeatedly executes body while test expression is true. Presumes\nsome side-effect will cause test to become false/nil. Returns nil"},
           "closure-warnings/const" {:ns "closure-warnings",
                                     :name "const",
                                     :type "warning",
                                     :full-name "closure-warnings/const",
                                     :full-name-encode "closure-warnings/const",
                                     :name-encode "const",
                                     :history [["+" "0.0-2120"]]},
           "cljs.core/import-macros" {:ns "cljs.core",
                                      :name "import-macros",
                                      :signature ["[ns [& vars]]"],
                                      :name-encode "import-macros",
                                      :type "macro",
                                      :full-name-encode "cljs.core/import-macros",
                                      :source {:code "(defmacro import-macros [ns [& vars]]\n  (core/let [ns (find-ns ns)\n             vars (map #(ns-resolve ns %) vars)\n             syms (map (core/fn [^clojure.lang.Var v] (core/-> v .sym (with-meta {:macro true}))) vars)\n             defs (map (core/fn [sym var]\n                                `(do (def ~sym (deref ~var))\n                                     ;for AOT compilation\n                                     (alter-meta! (var ~sym) assoc :macro true)))\n                       syms vars)]\n            `(do ~@defs\n                 :imported)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [47 57]},
                                      :full-name "cljs.core/import-macros",
                                      :history [["+" "0.0-927"]]},
           "cljs.repl.browser/add-in-order" {:ns "cljs.repl.browser",
                                             :name "add-in-order",
                                             :signature ["[{:keys [expecting fns]} order f]"],
                                             :name-encode "add-in-order",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/add-in-order",
                                             :source {:code "(defn add-in-order [{:keys [expecting fns]} order f]\n  {:expecting (or expecting order)\n   :fns (assoc fns order f)})",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [132 134]},
                                             :full-name "cljs.repl.browser/add-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.core/string-print" {:ns "cljs.core",
                                     :name "string-print",
                                     :signature ["[x]"],
                                     :name-encode "string-print",
                                     :type "function",
                                     :full-name-encode "cljs.core/string-print",
                                     :source {:code "(defn string-print [x]\n  (*print-fn* x)\n  nil)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [8129 8131]},
                                     :full-name "cljs.core/string-print",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/ES6IteratorSeq" {:protocols #{"ISeqable"
                                                    "ISeq"
                                                    "IPrintWithWriter"},
                                       :ns "cljs.core",
                                       :name "ES6IteratorSeq",
                                       :signature ["[value iter _rest]"],
                                       :name-encode "ES6IteratorSeq",
                                       :history [["+" "0.0-2411"]],
                                       :type "type",
                                       :full-name-encode "cljs.core/ES6IteratorSeq",
                                       :source {:code "(deftype ES6IteratorSeq [value iter ^:mutable _rest]\n  ISeqable\n  (-seq [this] this)\n  ISeq\n  (-first [_] value)\n  (-rest [_]\n    (when (nil? _rest)\n      (set! _rest (es6-iterator-seq iter)))\n    _rest))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [791 799]},
                                       :full-name "cljs.core/ES6IteratorSeq"},
           "cljs.core/-" {:return-type number,
                          :ns "cljs.core",
                          :name "-",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "-",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/-",
                          :source {:code "(defn ^number -\n  ([x] (cljs.core/- x))\n  ([x y] (cljs.core/- x y))\n  ([x y & more] (reduce - (cljs.core/- x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1846 1851]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric -\n  ([x] (core/list 'js* \"(- ~{})\" x))\n  ([x y] (core/list 'js* \"(~{} - ~{})\" x y))\n  ([x y & more] `(- (- ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [414 417]}],
                          :full-name "cljs.core/-",
                          :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/loop*" {:ns "cljs.core",
                              :name "loop*",
                              :type "special form",
                              :source {:code "(defmethod parse 'loop*\n  [op encl-env form _ _]\n  (analyze-let encl-env form true))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [984 986]},
                              :extra-sources ({:code "(defmethod emit* :loop [ast]\n  (emit-let ast true))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [688 689]}),
                              :full-name "cljs.core/loop*",
                              :full-name-encode "cljs.core/loopSTAR",
                              :name-encode "loopSTAR",
                              :history [["+" "0.0-927"]]},
           "cljs.core/vector-seq" {:ns "cljs.core",
                                   :name "vector-seq",
                                   :signature ["[v offset]"],
                                   :name-encode "vector-seq",
                                   :history [["+" "0.0-1211"]
                                             ["-" "0.0-1424"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/vector-seq",
                                   :source {:code "(defn vector-seq [v offset]\n  (let [c (-count v)]\n    (when (pos? c)\n      (reify\n        IPrintable\n        (-pr-seq [vseq opts] (pr-sequential pr-seq \"(\" \" \" \")\" opts vseq))\n        ISequential\n        IEquiv\n        (-equiv [vseq other] (equiv-sequential vseq other))\n        ASeq\n        ISeq\n        (-first [_] (-nth v offset))\n        (-rest [_]\n          (let [offset (inc offset)]\n            (if (< offset c)\n              (vector-seq v offset)\n              ())))\n        ISeqable\n        (-seq [vseq] vseq)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1236",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2522 2540]},
                                   :full-name "cljs.core/vector-seq",
                                   :removed {:in "0.0-1424",
                                             :last-seen "0.0-1236"}},
           "cljs.core/IIterable" {:ns "cljs.core",
                                  :name "IIterable",
                                  :name-encode "IIterable",
                                  :implementations #{"PersistentVector"
                                                     "Range"
                                                     "IndexedSeq"
                                                     "PersistentArrayMap"},
                                  :history [["+" "0.0-2356"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IIterable",
                                  :source {:code "(defprotocol IIterable\n  (-iterator [coll]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [421 422]},
                                  :methods [{:name "-iterator",
                                             :signature ["[coll]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IIterable"},
           "cljs.test/testing-contexts-str" {:ns "cljs.test",
                                             :name "testing-contexts-str",
                                             :signature ["[]"],
                                             :name-encode "testing-contexts-str",
                                             :history [["+"
                                                        "0.0-2496"]],
                                             :type "function",
                                             :full-name-encode "cljs.test/testing-contexts-str",
                                             :source {:code "(defn testing-contexts-str\n  []\n  (apply str (interpose \" \" (reverse (:testing-contexts (get-current-env))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/test.cljs",
                                                      :lines [248 252]},
                                             :full-name "cljs.test/testing-contexts-str",
                                             :docstring "Returns a string representation of the current test context. Joins\nstrings in *testing-contexts* with spaces."},
           "clojure.zip/vector-zip" {:ns "clojure.zip",
                                     :name "vector-zip",
                                     :signature ["[root]"],
                                     :name-encode "vector-zip",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.zip/vector-zip",
                                     :source {:code "(defn vector-zip\n  [root]\n    (zipper vector?\n            seq\n            (fn [node children] (with-meta (vec children) (meta node)))\n            root))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/zip.cljs",
                                              :lines [42 48]},
                                     :full-name "clojure.zip/vector-zip",
                                     :docstring "Returns a zipper for nested vectors, given a root vector"},
           "cljs.reader/read-2-chars" {:ns "cljs.reader",
                                       :name "read-2-chars",
                                       :signature ["[reader]"],
                                       :name-encode "read-2-chars",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-2-chars",
                                       :source {:code "(defn read-2-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [167 171]},
                                       :full-name "cljs.reader/read-2-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/chunk" {:ns "cljs.core",
                              :name "chunk",
                              :signature ["[b]"],
                              :name-encode "chunk",
                              :type "function",
                              :full-name-encode "cljs.core/chunk",
                              :source {:code "(defn chunk [b]\n  (.chunk b))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2740 2741]},
                              :full-name "cljs.core/chunk",
                              :history [["+" "0.0-1424"]]},
           "cljs.core/conj!" {:ns "cljs.core",
                              :name "conj!",
                              :signature ["[]"
                                          "[coll]"
                                          "[tcoll val]"
                                          "[tcoll val & vals]"],
                              :name-encode "conjBANG",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/conjBANG",
                              :source {:code "(defn conj!\n  ([] (transient []))\n  ([coll] coll)\n  ([tcoll val]\n    (-conj! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-conj! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2923 2934]},
                              :full-name "cljs.core/conj!",
                              :docstring "Adds x to the transient collection, and return coll. The 'addition'\nmay happen at different 'places' depending on the concrete type."},
           "syntax/earmuffs" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "earmuffs",
                              :name-encode "earmuffs",
                              :type "convention",
                              :full-name-encode "syntax/earmuffs",
                              :full-name "syntax/earmuffs",
                              :history [["+" "0.0-927"]]},
           "cljs.test/do-report" {:ns "cljs.test",
                                  :name "do-report",
                                  :signature ["[m]"],
                                  :name-encode "do-report",
                                  :type "function",
                                  :full-name-encode "cljs.test/do-report",
                                  :source {:code "(defn do-report [m]\n  (let [m (case (:type m)\n            :fail (merge (file-and-line (js/Error.) 4) m)\n            :error (merge (file-and-line (:actual m) 0) m)\n            m)]\n    (report m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [347 352]},
                                  :full-name "cljs.test/do-report",
                                  :history [["+" "0.0-2496"]]},
           "cljs.core/print-map" {:ns "cljs.core",
                                  :name "print-map",
                                  :signature ["[m print-one writer opts]"],
                                  :name-encode "print-map",
                                  :type "function",
                                  :full-name-encode "cljs.core/print-map",
                                  :source {:code "(defn print-map [m print-one writer opts]\n  (pr-sequential-writer\n    writer\n    (fn [e w opts]\n      (do (print-one (key e) w opts)\n          (-write w \\space)\n          (print-one (val e) w opts)))\n    \"{\" \", \" \"}\"\n    opts (seq m)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8316 8324]},
                                  :full-name "cljs.core/print-map",
                                  :history [["+" "0.0-2120"]]},
           "cljs.core/js->clj" {:ns "cljs.core",
                                :name "js->clj",
                                :signature ["[x]" "[x & opts]"],
                                :name-encode "js-GTclj",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/js-GTclj",
                                :source {:code "(defn js->clj\n  ([x] (js->clj x {:keywordize-keys false}))\n  ([x & opts]\n    (let [{:keys [keywordize-keys]} opts\n          keyfn (if keywordize-keys keyword str)\n          f (fn thisfn [x]\n              (cond\n                (satisfies? IEncodeClojure x)\n                (-js->clj x (apply array-map opts))\n\n                (seq? x)\n                (doall (map thisfn x))\n\n                (coll? x)\n                (into (empty x) (map thisfn x))\n\n                (array? x)\n                (vec (map thisfn x))\n                 \n                (identical? (type x) js/Object)\n                (into {} (for [k (js-keys x)]\n                           [(keyfn k) (thisfn (aget x k))]))\n\n                :else x))]\n      (f x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8662 8690]},
                                :full-name "cljs.core/js->clj",
                                :docstring "Recursively transforms JavaScript arrays into ClojureScript\nvectors, and JavaScript objects into ClojureScript maps.  With\noption ':keywordize-keys true' will convert object fields from\nstrings to keywords."},
           "cljs.core/List" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IStack"
                                          "IEmptyableCollection"
                                          "ICounted"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "ASeq"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"
                                          "IList"},
                             :ns "cljs.core",
                             :name "List",
                             :signature ["[meta first rest count __hash]"],
                             :name-encode "List",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/List",
                             :source {:code "(deftype List [meta first rest count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (List. meta first rest count __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (List. meta first rest count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ASeq\n  ISeq\n  (-first [coll] first)\n  (-rest [coll]\n    (if (== count 1)\n      ()\n      rest))\n\n  INext\n  (-next [coll]\n    (if (== count 1)\n      nil\n      rest))\n\n  IStack\n  (-peek [coll] first)\n  (-pop [coll] (-rest coll))\n\n  ICollection\n  (-conj [coll o] (List. meta o coll (inc count) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ICounted\n  (-count [coll] count)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2270 2327]},
                             :full-name "cljs.core/List"},
           "cljs.core/identical?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "identical?",
                                   :signature ["[x y]"],
                                   :name-encode "identicalQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/identicalQMARK",
                                   :source {:code "(defn ^boolean identical?\n  [x y]\n  (cljs.core/identical? x y))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [80 83]},
                                   :extra-sources [{:code "(defmacro identical? [a b]\n  (bool-expr (core/list 'js* \"(~{} === ~{})\" a b)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [319 320]}],
                                   :full-name "cljs.core/identical?",
                                   :docstring "Tests if 2 arguments are the same object"},
           "cljs.core/*main-cli-fn*" {:ns "cljs.core",
                                      :name "*main-cli-fn*",
                                      :name-encode "STARmain-cli-fnSTAR",
                                      :type "var",
                                      :full-name-encode "cljs.core/STARmain-cli-fnSTAR",
                                      :source {:code "(def\n  ^{:doc \"When compiled for a command-line target, whatever\n  function *main-fn* is set to will be called with the command-line\n  argv as arguments\"}\n  *main-cli-fn* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [127 131]},
                                      :full-name "cljs.core/*main-cli-fn*",
                                      :docstring "When compiled for a command-line target, whatever\nfunction *main-fn* is set to will be called with the command-line\nargv as arguments",
                                      :history [["+" "0.0-927"]]},
           "clojure.browser.dom/html->dom" {:ns "clojure.browser.dom",
                                            :name "html->dom",
                                            :signature ["[s]"],
                                            :name-encode "html-GTdom",
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/html-GTdom",
                                            :source {:code "(defn html->dom [s]\n  (gdom/htmlToDocumentFragment s))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [101 102]},
                                            :full-name "clojure.browser.dom/html->dom",
                                            :history [["+" "0.0-927"]]},
           "cljs.repl.server/handlers" {:ns "cljs.repl.server",
                                        :name "handlers",
                                        :name-encode "handlers",
                                        :type "var",
                                        :full-name-encode "cljs.repl.server/handlers",
                                        :source {:code "(defonce handlers (atom {}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [43]},
                                        :full-name "cljs.repl.server/handlers",
                                        :history [["+" "0.0-1503"]]},
           "cljs.repl.node/load-javascript" {:ns "cljs.repl.node",
                                             :name "load-javascript",
                                             :signature ["[repl-env provides url]"],
                                             :name-encode "load-javascript",
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.node/load-javascript",
                                             :source {:code "(defn load-javascript\n  [repl-env provides url]\n  (node-eval repl-env\n    (str \"goog.require('\" (comp/munge (first provides)) \"')\")))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/clj/cljs/repl/node.clj",
                                                      :lines [67 71]},
                                             :full-name "cljs.repl.node/load-javascript",
                                             :docstring "Load a Closure JavaScript file into the Node REPL process."},
           "cljs.core/LazyTransformer.create" {:ns "cljs.core",
                                               :name "LazyTransformer.create",
                                               :signature ["[xform coll]"],
                                               :name-encode "LazyTransformerDOTcreate",
                                               :history [["+"
                                                          "0.0-2301"]],
                                               :parent-type "LazyTransformer",
                                               :type "function",
                                               :full-name-encode "cljs.core/LazyTransformerDOTcreate",
                                               :source {:code "(set! (.-create LazyTransformer)\n  (fn [xform coll]\n    (LazyTransformer. (stepper xform (iter coll)) nil nil nil)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [3260
                                                                3262]},
                                               :full-name "cljs.core/LazyTransformer.create"},
           "cljs.core/chunk-next" {:ns "cljs.core",
                                   :name "chunk-next",
                                   :signature ["[s]"],
                                   :name-encode "chunk-next",
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-next",
                                   :source {:code "(defn chunk-next [s]\n  (if (implements? IChunkedNext s)\n    (-chunked-next s)\n    (seq (-chunked-rest s))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2749 2752]},
                                   :full-name "cljs.core/chunk-next",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/enable-console-print!" {:ns "cljs.core",
                                              :name "enable-console-print!",
                                              :signature ["[]"],
                                              :name-encode "enable-console-printBANG",
                                              :history [["+"
                                                         "0.0-2060"]],
                                              :type "function",
                                              :full-name-encode "cljs.core/enable-console-printBANG",
                                              :source {:code "(defn enable-console-print!\n  []\n  (set! *print-newline* false)\n  (set! *print-fn*\n    (fn [& args]\n      (.apply (.-log js/console) js/console (into-array args)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [51 57]},
                                              :full-name "cljs.core/enable-console-print!",
                                              :docstring "Set *print-fn* to console.log"},
           "cljs.core/sorted?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "sorted?",
                                :signature ["[x]"],
                                :name-encode "sortedQMARK",
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :full-name-encode "cljs.core/sortedQMARK",
                                :source {:code "(defn ^boolean sorted?\n  [x] (satisfies? ISorted x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1522 1524]},
                                :full-name "cljs.core/sorted?",
                                :docstring "Returns true if coll satisfies ISorted"},
           "cljs.core/some" {:ns "cljs.core",
                             :name "some",
                             :signature ["[pred coll]"],
                             :name-encode "some",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/some",
                             :source {:code "(defn some\n  [pred coll]\n    (when (seq coll)\n      (or (pred (first coll)) (recur pred (next coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3305 3312]},
                             :full-name "cljs.core/some",
                             :docstring "Returns the first logical true value of (pred x) for any x in coll,\nelse nil.  One common idiom is to use a set as pred, for example\nthis will return :fred if :fred is in the sequence, otherwise nil:\n(some #{:fred} coll)"},
           "cljs.core/PersistentArrayMapSeq" {:protocols #{"ISeqable"
                                                           "IMeta"
                                                           "IWithMeta"
                                                           "IEmptyableCollection"
                                                           "ICounted"
                                                           "IReduce"
                                                           "ISequential"
                                                           "ISeq"
                                                           "ICollection"
                                                           "IHash"
                                                           "IPrintWithWriter"
                                                           "INext"
                                                           "IEquiv"},
                                              :ns "cljs.core",
                                              :name "PersistentArrayMapSeq",
                                              :signature ["[arr i _meta]"],
                                              :name-encode "PersistentArrayMapSeq",
                                              :history [["+"
                                                         "0.0-1820"]],
                                              :type "type",
                                              :full-name-encode "cljs.core/PersistentArrayMapSeq",
                                              :source {:code "(deftype PersistentArrayMapSeq [arr i _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (PersistentArrayMapSeq. arr i new-meta))\n\n  ICounted\n  (-count [coll]\n    (/ (- (alength arr) i) 2))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    [(aget arr i) (aget arr (inc i))])\n\n  (-rest [coll]\n    (if (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)\n      ()))\n\n  INext\n  (-next [coll]\n    (when (< i (- (alength arr) 2))\n      (PersistentArrayMapSeq. arr (+ i 2) _meta)))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [5259
                                                               5310]},
                                              :full-name "cljs.core/PersistentArrayMapSeq"},
           "cljs.reader/make-unicode-char" {:ns "cljs.reader",
                                            :name "make-unicode-char",
                                            :signature ["[code-str]"],
                                            :name-encode "make-unicode-char",
                                            :type "function",
                                            :full-name-encode "cljs.reader/make-unicode-char",
                                            :source {:code "(defn make-unicode-char [code-str]\n    (let [code (js/parseInt code-str 16)]\n      (.fromCharCode js/String code)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [189 191]},
                                            :full-name "cljs.reader/make-unicode-char",
                                            :history [["+" "0.0-1424"]]},
           "cljs.core/if" {:ns "cljs.core",
                           :name "if",
                           :type "special form",
                           :source {:code "(defmethod parse 'if\n  [op env [_ test then else :as form] name _]\n  (when (< (count form) 3)\n    (throw (error env \"Too few arguments to if\")))\n  (let [test-expr (disallowing-recur (analyze (assoc env :context :expr) test))\n        then-expr (allowing-redef (analyze env then))\n        else-expr (allowing-redef (analyze env else))]\n    {:env env :op :if :form form\n     :test test-expr :then then-expr :else else-expr\n     :unchecked @*unchecked-if*\n     :children [test-expr then-expr else-expr]}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [563 573]},
                           :extra-sources ({:code "(defmethod emit* :if\n  [{:keys [test then else env unchecked]}]\n  (let [context (:context env)\n        checked (not (or unchecked (safe-test? env test)))]\n    (cond\n      (truthy-constant? test) (emitln then)\n      (falsey-constant? test) (emitln else)\n      :else\n      (if (= :expr context)\n        (emits \"(\" (when checked \"cljs.core.truth_\") \"(\" test \")?\" then \":\" else \")\")\n        (do\n          (if checked\n            (emitln \"if(cljs.core.truth_(\" test \")){\")\n            (emitln \"if(\" test \"){\"))\n          (emitln then \"} else {\")\n          (emitln else \"}\"))))))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [363 378]}),
                           :full-name "cljs.core/if",
                           :full-name-encode "cljs.core/if",
                           :name-encode "if",
                           :history [["+" "0.0-927"]]},
           "clojure.core.reducers/Cat" {:protocols #{"CollFold"
                                                     "cljs.core/ISeqable"
                                                     "cljs.core/IReduce"
                                                     "cljs.core/ICounted"},
                                        :ns "clojure.core.reducers",
                                        :name "Cat",
                                        :signature ["[cnt left right]"],
                                        :name-encode "Cat",
                                        :history [["+" "0.0-1236"]],
                                        :type "type",
                                        :full-name-encode "clojure.core.reducers/Cat",
                                        :source {:code "(deftype Cat [cnt left right]\n  cljs.core/ICounted\n  (-count [_] cnt)\n\n  cljs.core/ISeqable\n  (-seq [_] (concat (seq left) (seq right)))\n\n  cljs.core/IReduce\n  (-reduce [this f1] (-reduce this f1 (f1)))\n  (-reduce\n    [_  f1 init]\n    (-reduce\n     right f1\n     (-reduce left f1 init)))\n\n  CollFold\n  (coll-fold\n    [this n combinef reducef]\n    (-reduce this reducef)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [193 211]},
                                        :full-name "clojure.core.reducers/Cat"},
           "cljs.core/write-all" {:ns "cljs.core",
                                  :name "write-all",
                                  :signature ["[writer & ss]"],
                                  :name-encode "write-all",
                                  :type "function",
                                  :full-name-encode "cljs.core/write-all",
                                  :source {:code "(defn write-all [writer & ss]\n  (doseq [s ss]\n    (-write writer s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8125 8127]},
                                  :full-name "cljs.core/write-all",
                                  :history [["+" "0.0-1503"]]},
           "cljs.core/doall" {:ns "cljs.core",
                              :name "doall",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "doall",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/doall",
                              :source {:code "(defn doall\n  ([coll]\n   (dorun coll)\n   coll)\n  ([n coll]\n   (dorun n coll)\n   coll))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8042 8054]},
                              :full-name "cljs.core/doall",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. doall can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, retains the head and returns it, thus causing the entire\nseq to reside in memory at one time."},
           "cljs.core/condp" {:ns "cljs.core",
                              :name "condp",
                              :signature ["[pred expr & clauses]"],
                              :name-encode "condp",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/condp",
                              :source {:code "(defmacro condp\n  [pred expr & clauses]\n  (let [gpred (gensym \"pred__\")\n        gexpr (gensym \"expr__\")\n        emit (fn emit [pred expr args]\n               (let [[[a b c :as clause] more]\n                       (split-at (if (= :>> (second args)) 3 2) args)\n                       n (count clause)]\n                 (core/cond\n                  (= 0 n) `(throw (js/Error. (core/str \"No matching clause: \" ~expr)))\n                  (= 1 n) a\n                  (= 2 n) `(if (~pred ~a ~expr)\n                             ~b\n                             ~(emit pred expr more))\n                  :else `(if-let [p# (~pred ~a ~expr)]\n                           (~c p#)\n                           ~(emit pred expr more)))))\n        gres (gensym \"res__\")]\n    `(let [~gpred ~pred\n           ~gexpr ~expr]\n       ~(emit gpred gexpr clauses))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1139 1179]},
                              :full-name "cljs.core/condp",
                              :docstring "Takes a binary predicate, an expression, and a set of clauses.\nEach clause can take the form of either:\n\ntest-expr result-expr\n\ntest-expr :>> result-fn\n\nNote :>> is an ordinary keyword.\n\nFor each clause, (pred test-expr expr) is evaluated. If it returns\nlogical true, the clause is a match. If a binary clause matches, the\nresult-expr is returned, if a ternary clause matches, its result-fn,\nwhich must be a unary function, is called with the result of the\npredicate as its argument, the result of that call being the return\nvalue of condp. A single default expression can follow the clauses,\nand its value will be returned if no clause matches. If no default\nexpression is provided and no clause matches, an\nIllegalArgumentException is thrown."},
           "clojure.zip/down" {:ns "clojure.zip",
                               :name "down",
                               :signature ["[loc]"],
                               :name-encode "down",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/down",
                               :source {:code "(defn down\n  [loc]\n    (when (branch? loc)\n      (let [[node path] loc\n            [c & cnext :as cs] (children loc)]\n        (when cs\n          (with-meta [c {:l [] \n                         :pnodes (if path (conj (:pnodes path) node) [node]) \n                         :ppath path \n                         :r cnext}] (meta loc))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [98 109]},
                               :full-name "clojure.zip/down",
                               :docstring "Returns the loc of the leftmost child of the node at this loc, or\nnil if no children"},
           "cljs.core/IPending" {:ns "cljs.core",
                                 :name "IPending",
                                 :name-encode "IPending",
                                 :implementations #{"Delay"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IPending",
                                 :source {:code "(defprotocol IPending\n  (^boolean -realized? [d]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [365 366]},
                                 :methods [{:name "-realized?",
                                            :signature ["[d]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IPending"},
           "cljs.core/count" {:ns "cljs.core",
                              :name "count",
                              :signature ["[coll]"],
                              :name-encode "count",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/count",
                              :source {:code "(defn count\n  [coll]\n  (if-not (nil? coll)\n    (cond\n      (implements? ICounted coll)\n      (-count ^not-native coll)\n\n      (array? coll)\n      (alength coll)\n    \n      (string? coll)\n      (alength coll)\n\n      (native-satisfies? ICounted coll)\n      (-count coll)\n\n      :else (accumulating-seq-count coll))\n    0))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1207 1226]},
                              :full-name "cljs.core/count",
                              :docstring "Returns the number of items in the collection. (count nil) returns\n0.  Also works on strings, arrays, and Maps"},
           "cljs.core/bit-test" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "bit-test",
                                 :signature ["[x n]"],
                                 :name-encode "bit-test",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-test",
                                 :source {:code "(defn ^boolean bit-test\n  [x n]\n  (cljs.core/bit-test x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2126 2129]},
                                 :extra-sources [{:code "(defmacro bit-test [x n]\n  (bool-expr (core/list 'js* \"((~{} & (1 << ~{})) != 0)\" x n)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [523 524]}],
                                 :full-name "cljs.core/bit-test",
                                 :docstring "Test bit at index n"},
           "cljs.core/js-mod" {:ns "cljs.core",
                               :name "js-mod",
                               :signature ["[n d]"],
                               :name-encode "js-mod",
                               :history [["+" "0.0-1552"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/js-mod",
                               :source {:code "(defn js-mod\n  [n d]\n  (cljs.core/js-mod n d))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2061 2064]},
                               :extra-sources [{:code "(defmacro ^::ana/numeric js-mod [num div]\n  (core/list 'js* \"(~{} % ~{})\" num div))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [487 488]}],
                               :full-name "cljs.core/js-mod",
                               :docstring "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers"},
           "cljs.core/es6-set-entries-iterator" {:ns "cljs.core",
                                                 :name "es6-set-entries-iterator",
                                                 :signature ["[coll]"],
                                                 :name-encode "es6-set-entries-iterator",
                                                 :type "function",
                                                 :full-name-encode "cljs.core/es6-set-entries-iterator",
                                                 :source {:code "(defn es6-set-entries-iterator [coll]\n  (ES6SetEntriesIterator. (seq coll)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5179
                                                                  5180]},
                                                 :full-name "cljs.core/es6-set-entries-iterator",
                                                 :history [["+"
                                                            "0.0-2371"]]},
           "cljs.test/set-env!" {:ns "cljs.test",
                                 :name "set-env!",
                                 :signature ["[new-env]"],
                                 :name-encode "set-envBANG",
                                 :type "function",
                                 :full-name-encode "cljs.test/set-envBANG",
                                 :source {:code "(defn set-env! [new-env]\n  (set! *current-env* new-env))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/test.cljs",
                                          :lines [232 233]},
                                 :full-name "cljs.test/set-env!",
                                 :history [["+" "0.0-2496"]]},
           "cljs.core/SetEntriesIterator" {:ns "cljs.core",
                                           :name "SetEntriesIterator",
                                           :signature ["[s]"],
                                           :name-encode "SetEntriesIterator",
                                           :history [["+" "0.0-2268"]
                                                     ["-" "0.0-2371"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/SetEntriesIterator",
                                           :source {:code "(deftype SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2356",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4887 4894]},
                                           :full-name "cljs.core/SetEntriesIterator",
                                           :removed {:in "0.0-2371",
                                                     :last-seen "0.0-2356"}},
           "cljs.core/loop" {:ns "cljs.core",
                             :name "loop",
                             :signature ["[bindings & body]"],
                             :name-encode "loop",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/loop",
                             :source {:code "(defmacro loop\n  [bindings & body]\n    (assert-args\n      (vector? bindings) \"a vector for its binding\"\n      (even? (count bindings)) \"an even number of forms in binding vector\")\n    (let [db (destructure bindings)]\n      (if (= db bindings)\n        `(loop* ~bindings ~@body)\n        (let [vs (take-nth 2 (drop 1 bindings))\n              bs (take-nth 2 bindings)\n              gs (map (fn [b] (if (core/symbol? b) b (gensym))) bs)\n              bfs (reduce (fn [ret [b v g]]\n                            (if (core/symbol? b)\n                              (conj ret g v)\n                              (conj ret g v b g)))\n                          [] (map core/vector bs vs gs))]\n          `(let ~bfs\n             (loop* ~(vec (interleave gs gs))\n               (let ~(vec (interleave bs gs))\n                 ~@body)))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [159 181]},
                             :full-name "cljs.core/loop",
                             :docstring "Evaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein. Acts as a recur target."},
           "cljs.core/subvec" {:ns "cljs.core",
                               :name "subvec",
                               :signature ["[v start]"
                                           "[v start end]"],
                               :name-encode "subvec",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/subvec",
                               :source {:code "(defn subvec\n  ([v start]\n     (subvec v start (count v)))\n  ([v start end]\n     (build-subvec nil v start end nil)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4680 4689]},
                               :full-name "cljs.core/subvec",
                               :docstring "Returns a persistent vector of the items in vector from\nstart (inclusive) to end (exclusive).  If end is not supplied,\ndefaults to (count vector). This operation is O(1) and very fast, as\nthe resulting vector shares structure with the original and no\ntrimming is done."},
           "cljs.core/bit-clear" {:ns "cljs.core",
                                  :name "bit-clear",
                                  :signature ["[x n]"],
                                  :name-encode "bit-clear",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/bit-clear",
                                  :source {:code "(defn bit-clear\n  [x n]\n  (cljs.core/bit-clear x n))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2107 2110]},
                                  :extra-sources [{:code "(defmacro ^::ana/numeric bit-clear [x n]\n  (core/list 'js* \"(~{} & ~(1 << ~{}))\" x n))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [517 518]}],
                                  :full-name "cljs.core/bit-clear",
                                  :docstring "Clear bit at index n"},
           "syntax/Math-namespace" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "Math-namespace",
                                    :name-encode "Math-namespace",
                                    :type "special namespace",
                                    :full-name-encode "syntax/Math-namespace",
                                    :full-name "syntax/Math-namespace",
                                    :history [["+" "0.0-927"]]},
           "repl-options/warn-on-undeclared" {:ns "repl-options",
                                              :name "warn-on-undeclared",
                                              :name-encode "warn-on-undeclared",
                                              :type "option",
                                              :full-name-encode "repl-options/warn-on-undeclared",
                                              :full-name "repl-options/warn-on-undeclared",
                                              :history [["+"
                                                         "0.0-971"]]},
           "cljs.core/gensym" {:ns "cljs.core",
                               :name "gensym",
                               :signature ["[]" "[prefix-string]"],
                               :name-encode "gensym",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/gensym",
                               :source {:code "(defn gensym\n  ([] (gensym \"G__\"))\n  ([prefix-string]\n     (when (nil? gensym_counter)\n       (set! gensym_counter (atom 0)))\n     (symbol (str prefix-string (swap! gensym_counter inc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8502 8510]},
                               :full-name "cljs.core/gensym",
                               :docstring "Returns a new symbol with a unique name. If a prefix string is\nsupplied, the name is prefix# where # is some unique number. If\nprefix is not supplied, the prefix is 'G__'."},
           "compiler-options/optimizations" {:ns "compiler-options",
                                             :name "optimizations",
                                             :name-encode "optimizations",
                                             :type "option",
                                             :full-name-encode "compiler-options/optimizations",
                                             :full-name "compiler-options/optimizations",
                                             :history [["+" "0.0-971"]]},
           "warnings/redef-in-file" {:ns "warnings",
                                     :name "redef-in-file",
                                     :type "warning",
                                     :full-name "warnings/redef-in-file",
                                     :full-name-encode "warnings/redef-in-file",
                                     :name-encode "redef-in-file",
                                     :history [["+" "0.0-2629"]]},
           "cljs.core/in-ns" {:ns "cljs.core",
                              :name "in-ns",
                              :name-encode "in-ns",
                              :type "special form (repl)",
                              :full-name-encode "cljs.core/in-ns",
                              :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n         (when-not (and (= quote 'quote) (symbol? ns-name))\n           (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n         (when-not (ana/get-namespace ns-name)\n           (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n           (-evaluate repl-env \"<cljs repl>\" 1\n             (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n         (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require-macros\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n         (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))}))",
                                       :title "repl specials table",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/repl.clj",
                                       :lines [275 336]},
                              :full-name "cljs.core/in-ns",
                              :repl-only? true,
                              :history [["+" "0.0-927"]]},
           "cljs.core/Symbol" {:protocols #{"IFn"
                                            "IMeta"
                                            "IWithMeta"
                                            "IHash"
                                            "INamed"
                                            "IComparable"
                                            "IPrintWithWriter"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Symbol",
                               :signature ["[ns name str _hash _meta]"],
                               :name-encode "Symbol",
                               :history [["+" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Symbol",
                               :source {:code "(deftype Symbol [ns name str ^:mutable _hash _meta]\n  Object\n  (toString [_] str)\n  (equiv [this other] (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Symbol other)\n      (identical? str (.-str other))\n      false))\n\n  IFn\n  (-invoke [sym coll]\n    (-lookup coll sym nil))\n  (-invoke [sym coll not-found]\n    (-lookup coll sym not-found))\n\n  IMeta\n  (-meta [_] _meta)\n\n  IWithMeta\n  (-with-meta [_ new-meta] (Symbol. ns name str _hash new-meta))\n\n  IHash\n  (-hash [sym]\n    (caching-hash sym hash-symbol _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer str)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [592 624]},
                               :full-name "cljs.core/Symbol"},
           "cljs.core/hash-string*" {:ns "cljs.core",
                                     :name "hash-string*",
                                     :signature ["[s]"],
                                     :name-encode "hash-stringSTAR",
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-stringSTAR",
                                     :source {:code "(defn hash-string* [s]\n  (if-not (nil? s)\n    (let [len (alength s)]\n      (if (pos? len)\n        (loop [i 0 hash 0]\n          (if (< i len)\n            (recur (inc i) (+ (imul 31 hash) (.charCodeAt s i)))\n            hash))\n        0))\n    0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [513 522]},
                                     :full-name "cljs.core/hash-string*",
                                     :history [["+" "0.0-2261"]]},
           "cljs.core/shuffle" {:ns "cljs.core",
                                :name "shuffle",
                                :signature ["[coll]"],
                                :name-encode "shuffle",
                                :history [["+" "0.0-1424"]],
                                :type "function",
                                :full-name-encode "cljs.core/shuffle",
                                :source {:code "(defn shuffle\n  [coll]\n  (let [a (to-array coll)]\n    (garray/shuffle a)\n    (vec a)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1748 1753]},
                                :full-name "cljs.core/shuffle",
                                :docstring "Return a random permutation of coll"},
           "cljs.core/+" {:return-type number,
                          :ns "cljs.core",
                          :name "+",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "PLUS",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/PLUS",
                          :source {:code "(defn ^number +\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/+ x y))\n  ([x y & more]\n    (reduce + (cljs.core/+ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1838 1844]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric +\n  ([] 0)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} + ~{})\" x y))\n  ([x y & more] `(+ (+ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [355 359]}],
                          :full-name "cljs.core/+",
                          :docstring "Returns the sum of nums. (+) returns 0."},
           "cljs.core/clone" {:ns "cljs.core",
                              :name "clone",
                              :signature ["[value]"],
                              :name-encode "clone",
                              :type "function",
                              :full-name-encode "cljs.core/clone",
                              :source {:code "(defn clone [value]\n  (-clone value))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [696 697]},
                              :full-name "cljs.core/clone",
                              :history [["+" "0.0-2134"]]},
           "cljs.core/comp" {:ns "cljs.core",
                             :name "comp",
                             :signature ["[]"
                                         "[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f1 f2 f3 & fs]"],
                             :name-encode "comp",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/comp",
                             :source {:code "(defn comp\n  ([] identity)\n  ([f] f)\n  ([f g]\n     (fn\n       ([] (f (g)))\n       ([x] (f (g x)))\n       ([x y] (f (g x y)))\n       ([x y z] (f (g x y z)))\n       ([x y z & args] (f (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (f (g (h))))\n       ([x] (f (g (h x))))\n       ([x y] (f (g (h x y))))\n       ([x y z] (f (g (h x y z))))\n       ([x y z & args] (f (g (apply h x y z args))))))\n  ([f1 f2 f3 & fs]\n    (let [fs (reverse (list* f1 f2 f3 fs))]\n      (fn [& args]\n        (loop [ret (apply (first fs) args) fs (next fs)]\n          (if fs\n            (recur ((first fs) ret) (next fs))\n            ret))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3343 3370]},
                             :full-name "cljs.core/comp",
                             :docstring "Takes a set of functions and returns a fn that is the composition\nof those fns.  The returned fn takes a variable number of args,\napplies the rightmost of fns to the args, the next\nfn (right-to-left) to the result, etc."},
           "cljs.core/ArrayIter" {:ns "cljs.core",
                                  :name "ArrayIter",
                                  :signature ["[arr i]"],
                                  :name-encode "ArrayIter",
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayIter",
                                  :source {:code "(deftype ArrayIter [arr ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3077 3084]},
                                  :full-name "cljs.core/ArrayIter",
                                  :history [["+" "0.0-2301"]]},
           "syntax/comma" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "comma",
                           :name-encode "comma",
                           :type "special character",
                           :full-name-encode "syntax/comma",
                           :full-name "syntax/comma",
                           :history [["+" "0.0-927"]]},
           "cljs.reader/desugar-meta" {:ns "cljs.reader",
                                       :name "desugar-meta",
                                       :signature ["[f]"],
                                       :name-encode "desugar-meta",
                                       :type "function",
                                       :full-name-encode "cljs.reader/desugar-meta",
                                       :source {:code "(defn desugar-meta\n  [f]\n  (cond\n   (symbol? f) {:tag f}\n   (string? f) {:tag f}\n   (keyword? f) {f true}\n   :else f))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [353 359]},
                                       :full-name "cljs.reader/desugar-meta",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl/load-namespace" {:ns "cljs.repl",
                                       :name "load-namespace",
                                       :signature ["[repl-env sym]"
                                                   "[repl-env sym opts]"],
                                       :name-encode "load-namespace",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/load-namespace",
                                       :source {:code "(defn load-namespace\n  ([repl-env sym] (load-namespace repl-env sym nil))\n  ([repl-env sym opts]\n   (let [sym      (if (and (seq? sym)\n                        (= (first sym) 'quote))\n                    (second sym)\n                    sym)\n         ;; TODO: add pre-condition to source-on-disk, the\n         ;; source must supply at least :url - David\n         sources  (cljsc/add-dependencies\n                    (merge (env->opts repl-env) opts)\n                    {:requires [(name sym)] :type :seed\n                     :url (:uri (cljsc/source-for-namespace\n                                  sym env/*compiler*))})\n         deps     (->> sources\n                    (remove (comp #{[\"goog\"]} :provides))\n                    (remove (comp #{:seed} :type))\n                    (map #(select-keys % [:provides :url])))]\n     (if (:output-dir opts)\n       ;; REPLs that read from :output-dir just need to add deps,\n       ;; environment will handle actual loading - David\n       (doseq [source (map #(cljsc/source-on-disk opts %) sources)]\n         (-evaluate repl-env \"<cljs repl>\" 1\n           (cljsc/add-dep-string opts source)))\n       ;; REPLs that stream must manually load each dep - David\n       (doseq [{:keys [url provides]} deps]\n         (-load repl-env provides url))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [113 142]},
                                       :full-name "cljs.repl/load-namespace",
                                       :docstring "Load a namespace and all of its dependencies into the evaluation environment.\nThe environment is responsible for ensuring that each namespace is loaded once and\nonly once."},
           "cljs.core/pr" {:ns "cljs.core",
                           :name "pr",
                           :signature ["[& objs]"],
                           :name-encode "pr",
                           :history [["+" "0.0-927"]],
                           :type "function",
                           :full-name-encode "cljs.core/pr",
                           :source {:code "(defn pr\n  [& objs]\n  (pr-with-opts objs (pr-opts)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [8277 8283]},
                           :full-name "cljs.core/pr",
                           :docstring "Prints the object(s) using string-print.  Prints the\nobject(s), separated by spaces if there is more than one.\nBy default, pr and prn print in a way that objects can be\nread by the reader"},
           "compiler-options/static-fns" {:ns "compiler-options",
                                          :name "static-fns",
                                          :name-encode "static-fns",
                                          :type "option",
                                          :full-name-encode "compiler-options/static-fns",
                                          :full-name "compiler-options/static-fns",
                                          :history [["+" "0.0-1424"]]},
           "cljs.test/run-tests" {:ns "cljs.test",
                                  :name "run-tests",
                                  :signature ["[]"
                                              "[env-or-ns]"
                                              "[env-or-ns & namespaces]"],
                                  :name-encode "run-tests",
                                  :history [["+" "0.0-2496"]],
                                  :type "macro",
                                  :full-name-encode "cljs.test/run-tests",
                                  :source {:code "(defmacro run-tests\n  ([] `(run-tests (cljs.test/empty-env) '~ana/*cljs-ns*))\n  ([env-or-ns]\n   (if (ns? env-or-ns)\n     `(run-tests (cljs.test/empty-env) ~env-or-ns)\n     `(run-tests ~env-or-ns '~ana/*cljs-ns*)))\n  ([env-or-ns & namespaces]\n   (assert (every?\n             (fn [[quote ns]] (and (= quote 'quote) (symbol? ns)))\n             namespaces)\n     \"All arguments to run-tests must be quoted symbols\")\n   (let [is-ns (ns? env-or-ns)]\n     `(do\n        ~(if is-ns\n           `(cljs.test/set-env! (cljs.test/empty-env))\n           `(cljs.test/set-env! ~env-or-ns))\n        ;; TODO: support async - David\n        (let [summary# (assoc\n                         (reduce\n                           (fn [acc# res#]\n                             (merge-with +\n                               acc#\n                               (:report-counters res#)))\n                           {:test 0 :pass 0 :fail 0 :error 0}\n                           [~@(map\n                                (fn [ns]\n                                  `(cljs.test/test-ns ~ns))\n                                (if is-ns\n                                  (concat [env-or-ns] namespaces)\n                                  namespaces))])\n                         :type :summary)]\n          (do-report summary#)\n          summary#)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/test.clj",
                                           :lines [228 263]},
                                  :full-name "cljs.test/run-tests",
                                  :docstring "Runs all tests in the given namespaces; prints results.\nDefaults to current namespace if none given.  Returns a map\nsummarizing test results."},
           "clojure.string/upper-case" {:ns "clojure.string",
                                        :name "upper-case",
                                        :signature ["[s]"],
                                        :name-encode "upper-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/upper-case",
                                        :source {:code "(defn upper-case\n  [s]\n  (.toUpperCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [68 71]},
                                        :full-name "clojure.string/upper-case",
                                        :docstring "Converts string to all upper-case."},
           "cljs.core/chars" {:ns "cljs.core",
                              :name "chars",
                              :signature ["[x]"],
                              :name-encode "chars",
                              :type "function",
                              :full-name-encode "cljs.core/chars",
                              :source {:code "(defn chars [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2054]},
                              :full-name "cljs.core/chars",
                              :history [["+" "0.0-1798"]]},
           "cljs.analyzer.api/find-ns" {:ns "cljs.analyzer.api",
                                        :name "find-ns",
                                        :signature ["[sym]"],
                                        :name-encode "find-ns",
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/find-ns",
                                        :source {:code "(defn find-ns\n  [sym]\n  {:pre [(symbol? sym)]}\n  (get-in @env/*compiler* [::ana/namespaces sym]))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/analyzer/api.clj",
                                                 :lines [30 35]},
                                        :full-name "cljs.analyzer.api/find-ns",
                                        :docstring "Given a namespace return the corresponding namespace analysis map. Analagous\nto clojure.core/find-ns."},
           "syntax/string" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "string",
                            :name-encode "string",
                            :type "syntax",
                            :full-name-encode "syntax/string",
                            :extra-sources ({:code "(defn- read-string*\n  [reader _]\n  (loop [sb (StringBuilder.)\n         ch (read-char reader)]\n    (case ch\n      nil (reader-error reader \"EOF while reading string\")\n      \\\\ (recur (doto sb (.append (escape-char sb reader)))\n                (read-char reader))\n      \\\" (str sb)\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [264 273]}
                                            {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [591 610]}),
                            :full-name "syntax/string",
                            :history [["+" "0.0-1853"]]},
           "clojure.browser.event/expose" {:ns "clojure.browser.event",
                                           :name "expose",
                                           :signature ["[e]"],
                                           :name-encode "expose",
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/expose",
                                           :source {:code "(defn expose [e]\n  (events/expose e))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [81 82]},
                                           :full-name "clojure.browser.event/expose",
                                           :history [["+" "0.0-927"]]},
           "clojure.browser.event/listen-once" {:ns "clojure.browser.event",
                                                :name "listen-once",
                                                :signature ["[src type fn]"
                                                            "[src type fn capture?]"],
                                                :name-encode "listen-once",
                                                :type "function",
                                                :full-name-encode "clojure.browser.event/listen-once",
                                                :source {:code "(defn listen-once\n  ([src type fn]\n     (listen-once src type fn false))\n  ([src type fn capture?]\n     (events/listenOnce src\n                        (get (event-types src) type type)\n                        fn\n                        capture?)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/clojure/browser/event.cljs",
                                                         :lines [55
                                                                 62]},
                                                :full-name "clojure.browser.event/listen-once",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/m3-C1" {:ns "cljs.core",
                              :name "m3-C1",
                              :name-encode "m3-C1",
                              :type "var",
                              :full-name-encode "cljs.core/m3-C1",
                              :source {:code "(def m3-C1 0xcc9e2d51)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [465]},
                              :full-name "cljs.core/m3-C1",
                              :history [["+" "0.0-2261"]]},
           "cljs.core/empty?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "empty?",
                               :signature ["[coll]"],
                               :name-encode "emptyQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/emptyQMARK",
                               :source {:code "(defn ^boolean empty?\n  [coll] (or (nil? coll)\n             (not (seq coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1494 1498]},
                               :full-name "cljs.core/empty?",
                               :docstring "Returns true if coll has no items - same as (not (seq coll)).\nPlease use the idiom (seq x) rather than (not (empty? x))"},
           "cljs.core/m3-fmix" {:return-type number,
                                :ns "cljs.core",
                                :name "m3-fmix",
                                :signature ["[h1 len]"],
                                :name-encode "m3-fmix",
                                :history [["+" "0.0-2261"]],
                                :type "function",
                                :full-name-encode "cljs.core/m3-fmix",
                                :source {:code "(defn ^number m3-fmix [h1 len]\n  (as-> h1 h1\n    (bit-xor h1 len)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))\n    (imul h1 0x85ebca6b)\n    (bit-xor h1 (unsigned-bit-shift-right h1 13))\n    (imul h1 0xc2b2ae35)\n    (bit-xor h1 (unsigned-bit-shift-right h1 16))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [474 481]},
                                :full-name "cljs.core/m3-fmix"},
           "compiler-options/pretty-print" {:ns "compiler-options",
                                            :name "pretty-print",
                                            :name-encode "pretty-print",
                                            :type "option",
                                            :full-name-encode "compiler-options/pretty-print",
                                            :full-name "compiler-options/pretty-print",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/newline" {:ns "cljs.core",
                                :name "newline",
                                :signature ["[opts]"],
                                :name-encode "newline",
                                :type "function",
                                :full-name-encode "cljs.core/newline",
                                :source {:code "(defn newline [opts]\n  (string-print \"\\n\")\n  (when (get opts :flush-on-newline)\n    (flush)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8262 8265]},
                                :full-name "cljs.core/newline",
                                :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashMap" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMap"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IKVReduce"
                                                       "IEditableCollection"
                                                       "IEmptyableCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IAssociative"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentHashMap",
                                          :signature ["[meta cnt root has-nil? nil-val __hash]"],
                                          :name-encode "PersistentHashMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashMap",
                                          :source {:code "(deftype PersistentHashMap [meta cnt root ^boolean has-nil? nil-val ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k]\n    (-lookup coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashMap. meta cnt root has-nil? nil-val __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentHashMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? cnt)\n      (let [s (if-not (nil? root) (.inode-seq root))]\n        (if has-nil?\n          (cons [nil nil-val] s)\n          s))))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (cond (nil? k)    (if has-nil?\n                        nil-val\n                        not-found)\n          (nil? root) not-found\n          :else       (.inode-lookup root 0 (hash k) k not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (nil? k)\n      (if (and has-nil? (identical? v nil-val))\n        coll\n        (PersistentHashMap. meta (if has-nil? cnt (inc cnt)) root true v nil))\n      (let [added-leaf? (Box. false)\n            new-root    (-> (if (nil? root)\n                              (.-EMPTY BitmapIndexedNode)\n                              root)\n                            (.inode-assoc 0 (hash k) k v added-leaf?))]\n        (if (identical? new-root root)\n          coll\n          (PersistentHashMap. meta (if ^boolean (.-val added-leaf?) (inc cnt) cnt) new-root has-nil? nil-val nil)))))\n\n  (-contains-key? [coll k]\n    (cond (nil? k)    has-nil?\n          (nil? root) false\n          :else       (not (identical? (.inode-lookup root 0 (hash k) k lookup-sentinel)\n                                       lookup-sentinel))))\n\n  IMap\n  (-dissoc [coll k]\n    (cond (nil? k)    (if has-nil?\n                        (PersistentHashMap. meta (dec cnt) root false nil nil)\n                        coll)\n          (nil? root) coll\n          :else\n          (let [new-root (.inode-without root 0 (hash k) k)]\n            (if (identical? new-root root)\n              coll\n              (PersistentHashMap. meta (dec cnt) new-root has-nil? nil-val nil)))))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [init (if has-nil? (f init nil nil-val) init)]\n      (cond\n        (reduced? init)          @init\n        (not (nil? root)) (.kv-reduce root f init)\n        :else                    init)))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientHashMap. (js-obj) root cnt has-nil? nil-val)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6202 6327]},
                                          :full-name "cljs.core/PersistentHashMap"},
           "cljs.core/replace" {:ns "cljs.core",
                                :name "replace",
                                :signature ["[smap]" "[smap coll]"],
                                :name-encode "replace",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/replace",
                                :source {:code "(defn replace\n  ([smap]\n     (map #(if-let [e (find smap %)] (val e) %)))\n  ([smap coll]\n     (if (vector? coll)\n       (let [n (count coll)]\n         (reduce (fn [v i]\n                   (if-let [e (find smap (nth v i))]\n                     (assoc v i (second e))\n                     v))\n           coll (take n (iterate inc 0))))\n       (map #(if-let [e (find smap %)] (second e) %) coll))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7615 7630]},
                                :full-name "cljs.core/replace",
                                :docstring "Given a map of replacement pairs and a vector/collection, returns a\nvector/seq with any elements = a key in smap replaced with the\ncorresponding val in smap.  Returns a transducer when no collection\nis provided."},
           "cljs.core/rand" {:ns "cljs.core",
                             :name "rand",
                             :signature ["[]" "[n]"],
                             :name-encode "rand",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rand",
                             :source {:code "(defn rand\n  ([] (rand 1))\n  ([n] (* (Math/random) n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [8723 8727]},
                             :full-name "cljs.core/rand",
                             :docstring "Returns a random floating point number between 0 (inclusive) and\nn (default 1) (exclusive)."},
           "cljs.core/add-watch" {:ns "cljs.core",
                                  :name "add-watch",
                                  :signature ["[iref key f]"],
                                  :name-encode "add-watch",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/add-watch",
                                  :source {:code "(defn add-watch\n  [iref key f]\n  (-add-watch iref key f)\n  iref)",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8465 8488]},
                                  :full-name "cljs.core/add-watch",
                                  :docstring "Alpha - subject to change.\n\nAdds a watch function to an atom reference. The watch fn must be a\nfn of 4 args: a key, the reference, its old-state, its\nnew-state. Whenever the reference's state might have been changed,\nany registered watches will have their functions called. The watch\nfn will be called synchronously. Note that an atom's state\nmay have changed again prior to the fn call, so use old/new-state\nrather than derefing the reference. Keys must be unique per\nreference, and can be used to remove the watch with remove-watch,\nbut are otherwise considered opaque by the watch mechanism.  Bear in\nmind that regardless of the result or action of the watch fns the\natom's value will change.  Example:\n\n    (def a (atom 0))\n    (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n    (swap! a inc)\n    ;; Assertion Error\n    (deref a)\n    ;=> 1"},
           "cljs.repl.rhino/loaded-libs" {:ns "cljs.repl.rhino",
                                          :name "loaded-libs",
                                          :name-encode "loaded-libs",
                                          :type "var",
                                          :full-name-encode "cljs.repl.rhino/loaded-libs",
                                          :source {:code "(def loaded-libs (atom #{}))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1552",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [20]},
                                          :full-name "cljs.repl.rhino/loaded-libs",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1576"]],
                                          :removed {:in "0.0-1576",
                                                    :last-seen "0.0-1552"}},
           "cljs.core/cloneable?" {:ns "cljs.core",
                                   :name "cloneable?",
                                   :signature ["[value]"],
                                   :name-encode "cloneableQMARK",
                                   :type "function",
                                   :full-name-encode "cljs.core/cloneableQMARK",
                                   :source {:code "(defn cloneable? [value]\n  (satisfies? ICloneable value))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [699 700]},
                                   :full-name "cljs.core/cloneable?",
                                   :history [["+" "0.0-2156"]]},
           "clojure.string/capitalize" {:ns "clojure.string",
                                        :name "capitalize",
                                        :signature ["[s]"],
                                        :name-encode "capitalize",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/capitalize",
                                        :source {:code "(defn capitalize\n  [s]\n  (if (< (count s) 2)\n    (upper-case s)\n    (str (upper-case (subs s 0 1))\n         (lower-case (subs s 1)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [78 85]},
                                        :full-name "clojure.string/capitalize",
                                        :docstring "Converts first character of the string to upper-case, all other\ncharacters to lower-case."},
           "cljs.core/short" {:return-type number,
                              :ns "cljs.core",
                              :name "short",
                              :signature ["[x]"],
                              :name-encode "short",
                              :history [["+" "0.0-1798"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/short",
                              :source {:code "(defn ^number short [x] x)",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1945]},
                              :extra-sources [{:code "(defmacro short [x] x)",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [362]}],
                              :full-name "cljs.core/short"},
           "cljs.core/replicate" {:ns "cljs.core",
                                  :name "replicate",
                                  :signature ["[n x]"],
                                  :name-encode "replicate",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/replicate",
                                  :source {:code "(defn replicate\n  [n x] (take n (repeat x)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3882 3884]},
                                  :full-name "cljs.core/replicate",
                                  :docstring "Returns a lazy seq of n xs."},
           "cljs.core/es6-entries-iterator" {:ns "cljs.core",
                                             :name "es6-entries-iterator",
                                             :signature ["[coll]"],
                                             :name-encode "es6-entries-iterator",
                                             :type "function",
                                             :full-name-encode "cljs.core/es6-entries-iterator",
                                             :source {:code "(defn es6-entries-iterator [coll]\n  (ES6EntriesIterator. (seq coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [5166
                                                              5167]},
                                             :full-name "cljs.core/es6-entries-iterator",
                                             :history [["+"
                                                        "0.0-2371"]]},
           "cljs.core/ArrayChunk" {:protocols #{"ICounted"
                                                "IReduce"
                                                "IChunk"
                                                "IIndexed"},
                                   :ns "cljs.core",
                                   :name "ArrayChunk",
                                   :signature ["[arr off end]"],
                                   :name-encode "ArrayChunk",
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ArrayChunk",
                                   :source {:code "(deftype ArrayChunk [arr off end]\n  ICounted\n  (-count [_] (- end off))\n\n  IIndexed\n  (-nth [coll i]\n    (aget arr (+ off i)))\n  (-nth [coll i not-found]\n    (if (and (>= i 0) (< i (- end off)))\n      (aget arr (+ off i))\n      not-found))\n\n  IChunk\n  (-drop-first [coll]\n    (if (== off end)\n      (throw (js/Error. \"-drop-first of empty chunk\"))\n      (ArrayChunk. arr (inc off) end)))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr off) (inc off)))\n  (-reduce [coll f start]\n    (array-reduce arr f start off)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2636 2658]},
                                   :full-name "cljs.core/ArrayChunk"},
           "cljs.core/sequential?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "sequential?",
                                    :signature ["[x]"],
                                    :name-encode "sequentialQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/sequentialQMARK",
                                    :source {:code "(defn ^boolean sequential?\n  [x] (satisfies? ISequential x))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [1518 1520]},
                                    :full-name "cljs.core/sequential?",
                                    :docstring "Returns true if coll satisfies ISequential"},
           "cljs.core/underive" {:ns "cljs.core",
                                 :name "underive",
                                 :signature ["[tag parent]"
                                             "[h tag parent]"],
                                 :name-encode "underive",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/underive",
                                 :source {:code "(defn underive\n  ([tag parent]\n    (swap-global-hierarchy! underive tag parent)\n    nil)\n  ([h tag parent]\n    (let [parentMap (:parents h)\n          childsParents (if (parentMap tag)\n                          (disj (parentMap tag) parent) #{})\n          newParents (if (not-empty childsParents)\n                      (assoc parentMap tag childsParents)\n                      (dissoc parentMap tag))\n          deriv-seq (flatten (map #(cons (first %) (interpose (first %) (second %)))\n                                  (seq newParents)))]\n      (if (contains? (parentMap tag) parent)\n        (reduce #(apply derive %1 %2) (make-hierarchy)\n                (partition 2 deriv-seq))\n        h))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8845 8864]},
                                 :full-name "cljs.core/underive",
                                 :docstring "Removes a parent/child relationship between parent and\ntag. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "cljs.core/PersistentArrayMapIterator" {:ns "cljs.core",
                                                   :name "PersistentArrayMapIterator",
                                                   :signature ["[arr i cnt]"],
                                                   :name-encode "PersistentArrayMapIterator",
                                                   :type "type",
                                                   :full-name-encode "cljs.core/PersistentArrayMapIterator",
                                                   :source {:code "(deftype PersistentArrayMapIterator [arr ^:mutable i cnt]\n  Object\n  (hasNext [_]\n    (< i cnt))\n  (next [_]\n    (let [ret [(aget arr i) (aget arr (inc i))]]\n      (set! i (+ i 2))\n      ret)))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [5320
                                                                    5327]},
                                                   :full-name "cljs.core/PersistentArrayMapIterator",
                                                   :history [["+"
                                                              "0.0-2371"]]},
           "cljs.core/get-method" {:ns "cljs.core",
                                   :name "get-method",
                                   :signature ["[multifn dispatch-val]"],
                                   :name-encode "get-method",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/get-method",
                                   :source {:code "(defn get-method\n  [multifn dispatch-val] (-get-method multifn dispatch-val))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [9135 9138]},
                                   :full-name "cljs.core/get-method",
                                   :docstring "Given a multimethod and a dispatch value, returns the dispatch fn\nthat would apply to that value, or nil if none apply and no default"},
           "cljs.core/=" {:return-type boolean,
                          :ns "cljs.core",
                          :name "=",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "EQ",
                          :history [["+" "0.0-927"]],
                          :type "function",
                          :full-name-encode "cljs.core/EQ",
                          :source {:code "(defn ^boolean =\n  ([x] true)\n  ([x y]\n    (if (nil? x)\n      (nil? y)\n      (or (identical? x y)\n        ^boolean (-equiv x y))))\n  ([x y & more]\n     (if (= x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (= y (first more)))\n       false)))",
                                   :title "Source code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [758 774]},
                          :full-name "cljs.core/=",
                          :docstring "Equality. Returns true if x equals y, false if not. Compares\nnumbers and collections in a type-independent manner.  Clojure's immutable data\nstructures define -equiv (and thus =) as a value, not an identity,\ncomparison."},
           "cljs.repl.server/dispatch-on" {:ns "cljs.repl.server",
                                           :name "dispatch-on",
                                           :signature ["[method pred handler]"
                                                       "[method {:as m}]"],
                                           :name-encode "dispatch-on",
                                           :history [["+" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.server/dispatch-on",
                                           :source {:code "(defn dispatch-on\n  ([method pred handler]\n    (dispatch-on method {:pred pred :handler handler}))\n  ([method {:as m}]\n    (swap! handlers\n      (fn [old]\n        (update-in old [method] #(conj (vec %) m))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/repl/server.clj",
                                                    :lines [45 57]},
                                           :full-name "cljs.repl.server/dispatch-on",
                                           :docstring "Registers a handler to be dispatched based on a request method and a\npredicate.\n\npred should be a function that accepts an options map, a connection,\nand a request map and returns a boolean value based on whether or not\nthat request should be dispatched to the related handler."},
           "cljs.reader/deregister-default-tag-parser!" {:ns "cljs.reader",
                                                         :name "deregister-default-tag-parser!",
                                                         :signature ["[]"],
                                                         :name-encode "deregister-default-tag-parserBANG",
                                                         :type "function",
                                                         :full-name-encode "cljs.reader/deregister-default-tag-parserBANG",
                                                         :source {:code "(defn deregister-default-tag-parser!\n  []\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] nil))\n    old-parser))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2760",
                                                                  :filename "src/cljs/cljs/reader.cljs",
                                                                  :lines [608
                                                                          612]},
                                                         :full-name "cljs.reader/deregister-default-tag-parser!",
                                                         :history [["+"
                                                                    "0.0-1576"]]},
           "syntax/comment" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "comment",
                             :name-encode "comment",
                             :type "syntax",
                             :full-name-encode "syntax/comment",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [120 122]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [591 610]}),
                             :full-name "syntax/comment",
                             :history [["+" "0.0-1853"]]},
           "cljs.core/defn-" {:ns "cljs.core",
                              :name "defn-",
                              :signature ["[name & decls]"],
                              :name-encode "defn-",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/defn-",
                              :source {:code "(defmacro defn-\n  [name & decls]\n    (list* `defn (with-meta name (assoc (meta name) :private true)) decls))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [4529 4533]},
                              :full-name "cljs.core/defn-",
                              :docstring "same as defn, yielding non-public def"},
           "compiler-options/target" {:ns "compiler-options",
                                      :name "target",
                                      :name-encode "target",
                                      :type "option",
                                      :full-name-encode "compiler-options/target",
                                      :full-name "compiler-options/target",
                                      :history [["+" "0.0-971"]]},
           "cljs.reader/read-symbol" {:ns "cljs.reader",
                                      :name "read-symbol",
                                      :signature ["[reader initch]"],
                                      :name-encode "read-symbol",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-symbol",
                                      :source {:code "(defn read-symbol\n  [reader initch]\n  (let [token (read-token reader initch)]\n    (if (and (gstring/contains token \"/\")\n             (not (== (.-length token) 1)))\n      (symbol (subs token 0 (.indexOf token \"/\"))\n              (subs token (inc (.indexOf token \"/\"))\n                (.-length token)))\n      (special-symbols token (symbol token)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [327 335]},
                                      :full-name "cljs.reader/read-symbol",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/push-back-reader" {:ns "cljs.reader",
                                           :name "push-back-reader",
                                           :signature ["[s]"],
                                           :name-encode "push-back-reader",
                                           :type "function",
                                           :full-name-encode "cljs.reader/push-back-reader",
                                           :source {:code "(defn push-back-reader [s]\n  \"Creates a StringPushbackReader from a given string\"\n  (StringPushbackReader. s (array) -1))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [29 31]},
                                           :full-name "cljs.reader/push-back-reader",
                                           :history [["+" "0.0-927"]]},
           "closure-warnings/access-controls" {:ns "closure-warnings",
                                               :name "access-controls",
                                               :type "warning",
                                               :full-name "closure-warnings/access-controls",
                                               :full-name-encode "closure-warnings/access-controls",
                                               :name-encode "access-controls",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/deftype" {:ns "cljs.core",
                                :name "deftype",
                                :signature ["[t fields & impls]"],
                                :name-encode "deftype",
                                :type "macro",
                                :full-name-encode "cljs.core/deftype",
                                :source {:code "(defmacro deftype [t fields & impls]\n  (let [env &env\n        r (:name (cljs.analyzer/resolve-var (dissoc env :locals) t))\n        [fpps pmasks] (prepare-protocol-masks env impls)\n        protocols (collect-protocols impls env)\n        t (vary-meta t assoc\n            :protocols protocols\n            :skip-protocol-flag fpps) ]\n    `(do\n       (deftype* ~t ~fields ~pmasks\n         ~(if (seq impls)\n            `(extend-type ~t ~@(dt->et t impls fields))))\n       (set! (.-cljs$lang$type ~t) true)\n       (set! (.-cljs$lang$ctorStr ~t) ~(core/str r))\n       (set! (.-cljs$lang$ctorPrWriter ~t) (fn [this# writer# opt#] (-write writer# ~(core/str r))))\n\n       ~(build-positional-factory t r fields)\n       ~t)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [889 906]},
                                :full-name "cljs.core/deftype",
                                :history [["+" "0.0-927"]]},
           "cljs.repl/print-doc" {:ns "cljs.repl",
                                  :name "print-doc",
                                  :signature ["[m]"],
                                  :name-encode "print-doc",
                                  :type "function",
                                  :full-name-encode "cljs.repl/print-doc",
                                  :source {:code "(defn print-doc [m]\n  (println \"-------------------------\")\n  (println (str (when-let [ns (:ns m)] (str ns \"/\")) (:name m)))\n  (cond\n    (:forms m) (doseq [f (:forms m)]\n                 (print \"  \")\n                 (prn f))\n    (:arglists m) (prn (:arglists m)))\n  (if (:special-form m)\n    (do\n      (println \"Special Form\")\n      (println \" \" (:doc m)) \n      (if (contains? m :url)\n        (when (:url m)\n          (println (str \"\\n  Please see http://clojure.org/\" (:url m))))\n        (println (str \"\\n  Please see http://clojure.org/special_forms#\"\n                   (:name m)))))\n    (do\n      (when (:macro m)\n        (println \"Macro\")) \n      (println \" \" (:doc m)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/repl.cljs",
                                           :lines [11 31]},
                                  :full-name "cljs.repl/print-doc",
                                  :history [["+" "0.0-2496"]]},
           "cljs.core/longs" {:ns "cljs.core",
                              :name "longs",
                              :signature ["[x]"],
                              :name-encode "longs",
                              :type "function",
                              :full-name-encode "cljs.core/longs",
                              :source {:code "(defn longs [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2059]},
                              :full-name "cljs.core/longs",
                              :history [["+" "0.0-1798"]]},
           "cljs.core/Subvec" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IReversible"
                                            "IStack"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "IReduce"
                                            "ILookup"
                                            "ISequential"
                                            "ICollection"
                                            "IHash"
                                            "IComparable"
                                            "IPrintWithWriter"
                                            "IIndexed"
                                            "IAssociative"
                                            "IVector"
                                            "IEquiv"
                                            "ICloneable"},
                               :ns "cljs.core",
                               :name "Subvec",
                               :signature ["[meta v start end __hash]"],
                               :name-encode "Subvec",
                               :history [["+" "0.0-927"]],
                               :type "type",
                               :full-name-encode "cljs.core/Subvec",
                               :source {:code "(deftype Subvec [meta v start end ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (Subvec. meta v start end __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (build-subvec meta v start end __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (-nth v (dec end)))\n  (-pop [coll]\n    (if (== start end)\n      (throw (js/Error. \"Can't pop empty vector\"))\n      (build-subvec meta v start (dec end) nil)))\n\n  ICollection\n  (-conj [coll o]\n    (build-subvec meta (-assoc-n v end o) start (inc end) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [subvec-seq (fn subvec-seq [i]\n                       (when-not (== i end)\n                         (cons (-nth v i)\n                               (lazy-seq\n                                (subvec-seq (inc i))))))]\n      (subvec-seq start)))\n\n  IReversible\n  (-rseq [coll]\n    (if-not (== start end)\n      (RSeq. coll (dec (- end start)) nil)))\n\n  ICounted\n  (-count [coll] (- end start))\n\n  IIndexed\n  (-nth [coll n]\n    (if (or (neg? n) (<= end (+ start n)))\n      (vector-index-out-of-bounds n (- end start))\n      (-nth v (+ start n))))\n  (-nth [coll n not-found]\n    (if (or (neg? n) (<= end (+ start n)))\n      not-found\n      (-nth v (+ start n) not-found)))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IAssociative\n  (-assoc [coll key val]\n    (if (number? key)\n      (-assoc-n coll key val)\n      (throw (js/Error. \"Subvec's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (let [v-pos (+ start n)]\n      (build-subvec meta (assoc v v-pos val) start (max end (inc v-pos)) nil)))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce coll f))\n  (-reduce [coll f start]\n    (ci-reduce coll f start))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4573 4665]},
                               :full-name "cljs.core/Subvec"},
           "cljs.repl.browser/run-in-order" {:ns "cljs.repl.browser",
                                             :name "run-in-order",
                                             :signature ["[{:keys [expecting fns]}]"],
                                             :name-encode "run-in-order",
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/run-in-order",
                                             :source {:code "(defn run-in-order [{:keys [expecting fns]}]\n  (loop [order expecting fns fns]\n    (if-let [f (get fns order)]\n      (do\n        (f)\n        (recur (inc order) (dissoc fns order)))\n      {:expecting order :fns fns})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [136 142]},
                                             :full-name "cljs.repl.browser/run-in-order",
                                             :history [["+" "0.0-927"]]},
           "cljs.repl.browser/compile-client-js" {:ns "cljs.repl.browser",
                                                  :name "compile-client-js",
                                                  :signature ["[opts]"],
                                                  :name-encode "compile-client-js",
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/compile-client-js",
                                                  :source {:code "(defn compile-client-js [opts]\n  (cljsc/build\n    '[(ns clojure.browser.repl.client\n        (:require [goog.events :as event]\n                  [clojure.browser.repl :as repl]))\n      (defn start [url]\n        (event/listen js/window\n          \"load\"\n          (fn []\n            (repl/start-evaluator url))))]\n    {:optimizations (:optimizations opts)\n     :output-dir (:working-dir opts)}))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [212
                                                                   223]},
                                                  :full-name "cljs.repl.browser/compile-client-js",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/." {:ns "cljs.core",
                          :name ".",
                          :type "special form",
                          :source {:code "(defmethod parse '.\n  [_ env [_ target & [field & member+] :as form] _ _]\n  (disallowing-recur\n   (let [{:keys [dot-action target method field args]} (build-dot-form [target field member+])\n         enve        (assoc env :context :expr)\n         targetexpr  (analyze enve target)]\n     (case dot-action\n           ::access {:env env :op :dot :form form\n                     :target targetexpr\n                     :field field\n                     :children [targetexpr]\n                     :tag (-> form meta :tag)}\n           ::call   (let [argexprs (map #(analyze enve %) args)]\n                      {:env env :op :dot :form form\n                       :target targetexpr\n                       :method method\n                       :args argexprs\n                       :children (into [targetexpr] argexprs)\n                       :tag (-> form meta :tag)})))))",
                                   :title "Parser code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/clj/cljs/analyzer.clj",
                                   :lines [1461 1479]},
                          :extra-sources ({:code "(defmethod emit* :dot\n  [{:keys [target field method args env]}]\n  (emit-wrap env\n             (if field\n               (emits target \".\" (munge field #{}))\n               (emits target \".\" (munge method #{}) \"(\"\n                      (comma-sep args)\n                      \")\"))))",
                                           :title "Emitting code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/compiler.clj",
                                           :lines [877 884]}),
                          :full-name "cljs.core/.",
                          :full-name-encode "cljs.core/DOT",
                          :name-encode "DOT",
                          :history [["+" "0.0-927"]]},
           "syntax/js-namespace" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "js-namespace",
                                  :name-encode "js-namespace",
                                  :type "special namespace",
                                  :full-name-encode "syntax/js-namespace",
                                  :full-name "syntax/js-namespace",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/if-some" {:ns "cljs.core",
                                :name "if-some",
                                :signature ["[bindings then]"
                                            "[bindings then else & oldform]"],
                                :name-encode "if-some",
                                :history [["+" "0.0-2261"]],
                                :type "macro",
                                :full-name-encode "cljs.core/if-some",
                                :source {:code "(defmacro if-some\n  ([bindings then]\n   `(if-some ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if (nil? temp#)\n          ~else\n          (let [~form temp#]\n            ~then))))))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [1756 1774]},
                                :full-name "cljs.core/if-some",
                                :docstring "bindings => binding-form test\n\nIf test is not nil, evaluates then with binding-form bound to the\nvalue of test, if not, yields else"},
           "cljs.test/js-filename" {:ns "cljs.test",
                                    :name "js-filename",
                                    :signature ["[stack-element]"],
                                    :name-encode "js-filename",
                                    :type "function",
                                    :full-name-encode "cljs.test/js-filename",
                                    :source {:code "(defn js-filename [stack-element]\n  (first (.split (last (.split stack-element \"/out/\")) \":\")))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/test.cljs",
                                             :lines [311 312]},
                                    :full-name "cljs.test/js-filename",
                                    :history [["+" "0.0-2496"]]},
           "cljs.core/IReversible" {:ns "cljs.core",
                                    :name "IReversible",
                                    :name-encode "IReversible",
                                    :implementations #{"Subvec"
                                                       "PersistentTreeSet"
                                                       "PersistentVector"
                                                       "IndexedSeq"
                                                       "PersistentTreeMap"},
                                    :history [["+" "0.0-1211"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IReversible",
                                    :source {:code "(defprotocol IReversible\n  (^clj -rseq [coll]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [344 345]},
                                    :methods [{:name "-rseq",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IReversible"},
           "cljs.core/extend-protocol" {:ns "cljs.core",
                                        :name "extend-protocol",
                                        :signature ["[p & specs]"],
                                        :name-encode "extend-protocol",
                                        :history [["+" "0.0-927"]],
                                        :type "macro",
                                        :full-name-encode "cljs.core/extend-protocol",
                                        :source {:code "(defmacro extend-protocol \n  [p & specs]\n  (emit-extend-protocol p specs))",
                                                 :title "Source code",
                                                 :repo "clojure",
                                                 :tag "clojure-1.6.0",
                                                 :filename "src/clj/clojure/core_deftype.clj",
                                                 :lines [807 845]},
                                        :full-name "cljs.core/extend-protocol",
                                        :docstring "Useful when you want to provide several implementations of the same\nprotocol all at once. Takes a single protocol and the implementation\nof that protocol for one or more types. Expands into calls to\nextend-type:\n\n(extend-protocol Protocol\n  AType\n    (foo [x] ...)\n    (bar [x y] ...)\n  BType\n    (foo [x] ...)\n    (bar [x y] ...)\n  AClass\n    (foo [x] ...)\n    (bar [x y] ...)\n  nil\n    (foo [x] ...)\n    (bar [x y] ...))\n\nexpands into:\n\n(do\n (clojure.core/extend-type AType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type BType Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type AClass Protocol \n   (foo [x] ...) \n   (bar [x y] ...))\n (clojure.core/extend-type nil Protocol \n   (foo [x] ...) \n   (bar [x y] ...)))"},
           "cljs.reader/read" {:ns "cljs.reader",
                               :name "read",
                               :signature ["[reader eof-is-error sentinel is-recursive]"],
                               :name-encode "read",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.reader/read",
                               :source {:code "(defn read\n  [reader eof-is-error sentinel is-recursive]\n  (let [ch (read-char reader)]\n    (cond\n     (nil? ch) (if eof-is-error (reader-error reader \"EOF while reading\") sentinel)\n     (whitespace? ch) (recur reader eof-is-error sentinel is-recursive)\n     (comment-prefix? ch) (recur (read-comment reader ch) eof-is-error sentinel is-recursive)\n     :else (let [f (macros ch)\n                 res\n                 (cond\n                  f (f reader ch)\n                  (number-literal? reader ch) (read-number reader ch)\n                  :else (read-symbol reader ch))]\n     (if (identical? res reader)\n       (recur reader eof-is-error sentinel is-recursive)\n       res)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/reader.cljs",
                                        :lines [424 441]},
                               :full-name "cljs.reader/read",
                               :docstring "Reads the first object from a PushbackReader. Returns the object read.\nIf EOF, throws if eof-is-error is true. Otherwise returns sentinel."},
           "cljs.core/EmptyList" {:protocols #{"ISeqable"
                                               "IMeta"
                                               "IWithMeta"
                                               "IStack"
                                               "IEmptyableCollection"
                                               "ICounted"
                                               "IReduce"
                                               "ISequential"
                                               "ISeq"
                                               "ICollection"
                                               "IHash"
                                               "IPrintWithWriter"
                                               "INext"
                                               "IEquiv"
                                               "ICloneable"
                                               "IList"},
                                  :ns "cljs.core",
                                  :name "EmptyList",
                                  :signature ["[meta]"],
                                  :name-encode "EmptyList",
                                  :history [["+" "0.0-927"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/EmptyList",
                                  :source {:code "(deftype EmptyList [meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IList\n\n  ICloneable\n  (-clone [_] (EmptyList. meta))\n\n  IWithMeta\n  (-with-meta [coll meta] (EmptyList. meta))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] nil)\n  (-rest [coll] ())\n\n  INext\n  (-next [coll] nil)\n\n  IStack\n  (-peek [coll] nil)\n  (-pop [coll] (throw (js/Error. \"Can't pop empty list\")))\n\n  ICollection\n  (-conj [coll o] (List. meta o nil 1 nil))\n\n  IEmptyableCollection\n  (-empty [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] empty-ordered-hash)\n\n  ISeqable\n  (-seq [coll] nil)\n\n  ICounted\n  (-count [coll] 0)\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2331 2381]},
                                  :full-name "cljs.core/EmptyList"},
           "cljs.core/specify!" {:ns "cljs.core",
                                 :name "specify!",
                                 :signature ["[expr & impls]"],
                                 :name-encode "specifyBANG",
                                 :type "macro",
                                 :full-name-encode "cljs.core/specifyBANG",
                                 :source {:code "(defmacro specify! [expr & impls]\n  (let [x (with-meta (gensym \"x\") {:extend :instance})]\n    `(let [~x ~expr]\n       (extend-type ~x ~@impls)\n       ~x)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [631 635]},
                                 :full-name "cljs.core/specify!",
                                 :history [["+" "0.0-2156"]]},
           "warnings/undeclared-var" {:ns "warnings",
                                      :name "undeclared-var",
                                      :type "warning",
                                      :full-name "warnings/undeclared-var",
                                      :full-name-encode "warnings/undeclared-var",
                                      :name-encode "undeclared-var",
                                      :history [["+" "0.0-2014"]]},
           "cljs.core/cat" {:ns "cljs.core",
                            :name "cat",
                            :signature ["[rf]"],
                            :name-encode "cat",
                            :history [["+" "0.0-2341"]],
                            :type "function",
                            :full-name-encode "cljs.core/cat",
                            :source {:code "(defn cat\n  [rf]\n  (let [rf1 (preserving-reduced rf)]  \n    (fn\n      ([] (rf))\n      ([result] (rf result))\n      ([result input]\n         (reduce rf1 result input)))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [8554 8564]},
                            :full-name "cljs.core/cat",
                            :docstring "A transducer which concatenates the contents of each input, which must be a\ncollection, into the reduction."},
           "clojure.walk/postwalk" {:ns "clojure.walk",
                                    :name "postwalk",
                                    :signature ["[f form]"],
                                    :name-encode "postwalk",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.walk/postwalk",
                                    :source {:code "(defn postwalk\n  [f form]\n  (walk (partial postwalk f) f form))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/clojure/walk.cljs",
                                             :lines [50 56]},
                                    :full-name "clojure.walk/postwalk",
                                    :docstring "Performs a depth-first, post-order traversal of form.  Calls f on\neach sub-form, uses f's return value in place of the original.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :name-encode "PersistentArrayMapDOTHASHMAP-THRESHOLD",
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP-THRESHOLD",
                                                             :source {:code "(set! (.-HASHMAP-THRESHOLD PersistentArrayMap) 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r2760",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [5489]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-2301"]]},
           "repl-options/src" {:ns "repl-options",
                               :name "src",
                               :name-encode "src",
                               :type "option",
                               :full-name-encode "repl-options/src",
                               :full-name "repl-options/src",
                               :history [["+" "0.0-1503"]]},
           "clojure.zip/edit" {:ns "clojure.zip",
                               :name "edit",
                               :signature ["[loc f & args]"],
                               :name-encode "edit",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/edit",
                               :source {:code "(defn edit\n  [loc f & args]\n    (replace loc (apply f (node loc) args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [189 192]},
                               :full-name "clojure.zip/edit",
                               :docstring "Replaces the node at this loc with the value of (f node args)"},
           "cljs.core/unreduced" {:ns "cljs.core",
                                  :name "unreduced",
                                  :signature ["[x]"],
                                  :name-encode "unreduced",
                                  :history [["+" "0.0-2411"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/unreduced",
                                  :source {:code "(defn unreduced\n  [x]\n  (if (reduced? x) (deref x) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [909 912]},
                                  :full-name "cljs.core/unreduced",
                                  :docstring "If x is reduced?, returns (deref x), else returns x"},
           "cljs.core/re-seq" {:ns "cljs.core",
                               :name "re-seq",
                               :signature ["[re s]"],
                               :name-encode "re-seq",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/re-seq",
                               :source {:code "(defn re-seq\n  [re s]\n  (let [match-data (re-find re s)\n        match-idx (.search s re)\n        match-str (if (coll? match-data) (first match-data) match-data)\n        post-match (subs s (+ match-idx (count match-str)))]\n    (when match-data (lazy-seq (cons match-data (when (seq post-match) (re-seq re post-match)))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8087 8094]},
                               :full-name "cljs.core/re-seq",
                               :docstring "Returns a lazy sequence of successive matches of re in s."},
           "cljs.reader/read-list" {:ns "cljs.reader",
                                    :name "read-list",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-list",
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-list",
                                    :source {:code "(defn read-list\n  [rdr _]\n  (apply list (read-delimited-list \")\" rdr true)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [264 266]},
                                    :full-name "cljs.reader/read-list",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/IKVReduce" {:ns "cljs.core",
                                  :name "IKVReduce",
                                  :name-encode "IKVReduce",
                                  :implementations #{"PersistentHashMap"
                                                     "ObjMap"
                                                     "PersistentVector"
                                                     "PersistentTreeMap"
                                                     "PersistentArrayMap"},
                                  :history [["+" "0.0-1211"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IKVReduce",
                                  :source {:code "(defprotocol IKVReduce\n  (-kv-reduce [coll f init]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [323 324]},
                                  :methods [{:name "-kv-reduce",
                                             :signature ["[coll f init]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IKVReduce"},
           "cljs.core/Atom" {:protocols #{"IWatchable"
                                          "IMeta"
                                          "IDeref"
                                          "IHash"
                                          "IPrintWithWriter"
                                          "IAtom"
                                          "IEquiv"},
                             :ns "cljs.core",
                             :name "Atom",
                             :signature ["[state meta validator watches]"],
                             :name-encode "Atom",
                             :history [["+" "0.0-927"]],
                             :type "type",
                             :full-name-encode "cljs.core/Atom",
                             :source {:code "(deftype Atom [state meta validator watches]\n  Object\n  (equiv [this other]\n    (-equiv this other))\n\n  IAtom\n  \n  IEquiv\n  (-equiv [o other] (identical? o other))\n\n  IDeref\n  (-deref [_] state)\n\n  IMeta\n  (-meta [_] meta)\n\n  IWatchable\n  (-notify-watches [this oldval newval]\n    (doseq [[key f] watches]\n      (f key this oldval newval)))\n  (-add-watch [this key f]\n    (set! (.-watches this) (assoc watches key f))\n    this)\n  (-remove-watch [this key]\n    (set! (.-watches this) (dissoc watches key)))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3487 3514]},
                             :full-name "cljs.core/Atom"},
           "clojure.core.reducers/foldcat" {:ns "clojure.core.reducers",
                                            :name "foldcat",
                                            :signature ["[coll]"],
                                            :name-encode "foldcat",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/foldcat",
                                            :source {:code "(defn foldcat\n  [coll]\n  (fold cat append! coll))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [237 240]},
                                            :full-name "clojure.core.reducers/foldcat",
                                            :docstring "Equivalent to (fold cat append! coll)"},
           "cljs.core/specify" {:ns "cljs.core",
                                :name "specify",
                                :signature ["[expr & impls]"],
                                :name-encode "specify",
                                :type "macro",
                                :full-name-encode "cljs.core/specify",
                                :source {:code "(defmacro specify [expr & impls]\n  `(cljs.core/specify! (cljs.core/clone ~expr)\n     ~@impls))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [637 639]},
                                :full-name "cljs.core/specify",
                                :history [["+" "0.0-2138"]]},
           "cljs.repl.server/start" {:ns "cljs.repl.server",
                                     :name "start",
                                     :signature ["[opts]"],
                                     :name-encode "start",
                                     :history [["+" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.repl.server/start",
                                     :source {:code "(defn start\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/repl/server.clj",
                                              :lines [168 173]},
                                     :full-name "cljs.repl.server/start",
                                     :docstring "Start the server on the specified port."},
           "cljs.core/IMap" {:ns "cljs.core",
                             :name "IMap",
                             :name-encode "IMap",
                             :implementations #{"PersistentHashMap"
                                                "ObjMap"
                                                "PersistentTreeMap"
                                                "PersistentArrayMap"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/IMap",
                             :source {:code "(defprotocol IMap\n  #_(-assoc-ex [coll k v])\n  (^clj -dissoc [coll k]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [290 292]},
                             :methods [{:name "-dissoc",
                                        :signature ["[coll k]"],
                                        :docstring nil}],
                             :full-name "cljs.core/IMap"},
           "cljs.core/pr-sequential-writer" {:ns "cljs.core",
                                             :name "pr-sequential-writer",
                                             :signature ["[writer print-one begin sep end opts coll]"],
                                             :name-encode "pr-sequential-writer",
                                             :type "function",
                                             :full-name-encode "cljs.core/pr-sequential-writer",
                                             :source {:code "(defn pr-sequential-writer [writer print-one begin sep end opts coll]\n  (binding [*print-level* (when-not (nil? *print-level*) (dec *print-level*))]\n    (if (and (not (nil? *print-level*)) (neg? *print-level*))\n      (-write writer \"#\")\n      (do\n        (-write writer begin)\n        (when (seq coll)\n          (print-one (first coll) writer opts))\n        (loop [coll (next coll) n (dec (:print-length opts))]\n          (if (and coll (or (nil? n) (not (zero? n))))\n            (do\n              (-write writer sep)\n              (print-one (first coll) writer opts)\n              (recur (next coll) (dec n)))\n            (when (and (seq coll) (zero? n))\n              (-write writer sep)\n              (-write writer \"...\"))))\n        (-write writer end)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [8106
                                                              8123]},
                                             :full-name "cljs.core/pr-sequential-writer",
                                             :history [["+"
                                                        "0.0-1503"]]},
           "cljs.core/unchecked-multiply" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-multiply",
                                           :signature ["[]"
                                                       "[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :name-encode "unchecked-multiply",
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-multiply",
                                           :source {:code "(defn ^number unchecked-multiply\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-multiply x y))\n  ([x y & more] (reduce unchecked-multiply (cljs.core/unchecked-multiply x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [1988 1993]},
                                           :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-multiply\n  ([& xs] `(* ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/clj/cljs/core.clj",
                                                            :lines [393
                                                                    394]}],
                                           :full-name "cljs.core/unchecked-multiply",
                                           :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.reader/read-vector" {:ns "cljs.reader",
                                      :name "read-vector",
                                      :signature ["[rdr _]"],
                                      :name-encode "read-vector",
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-vector",
                                      :source {:code "(defn read-vector\n  [rdr _]\n  (read-delimited-list \"]\" rdr true))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [270 272]},
                                      :full-name "cljs.reader/read-vector",
                                      :history [["+" "0.0-927"]]},
           "clojure.set/join" {:ns "clojure.set",
                               :name "join",
                               :signature ["[xrel yrel]"
                                           "[xrel yrel km]"],
                               :name-encode "join",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.set/join",
                               :source {:code "(defn join\n  ([xrel yrel] ;natural join\n   (if (and (seq xrel) (seq yrel))\n     (let [ks (intersection (set (keys (first xrel))) (set (keys (first yrel))))\n           [r s] (if (<= (count xrel) (count yrel))\n                   [xrel yrel]\n                   [yrel xrel])\n           idx (index r ks)]\n       (reduce (fn [ret x]\n                 (let [found (idx (select-keys x ks))]\n                   (if found\n                     (reduce #(conj %1 (merge %2 x)) ret found)\n                     ret)))\n               #{} s))\n     #{}))\n  ([xrel yrel km] ;arbitrary key mapping\n   (let [[r s k] (if (<= (count xrel) (count yrel))\n                   [xrel yrel (map-invert km)]\n                   [yrel xrel km])\n         idx (index r (vals k))]\n     (reduce (fn [ret x]\n               (let [found (idx (rename-keys (select-keys x (keys k)) k))]\n                 (if found\n                   (reduce #(conj %1 (merge %2 x)) ret found)\n                   ret)))\n             #{} s))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/set.cljs",
                                        :lines [101 129]},
                               :full-name "clojure.set/join",
                               :docstring "When passed 2 rels, returns the rel corresponding to the natural\njoin. When passed an additional keymap, joins on the corresponding\nkeys."},
           "closure-warnings/fileoverview-jsdoc" {:ns "closure-warnings",
                                                  :name "fileoverview-jsdoc",
                                                  :type "warning",
                                                  :full-name "closure-warnings/fileoverview-jsdoc",
                                                  :full-name-encode "closure-warnings/fileoverview-jsdoc",
                                                  :name-encode "fileoverview-jsdoc",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/HashMap" {:protocols #{"IFn"
                                             "ISeqable"
                                             "IMap"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "ICounted"
                                             "ILookup"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IAssociative"
                                             "IPrintable"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "HashMap",
                                :signature ["[meta count hashobj __hash]"],
                                :name-encode "HashMap",
                                :history [["+" "0.0-927"]
                                          ["-" "0.0-1798"]],
                                :type "type",
                                :full-name-encode "cljs.core/HashMap",
                                :source {:code "(deftype HashMap [meta count hashobj ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (HashMap. meta count hashobj __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.HashMap/EMPTY meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-imap __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? count)\n      (let [hashes (.sort (js-keys hashobj))]\n        (mapcat #(map vec (partition 2 (aget hashobj %)))\n                hashes))))\n\n  ICounted\n  (-count [coll] count)\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        (aget bucket (inc i))\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [h (hash k)\n          bucket (aget hashobj h)]\n      (if bucket\n        (let [new-bucket (aclone bucket)\n              new-hashobj (goog.object/clone hashobj)]\n          (aset new-hashobj h new-bucket)\n          (if-let [i (scan-array 2 k new-bucket)]\n            (do                         ; found key, replace\n              (aset new-bucket (inc i) v)\n              (HashMap. meta count new-hashobj nil))\n            (do                         ; did not find key, append\n              (.push new-bucket k v)\n              (HashMap. meta (inc count) new-hashobj nil))))\n        (let [new-hashobj (goog.object/clone hashobj)] ; did not find bucket\n          (aset new-hashobj h (array k v))\n          (HashMap. meta (inc count) new-hashobj nil)))))\n  (-contains-key? [coll k]\n    (let [bucket (aget hashobj (hash k))\n          i (when bucket (scan-array 2 k bucket))]\n      (if i\n        true\n        false)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [h (hash k)\n          bucket (aget hashobj h)\n          i (when bucket (scan-array 2 k bucket))]\n      (if (not i)\n        coll ; key not found, return coll unchanged\n        (let [new-hashobj (goog.object/clone hashobj)]\n          (if (> 3 (alength bucket))\n            (js-delete new-hashobj h)\n            (let [new-bucket (aclone bucket)]\n              (.splice new-bucket i 2)\n              (aset new-hashobj h new-bucket)))\n          (HashMap. meta (dec count) new-hashobj nil)))))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r1586",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3737 3828]},
                                :full-name "cljs.core/HashMap",
                                :removed {:in "0.0-1798",
                                          :last-seen "0.0-1586"}},
           "cljs.repl.browser/handle-get" {:ns "cljs.repl.browser",
                                           :name "handle-get",
                                           :signature ["[opts conn request]"],
                                           :name-encode "handle-get",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1503"]],
                                           :type "function",
                                           :full-name-encode "cljs.repl.browser/handle-get",
                                           :source {:code "(defn handle-get [opts conn request]\n  (let [path (:path request)]\n    (cond\n     (.startsWith path \"/repl\") (send-repl-client-page opts conn request)\n     (:serve-static opts) (send-static opts conn request)\n     :else (send-404 conn (:path request)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1450",
                                                    :filename "src/clj/cljs/repl/browser.clj",
                                                    :lines [199 204]},
                                           :full-name "cljs.repl.browser/handle-get",
                                           :removed {:in "0.0-1503",
                                                     :last-seen "0.0-1450"}},
           "cljs.core/es6-iterable" {:ns "cljs.core",
                                     :name "es6-iterable",
                                     :signature ["[ty]"],
                                     :name-encode "es6-iterable",
                                     :type "macro",
                                     :full-name-encode "cljs.core/es6-iterable",
                                     :source {:code "(defmacro es6-iterable [ty]\n  `(aset (.-prototype ~ty) cljs.core/ITER_SYMBOL\n     (fn []\n       (this-as this#\n         (cljs.core/es6-iterator this#)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1670 1674]},
                                     :full-name "cljs.core/es6-iterable",
                                     :history [["+" "0.0-2411"]]},
           "cljs.reader/int-pattern" {:ns "cljs.reader",
                                      :name "int-pattern",
                                      :name-encode "int-pattern",
                                      :type "var",
                                      :full-name-encode "cljs.reader/int-pattern",
                                      :source {:code "(def int-pattern (re-pattern \"^([-+]?)(?:(0)|([1-9][0-9]*)|0[xX]([0-9A-Fa-f]+)|0([0-7]+)|([1-9][0-9]?)[rR]([0-9A-Za-z]+))(N)?$\"))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [98]},
                                      :full-name "cljs.reader/int-pattern",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/swap!" {:ns "cljs.core",
                              :name "swap!",
                              :signature ["[a f]"
                                          "[a f x]"
                                          "[a f x y]"
                                          "[a f x y & more]"],
                              :name-encode "swapBANG",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/swapBANG",
                              :source {:code "(defn swap!\n  ([a f]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a)))\n       (-swap! a f)))\n  ([a f x]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x))\n       (-swap! a f x)))\n  ([a f x y]\n     (if (instance? Atom a)\n       (reset! a (f (.-state a) x y))\n       (-swap! a f x y)))\n  ([a f x y & more]\n     (if (instance? Atom a)\n       (reset! a (apply f (.-state a) x y more))\n       (-swap! a f x y more))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3550 3570]},
                              :full-name "cljs.core/swap!",
                              :docstring "Atomically swaps the value of atom to be:\n(apply f current-value-of-atom args). Note that f may be called\nmultiple times, and thus should be free of side effects.  Returns\nthe value that was swapped in."},
           "cljs.core/finally" {:ns "cljs.core",
                                :name "finally",
                                :type "special form",
                                :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                         :title "Parser code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/analyzer.clj",
                                         :lines [599 658]},
                                :extra-sources ({:code "(defmethod emit* :try\n  [{:keys [env try catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :constant (:op finally)) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                                 :title "Emitting code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/compiler.clj",
                                                 :lines [648 663]}),
                                :full-name "cljs.core/finally",
                                :full-name-encode "cljs.core/finally",
                                :name-encode "finally",
                                :history [["+" "0.0-927"]]},
           "warnings/extending-base-js-type" {:ns "warnings",
                                              :name "extending-base-js-type",
                                              :type "warning",
                                              :full-name "warnings/extending-base-js-type",
                                              :full-name-encode "warnings/extending-base-js-type",
                                              :name-encode "extending-base-js-type",
                                              :history [["+"
                                                         "0.0-2024"]]},
           "cljs.core/dec" {:ns "cljs.core",
                            :name "dec",
                            :signature ["[x]"],
                            :name-encode "dec",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/dec",
                            :source {:code "(defn dec\n  [x] (- x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1917 1919]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric dec [x]\n  `(- ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [460 461]}],
                            :full-name "cljs.core/dec",
                            :docstring "Returns a number one less than num."},
           "cljs.core/EntriesIterator" {:ns "cljs.core",
                                        :name "EntriesIterator",
                                        :signature ["[s]"],
                                        :name-encode "EntriesIterator",
                                        :history [["+" "0.0-2268"]
                                                  ["-" "0.0-2371"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/EntriesIterator",
                                        :source {:code "(deftype EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2356",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4874 4881]},
                                        :full-name "cljs.core/EntriesIterator",
                                        :removed {:in "0.0-2371",
                                                  :last-seen "0.0-2356"}},
           "cljs.core/*clojurescript-version*" {:ns "cljs.core",
                                                :name "*clojurescript-version*",
                                                :name-encode "STARclojurescript-versionSTAR",
                                                :type "var",
                                                :full-name-encode "cljs.core/STARclojurescript-versionSTAR",
                                                :source {:code "(def *clojurescript-version*)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [16]},
                                                :full-name "cljs.core/*clojurescript-version*",
                                                :history [["+"
                                                           "0.0-2014"]]},
           "clojure.core.reducers/fold" {:ns "clojure.core.reducers",
                                         :name "fold",
                                         :signature ["[reducef coll]"
                                                     "[combinef reducef coll]"
                                                     "[n combinef reducef coll]"],
                                         :name-encode "fold",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/fold",
                                         :source {:code "(defn fold\n  ([reducef coll] (fold reducef reducef coll))\n  ([combinef reducef coll] (fold 512 combinef reducef coll))\n  ([n combinef reducef coll]\n     (coll-fold coll n combinef reducef)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [49 64]},
                                         :full-name "clojure.core.reducers/fold",
                                         :docstring "Reduces a collection using a (potentially parallel) reduce-combine\nstrategy. The collection is partitioned into groups of approximately\nn (default 512), each of which is reduced with reducef (with a seed\nvalue obtained by calling (combinef) with no arguments). The results\nof these reductions are then reduced with combinef (default\nreducef). combinef must be associative, and, when called with no\narguments, (combinef) must produce its identity element. These\noperations may be performed in parallel, but the results will\npreserve order.\n\nNote: Performing operations in parallel is currently not implemented."},
           "cljs.core/StringBufferWriter" {:protocols #{"IWriter"},
                                           :ns "cljs.core",
                                           :name "StringBufferWriter",
                                           :signature ["[sb]"],
                                           :name-encode "StringBufferWriter",
                                           :history [["+" "0.0-1503"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/StringBufferWriter",
                                           :source {:code "(deftype StringBufferWriter [sb]\n  IWriter\n  (-write [_ s] (.append sb s))\n  (-flush [_] nil))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [426 429]},
                                           :full-name "cljs.core/StringBufferWriter"},
           "clojure.browser.dom/remove-children" {:ns "clojure.browser.dom",
                                                  :name "remove-children",
                                                  :signature ["[id]"],
                                                  :name-encode "remove-children",
                                                  :history [["+"
                                                             "0.0-927"]],
                                                  :type "function",
                                                  :full-name-encode "clojure.browser.dom/remove-children",
                                                  :source {:code "(defn remove-children\n  [id]\n  (let [parent (gdom/getElement (name id))]\n    (do (gdom/removeChildren parent))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/cljs/clojure/browser/dom.cljs",
                                                           :lines [92
                                                                   96]},
                                                  :full-name "clojure.browser.dom/remove-children",
                                                  :docstring "Remove all children from the element with the passed id."},
           "cljs.core/BlackNode" {:protocols #{"IFn"
                                               "ISeqable"
                                               "IMeta"
                                               "IWithMeta"
                                               "IStack"
                                               "IEmptyableCollection"
                                               "ICounted"
                                               "IReduce"
                                               "ILookup"
                                               "ISequential"
                                               "ICollection"
                                               "IHash"
                                               "IPrintWithWriter"
                                               "IIndexed"
                                               "IAssociative"
                                               "IVector"
                                               "IEquiv"
                                               "IMapEntry"},
                                  :ns "cljs.core",
                                  :name "BlackNode",
                                  :signature ["[key val left right __hash]"],
                                  :name-encode "BlackNode",
                                  :history [["+" "0.0-1211"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/BlackNode",
                                  :source {:code "(deftype BlackNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (.balance-left ins node))\n\n  (add-right [node ins]\n    (.balance-right ins node))\n\n  (remove-left [node del]\n    (balance-left-del key val del right))\n\n  (remove-right [node del]\n    (balance-right-del key val left del))\n\n  (blacken [node] node)\n\n  (redden [node] (RedNode. key val left right nil))\n\n  (balance-left [node parent]\n    (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil))\n\n  (balance-right [node parent]\n    (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil))\n\n  (replace [node key val left right]\n    (BlackNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [6622 6722]},
                                  :full-name "cljs.core/BlackNode"},
           "cljs.core/some->" {:ns "cljs.core",
                               :name "some->",
                               :signature ["[expr & forms]"],
                               :name-encode "some-GT",
                               :history [["+" "0.0-1798"]],
                               :type "macro",
                               :full-name-encode "cljs.core/some-GT",
                               :source {:code "(defmacro some->\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (-> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [6923 6932]},
                               :full-name "cljs.core/some->",
                               :docstring "When expr is not nil, threads it into the first form (via ->),\nand when that result is not nil, through the next etc"},
           "cljs.core/get-validator" {:ns "cljs.core",
                                      :name "get-validator",
                                      :signature ["[iref]"],
                                      :name-encode "get-validator",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/get-validator",
                                      :source {:code "(defn get-validator\n  [iref]\n  (.-validator iref))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3591 3594]},
                                      :full-name "cljs.core/get-validator",
                                      :docstring "Gets the validator-fn for a var/ref/agent/atom."},
           "cljs.core/coll?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "coll?",
                              :signature ["[x]"],
                              :name-encode "collQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/collQMARK",
                              :source {:code "(defn ^boolean coll?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ICollection x)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1500 1505]},
                              :full-name "cljs.core/coll?",
                              :docstring "Returns true if x satisfies ICollection"},
           "cljs.core/unchecked-negate-int" {:ns "cljs.core",
                                             :name "unchecked-negate-int",
                                             :signature ["[x]"],
                                             :name-encode "unchecked-negate-int",
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-negate-int",
                                             :source {:code "(defn unchecked-negate-int [x]\n  (cljs.core/unchecked-negate-int x))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [2005
                                                              2006]},
                                             :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-negate-int\n  ([x] `(- ~x)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r2760",
                                                              :filename "src/clj/cljs/core.clj",
                                                              :lines [402
                                                                      403]}],
                                             :full-name "cljs.core/unchecked-negate-int"},
           "cljs.core/bit-or" {:ns "cljs.core",
                               :name "bit-or",
                               :signature ["[x y]" "[x y & more]"],
                               :name-encode "bit-or",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/bit-or",
                               :source {:code "(defn bit-or\n  ([x y] (cljs.core/bit-or x y))\n  ([x y & more]\n     (reduce bit-or (cljs.core/bit-or x y) more)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2095 2099]},
                               :extra-sources [{:code "(defmacro ^::ana/numeric bit-or\n  ([x y] (core/list 'js* \"(~{} | ~{})\" x y))\n  ([x y & more] `(bit-or (bit-or ~x ~y) ~@more)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [502 504]}],
                               :full-name "cljs.core/bit-or",
                               :docstring "Bitwise or"},
           "cljs.core/nfirst" {:ns "cljs.core",
                               :name "nfirst",
                               :signature ["[coll]"],
                               :name-encode "nfirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/nfirst",
                               :source {:code "(defn nfirst\n  [coll]\n  (next (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1153 1156]},
                               :full-name "cljs.core/nfirst",
                               :docstring "Same as (next (first x))"},
           "cljs.core/keep" {:ns "cljs.core",
                             :name "keep",
                             :signature ["[f]" "[f coll]"],
                             :name-encode "keep",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/keep",
                             :source {:code "(defn keep\n  ([f]\n   (fn [rf]\n     (fn\n       ([] (rf))\n       ([result] (rf result))\n       ([result input]\n          (let [v (f input)]\n            (if (nil? v)\n              result\n              (rf result v)))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n            (let [x (f (-nth c i))]\n              (when-not (nil? x)\n                (chunk-append b x))))\n          (chunk-cons (chunk b) (keep f (chunk-rest s))))\n        (let [x (f (first s))]\n          (if (nil? x)\n            (keep f (rest s))\n            (cons x (keep f (rest s))))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3453 3482]},
                             :full-name "cljs.core/keep",
                             :docstring "Returns a lazy sequence of the non-nil results of (f item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a transducer when no collection is provided."},
           "cljs.core/take" {:ns "cljs.core",
                             :name "take",
                             :signature ["[n]" "[n coll]"],
                             :name-encode "take",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/take",
                             :source {:code "(defn take\n  ([n]\n     (fn [rf]\n       (let [na (volatile! n)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [n @na\n                    nn (vswap! na dec)\n                    result (if (pos? n)\n                             (rf result input)\n                             result)]\n                (if (not (pos? nn))\n                  (ensure-reduced result)\n                  result)))))))\n  ([n coll]\n     (lazy-seq\n       (when (pos? n)\n         (when-let [s (seq coll)]\n           (cons (first s) (take (dec n) (rest s))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3779 3802]},
                             :full-name "cljs.core/take",
                             :docstring "Returns a lazy sequence of the first n items in coll, or all items if\nthere are fewer than n.  Returns a stateful transducer when\nno collection is provided."},
           "cljs.core/PersistentHashSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashSet.EMPTY",
                                                :name-encode "PersistentHashSetDOTEMPTY",
                                                :parent-type "PersistentHashSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashSet)\n  (PersistentHashSet. nil (.-EMPTY PersistentArrayMap) empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [7425
                                                                 7426]},
                                                :full-name "cljs.core/PersistentHashSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/cond" {:ns "cljs.core",
                             :name "cond",
                             :signature ["[& clauses]"],
                             :name-encode "cond",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/cond",
                             :source {:code "(defmacro cond\n  [& clauses]\n    (when clauses\n      (list 'if (first clauses)\n            (if (next clauses)\n                (second clauses)\n                (throw (IllegalArgumentException.\n                         \"cond requires an even number of forms\")))\n            (cons 'clojure.core/cond (next (next clauses))))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [558 571]},
                             :full-name "cljs.core/cond",
                             :docstring "Takes a set of test/expr pairs. It evaluates each test one at a\ntime.  If a test returns logical true, cond evaluates and returns\nthe value of the corresponding expr and doesn't evaluate any of the\nother tests or exprs. (cond) returns nil."},
           "cljs.core/bit-and" {:ns "cljs.core",
                                :name "bit-and",
                                :signature ["[x y]" "[x y & more]"],
                                :name-encode "bit-and",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-and",
                                :source {:code "(defn bit-and\n  ([x y] (cljs.core/bit-and x y))\n  ([x y & more]\n     (reduce bit-and (cljs.core/bit-and x y) more)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2089 2093]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-and\n  ([x y] (core/list 'js* \"(~{} & ~{})\" x y))\n  ([x y & more] `(bit-and (bit-and ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [493 495]}],
                                :full-name "cljs.core/bit-and",
                                :docstring "Bitwise and"},
           "cljs.core/MetaFn" {:protocols #{"IFn"
                                            "IMeta"
                                            "IWithMeta"
                                            "Fn"},
                               :ns "cljs.core",
                               :name "MetaFn",
                               :signature ["[afn meta]"],
                               :name-encode "MetaFn",
                               :history [["+" "0.0-2234"]],
                               :type "type",
                               :full-name-encode "cljs.core/MetaFn",
                               :source {:code "(deftype MetaFn [afn meta]\n  IMeta\n  (-meta [_] meta)\n  IWithMeta\n  (-with-meta [_ new-meta]\n    (MetaFn. afn new-meta))\n  Fn\n  IFn\n  (-invoke [_]\n    (afn))\n  (-invoke [_ a]\n    (afn a))\n  (-invoke [_ a b]\n    (afn a b))\n  (-invoke [_ a b c]\n    (afn a b c))\n  (-invoke [_ a b c d]\n    (afn a b c d))\n  (-invoke [_ a b c d e]\n    (afn a b c d e))\n  (-invoke [_ a b c d e f]\n    (afn a b c d e f))\n  (-invoke [_ a b c d e f g]\n    (afn a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    (afn a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    (afn a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    (afn a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    (afn a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    (afn a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    (afn a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    (afn a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    (afn a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    (afn a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    (afn a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    (afn a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    (afn a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    (afn a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply afn a b c d e f g h i j k l m n o p q r s t rest)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1396 1447]},
                               :full-name "cljs.core/MetaFn"},
           "cljs.core/ObjMap.fromObject" {:ns "cljs.core",
                                          :name "ObjMap.fromObject",
                                          :signature ["[ks obj]"],
                                          :name-encode "ObjMapDOTfromObject",
                                          :history [["+" "0.0-927"]],
                                          :parent-type "ObjMap",
                                          :type "function",
                                          :full-name-encode "cljs.core/ObjMapDOTfromObject",
                                          :source {:code "(set! (.-fromObject ObjMap) (fn [ks obj] (ObjMap. nil ks obj 0 nil)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5154]},
                                          :full-name "cljs.core/ObjMap.fromObject"},
           "cljs.core/PersistentArrayMap" {:protocols #{"IFn"
                                                        "ISeqable"
                                                        "IMap"
                                                        "IMeta"
                                                        "IWithMeta"
                                                        "IKVReduce"
                                                        "IEditableCollection"
                                                        "IEmptyableCollection"
                                                        "ICounted"
                                                        "IReduce"
                                                        "ILookup"
                                                        "ICollection"
                                                        "IHash"
                                                        "IPrintWithWriter"
                                                        "IIterable"
                                                        "IAssociative"
                                                        "IEquiv"
                                                        "ICloneable"},
                                           :ns "cljs.core",
                                           :name "PersistentArrayMap",
                                           :signature ["[meta cnt arr __hash]"],
                                           :name-encode "PersistentArrayMap",
                                           :history [["+" "0.0-1211"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentArrayMap",
                                           :source {:code "(deftype PersistentArrayMap [meta cnt arr ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k]\n    (-lookup coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentArrayMap. meta cnt arr __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentArrayMap. meta cnt arr __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (-with-meta (.-EMPTY PersistentArrayMap) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (if (implements? IMap other)\n      (let [alen (alength arr)\n            ^not-native other other]\n        (if (== cnt (-count other))\n          (loop [i 0]\n            (if (< i alen)\n              (let [v (-lookup other (aget arr i) lookup-sentinel)]\n                (if-not (identical? v lookup-sentinel)\n                  (if (= (aget arr (inc i)) v)\n                    (recur (+ i 2))\n                    false)\n                  false))\n              true))\n          false))\n      (equiv-map coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  IIterable\n  (-iterator [this]\n    (PersistentArrayMapIterator. arr 0 (* cnt 2)))\n  \n  ISeqable\n  (-seq [coll]\n    (persistent-array-map-seq arr 0 nil))\n\n  ICounted\n  (-count [coll] cnt)\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [idx (array-map-index-of coll k)]\n      (if (== idx -1)\n        not-found\n        (aget arr (inc idx)))))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [idx (array-map-index-of coll k)]\n      (cond\n        (== idx -1)\n        (if (< cnt (.-HASHMAP-THRESHOLD PersistentArrayMap))\n          (let [arr (array-map-extend-kv coll k v)]\n            (PersistentArrayMap. meta (inc cnt) arr nil))\n          (-> (into (.-EMPTY PersistentHashMap) coll)\n            (-assoc k v)\n            (-with-meta meta)))\n\n        (identical? v (aget arr (inc idx)))\n        coll\n\n        :else\n        (let [arr (doto (aclone arr)\n                    (aset (inc idx) v))]\n          (PersistentArrayMap. meta cnt arr nil)))))\n\n  (-contains-key? [coll k]\n    (not (== (array-map-index-of coll k) -1)))\n\n  IMap\n  (-dissoc [coll k]\n    (let [idx (array-map-index-of coll k)]\n      (if (>= idx 0)\n        (let [len     (alength arr)\n              new-len (- len 2)]\n          (if (zero? new-len)\n            (-empty coll)\n            (let [new-arr (make-array new-len)]\n              (loop [s 0 d 0]\n                (cond\n                  (>= s len) (PersistentArrayMap. meta (dec cnt) new-arr nil)\n                  (= k (aget arr s)) (recur (+ s 2) d)\n                  :else (do (aset new-arr d (aget arr s))\n                            (aset new-arr (inc d) (aget arr (inc s)))\n                            (recur (+ s 2) (+ d 2))))))))\n        coll)))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength arr)]\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [init (f init (aget arr i) (aget arr (inc i)))]\n            (if (reduced? init)\n              @init\n              (recur (+ i 2) init)))\n          init))))\n  \n  IReduce\n  (-reduce [coll f]\n    (seq-reduce f coll))\n  (-reduce [coll f start]\n    (seq-reduce f start coll))\n  \n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientArrayMap. (js-obj) (alength arr) (aclone arr))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [5329 5485]},
                                           :full-name "cljs.core/PersistentArrayMap"},
           "clojure.browser.event/unique-event-id" {:ns "clojure.browser.event",
                                                    :name "unique-event-id",
                                                    :signature ["[event-type]"],
                                                    :name-encode "unique-event-id",
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unique-event-id",
                                                    :source {:code "(defn unique-event-id [event-type])",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [94]},
                                                    :full-name "clojure.browser.event/unique-event-id",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/vswap!" {:ns "cljs.core",
                               :name "vswap!",
                               :signature ["[vol f & args]"],
                               :name-encode "vswapBANG",
                               :history [["+" "0.0-2496"]],
                               :type "macro",
                               :full-name-encode "cljs.core/vswapBANG",
                               :source {:code "(defmacro vswap!\n  [vol f & args]\n  `(-vreset! ~vol (~f (-deref ~vol) ~@args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1687 1692]},
                               :full-name "cljs.core/vswap!",
                               :docstring "Non-atomically swaps the value of the volatile as if:\n(apply f current-value-of-vol args). Returns the value that\nwas swapped in."},
           "closure-warnings/debugger-statement-present" {:ns "closure-warnings",
                                                          :name "debugger-statement-present",
                                                          :type "warning",
                                                          :full-name "closure-warnings/debugger-statement-present",
                                                          :full-name-encode "closure-warnings/debugger-statement-present",
                                                          :name-encode "debugger-statement-present",
                                                          :history [["+"
                                                                     "0.0-2120"]]},
           "cljs.core/ObjMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                 :name "ObjMap.HASHMAP_THRESHOLD",
                                                 :name-encode "ObjMapDOTHASHMAP_THRESHOLD",
                                                 :parent-type "ObjMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/ObjMapDOTHASHMAP_THRESHOLD",
                                                 :source {:code "(set! (.-HASHMAP_THRESHOLD ObjMap) 8)",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5152]},
                                                 :full-name "cljs.core/ObjMap.HASHMAP_THRESHOLD",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "clojure.set/project" {:ns "clojure.set",
                                  :name "project",
                                  :signature ["[xrel ks]"],
                                  :name-encode "project",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/project",
                                  :source {:code "(defn project\n  [xrel ks]\n    (set (map #(select-keys % ks) xrel)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [67 70]},
                                  :full-name "clojure.set/project",
                                  :docstring "Returns a rel of the elements of xrel with only the keys in ks"},
           "cljs.core/int" {:ns "cljs.core",
                            :name "int",
                            :signature ["[x]"],
                            :name-encode "int",
                            :history [["+" "0.0-1211"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/int",
                            :source {:code "(defn int\n  [x]\n  (bit-or x 0))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2032 2035]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric int [x]\n  `(bit-or ~x 0))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [506 507]}],
                            :full-name "cljs.core/int",
                            :docstring "Coerce to int by stripping decimal places."},
           "clojure.reflect/macroexpand" {:ns "clojure.reflect",
                                          :name "macroexpand",
                                          :signature ["[form]"],
                                          :name-encode "macroexpand",
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "clojure.reflect/macroexpand",
                                          :source {:code "(defn macroexpand\n  [form]\n  (query-reflection (str \"macroform=\" (js/encodeURIComponent (str form))) println))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/clojure/reflect.cljs",
                                                   :lines [32 36]},
                                          :full-name "clojure.reflect/macroexpand",
                                          :docstring "Queries the reflection api with a quoted macro form, then calls the\ncallback function with the macroexpanded form, as a string."},
           "syntax/quote" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "quote",
                           :name-encode "quote",
                           :type "syntax",
                           :full-name-encode "syntax/quote",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [591 610]}),
                           :full-name "syntax/quote",
                           :history [["+" "0.0-1853"]]},
           "clojure.string/trim-newline" {:ns "clojure.string",
                                          :name "trim-newline",
                                          :signature ["[s]"],
                                          :name-encode "trim-newline",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.string/trim-newline",
                                          :source {:code "(defn trim-newline\n  [s]\n  (loop [index (.-length s)]\n    (if (zero? index)\n      \"\"\n      (let [ch (get s (dec index))]\n        (if (or (= ch \\newline) (= ch \\return))\n          (recur (dec index))\n          (.substring s 0 index))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/clojure/string.cljs",
                                                   :lines [162 172]},
                                          :full-name "clojure.string/trim-newline",
                                          :docstring "Removes all trailing newline \\n or return \\r characters from\nstring.  Similar to Perl's chomp."},
           "cljs.repl.reflect/parse-param" {:ns "cljs.repl.reflect",
                                            :name "parse-param",
                                            :signature ["[path]"],
                                            :name-encode "parse-param",
                                            :history [["+" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/parse-param",
                                            :source {:code "(defn parse-param\n  [path]\n  (-> (str/split path #\"\\?\")\n      (last)\n      (str/split #\"=\")))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/reflect.clj",
                                                     :lines [44 50]},
                                            :full-name "cljs.repl.reflect/parse-param",
                                            :docstring "Parses the query parameter of a path of the form \"/reflect?var=foo\"\ninto the vector [\"var\" \"foo\"]."},
           "cljs.core/pr-seq-writer" {:ns "cljs.core",
                                      :name "pr-seq-writer",
                                      :signature ["[objs writer opts]"],
                                      :name-encode "pr-seq-writer",
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-seq-writer",
                                      :source {:code "(defn pr-seq-writer [objs writer opts]\n  (pr-writer (first objs) writer opts)\n  (doseq [obj (next objs)]\n    (-write writer \" \")\n    (pr-writer obj writer opts)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [8226 8230]},
                                      :full-name "cljs.core/pr-seq-writer",
                                      :history [["+" "0.0-1503"]]},
           "cljs.repl/analyze-source" {:ns "cljs.repl",
                                       :name "analyze-source",
                                       :signature ["[src-dir]"],
                                       :name-encode "analyze-source",
                                       :history [["+" "0.0-1503"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl/analyze-source",
                                       :source {:code "(defn analyze-source\n  [src-dir]\n  (if-let [src-dir (and (not (empty? src-dir))\n                     (File. src-dir))]\n    (doseq [file (comp/cljs-files-in src-dir)]\n      (ana/analyze-file (str \"file://\" (.getAbsolutePath file))))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [338 345]},
                                       :full-name "cljs.repl/analyze-source",
                                       :docstring "Given a source directory, analyzes all .cljs files. Used to populate\n(:cljs.analyzer/namespaces compiler-env) so as to support code reflection."},
           "cljs.repl.browser/stop-server" {:ns "cljs.repl.browser",
                                            :name "stop-server",
                                            :signature ["[]"],
                                            :name-encode "stop-server",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/stop-server",
                                            :source {:code "(defn stop-server\n  []\n  (.close (:socket @server-state)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [272 274]},
                                            :full-name "cljs.repl.browser/stop-server",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.core/chunk-cons" {:ns "cljs.core",
                                   :name "chunk-cons",
                                   :signature ["[chunk rest]"],
                                   :name-encode "chunk-cons",
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-cons",
                                   :source {:code "(defn chunk-cons [chunk rest]\n  (if (zero? (-count chunk))\n    rest\n    (ChunkedCons. chunk rest nil nil)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2732 2735]},
                                   :full-name "cljs.core/chunk-cons",
                                   :history [["+" "0.0-1424"]]},
           "syntax/namespace" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "namespace",
                               :name-encode "namespace",
                               :type "special character",
                               :full-name-encode "syntax/namespace",
                               :full-name "syntax/namespace",
                               :history [["+" "0.0-927"]]},
           "clojure.zip/insert-left" {:ns "clojure.zip",
                                      :name "insert-left",
                                      :signature ["[loc item]"],
                                      :name-encode "insert-left",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.zip/insert-left",
                                      :source {:code "(defn insert-left\n  [loc item]\n    (let [[node {l :l :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :l (conj l item) :changed? true)] (meta loc)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/clojure/zip.cljs",
                                               :lines [165 172]},
                                      :full-name "clojure.zip/insert-left",
                                      :docstring "Inserts the item as the left sibling of the node at this loc,\nwithout moving"},
           "cljs.core/*print-level*" {:ns "cljs.core",
                                      :name "*print-level*",
                                      :name-encode "STARprint-levelSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.core/STARprint-levelSTAR",
                                      :source {:code "(def ^:dynamic *print-level* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [38]},
                                      :full-name "cljs.core/*print-level*",
                                      :history [["+" "0.0-2120"]]},
           "cljs.core/true?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "true?",
                              :signature ["[x]"],
                              :name-encode "trueQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/trueQMARK",
                              :source {:code "(defn ^boolean true?\n  [x] (cljs.core/true? x))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1585 1587]},
                              :extra-sources [{:code "(defmacro true? [x]\n  (bool-expr (core/list 'js* \"~{} === true\" x)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [296 297]}],
                              :full-name "cljs.core/true?",
                              :docstring "Returns true if x is the value true, false otherwise."},
           "cljs.core/unchecked-substract-int" {:return-type number,
                                                :ns "cljs.core",
                                                :name "unchecked-substract-int",
                                                :signature ["[x]"
                                                            "[x y]"
                                                            "[x y & more]"],
                                                :name-encode "unchecked-substract-int",
                                                :history [["+"
                                                           "0.0-1798"]
                                                          ["-"
                                                           "0.0-2277"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/unchecked-substract-int",
                                                :source {:code "(defn ^number unchecked-substract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-substract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2268",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1812
                                                                 1817]},
                                                :full-name "cljs.core/unchecked-substract-int",
                                                :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                                :removed {:in "0.0-2277",
                                                          :last-seen "0.0-2268"}},
           "clojure.browser.net/xpc-connection" {:ns "clojure.browser.net",
                                                 :name "xpc-connection",
                                                 :signature ["[]"
                                                             "[config]"],
                                                 :name-encode "xpc-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xpc-connection",
                                                 :source {:code "(defn xpc-connection\n  ([]\n     (when-let [config (.getParameterValue\n                        (Uri. (.-href (.-location js/window)))\n                        \"xpc\")]\n       (CrossPageChannel. (gjson/parse config))))\n  ([config]\n     (CrossPageChannel.\n      (reduce (fn [sum [k v]]\n                (if-let [field (get xpc-config-fields k)]\n                  (doto sum (aset field v))\n                  sum))\n              (js-obj)\n              config))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [116
                                                                  138]},
                                                 :full-name "clojure.browser.net/xpc-connection",
                                                 :docstring "When passed with a config hash-map, returns a parent\nCrossPageChannel object. Keys in the config hash map are downcased\nversions of the goog.net.xpc.CfgFields enum keys,\ne.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\nhash.\n\nWhen passed with no args, creates a child CrossPageChannel object,\nand the config is automatically taken from the URL param 'xpc', as\nper the CrossPageChannel API."},
           "cljs.core/ES6EntriesIterator" {:ns "cljs.core",
                                           :name "ES6EntriesIterator",
                                           :signature ["[s]"],
                                           :name-encode "ES6EntriesIterator",
                                           :type "type",
                                           :full-name-encode "cljs.core/ES6EntriesIterator",
                                           :source {:code "(deftype ES6EntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [[k v] (first s)]\n        (set! s (next s))\n        #js {:value #js [k v] :done false})\n      #js {:value nil :done true})))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [5157 5164]},
                                           :full-name "cljs.core/ES6EntriesIterator",
                                           :history [["+" "0.0-2371"]]},
           "cljs.core/not" {:return-type boolean,
                            :ns "cljs.core",
                            :name "not",
                            :signature ["[x]"],
                            :name-encode "not",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/not",
                            :source {:code "(defn ^boolean not\n  [x] (if x false true))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [96 98]},
                            :full-name "cljs.core/not",
                            :docstring "Returns true if x is logical false, false otherwise."},
           "cljs.core/js-obj" {:ns "cljs.core",
                               :name "js-obj",
                               :signature ["[]" "[& keyvals]"],
                               :name-encode "js-obj",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/js-obj",
                               :source {:code "(defn js-obj\n  ([]\n     (cljs.core/js-obj))\n  ([& keyvals]\n     (apply gobject/create keyvals)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1547 1551]},
                               :extra-sources [{:code "(defmacro js-obj [& rest]\n  (let [sym-or-str? (fn [x] (core/or (core/symbol? x) (core/string? x)))\n        filter-on-keys (fn [f coll]\n                         (->> coll\n                              (filter (fn [[k _]] (f k)))\n                              (into {})))\n        kvs (into {} (map vec (partition 2 rest)))\n        sym-pairs (filter-on-keys core/symbol? kvs)\n        expr->local (zipmap\n                     (filter (complement sym-or-str?) (keys kvs))\n                     (repeatedly gensym))\n        obj (gensym \"obj\")]\n    `(let [~@(apply concat (clojure.set/map-invert expr->local))\n           ~obj ~(js-obj* (filter-on-keys core/string? kvs))]\n       ~@(map (fn [[k v]] `(aset ~obj ~k ~v)) sym-pairs)\n       ~@(map (fn [[k v]] `(aset ~obj ~v ~(core/get kvs k))) expr->local)\n       ~obj)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [1473 1489]}],
                               :full-name "cljs.core/js-obj"},
           "cljs.core/complement" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "complement",
                                   :signature ["[f]"],
                                   :name-encode "complement",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/complement",
                                   :source {:code "(defn ^boolean complement\n  [f]\n  (fn\n    ([] (not (f)))\n    ([x] (not (f x)))\n    ([x y] (not (f x y)))\n    ([x y & zs] (not (apply f x y zs)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3329 3337]},
                                   :full-name "cljs.core/complement",
                                   :docstring "Takes a fn f and returns a fn that takes the same arguments as f,\nhas the same effects, if any, and returns the opposite truth value."},
           "cljs.core/spread" {:ns "cljs.core",
                               :name "spread",
                               :signature ["[arglist]"],
                               :name-encode "spread",
                               :type "function",
                               :full-name-encode "cljs.core/spread",
                               :source {:code "(defn spread\n  [arglist]\n  (cond\n   (nil? arglist) nil\n   (nil? (next arglist)) (seq (first arglist))\n   :else (cons (first arglist)\n               (spread (next arglist)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2865 2871]},
                               :full-name "cljs.core/spread",
                               :history [["+" "0.0-927"]]},
           "cljs.core/unchecked-double" {:return-type number,
                                         :ns "cljs.core",
                                         :name "unchecked-double",
                                         :signature ["[x]"],
                                         :name-encode "unchecked-double",
                                         :history [["+" "0.0-1798"]],
                                         :type "function/macro",
                                         :full-name-encode "cljs.core/unchecked-double",
                                         :source {:code "(defn ^number unchecked-double [x] x)",
                                                  :title "Function code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [1953]},
                                         :extra-sources [{:code "(defmacro unchecked-double [x] x)",
                                                          :title "Macro code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/clj/cljs/core.clj",
                                                          :lines [370]}],
                                         :full-name "cljs.core/unchecked-double"},
           "closure-warnings/undefined-names" {:ns "closure-warnings",
                                               :name "undefined-names",
                                               :type "warning",
                                               :full-name "closure-warnings/undefined-names",
                                               :full-name-encode "closure-warnings/undefined-names",
                                               :name-encode "undefined-names",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/keyword" {:ns "cljs.core",
                                :name "keyword",
                                :signature ["[name]" "[ns name]"],
                                :name-encode "keyword",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/keyword",
                                :source {:code "(defn keyword\n  ([name] (cond\n            (keyword? name) name\n            (symbol? name) (Keyword.\n                             (cljs.core/namespace name)\n                             (cljs.core/name name) (.-str name) nil)\n            (string? name) (let [parts (.split name \"/\")]\n                             (if (== (alength parts) 2)\n                               (Keyword. (aget parts 0) (aget parts 1) name nil)\n                               (Keyword. nil (aget parts 0) name nil)))))\n  ([ns name] (Keyword. ns name (str (when ns (str ns \"/\")) name) nil)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2536 2548]},
                                :full-name "cljs.core/keyword",
                                :docstring "Returns a Keyword with the given namespace and name.  Do not use :\nin the keyword strings, it will be added automatically."},
           "syntax/keyword-qualify" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "keyword-qualify",
                                     :name-encode "keyword-qualify",
                                     :type "syntax",
                                     :full-name-encode "syntax/keyword-qualify",
                                     :extra-sources ({:code "(defn- read-keyword\n  [reader initch]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                                      :title "Reader code",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-0.8.10",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [315 333]}
                                                     {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                      :title "Reader table",
                                                      :repo "tools.reader",
                                                      :tag "tools.reader-0.8.10",
                                                      :filename "src/main/clojure/clojure/tools/reader.clj",
                                                      :lines [591 610]}),
                                     :full-name "syntax/keyword-qualify",
                                     :history [["+" "0.0-1853"]]},
           "cljs.core/sort" {:ns "cljs.core",
                             :name "sort",
                             :signature ["[coll]" "[comp coll]"],
                             :name-encode "sort",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/sort",
                             :source {:code "(defn sort\n  ([coll]\n   (sort compare coll))\n  ([comp coll]\n   (if (seq coll)\n     (let [a (to-array coll)]\n       ;; matching Clojure's stable sort, though docs don't promise it\n       (garray/stableSort a (fn->comparator comp))\n       (seq a))\n     ())))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1707 1719]},
                             :full-name "cljs.core/sort",
                             :docstring "Returns a sorted sequence of the items in coll. Comp can be\nboolean-valued comparison function, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "clojure.string/trim" {:ns "clojure.string",
                                  :name "trim",
                                  :signature ["[s]"],
                                  :name-encode "trim",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.string/trim",
                                  :source {:code "(defn trim\n    [s]\n    (gstring/trim s))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/string.cljs",
                                           :lines [147 150]},
                                  :full-name "clojure.string/trim",
                                  :docstring "Removes whitespace from both ends of string."},
           "cljs.core/meta" {:ns "cljs.core",
                             :name "meta",
                             :signature ["[o]"],
                             :name-encode "meta",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/meta",
                             :source {:code "(defn meta\n  [o]\n  (when (and (not (nil? o))\n             (satisfies? IMeta o))\n    (-meta o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1458 1463]},
                             :full-name "cljs.core/meta",
                             :docstring "Returns the metadata of obj, returns nil if there is no metadata."},
           "clojure.core.reducers/monoid" {:ns "clojure.core.reducers",
                                           :name "monoid",
                                           :signature ["[op ctor]"],
                                           :name-encode "monoid",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/monoid",
                                           :source {:code "(defn monoid\n  [op ctor]\n  (fn m\n    ([] (ctor))\n    ([a b] (op a b))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [242 249]},
                                           :full-name "clojure.core.reducers/monoid",
                                           :docstring "Builds a combining fn out of the supplied operator and identity\nconstructor. op must be associative and ctor called with no args\nmust return an identity value for it."},
           "cljs.core/time" {:ns "cljs.core",
                             :name "time",
                             :signature ["[expr]"],
                             :name-encode "time",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/time",
                             :source {:code "(defmacro time\n  [expr]\n  `(let [start# (.getTime (js/Date.))\n         ret# ~expr]\n     (prn (core/str \"Elapsed time: \" (- (.getTime (js/Date.)) start#) \" msecs\"))\n     ret#))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1595 1601]},
                             :full-name "cljs.core/time",
                             :docstring "Evaluates expr and prints the time it took. Returns the value of expr."},
           "cljs.core/boolean" {:return-type boolean,
                                :ns "cljs.core",
                                :name "boolean",
                                :signature ["[x]"],
                                :name-encode "boolean",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/boolean",
                                :source {:code "(defn ^boolean boolean [x]\n  (if x true false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1604 1605]},
                                :full-name "cljs.core/boolean"},
           "cljs.reader/read-token" {:ns "cljs.reader",
                                     :name "read-token",
                                     :signature ["[rdr initch]"],
                                     :name-encode "read-token",
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-token",
                                     :source {:code "(defn read-token\n  [rdr initch]\n  (loop [sb (StringBuffer. initch)\n         ch (read-char rdr)]\n    (if (or (nil? ch)\n            (whitespace? ch)\n            (macro-terminating? ch))\n      (do (unread rdr ch) (.toString sb))\n      (recur (do (.append sb ch) sb) (read-char rdr)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [79 87]},
                                     :full-name "cljs.reader/read-token",
                                     :history [["+" "0.0-927"]]},
           "compiler-options/asset-path" {:ns "compiler-options",
                                          :name "asset-path",
                                          :name-encode "asset-path",
                                          :type "option",
                                          :full-name-encode "compiler-options/asset-path",
                                          :full-name "compiler-options/asset-path",
                                          :history [["+" "0.0-2727"]]},
           "cljs.core/update-in" {:ns "cljs.core",
                                  :name "update-in",
                                  :signature ["[m [k & ks] f]"
                                              "[m [k & ks] f a]"
                                              "[m [k & ks] f a b]"
                                              "[m [k & ks] f a b c]"
                                              "[m [k & ks] f a b c & args]"],
                                  :name-encode "update-in",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/update-in",
                                  :source {:code "(defn update-in\n  ([m [k & ks] f]\n   (if ks\n     (assoc m k (update-in (get m k) ks f))\n     (assoc m k (f (get m k)))))\n  ([m [k & ks] f a]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a))\n     (assoc m k (f (get m k) a))))\n  ([m [k & ks] f a b]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b))\n     (assoc m k (f (get m k) a b))))\n  ([m [k & ks] f a b c]\n   (if ks\n     (assoc m k (update-in (get m k) ks f a b c))\n     (assoc m k (f (get m k) a b c))))\n  ([m [k & ks] f a b c & args]\n   (if ks\n     (assoc m k (apply update-in (get m k) ks f a b c args))\n     (assoc m k (apply f (get m k) a b c args)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [4108 4133]},
                                  :full-name "cljs.core/update-in",
                                  :docstring "'Updates' a value in a nested associative structure, where ks is a\nsequence of keys and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nnested structure.  If any levels do not exist, hash-maps will be\ncreated."},
           "cljs.core/map-indexed" {:ns "cljs.core",
                                    :name "map-indexed",
                                    :signature ["[f]" "[f coll]"],
                                    :name-encode "map-indexed",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/map-indexed",
                                    :source {:code "(defn map-indexed\n  ([f]\n    (fn [rf]\n      (let [i (volatile! -1)]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (rf result (f (vswap! i inc) input)))))))\n  ([f coll]\n    (letfn [(mapi [idx coll]\n              (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (chunk-append b (f (+ idx i) (-nth c i))))\n                      (chunk-cons (chunk b) (mapi (+ idx size) (chunk-rest s))))\n                    (cons (f idx (first s)) (mapi (inc idx) (rest s)))))))]\n      (mapi 0 coll))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3426 3451]},
                                    :full-name "cljs.core/map-indexed",
                                    :docstring "Returns a lazy sequence consisting of the result of applying f to 0\nand the first item of coll, followed by applying f to 1 and the second\nitem in coll, etc, until coll is exhausted. Thus function f should\naccept 2 arguments, index and item."},
           "cljs.core/IVolatile" {:ns "cljs.core",
                                  :name "IVolatile",
                                  :name-encode "IVolatile",
                                  :implementations #{"Volatile"},
                                  :history [["+" "0.0-2496"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IVolatile",
                                  :source {:code "(defprotocol IVolatile\n  (-vreset! [o new-value]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [418 419]},
                                  :methods [{:name "-vreset!",
                                             :signature ["[o new-value]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IVolatile"},
           "cljs.core/printf" {:ns "cljs.core",
                               :name "printf",
                               :signature ["[fmt & args]"],
                               :name-encode "printf",
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/printf",
                               :source {:code "(defn printf\n  [fmt & args]\n  (print (apply format fmt args)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [6758 6761]},
                               :full-name "cljs.core/printf",
                               :docstring "Prints formatted output, as per format",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "clojure.core.reducers/map" {:ns "clojure.core.reducers",
                                        :name "map",
                                        :signature ["[f]" "[f coll]"],
                                        :name-encode "map",
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/map",
                                        :source {:code "(defcurried map\n  \"Applies f to every value in the reduction of coll. Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (f1 ret (f k v)))))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [96 104]},
                                        :full-name "clojure.core.reducers/map",
                                        :docstring "Applies f to every value in the reduction of coll. Foldable."},
           "cljs.core/IStack" {:ns "cljs.core",
                               :name "IStack",
                               :name-encode "IStack",
                               :implementations #{"Subvec"
                                                  "PersistentQueue"
                                                  "RedNode"
                                                  "EmptyList"
                                                  "BlackNode"
                                                  "PersistentVector"
                                                  "List"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IStack",
                               :source {:code "(defprotocol IStack\n  (-peek [coll])\n  (^clj -pop [coll]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [301 303]},
                               :methods [{:name "-peek",
                                          :signature ["[coll]"],
                                          :docstring nil}
                                         {:name "-pop",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IStack"},
           "cljs.reader/parse-and-validate-timestamp" {:ns "cljs.reader",
                                                       :name "parse-and-validate-timestamp",
                                                       :signature ["[s]"],
                                                       :name-encode "parse-and-validate-timestamp",
                                                       :type "function",
                                                       :full-name-encode "cljs.reader/parse-and-validate-timestamp",
                                                       :source {:code "(defn parse-and-validate-timestamp [s]\n  (let [[_ years months days hours minutes seconds fraction offset-sign offset-hours offset-minutes :as v] \n        (re-matches timestamp-regex s)]\n    (if-not v\n      (reader-error nil (str \"Unrecognized date/time syntax: \" s))\n      (let [years (parse-int years)\n            months (or (parse-int months) 1)\n            days (or (parse-int days) 1)\n            hours (or (parse-int hours) 0)\n            minutes (or (parse-int minutes) 0)\n            seconds (or (parse-int seconds) 0)\n            fraction (or (parse-int (zero-fill-right-and-truncate fraction 3)) 0)\n            offset-sign (if (= offset-sign \"-\") -1 1)\n            offset-hours (or (parse-int offset-hours) 0)\n            offset-minutes (or (parse-int offset-minutes) 0)\n            offset (* offset-sign (+ (* offset-hours 60) offset-minutes))]\n        [years\n         (check 1 months 12 \"timestamp month field must be in range 1..12\")\n         (check 1 days (days-in-month months (leap-year? years)) \"timestamp day field must be in range 1..last day in month\")\n         (check 0 hours 23 \"timestamp hour field must be in range 0..23\")\n         (check 0 minutes 59 \"timestamp minute field must be in range 0..59\")\n         (check 0 seconds (if (= minutes 59) 60 59) \"timestamp second field must be in range 0..60\")\n         (check 0 fraction 999 \"timestamp millisecond field must be in range 0..999\")\n         offset]))))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r2760",
                                                                :filename "src/cljs/cljs/reader.cljs",
                                                                :lines [492
                                                                        515]},
                                                       :full-name "cljs.reader/parse-and-validate-timestamp",
                                                       :history [["+"
                                                                  "0.0-1853"]]},
           "closure-warnings/missing-properties" {:ns "closure-warnings",
                                                  :name "missing-properties",
                                                  :type "warning",
                                                  :full-name "closure-warnings/missing-properties",
                                                  :full-name-encode "closure-warnings/missing-properties",
                                                  :name-encode "missing-properties",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/ISorted" {:ns "cljs.core",
                                :name "ISorted",
                                :name-encode "ISorted",
                                :implementations #{"PersistentTreeSet"
                                                   "PersistentTreeMap"},
                                :history [["+" "0.0-1211"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/ISorted",
                                :source {:code "(defprotocol ISorted\n  (^clj -sorted-seq [coll ascending?])\n  (^clj -sorted-seq-from [coll k ascending?])\n  (-entry-key [coll entry])\n  (-comparator [coll]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [347 351]},
                                :methods [{:name "-sorted-seq",
                                           :signature ["[coll ascending?]"],
                                           :docstring nil}
                                          {:name "-sorted-seq-from",
                                           :signature ["[coll k ascending?]"],
                                           :docstring nil}
                                          {:name "-entry-key",
                                           :signature ["[coll entry]"],
                                           :docstring nil}
                                          {:name "-comparator",
                                           :signature ["[coll]"],
                                           :docstring nil}],
                                :full-name "cljs.core/ISorted"},
           "cljs.test/file-and-line" {:ns "cljs.test",
                                      :name "file-and-line",
                                      :signature ["[exception depth]"],
                                      :name-encode "file-and-line",
                                      :type "function",
                                      :full-name-encode "cljs.test/file-and-line",
                                      :source {:code "(defn file-and-line [exception depth]\n  (let [stack (.-stack exception)]\n      (if (and stack (string? stack))\n        ;; TODO: flesh out\n        (let [stacktrace\n              (vec (map string/trim\n                     (string/split stack #\"\\n\")))\n              stack-element (nth stacktrace depth)\n              fname (js-filename stack-element)\n              [line column] (js-line-and-column stack-element)\n              [fname line column] (mapped-line-and-column fname line column)]\n          {:file fname :line line :column column})\n        {:file (.-fileName exception)\n         :line (.-lineNumber exception)}))  )",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/test.cljs",
                                               :lines [332 345]},
                                      :full-name "cljs.test/file-and-line",
                                      :history [["+" "0.0-2496"]]},
           "cljs.core/IIndexed" {:ns "cljs.core",
                                 :name "IIndexed",
                                 :name-encode "IIndexed",
                                 :implementations #{"Subvec"
                                                    "RedNode"
                                                    "ArrayChunk"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "Range"
                                                    "TransientVector"
                                                    "IndexedSeq"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IIndexed",
                                 :source {:code "(defprotocol IIndexed\n  (-nth [coll n] [coll n not-found]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [270 271]},
                                 :methods [{:name "-nth",
                                            :signature ["[coll n]"
                                                        "[coll n not-found]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IIndexed"},
           "clojure.browser.repl/repl-print" {:ns "clojure.browser.repl",
                                              :name "repl-print",
                                              :signature ["[data]"],
                                              :name-encode "repl-print",
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/repl-print",
                                              :source {:code "(defn repl-print [data]\n  (if-let [conn @xpc-connection]\n    (net/transmit conn :print (pr-str data))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [23 25]},
                                              :full-name "clojure.browser.repl/repl-print",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.browser.net/xpc-config-fields" {:ns "clojure.browser.net",
                                                    :name "xpc-config-fields",
                                                    :name-encode "xpc-config-fields",
                                                    :type "var",
                                                    :full-name-encode "clojure.browser.net/xpc-config-fields",
                                                    :source {:code "(def xpc-config-fields\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (js->clj CfgFields))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/clojure/browser/net.cljs",
                                                             :lines [73
                                                                     79]},
                                                    :full-name "clojure.browser.net/xpc-config-fields",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/ISwap" {:ns "cljs.core",
                              :name "ISwap",
                              :name-encode "ISwap",
                              :type "protocol",
                              :full-name-encode "cljs.core/ISwap",
                              :source {:code "(defprotocol ISwap\n  (-swap! [o f] [o f a] [o f a b] [o f a b xs]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [415 416]},
                              :methods [{:name "-swap!",
                                         :signature ["[o f]"
                                                     "[o f a]"
                                                     "[o f a b]"
                                                     "[o f a b xs]"],
                                         :docstring nil}],
                              :full-name "cljs.core/ISwap",
                              :history [["+" "0.0-2173"]]},
           "cljs.core/nnext" {:ns "cljs.core",
                              :name "nnext",
                              :signature ["[coll]"],
                              :name-encode "nnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/nnext",
                              :source {:code "(defn nnext\n  [coll]\n  (next (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1163 1166]},
                              :full-name "cljs.core/nnext",
                              :docstring "Same as (next (next x))"},
           "cljs.core/*print-meta*" {:ns "cljs.core",
                                     :name "*print-meta*",
                                     :name-encode "STARprint-metaSTAR",
                                     :type "dynamic var",
                                     :full-name-encode "cljs.core/STARprint-metaSTAR",
                                     :source {:code "(def ^:dynamic *print-meta* false)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [35]},
                                     :full-name "cljs.core/*print-meta*",
                                     :history [["+" "0.0-927"]]},
           "cljs.reader/read-dispatch" {:ns "cljs.reader",
                                        :name "read-dispatch",
                                        :signature ["[rdr _]"],
                                        :name-encode "read-dispatch",
                                        :type "function",
                                        :full-name-encode "cljs.reader/read-dispatch",
                                        :source {:code "(defn read-dispatch\n  [rdr _]\n  (let [ch (read-char rdr)\n        dm (dispatch-macros ch)]\n    (if dm\n      (dm rdr _)\n      (if-let [obj (maybe-read-tagged-type rdr ch)]\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [250 258]},
                                        :full-name "cljs.reader/read-dispatch",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/distinct" {:ns "cljs.core",
                                 :name "distinct",
                                 :signature ["[]" "[coll]"],
                                 :name-encode "distinct",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/distinct",
                                 :source {:code "(defn distinct\n  ([]\n    (fn [rf]\n      (let [seen (volatile! #{})]\n        (fn\n          ([] (rf))\n          ([result] (rf result))\n          ([result input]\n            (if (contains? @seen input)\n              result\n              (do (vswap! seen conj input)\n                  (rf result input))))))))\n  ([coll]\n    (let [step (fn step [xs seen]\n                 (lazy-seq\n                   ((fn [[f :as xs] seen]\n                      (when-let [s (seq xs)]\n                        (if (contains? seen f)\n                          (recur (rest s) seen)\n                          (cons f (step (rest s) (conj seen f))))))\n                     xs seen)))]\n      (step coll #{}))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7632 7654]},
                                 :full-name "cljs.core/distinct",
                                 :docstring "Returns a lazy sequence of the elements of coll with duplicates removed"},
           "cljs.reader/wrapping-reader" {:ns "cljs.reader",
                                          :name "wrapping-reader",
                                          :signature ["[sym]"],
                                          :name-encode "wrapping-reader",
                                          :type "function",
                                          :full-name-encode "cljs.reader/wrapping-reader",
                                          :source {:code "(defn wrapping-reader\n  [sym]\n  (fn [rdr _]\n    (list sym (read rdr true nil true))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [361 364]},
                                          :full-name "cljs.reader/wrapping-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/LazyTransformer" {:protocols #{"ISeqable"
                                                     "IWithMeta"
                                                     "IEmptyableCollection"
                                                     "ISequential"
                                                     "ISeq"
                                                     "ICollection"
                                                     "IHash"
                                                     "IPrintWithWriter"
                                                     "INext"
                                                     "IEquiv"},
                                        :ns "cljs.core",
                                        :name "LazyTransformer",
                                        :signature ["[stepper first rest meta]"],
                                        :name-encode "LazyTransformer",
                                        :history [["+" "0.0-2301"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/LazyTransformer",
                                        :source {:code "(deftype LazyTransformer [^:mutable stepper ^:mutable first ^:mutable rest meta]\n  IWithMeta\n  (-with-meta [this new-meta]\n    (LazyTransformer. stepper first rest new-meta))\n\n  ICollection\n  (-conj [this o]\n    (cons o (-seq this)))\n\n  IEmptyableCollection\n  (-empty [this]\n    ())\n\n  ISequential\n  IEquiv\n  (-equiv [this other]\n    (let [s (-seq this)]\n      (if-not (nil? s)\n        (equiv-sequential this other)\n        (and (sequential? other)\n             (nil? (seq other))))))\n\n  IHash\n  (-hash [this]\n    (hash-ordered-coll this))\n\n  ISeqable\n  (-seq [this]\n    (when-not (nil? stepper)\n      (.step stepper this))\n    (if (nil? rest)\n      nil\n      this))\n\n  ISeq\n  (-first [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      first))\n\n  (-rest [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      ()\n      rest))\n\n  INext\n  (-next [this]\n    (when-not (nil? stepper)\n      (-seq this))\n    (if (nil? rest)\n      nil\n      (-seq rest))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [3201 3256]},
                                        :full-name "cljs.core/LazyTransformer"},
           "cljs.core/double-array" {:ns "cljs.core",
                                     :name "double-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :name-encode "double-array",
                                     :type "function",
                                     :full-name-encode "cljs.core/double-array",
                                     :source {:code "(defn double-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (double-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2817 2835]},
                                     :full-name "cljs.core/double-array",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/prn" {:ns "cljs.core",
                            :name "prn",
                            :signature ["[& objs]"],
                            :name-encode "prn",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/prn",
                            :source {:code "(defn prn\n  [& objs]\n  (pr-with-opts objs (pr-opts))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [8309 8314]},
                            :full-name "cljs.core/prn",
                            :docstring "Same as pr followed by (newline)."},
           "cljs.core/chunked-seq" {:ns "cljs.core",
                                    :name "chunked-seq",
                                    :signature ["[vec i off]"
                                                "[vec node i off]"
                                                "[vec node i off meta]"],
                                    :name-encode "chunked-seq",
                                    :type "function",
                                    :full-name-encode "cljs.core/chunked-seq",
                                    :source {:code "(defn chunked-seq\n  ([vec i off] (ChunkedSeq. vec (array-for vec i) i off nil nil))\n  ([vec node i off] (ChunkedSeq. vec node i off nil nil))\n  ([vec node i off meta]\n     (ChunkedSeq. vec node i off meta nil)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [4565 4569]},
                                    :full-name "cljs.core/chunked-seq",
                                    :history [["+" "0.0-1424"]]},
           "clojure.zip/leftmost" {:ns "clojure.zip",
                                   :name "leftmost",
                                   :signature ["[loc]"],
                                   :name-encode "leftmost",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/leftmost",
                                   :source {:code "(defn leftmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path (seq l))\n        (with-meta [(first l) (assoc path :l [] :r (concat (rest l) [node] r))] (meta loc))\n        loc)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [157 163]},
                                   :full-name "clojure.zip/leftmost",
                                   :docstring "Returns the loc of the leftmost sibling of the node at this loc, or self"},
           "cljs.core/nthrest" {:ns "cljs.core",
                                :name "nthrest",
                                :signature ["[coll n]"],
                                :name-encode "nthrest",
                                :history [["+" "0.0-2411"]],
                                :type "function",
                                :full-name-encode "cljs.core/nthrest",
                                :source {:code "(defn nthrest\n  [coll n]\n    (loop [n n xs coll]\n      (if (and (pos? n) (seq xs))\n        (recur (dec n) (rest xs))\n        xs)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1312 1318]},
                                :full-name "cljs.core/nthrest",
                                :docstring "Returns the nth rest of coll, coll when n is 0."},
           "cljs.core/js-in" {:ns "cljs.core",
                              :name "js-in",
                              :signature ["[key obj]"],
                              :name-encode "js-in",
                              :type "macro",
                              :full-name-encode "cljs.core/js-in",
                              :source {:code "(defmacro js-in [key obj]\n  (core/list 'js* \"~{} in ~{}\" key obj))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [290 291]},
                              :full-name "cljs.core/js-in",
                              :history [["+" "0.0-2411"]]},
           "cljs.core/>=" {:return-type boolean,
                           :ns "cljs.core",
                           :name ">=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "GTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/GTEQ",
                           :source {:code "(defn ^boolean >=\n  ([x] true)\n  ([x y] (cljs.core/>= x y))\n  ([x y & more]\n   (if (cljs.core/>= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/>= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1905 1915]},
                           :extra-sources [{:code "(defmacro ^::ana/numeric >=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} >= ~{})\" x y)))\n  ([x y & more] `(and (>= ~x ~y) (>= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [450 453]}],
                           :full-name "cljs.core/>=",
                           :docstring "Returns non-nil if nums are in monotonically non-increasing order,\notherwise false."},
           "cljs.repl.browser/read-request" {:ns "cljs.repl.browser",
                                             :name "read-request",
                                             :signature ["[rdr]"],
                                             :name-encode "read-request",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-request",
                                             :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond (.startsWith line \"POST\") (read-post line rdr)\n          (.startsWith line \"GET\") (read-get line rdr)\n          :else {:method :unknown :content line})))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [161 165]},
                                             :full-name "cljs.repl.browser/read-request",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.reader/macros" {:ns "cljs.reader",
                                 :name "macros",
                                 :signature ["[c]"],
                                 :name-encode "macros",
                                 :type "function",
                                 :full-name-encode "cljs.reader/macros",
                                 :source {:code "(defn macros [c]\n  (cond\n   (identical? c \\\") read-string*\n   (identical? c \\:) read-keyword\n   (identical? c \\;) read-comment\n   (identical? c \\') (wrapping-reader 'quote)\n   (identical? c \\@) (wrapping-reader 'deref)\n   (identical? c \\^) read-meta\n   (identical? c \\`) not-implemented\n   (identical? c \\~) not-implemented\n   (identical? c \\() read-list\n   (identical? c \\)) read-unmatched-delimiter\n   (identical? c \\[) read-vector\n   (identical? c \\]) read-unmatched-delimiter\n   (identical? c \\{) read-map\n   (identical? c \\}) read-unmatched-delimiter\n   (identical? c \\\\) read-char\n   (identical? c \\#) read-dispatch\n   :else nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/reader.cljs",
                                          :lines [394 412]},
                                 :full-name "cljs.reader/macros",
                                 :history [["+" "0.0-927"]]},
           "cljs.build.api/target-file-for-cljs-ns" {:return-type File,
                                                     :ns "cljs.build.api",
                                                     :name "target-file-for-cljs-ns",
                                                     :signature ["[ns-sym]"
                                                                 "[ns-sym output-dir]"],
                                                     :name-encode "target-file-for-cljs-ns",
                                                     :history [["+"
                                                                "0.0-2496"]],
                                                     :type "function",
                                                     :full-name-encode "cljs.build.api/target-file-for-cljs-ns",
                                                     :source {:code "(defn ^File target-file-for-cljs-ns\n  ([ns-sym] (target-file-for-cljs-ns ns-sym nil))\n  ([ns-sym output-dir]\n    (util/to-target-file\n      (util/output-directory {:output-dir output-dir})\n      {:ns ns-sym})))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2760",
                                                              :filename "src/clj/cljs/build/api.clj",
                                                              :lines [24
                                                                      35]},
                                                     :full-name "cljs.build.api/target-file-for-cljs-ns",
                                                     :docstring "Given an output directory and a clojurescript namespace return the\ncompilation target file for that namespace.\n\nFor example:\n(target-file-from-cljs-ns \"resources/out\" 'example.core) ->\n<File: \"resources/out/example/core.js\">"},
           "cljs.core/doseq" {:ns "cljs.core",
                              :name "doseq",
                              :signature ["[seq-exprs & body]"],
                              :name-encode "doseq",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/doseq",
                              :source {:code "(defmacro doseq\n  [seq-exprs & body]\n  (assert-args doseq\n     (vector? seq-exprs) \"a vector for its binding\"\n     (even? (count seq-exprs)) \"an even number of forms in binding vector\")\n  (let [err (fn [& msg] (throw (ex-info (apply core/str msg) {})))\n        step (fn step [recform exprs]\n               (if-not exprs\n                 [true `(do ~@body)]\n                 (let [k (first exprs)\n                       v (second exprs)\n\n                       seqsym (gensym \"seq__\")\n                       recform (if (core/keyword? k) recform `(recur (next ~seqsym) nil 0 0))\n                       steppair (step recform (nnext exprs))\n                       needrec (steppair 0)\n                       subform (steppair 1)]\n                   (core/cond\n                     (= k :let) [needrec `(let ~v ~subform)]\n                     (= k :while) [false `(when ~v\n                                            ~subform\n                                            ~@(when needrec [recform]))]\n                     (= k :when) [false `(if ~v\n                                           (do\n                                             ~subform\n                                             ~@(when needrec [recform]))\n                                           ~recform)]\n                     (core/keyword? k) (err \"Invalid 'doseq' keyword\" k)\n                     :else (let [chunksym (with-meta (gensym \"chunk__\")\n                                            {:tag 'not-native})\n                                 countsym (gensym \"count__\")\n                                 isym     (gensym \"i__\")\n                                 recform-chunk  `(recur ~seqsym ~chunksym ~countsym (unchecked-inc ~isym))\n                                 steppair-chunk (step recform-chunk (nnext exprs))\n                                 subform-chunk  (steppair-chunk 1)]\n                             [true `(loop [~seqsym   (seq ~v)\n                                           ~chunksym nil\n                                           ~countsym 0\n                                           ~isym     0]\n                                      (if (coercive-boolean (< ~isym ~countsym))\n                                        (let [~k (-nth ~chunksym ~isym)]\n                                          ~subform-chunk\n                                          ~@(when needrec [recform-chunk]))\n                                        (when-let [~seqsym (seq ~seqsym)]\n                                          (if (chunked-seq? ~seqsym)\n                                            (let [c# (chunk-first ~seqsym)]\n                                              (recur (chunk-rest ~seqsym) c#\n                                                     (count c#) 0))\n                                            (let [~k (first ~seqsym)]\n                                              ~subform\n                                              ~@(when needrec [recform]))))))])))))]\n    (nth (step nil (seq seq-exprs)) 1)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [1341 1395]},
                              :full-name "cljs.core/doseq",
                              :docstring "Repeatedly executes body (presumably for side-effects) with\nbindings and filtering as provided by \"for\".  Does not retain\nthe head of the sequence. Returns nil."},
           "cljs.core/*" {:return-type number,
                          :ns "cljs.core",
                          :name "*",
                          :signature ["[]"
                                      "[x]"
                                      "[x y]"
                                      "[x y & more]"],
                          :name-encode "STAR",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/STAR",
                          :source {:code "(defn ^number *\n  ([] 1)\n  ([x] x)\n  ([x y] (cljs.core/* x y))\n  ([x y & more] (reduce * (cljs.core/* x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1853 1858]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric *\n  ([] 1)\n  ([x] x)\n  ([x y] (core/list 'js* \"(~{} * ~{})\" x y))\n  ([x y & more] `(* (* ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [419 423]}],
                          :full-name "cljs.core/*",
                          :docstring "Returns the product of nums. (*) returns 1."},
           "cljs.core/into" {:ns "cljs.core",
                             :name "into",
                             :signature ["[to from]"
                                         "[to xform from]"],
                             :name-encode "into",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/into",
                             :source {:code "(defn into\n  ([to from]\n     (if-not (nil? to)\n       (if (implements? IEditableCollection to)\n         (with-meta (persistent! (reduce -conj! (transient to) from)) (meta to))\n         (reduce -conj to from))\n       (reduce conj () from)))\n  ([to xform from]\n     (if (implements? IEditableCollection to)\n       (with-meta (persistent! (transduce xform conj! (transient to) from)) (meta to))\n       (transduce xform conj to from))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [4017 4029]},
                             :full-name "cljs.core/into",
                             :docstring "Returns a new coll consisting of to-coll with all of the items of\nfrom-coll conjoined. A transducer may be supplied."},
           "cljs.repl.server/state" {:ns "cljs.repl.server",
                                     :name "state",
                                     :name-encode "state",
                                     :type "var",
                                     :full-name-encode "cljs.repl.server/state",
                                     :source {:code "(defonce state\n  (atom\n    {:socket nil\n     :connection nil\n     :promised-conn nil}))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/repl/server.clj",
                                              :lines [8 12]},
                                     :full-name "cljs.repl.server/state",
                                     :history [["+" "0.0-1503"]]},
           "cljs.core/defmethod" {:ns "cljs.core",
                                  :name "defmethod",
                                  :signature ["[multifn dispatch-val & fn-tail]"],
                                  :name-encode "defmethod",
                                  :history [["+" "0.0-927"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/defmethod",
                                  :source {:code "(defmacro defmethod\n  [multifn dispatch-val & fn-tail]\n  `(-add-method ~(with-meta multifn {:tag 'cljs.core/MultiFn}) ~dispatch-val (fn ~@fn-tail)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [1590 1593]},
                                  :full-name "cljs.core/defmethod",
                                  :docstring "Creates and installs a new method of multimethod associated with dispatch-value. "},
           "cljs.core/rest" {:return-type seq,
                             :ns "cljs.core",
                             :name "rest",
                             :signature ["[coll]"],
                             :name-encode "rest",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/rest",
                             :source {:code "(defn ^seq rest\n  [coll]\n  (if-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-rest ^not-native coll)\n      (let [s (seq coll)]\n        (if s\n          (-rest ^not-native s)\n          ())))\n    ()))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [736 747]},
                             :full-name "cljs.core/rest",
                             :docstring "Returns a possibly empty seq of the items after the first. Calls seq on its\nargument."},
           "cljs.reader/unicode-4-pattern" {:ns "cljs.reader",
                                            :name "unicode-4-pattern",
                                            :name-encode "unicode-4-pattern",
                                            :type "var",
                                            :full-name-encode "cljs.reader/unicode-4-pattern",
                                            :source {:code "(def unicode-4-pattern (re-pattern \"^[0-9A-Fa-f]{4}$\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [182]},
                                            :full-name "cljs.reader/unicode-4-pattern",
                                            :history [["+" "0.0-1424"]]},
           "closure-warnings/ambiguous-function-decl" {:ns "closure-warnings",
                                                       :name "ambiguous-function-decl",
                                                       :type "warning",
                                                       :full-name "closure-warnings/ambiguous-function-decl",
                                                       :full-name-encode "closure-warnings/ambiguous-function-decl",
                                                       :name-encode "ambiguous-function-decl",
                                                       :history [["+"
                                                                  "0.0-2120"]]},
           "cljs.core/dotimes" {:ns "cljs.core",
                                :name "dotimes",
                                :signature ["[bindings & body]"],
                                :name-encode "dotimes",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/dotimes",
                                :source {:code "(defmacro dotimes\n  [bindings & body]\n  (let [i (first bindings)\n        n (second bindings)]\n    `(let [n# ~n]\n       (loop [~i 0]\n         (when (< ~i n#)\n           ~@body\n           (recur (inc ~i)))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1522 1534]},
                                :full-name "cljs.core/dotimes",
                                :docstring "bindings => name n\n\nRepeatedly executes body (presumably for side-effects) with name\nbound to integers from 0 through n-1."},
           "cljs.core/dedupe" {:ns "cljs.core",
                               :name "dedupe",
                               :signature ["[]" "[coll]"],
                               :name-encode "dedupe",
                               :history [["+" "0.0-2301"]],
                               :type "function",
                               :full-name-encode "cljs.core/dedupe",
                               :source {:code "(defn dedupe\n  ([]\n   (fn [rf]\n     (let [pa (volatile! ::none)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [prior @pa]\n              (vreset! pa input)\n              (if (= prior input)\n                result\n                (rf result input))))))))\n  ([coll] (sequence (dedupe) coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8566 8581]},
                               :full-name "cljs.core/dedupe",
                               :docstring "Returns a lazy sequence removing consecutive duplicates in coll.\nReturns a transducer when no collection is provided."},
           "clojure.zip/lefts" {:ns "clojure.zip",
                                :name "lefts",
                                :signature ["[loc]"],
                                :name-encode "lefts",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.zip/lefts",
                                :source {:code "(defn lefts\n  [loc]\n    (seq (:l (loc 1))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/zip.cljs",
                                         :lines [87 90]},
                                :full-name "clojure.zip/lefts",
                                :docstring "Returns a seq of the left siblings of this loc"},
           "clojure.browser.dom/ensure-element" {:ns "clojure.browser.dom",
                                                 :name "ensure-element",
                                                 :signature ["[e]"],
                                                 :name-encode "ensure-element",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/ensure-element",
                                                 :source {:code "(defn ensure-element\n  [e]\n  (cond (keyword? e) (get-element e)\n        (string? e) (html->dom e)\n        :else e))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [107
                                                                  112]},
                                                 :full-name "clojure.browser.dom/ensure-element",
                                                 :docstring "Coerce the argument to a dom element if possible."},
           "cljs.core/defmacro" {:ns "cljs.core",
                                 :name "defmacro",
                                 :signature ["[name doc-string? attr-map? [params*] body]"
                                             "[name doc-string? attr-map? ([params*] body) + attr-map?]"],
                                 :name-encode "defmacro",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmacro",
                                 :source {:code "(def\n\n ^{:doc \"Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.\"\n   :arglists '([name doc-string? attr-map? [params*] body]\n                 [name doc-string? attr-map? ([params*] body)+ attr-map?])\n   :added \"1.0\"}\n defmacro (fn [&form &env \n                name & args]\n             (let [prefix (loop [p (list name) args args]\n                            (let [f (first args)]\n                              (if (string? f)\n                                (recur (cons f p) (next args))\n                                (if (map? f)\n                                  (recur (cons f p) (next args))\n                                  p))))\n                   fdecl (loop [fd args]\n                           (if (string? (first fd))\n                             (recur (next fd))\n                             (if (map? (first fd))\n                               (recur (next fd))\n                               fd)))\n                   fdecl (if (vector? (first fdecl))\n                           (list fdecl)\n                           fdecl)\n                   add-implicit-args (fn [fd]\n                             (let [args (first fd)]\n                               (cons (vec (cons '&form (cons '&env args))) (next fd))))\n                   add-args (fn [acc ds]\n                              (if (nil? ds)\n                                acc\n                                (let [d (first ds)]\n                                  (if (map? d)\n                                    (conj acc d)\n                                    (recur (conj acc (add-implicit-args d)) (next ds))))))\n                   fdecl (seq (add-args [] fdecl))\n                   decl (loop [p prefix d fdecl]\n                          (if p\n                            (recur (next p) (cons (first p) d))\n                            d))]\n               (list 'do\n                     (cons `defn decl)\n                     (list '. (list 'var name) '(setMacro))\n                     (list 'var name)))))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.6.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [422 466]},
                                 :full-name "cljs.core/defmacro",
                                 :docstring "Like defn, but the resulting function name is declared as a\nmacro and will be used as a macro by the compiler when it is\ncalled."},
           "cljs.core/remove" {:ns "cljs.core",
                               :name "remove",
                               :signature ["[pred]" "[pred coll]"],
                               :name-encode "remove",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/remove",
                               :source {:code "(defn remove\n  ([pred] (filter (complement pred)))\n  ([pred coll]\n     (filter (complement pred) coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3986 3992]},
                               :full-name "cljs.core/remove",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns false. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "cljs.test/test-all-vars" {:ns "cljs.test",
                                      :name "test-all-vars",
                                      :signature ["[[quote ns]]"],
                                      :name-encode "test-all-vars",
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/test-all-vars",
                                      :source {:code "(defmacro test-all-vars\n  ([[quote ns]]\n   `(let [env# (cljs.test/get-current-env)]\n      (when (nil? env#)\n        (cljs.test/set-env! (cljs.test/empty-env)))\n      ~(when (ana-api/ns-resolve ns 'cljs-test-once-fixtures)\n         `(cljs.test/update-current-env! [:once-fixtures] assoc '~ns\n            ~(symbol (name ns) \"cljs-test-once-fixtures\")))\n      ~(when (ana-api/ns-resolve ns 'cljs-test-each-fixtures)\n         `(cljs.test/update-current-env! [:each-fixtures] assoc '~ns\n            ~(symbol (name ns) \"cljs-test-each-fixtures\")))\n      (cljs.test/test-vars\n        [~@(map\n             (fn [[k _]]\n               `(var ~(symbol (name ns) (name k))))\n             (filter\n               (fn [[_ v]] (:test v))\n               (ana-api/ns-interns ns)))])\n      (when (nil? env#)\n        (cljs.test/clear-env!)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/test.clj",
                                               :lines [278 299]},
                                      :full-name "cljs.test/test-all-vars",
                                      :docstring "Calls test-vars on every var with :test metadata interned in the\nnamespace, with fixtures."},
           "cljs.core/set-print-fn!" {:ns "cljs.core",
                                      :name "set-print-fn!",
                                      :signature ["[f]"],
                                      :name-encode "set-print-fnBANG",
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/set-print-fnBANG",
                                      :source {:code "(defn set-print-fn!\n  [f] (set! *print-fn* f))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [28 30]},
                                      :full-name "cljs.core/set-print-fn!",
                                      :docstring "Set *print-fn* to f."},
           "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD" {:ns "cljs.core",
                                                             :name "PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :name-encode "PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :history [["+"
                                                                        "0.0-1211"]
                                                                       ["-"
                                                                        "0.0-2301"]],
                                                             :parent-type "PersistentArrayMap",
                                                             :type "var",
                                                             :full-name-encode "cljs.core/PersistentArrayMapDOTHASHMAP_THRESHOLD",
                                                             :source {:code "(set! cljs.core.PersistentArrayMap.HASHMAP_THRESHOLD 8)",
                                                                      :title "Source code",
                                                                      :repo "clojurescript",
                                                                      :tag "r2280",
                                                                      :filename "src/cljs/cljs/core.cljs",
                                                                      :lines [4672]},
                                                             :full-name "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD",
                                                             :removed {:in "0.0-2301",
                                                                       :last-seen "0.0-2280"}},
           "cljs.core/ns" {:ns "cljs.core",
                           :name "ns",
                           :type "special form",
                           :source {:code "(defmethod parse 'ns\n  [_ env [_ name & args :as form] _ opts]\n  (when-not (symbol? name) \n    (throw (error env \"Namespaces must be named by a symbol.\")))\n  (let [docstring (if (string? (first args)) (first args))\n        args      (if docstring (next args) args)\n        metadata  (if (map? (first args)) (first args))\n        form-meta (meta form)\n        args      (desugar-ns-specs (if metadata (next args) args))\n        name      (vary-meta name merge metadata)\n        excludes  (parse-ns-excludes env args)\n        deps      (atom #{})\n        aliases   (atom {:fns {} :macros {}})\n        spec-parsers {:require        (partial parse-require-spec env false deps aliases)\n                      :require-macros (partial parse-require-spec env true deps aliases)\n                      :use            (comp (partial parse-require-spec env false deps aliases)\n                                            (partial use->require env))\n                      :use-macros     (comp (partial parse-require-spec env true deps aliases)\n                                            (partial use->require env))\n                      :import         (partial parse-import-spec env deps)}\n        valid-forms (atom #{:use :use-macros :require :require-macros :import})\n        reload (atom {:use nil :require nil :use-macros nil :require-macros nil})\n        {uses :use requires :require use-macros :use-macros require-macros :require-macros imports :import :as params}\n        (reduce\n          (fn [m [k & libs]]\n            (when-not (#{:use :use-macros :require :require-macros :import} k)\n              (throw (error env \"Only :refer-clojure, :require, :require-macros, :use and :use-macros libspecs supported\")))\n            (when-not (@valid-forms k)\n              (throw (error env (str \"Only one \" k \" form is allowed per namespace definition\"))))\n            (swap! valid-forms disj k)\n            (when-not (= :import k)\n              (when (some #{:reload} libs)\n                (swap! reload assoc k :reload))\n              (when (some #{:reload-all} libs)\n                (swap! reload assoc k :reload-all)))\n            (apply merge-with merge m\n              (map (spec-parsers k)\n                (remove #{:reload :reload-all} libs))))\n          {} (remove (fn [[r]] (= r :refer-clojure)) args))]\n    (when (and *analyze-deps* (seq @deps))\n      (analyze-deps name @deps env opts))\n    (when (and *analyze-deps* (seq uses))\n      (check-uses uses env))\n    (set! *cljs-ns* name)\n    (when *load-macros*\n      (load-core)\n      (doseq [nsym (vals use-macros)]\n        (if-let [k (:use-macros @reload)]\n          (clojure.core/require nsym k)\n          (clojure.core/require nsym)))\n      (doseq [nsym (vals require-macros)]\n        (if-let [k (:require-macros @reload)]\n          (clojure.core/require nsym k)\n          (clojure.core/require nsym)))\n      (when (seq use-macros)\n        (check-use-macros use-macros env)))\n    (let [ns-info\n          {:name name\n           :doc docstring\n           :excludes excludes\n           :use-macros use-macros\n           :require-macros require-macros\n           :uses uses\n           :requires requires\n           :imports imports}\n          ns-info\n          (if (:merge form-meta)\n            ;; for merging information in via require usage in REPLs\n            (let [ns-info' (get-in @env/*compiler* [::namespaces name])]\n              (if (pos? (count ns-info'))\n                (let [merge-keys\n                      [:use-macros :require-macros :uses :requires :imports]]\n                  (merge\n                    ns-info'\n                    (merge-with merge\n                      (select-keys ns-info' merge-keys)\n                      (select-keys ns-info merge-keys))))\n                ns-info))\n            ns-info)]\n      (swap! env/*compiler* assoc-in [::namespaces name] ns-info)\n      (merge {:env env :op :ns :form form}\n        (cond-> ns-info\n          (@reload :use)\n          (update-in [:uses]\n            (fn [m] (with-meta m {(@reload :use) true})))\n          (@reload :require)\n          (update-in [:requires]\n            (fn [m] (with-meta m {(@reload :require) true}))))))))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [1278 1365]},
                           :extra-sources ({:code "(defmethod emit* :ns\n  [{:keys [name requires uses require-macros env]}]\n  (emitln \"goog.provide('\" (munge name) \"');\")\n  (when-not (= name 'cljs.core)\n    (emitln \"goog.require('cljs.core');\"))\n  (load-libs requires)\n  (load-libs uses requires))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [834 840]}),
                           :full-name "cljs.core/ns",
                           :full-name-encode "cljs.core/ns",
                           :name-encode "ns",
                           :history [["+" "0.0-927"]]},
           "cljs.core/if-not" {:ns "cljs.core",
                               :name "if-not",
                               :signature ["[test then]"
                                           "[test then else]"],
                               :name-encode "if-not",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-not",
                               :source {:code "(defmacro if-not\n  ([test then] `(if-not ~test ~then nil))\n  ([test then else]\n   `(if (not ~test) ~then ~else)))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [726 732]},
                               :full-name "cljs.core/if-not",
                               :docstring "Evaluates test. If logical false, evaluates and returns then expr, \notherwise else expr, if supplied, else nil."},
           "cljs.repl.reflect/macroexpand" {:ns "cljs.repl.reflect",
                                            :name "macroexpand",
                                            :signature ["[form]"],
                                            :name-encode "macroexpand",
                                            :type "function",
                                            :full-name-encode "cljs.repl.reflect/macroexpand",
                                            :source {:code "(defn macroexpand [form]\n  \"Fully expands a cljs macro form.\"\n  (let [mform (analyzer/macroexpand-1 {} form)]\n    (if (identical? form mform)\n      mform\n      (macroexpand mform))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/reflect.clj",
                                                     :lines [32 37]},
                                            :full-name "cljs.repl.reflect/macroexpand",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/string-iter" {:ns "cljs.core",
                                    :name "string-iter",
                                    :signature ["[x]"],
                                    :name-encode "string-iter",
                                    :type "function",
                                    :full-name-encode "cljs.core/string-iter",
                                    :source {:code "(defn string-iter [x]\n  (StringIter. x 0))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [3074 3075]},
                                    :full-name "cljs.core/string-iter",
                                    :history [["+" "0.0-2301"]]},
           "clojure.zip/path" {:ns "clojure.zip",
                               :name "path",
                               :signature ["[loc]"],
                               :name-encode "path",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/path",
                               :source {:code "(defn path\n  [loc]\n    (:pnodes (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [82 85]},
                               :full-name "clojure.zip/path",
                               :docstring "Returns a seq of nodes leading to this loc"},
           "cljs.core/mapcat" {:ns "cljs.core",
                               :name "mapcat",
                               :signature ["[f]" "[f & colls]"],
                               :name-encode "mapcat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/mapcat",
                               :source {:code "(defn mapcat\n  ([f] (comp (map f) cat))\n  ([f & colls]\n     (apply concat (apply map f colls))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3947 3955]},
                               :full-name "cljs.core/mapcat",
                               :docstring "Returns the result of applying concat to the result of applying map\nto f and colls.  Thus function f should return a collection. Returns\na transducer when no collections are provided"},
           "cljs.core/m3-mix-H1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-H1",
                                  :signature ["[h1 k1]"],
                                  :name-encode "m3-mix-H1",
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/m3-mix-H1",
                                  :source {:code "(defn ^number m3-mix-H1 [h1 k1]\n  (-> h1 (bit-xor k1) (int-rotate-left 13) (imul 5) (+ 0xe6546b64)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [471 472]},
                                  :full-name "cljs.core/m3-mix-H1"},
           "cljs.core/IWatchable" {:ns "cljs.core",
                                   :name "IWatchable",
                                   :name-encode "IWatchable",
                                   :implementations #{"Atom"},
                                   :history [["+" "0.0-927"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IWatchable",
                                   :source {:code "(defprotocol IWatchable\n  (-notify-watches [this oldval newval])\n  (-add-watch [this key f])\n  (-remove-watch [this key]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [368 371]},
                                   :methods [{:name "-notify-watches",
                                              :signature ["[this oldval newval]"],
                                              :docstring nil}
                                             {:name "-add-watch",
                                              :signature ["[this key f]"],
                                              :docstring nil}
                                             {:name "-remove-watch",
                                              :signature ["[this key]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IWatchable"},
           "cljs.core/PersistentHashMap.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashMap.fromArray",
                                                    :signature ["[arr no-clone]"],
                                                    :name-encode "PersistentHashMapDOTfromArray",
                                                    :history [["+"
                                                               "0.0-2719"]],
                                                    :parent-type "PersistentHashMap",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashMapDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashMap)\n  (fn [arr ^boolean no-clone]\n    (let [arr (if no-clone arr (aclone arr))\n          len (alength arr)]\n      (loop [i 0 ret (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (+ i 2)\n            (-assoc! ret (aget arr i) (aget arr (inc i))))\n          (-persistent! ret))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [6331
                                                                     6339]},
                                                    :full-name "cljs.core/PersistentHashMap.fromArray"},
           "cljs.core/run!" {:ns "cljs.core",
                             :name "run!",
                             :signature ["[proc coll]"],
                             :name-encode "runBANG",
                             :history [["+" "0.0-2301"]],
                             :type "function",
                             :full-name-encode "cljs.core/runBANG",
                             :source {:code "(defn run!\n  [proc coll]\n  (reduce #(proc %2) nil coll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [8615 8619]},
                             :full-name "cljs.core/run!",
                             :docstring "Runs the supplied procedure (via reduce), for purposes of side\neffects, on successive items in the collection. Returns nil"},
           "warnings/variadic-max-arity" {:ns "warnings",
                                          :name "variadic-max-arity",
                                          :type "warning",
                                          :full-name "warnings/variadic-max-arity",
                                          :full-name-encode "warnings/variadic-max-arity",
                                          :name-encode "variadic-max-arity",
                                          :history [["+" "0.0-2014"]]},
           "compiler-options/preamble" {:ns "compiler-options",
                                        :name "preamble",
                                        :name-encode "preamble",
                                        :type "option",
                                        :full-name-encode "compiler-options/preamble",
                                        :full-name "compiler-options/preamble",
                                        :history [["+" "0.0-2127"]]},
           "cljs.core/IndexedSeqIterator" {:ns "cljs.core",
                                           :name "IndexedSeqIterator",
                                           :signature ["[arr i]"],
                                           :name-encode "IndexedSeqIterator",
                                           :type "type",
                                           :full-name-encode "cljs.core/IndexedSeqIterator",
                                           :source {:code "(deftype IndexedSeqIterator [arr ^:mutable i]\n  Object\n  (hasNext [_]\n    (< i (alength arr)))\n  (next [_]\n    (let [ret (aget arr i)]\n      (set! i (inc i))\n      ret)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [994 1001]},
                                           :full-name "cljs.core/IndexedSeqIterator",
                                           :history [["+" "0.0-2371"]]},
           "cljs.core/unchecked-inc-int" {:ns "cljs.core",
                                          :name "unchecked-inc-int",
                                          :signature ["[x]"],
                                          :name-encode "unchecked-inc-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-inc-int",
                                          :source {:code "(defn unchecked-inc-int [x]\n  (cljs.core/unchecked-inc-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1985 1986]},
                                          :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-inc-int\n  ([x] `(inc ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [390
                                                                   391]}],
                                          :full-name "cljs.core/unchecked-inc-int"},
           "cljs.test/testing-vars-str" {:ns "cljs.test",
                                         :name "testing-vars-str",
                                         :signature ["[m]"],
                                         :name-encode "testing-vars-str",
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/testing-vars-str",
                                         :source {:code "(defn testing-vars-str\n  [m]\n  (let [{:keys [file line]} m]\n    (str\n      (reverse (map #(:name (meta %)) (:testing-vars (get-current-env))))\n      \" (\" file \":\" line \")\")))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/test.cljs",
                                                  :lines [238 246]},
                                         :full-name "cljs.test/testing-vars-str",
                                         :docstring "Returns a string representation of the current test.  Renders names\nin *testing-vars* as a list, then the source file and line of\ncurrent assertion."},
           "clojure.zip/rightmost" {:ns "clojure.zip",
                                    :name "rightmost",
                                    :signature ["[loc]"],
                                    :name-encode "rightmost",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/rightmost",
                                    :source {:code "(defn rightmost\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (if (and path r)\n        (with-meta [(last r) (assoc path :l (apply conj l node (butlast r)) :r nil)] (meta loc))\n        loc)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [142 148]},
                                    :full-name "clojure.zip/rightmost",
                                    :docstring "Returns the loc of the rightmost sibling of the node at this loc, or self"},
           "cljs.core/PersistentArrayMap.EMPTY" {:ns "cljs.core",
                                                 :name "PersistentArrayMap.EMPTY",
                                                 :name-encode "PersistentArrayMapDOTEMPTY",
                                                 :parent-type "PersistentArrayMap",
                                                 :type "var",
                                                 :full-name-encode "cljs.core/PersistentArrayMapDOTEMPTY",
                                                 :source {:code "(set! (.-EMPTY PersistentArrayMap) (PersistentArrayMap. nil 0 (array) empty-unordered-hash))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5487]},
                                                 :full-name "cljs.core/PersistentArrayMap.EMPTY",
                                                 :history [["+"
                                                            "0.0-1211"]]},
           "cljs.core/m3-C2" {:ns "cljs.core",
                              :name "m3-C2",
                              :name-encode "m3-C2",
                              :type "var",
                              :full-name-encode "cljs.core/m3-C2",
                              :source {:code "(def m3-C2 0x1b873593)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [466]},
                              :full-name "cljs.core/m3-C2",
                              :history [["+" "0.0-2261"]]},
           "cljs.repl.server/read-request" {:ns "cljs.repl.server",
                                            :name "read-request",
                                            :signature ["[rdr]"],
                                            :name-encode "read-request",
                                            :type "function",
                                            :full-name-encode "cljs.repl.server/read-request",
                                            :source {:code "(defn read-request [rdr]\n  (let [line (.readLine rdr)]\n    (cond\n      (.startsWith line \"POST\") (read-post line rdr)\n      (.startsWith line \"GET\") (read-get line rdr)\n      :else {:method :unknown :content line})))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/server.clj",
                                                     :lines [96 101]},
                                            :full-name "cljs.repl.server/read-request",
                                            :history [["+" "0.0-1503"]]},
           "cljs.test/compose-fixtures" {:ns "cljs.test",
                                         :name "compose-fixtures",
                                         :signature ["[f1 f2]"],
                                         :name-encode "compose-fixtures",
                                         :history [["+" "0.0-2496"]],
                                         :type "function",
                                         :full-name-encode "cljs.test/compose-fixtures",
                                         :source {:code "(defn compose-fixtures\n  [f1 f2]\n  (fn [g] (f1 (fn [] (f2 g)))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/test.cljs",
                                                  :lines [383 387]},
                                         :full-name "cljs.test/compose-fixtures",
                                         :docstring "Composes two fixture functions, creating a new fixture function\nthat combines their behavior."},
           "cljs.repl/load-file" {:ns "cljs.repl",
                                  :name "load-file",
                                  :signature ["[repl-env f]"
                                              "[repl-env f opts]"],
                                  :name-encode "load-file",
                                  :type "function",
                                  :full-name-encode "cljs.repl/load-file",
                                  :source {:code "(defn load-file\n  ([repl-env f] (load-file repl-env f nil))\n  ([repl-env f opts]\n    (if (:output-dir opts)\n      (let [src (if (util/url? f) f (io/resource f))\n            compiled (cljsc/compile src\n                       (assoc opts\n                         :output-file\n                         (cljsc/src-file->target-file src)))]\n        (-evaluate repl-env f 1 (cljsc/add-dep-string opts compiled))\n        (-evaluate repl-env f 1 (cljsc/src-file->goog-require src)))\n      (binding [ana/*cljs-ns* 'cljs.user]\n        (let [res (if (= File/separatorChar (first f)) f (io/resource f))]\n          (assert res (str \"Can't find \" f \" in classpath\"))\n          (load-stream repl-env f res))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [226 240]},
                                  :full-name "cljs.repl/load-file",
                                  :history [["+" "0.0-927"]]},
           "closure-warnings/check-regexp" {:ns "closure-warnings",
                                            :name "check-regexp",
                                            :type "warning",
                                            :full-name "closure-warnings/check-regexp",
                                            :full-name-encode "closure-warnings/check-regexp",
                                            :name-encode "check-regexp",
                                            :history [["+" "0.0-2120"]]},
           "compiler-options/closure-warnings" {:ns "compiler-options",
                                                :name "closure-warnings",
                                                :name-encode "closure-warnings",
                                                :type "option",
                                                :full-name-encode "compiler-options/closure-warnings",
                                                :full-name "compiler-options/closure-warnings",
                                                :sub-options-ns "closure-warnings",
                                                :history [["+"
                                                           "0.0-2120"]]},
           "cljs.core/unchecked-subtract" {:return-type number,
                                           :ns "cljs.core",
                                           :name "unchecked-subtract",
                                           :signature ["[x]"
                                                       "[x y]"
                                                       "[x y & more]"],
                                           :name-encode "unchecked-subtract",
                                           :history [["+" "0.0-1798"]],
                                           :type "function/macro",
                                           :full-name-encode "cljs.core/unchecked-subtract",
                                           :source {:code "(defn ^number unchecked-subtract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-subtract (cljs.core/unchecked-subtract x y) more)))",
                                                    :title "Function code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2013 2018]},
                                           :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-subtract\n  ([& xs] `(- ~@xs)))",
                                                            :title "Macro code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/clj/cljs/core.clj",
                                                            :lines [408
                                                                    409]}],
                                           :full-name "cljs.core/unchecked-subtract",
                                           :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/->" {:ns "cljs.core",
                           :name "->",
                           :signature ["[x & forms]"],
                           :name-encode "-GT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/-GT",
                           :source {:code "(defmacro ->\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n                       (with-meta `(~(first form) ~x ~@(next form)) (meta form))\n                       (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.6.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1558 1572]},
                           :full-name "cljs.core/->",
                           :docstring "Threads the expr through the forms. Inserts x as the\nsecond item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nsecond item in second form, etc."},
           "cljs.core/remove-all-methods" {:ns "cljs.core",
                                           :name "remove-all-methods",
                                           :signature ["[multifn]"],
                                           :name-encode "remove-all-methods",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/remove-all-methods",
                                           :source {:code "(defn remove-all-methods\n [multifn]\n (-reset multifn))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [9115 9118]},
                                           :full-name "cljs.core/remove-all-methods",
                                           :docstring "Removes all of the methods of multimethod."},
           "cljs.core/unchecked-add-int" {:return-type number,
                                          :ns "cljs.core",
                                          :name "unchecked-add-int",
                                          :signature ["[]"
                                                      "[x]"
                                                      "[x y]"
                                                      "[x y & more]"],
                                          :name-encode "unchecked-add-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-add-int",
                                          :source {:code "(defn ^number unchecked-add-int\n  ([] 0)\n  ([x] x)\n  ([x y] (cljs.core/unchecked-add-int x y))\n  ([x y & more] (reduce unchecked-add-int (cljs.core/unchecked-add-int x y) more)))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1962 1967]},
                                          :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-add-int\n  ([& xs] `(+ ~@xs)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [375
                                                                   376]}],
                                          :full-name "cljs.core/unchecked-add-int",
                                          :docstring "Returns the sum of nums. (+) returns 0."},
           "clojure.string/replace-first" {:ns "clojure.string",
                                           :name "replace-first",
                                           :signature ["[s match replacement]"],
                                           :name-encode "replace-first",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.string/replace-first",
                                           :source {:code "(defn replace-first\n  [s match replacement]\n  (.replace s match replacement))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/string.cljs",
                                                    :lines [40 47]},
                                           :full-name "clojure.string/replace-first",
                                           :docstring "Replaces the first instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/reduced?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "reduced?",
                                 :signature ["[r]"],
                                 :name-encode "reducedQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/reducedQMARK",
                                 :source {:code "(defn ^boolean reduced?\n  [r]\n  (instance? Reduced r))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [899 902]},
                                 :full-name "cljs.core/reduced?",
                                 :docstring "Returns true if x is the result of a call to reduced"},
           "clojure.browser.dom/get-value" {:ns "clojure.browser.dom",
                                            :name "get-value",
                                            :signature ["[e]"],
                                            :name-encode "get-value",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/get-value",
                                            :source {:code "(defn get-value\n  [e]\n  (.-value (ensure-element e)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [131 134]},
                                            :full-name "clojure.browser.dom/get-value",
                                            :docstring "Get the value of an element."},
           "clojure.core.reducers/CollFold" {:ns "clojure.core.reducers",
                                             :name "CollFold",
                                             :name-encode "CollFold",
                                             :type "protocol",
                                             :full-name-encode "clojure.core.reducers/CollFold",
                                             :source {:code "(defprotocol CollFold\n  (coll-fold [coll n combinef reducef]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/clojure/core/reducers.cljs",
                                                      :lines [46 47]},
                                             :methods [{:name "coll-fold",
                                                        :signature ["[coll n combinef reducef]"],
                                                        :docstring nil}],
                                             :full-name "clojure.core.reducers/CollFold",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.nodejs/process" {:ns "cljs.nodejs",
                                  :name "process",
                                  :name-encode "process",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/process",
                                  :source {:code "(def process (js* \"process\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [16]},
                                  :full-name "cljs.nodejs/process",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/some->>" {:ns "cljs.core",
                                :name "some->>",
                                :signature ["[expr & forms]"],
                                :name-encode "some-GTGT",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/some-GTGT",
                                :source {:code "(defmacro some->>\n  [expr & forms]\n  (let [g (gensym)\n        pstep (fn [step] `(if (nil? ~g) nil (->> ~g ~step)))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep forms))]\n       ~g)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [6934 6943]},
                                :full-name "cljs.core/some->>",
                                :docstring "When expr is not nil, threads it into the first form (via ->>),\nand when that result is not nil, through the next etc"},
           "cljs.core/unchecked-inc" {:ns "cljs.core",
                                      :name "unchecked-inc",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-inc",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-inc",
                                      :source {:code "(defn unchecked-inc [x]\n  (cljs.core/unchecked-inc x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1982 1983]},
                                      :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-inc\n  ([x] `(inc ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [387
                                                               388]}],
                                      :full-name "cljs.core/unchecked-inc"},
           "cljs.core/not=" {:return-type boolean,
                             :ns "cljs.core",
                             :name "not=",
                             :signature ["[x]" "[x y]" "[x y & more]"],
                             :name-encode "notEQ",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/notEQ",
                             :source {:code "(defn ^boolean not=\n  ([x] false)\n  ([x y] (not (= x y)))\n  ([x y & more]\n   (not (apply = x y more))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3047 3052]},
                             :full-name "cljs.core/not=",
                             :docstring "Same as (not (= obj1 obj2))"},
           "cljs.core/unchecked-subtract-int" {:return-type number,
                                               :ns "cljs.core",
                                               :name "unchecked-subtract-int",
                                               :signature ["[x]"
                                                           "[x y]"
                                                           "[x y & more]"],
                                               :name-encode "unchecked-subtract-int",
                                               :history [["+"
                                                          "0.0-1798"]],
                                               :type "function/macro",
                                               :full-name-encode "cljs.core/unchecked-subtract-int",
                                               :source {:code "(defn ^number unchecked-subtract-int\n  ([x] (cljs.core/unchecked-subtract-int x))\n  ([x y] (cljs.core/unchecked-subtract-int x y))\n  ([x y & more] (reduce unchecked-subtract-int (cljs.core/unchecked-subtract-int x y) more)))",
                                                        :title "Function code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [2020
                                                                2025]},
                                               :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-subtract-int\n  ([& xs] `(- ~@xs)))",
                                                                :title "Macro code",
                                                                :repo "clojurescript",
                                                                :tag "r2760",
                                                                :filename "src/clj/cljs/core.clj",
                                                                :lines [411
                                                                        412]}],
                                               :full-name "cljs.core/unchecked-subtract-int",
                                               :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result."},
           "cljs.core/ex-data" {:ns "cljs.core",
                                :name "ex-data",
                                :signature ["[ex]"],
                                :name-encode "ex-data",
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-data",
                                :source {:code "(defn ex-data\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-data ex)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9200 9206]},
                                :full-name "cljs.core/ex-data",
                                :docstring "Alpha - subject to change.\nReturns exception data (a map) if ex is an ExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/PersistentTreeMapSeq" {:protocols #{"ISeqable"
                                                          "IMeta"
                                                          "IWithMeta"
                                                          "IEmptyableCollection"
                                                          "ICounted"
                                                          "IReduce"
                                                          "ISequential"
                                                          "ISeq"
                                                          "ICollection"
                                                          "IHash"
                                                          "IPrintWithWriter"
                                                          "IEquiv"},
                                             :ns "cljs.core",
                                             :name "PersistentTreeMapSeq",
                                             :signature ["[meta stack ascending? cnt __hash]"],
                                             :name-encode "PersistentTreeMapSeq",
                                             :history [["+"
                                                        "0.0-1211"]],
                                             :type "type",
                                             :full-name-encode "cljs.core/PersistentTreeMapSeq",
                                             :source {:code "(deftype PersistentTreeMapSeq [meta stack ^boolean ascending? cnt ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ISeqable\n  (-seq [this] this)\n\n  ISequential\n  ISeq\n  (-first [this] (peek stack))\n  (-rest [this]\n    (let [t (first stack)\n          next-stack (tree-map-seq-push (if ascending? (.-right t) (.-left t))\n                                        (next stack)\n                                        ascending?)]\n      (if-not (nil? next-stack)\n        (PersistentTreeMapSeq. nil next-stack ascending? (dec cnt) nil)\n        ())))\n\n  ICounted\n  (-count [coll]\n    (if (neg? cnt)\n      (inc (count (next coll)))\n      cnt))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta]\n    (PersistentTreeMapSeq. meta stack ascending? cnt __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [6463
                                                              6512]},
                                             :full-name "cljs.core/PersistentTreeMapSeq"},
           "cljs.core/js-keys" {:ns "cljs.core",
                                :name "js-keys",
                                :signature ["[obj]"],
                                :name-encode "js-keys",
                                :type "function",
                                :full-name-encode "cljs.core/js-keys",
                                :source {:code "(defn js-keys [obj]\n  (let [keys (array)]\n    (goog.object/forEach obj (fn [val key obj] (.push keys key)))\n    keys))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1553 1556]},
                                :full-name "cljs.core/js-keys",
                                :history [["+" "0.0-927"]]},
           "cljs.repl.browser/browser-eval" {:ns "cljs.repl.browser",
                                             :name "browser-eval",
                                             :signature ["[form]"],
                                             :name-encode "browser-eval",
                                             :history [["+" "0.0-927"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/browser-eval",
                                             :source {:code "(defn browser-eval\n  [form]\n  (let [return-value (promise)]\n    (send-for-eval form\n      (fn [val] (deliver return-value val)))\n    (let [ret @return-value]\n      (try\n        (read-string ret)\n        (catch Exception e\n          {:status :error\n           :value (str \"Could not read return value: \" ret)})))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [164 180]},
                                             :full-name "cljs.repl.browser/browser-eval",
                                             :docstring "Given a string of JavaScript, evaluate it in the browser and return a map representing the\nresult of the evaluation. The map will contain the keys :type and :value. :type can be\n:success, :exception, or :error. :success means that the JavaScript was evaluated without\nexception and :value will contain the return value of the evaluation. :exception means that\nthere was an exception in the browser while evaluating the JavaScript and :value will\ncontain the error message. :error means that some other error has occured."},
           "clojure.zip/seq-zip" {:ns "clojure.zip",
                                  :name "seq-zip",
                                  :signature ["[root]"],
                                  :name-encode "seq-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/seq-zip",
                                  :source {:code "(defn seq-zip\n  [root]\n    (zipper seq?\n            identity\n            (fn [node children] (with-meta children (meta node)))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [34 40]},
                                  :full-name "clojure.zip/seq-zip",
                                  :docstring "Returns a zipper for nested sequences, given a root sequence"},
           "cljs.core/lazy-transformer" {:ns "cljs.core",
                                         :name "lazy-transformer",
                                         :signature ["[stepper]"],
                                         :name-encode "lazy-transformer",
                                         :type "function",
                                         :full-name-encode "cljs.core/lazy-transformer",
                                         :source {:code "(defn lazy-transformer [stepper]\n  (LazyTransformer. stepper nil nil nil))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3124 3125]},
                                         :full-name "cljs.core/lazy-transformer",
                                         :history [["+" "0.0-2301"]]},
           "cljs.repl.browser/server-state" {:ns "cljs.repl.browser",
                                             :name "server-state",
                                             :name-encode "server-state",
                                             :type "var",
                                             :full-name-encode "cljs.repl.browser/server-state",
                                             :source {:code "(defonce server-state (atom {:socket nil\n                             :connection nil\n                             :promised-conn nil\n                             :return-value-fn nil\n                             :client-js nil}))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [24 28]},
                                             :full-name "cljs.repl.browser/server-state",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/random-sample" {:ns "cljs.core",
                                      :name "random-sample",
                                      :signature ["[prob]"
                                                  "[prob coll]"],
                                      :name-encode "random-sample",
                                      :history [["+" "0.0-2301"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/random-sample",
                                      :source {:code "(defn random-sample\n  ([prob]\n     (filter (fn [_] (< (rand) prob))))\n  ([prob coll]\n     (filter (fn [_] (< (rand) prob)) coll)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [8585 8591]},
                                      :full-name "cljs.core/random-sample",
                                      :docstring "Returns items from coll with random probability of prob (0.0 -\n1.0).  Returns a transducer when no collection is provided."},
           "cljs.core/IVector" {:ns "cljs.core",
                                :name "IVector",
                                :name-encode "IVector",
                                :implementations #{"Subvec"
                                                   "RedNode"
                                                   "BlackNode"
                                                   "PersistentVector"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IVector",
                                :source {:code "(defprotocol IVector\n  (^clj -assoc-n [coll n val]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [305 306]},
                                :methods [{:name "-assoc-n",
                                           :signature ["[coll n val]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IVector"},
           "cljs.core/iter" {:ns "cljs.core",
                             :name "iter",
                             :signature ["[coll]"],
                             :name-encode "iter",
                             :type "function",
                             :full-name-encode "cljs.core/iter",
                             :source {:code "(defn iter [coll]\n  (cond\n    (nil? coll) (nil-iter)\n    (string? coll) (string-iter coll)\n    (array? coll) (array-iter coll)\n    (iterable? coll) (-iterator coll)\n    (seqable? coll) (seq-iter coll)\n    :else (throw (js/Error. (str \"Cannot create iterator from \" coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3113 3120]},
                             :full-name "cljs.core/iter",
                             :history [["+" "0.0-2301"]]},
           "cljs.core/persistent!" {:ns "cljs.core",
                                    :name "persistent!",
                                    :signature ["[tcoll]"],
                                    :name-encode "persistentBANG",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/persistentBANG",
                                    :source {:code "(defn persistent!\n  [tcoll]\n  (-persistent! tcoll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2916 2921]},
                                    :full-name "cljs.core/persistent!",
                                    :docstring "Returns a new, persistent version of the transient collection, in\nconstant time. The transient collection cannot be used after this\ncall, any such use will throw an exception."},
           "cljs.core/empty" {:ns "cljs.core",
                              :name "empty",
                              :signature ["[coll]"],
                              :name-encode "empty",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/empty",
                              :source {:code "(defn empty\n  [coll]\n  (when-not (nil? coll)\n    (-empty coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1195 1199]},
                              :full-name "cljs.core/empty",
                              :docstring "Returns an empty collection of the same category as coll, or nil"},
           "cljs.core/re-matches" {:ns "cljs.core",
                                   :name "re-matches",
                                   :signature ["[re s]"],
                                   :name-encode "re-matches",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-matches",
                                   :source {:code "(defn re-matches\n  [re s]\n  (if (string? s)\n    (let [matches (.exec re s)]\n      (when (= (first matches) s)\n        (if (== (count matches) 1)\n          (first matches)\n          (vec matches))))\n    (throw (js/TypeError. \"re-matches must match against a string.\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [8061 8070]},
                                   :full-name "cljs.core/re-matches",
                                   :docstring "Returns the result of (re-find re s) if re fully matches s."},
           "syntax/meta" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "meta",
                          :name-encode "meta",
                          :type "syntax",
                          :full-name-encode "syntax/meta",
                          :extra-sources ({:code "(defn- read-meta\n  [rdr _]\n  (log-source rdr\n    (let [[line column] (when (indexing-reader? rdr)\n                          [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n          m (desugar-meta (read rdr true nil true))]\n      (when-not (map? m)\n        (reader-error rdr \"Metadata must be Symbol, Keyword, String or Map\"))\n      (let [o (read rdr true nil true)]\n        (if (instance? IMeta o)\n          (let [m (if (and line (seq? o))\n                    (assoc m :line line :column column)\n                    m)]\n            (if (instance? IObj o)\n              (with-meta o (merge (meta o) m))\n              (reset-meta! o m)))\n          (reader-error rdr \"Metadata can only be applied to IMetas\"))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [340 356]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [591 610]}),
                          :full-name "syntax/meta",
                          :history [["+" "0.0-1853"]]},
           "clojure.browser.dom/DOMBuilder" {:ns "clojure.browser.dom",
                                             :name "DOMBuilder",
                                             :name-encode "DOMBuilder",
                                             :type "protocol",
                                             :full-name-encode "clojure.browser.dom/DOMBuilder",
                                             :source {:code "(defprotocol DOMBuilder\n  (-element [this] [this attrs-or-children] [this attrs children]))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/clojure/browser/dom.cljs",
                                                      :lines [17 18]},
                                             :methods [{:name "-element",
                                                        :signature ["[this]"
                                                                    "[this attrs-or-children]"
                                                                    "[this attrs children]"],
                                                        :docstring nil}],
                                             :full-name "clojure.browser.dom/DOMBuilder",
                                             :history [["+" "0.0-927"]]},
           "syntax/regex" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "regex",
                           :name-encode "regex",
                           :type "syntax",
                           :full-name-encode "syntax/regex",
                           :extra-sources ({:code "(defn read-regex\n  [rdr ch]\n  (let [sb (StringBuilder.)]\n    (loop [ch (read-char rdr)]\n      (if (identical? \\\" ch)\n        (Pattern/compile (str sb))\n        (if (nil? ch)\n          (reader-error rdr \"EOF while reading regex\")\n          (do\n            (.append sb ch )\n            (when (identical? \\\\ ch)\n              (let [ch (read-char rdr)]\n                (if (nil? ch)\n                  (reader-error rdr \"EOF while reading regex\"))\n                (.append sb ch)))\n            (recur (read-char rdr))))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                            :lines [129 144]}
                                           {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [612 623]}),
                           :full-name "syntax/regex",
                           :history [["+" "0.0-1853"]]},
           "cljs.core/extend-type" {:ns "cljs.core",
                                    :name "extend-type",
                                    :signature ["[type-sym & impls]"],
                                    :name-encode "extend-type",
                                    :type "macro",
                                    :full-name-encode "cljs.core/extend-type",
                                    :source {:code "(defmacro extend-type [type-sym & impls]\n  (let [env &env\n        _ (validate-impls env impls)\n        resolve (partial resolve-var env)\n        impl-map (->impl-map impls)\n        [type assign-impls] (if-let [type (base-type type-sym)]\n                              [type base-assign-impls]\n                              [(resolve type-sym) proto-assign-impls])]\n    (when (core/and (:extending-base-js-type cljs.analyzer/*cljs-warnings*)\n                    (js-base-type type-sym))\n      (cljs.analyzer/warning :extending-base-js-type env\n          {:current-symbol type-sym :suggested-symbol (js-base-type type-sym)}))\n    `(do ~@(mapcat #(assign-impls env resolve type-sym type %) impl-map))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [816 828]},
                                    :full-name "cljs.core/extend-type",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/ISeqable" {:ns "cljs.core",
                                 :name "ISeqable",
                                 :name-encode "ISeqable",
                                 :implementations #{"Subvec"
                                                    "PersistentQueue"
                                                    "PersistentHashMap"
                                                    "PersistentTreeSet"
                                                    "PersistentArrayMapSeq"
                                                    "RedNode"
                                                    "EmptyList"
                                                    "LazyTransformer"
                                                    "ObjMap"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "ValSeq"
                                                    "ChunkedCons"
                                                    "Range"
                                                    "PersistentQueueSeq"
                                                    "ChunkedSeq"
                                                    "ArrayNodeSeq"
                                                    "KeySeq"
                                                    "IndexedSeq"
                                                    "PersistentTreeMap"
                                                    "PersistentTreeMapSeq"
                                                    "ES6IteratorSeq"
                                                    "RSeq"
                                                    "PersistentArrayMap"
                                                    "PersistentHashSet"
                                                    "NodeSeq"
                                                    "List"
                                                    "Cons"
                                                    "LazySeq"
                                                    "Eduction"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ISeqable",
                                 :source {:code "(defprotocol ISeqable\n  (^clj-or-nil -seq [o]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [332 333]},
                                 :methods [{:name "-seq",
                                            :signature ["[o]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/ISeqable"},
           "cljs.core/assoc" {:ns "cljs.core",
                              :name "assoc",
                              :signature ["[coll k v]"
                                          "[coll k v & kvs]"],
                              :name-encode "assoc",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/assoc",
                              :source {:code "(defn assoc\n  ([coll k v]\n    (if-not (nil? coll)\n      (-assoc coll k v)\n      (hash-map k v)))\n  ([coll k v & kvs]\n     (let [ret (assoc coll k v)]\n       (if kvs\n         (recur ret (first kvs) (second kvs) (nnext kvs))\n         ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1364 1377]},
                              :full-name "cljs.core/assoc",
                              :docstring "assoc[iate]. When applied to a map, returns a new map of the\nsame (hashed/sorted) type, that contains the mapping of key(s) to\nval(s). When applied to a vector, returns a new vector that\ncontains val at index."},
           "clojure.browser.repl/xpc-connection" {:ns "clojure.browser.repl",
                                                  :name "xpc-connection",
                                                  :name-encode "xpc-connection",
                                                  :type "var",
                                                  :full-name-encode "clojure.browser.repl/xpc-connection",
                                                  :source {:code "(def xpc-connection (atom nil))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/cljs/clojure/browser/repl.cljs",
                                                           :lines [21]},
                                                  :full-name "clojure.browser.repl/xpc-connection",
                                                  :history [["+"
                                                             "0.0-927"]]},
           "cljs.core/IDerefWithTimeout" {:ns "cljs.core",
                                          :name "IDerefWithTimeout",
                                          :name-encode "IDerefWithTimeout",
                                          :type "protocol",
                                          :full-name-encode "cljs.core/IDerefWithTimeout",
                                          :source {:code "(defprotocol IDerefWithTimeout\n  (-deref-with-timeout [o msec timeout-val]))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [311 312]},
                                          :methods [{:name "-deref-with-timeout",
                                                     :signature ["[o msec timeout-val]"],
                                                     :docstring nil}],
                                          :full-name "cljs.core/IDerefWithTimeout",
                                          :history [["+" "0.0-927"]]},
           "warnings/invalid-protocol-symbol" {:ns "warnings",
                                               :name "invalid-protocol-symbol",
                                               :type "warning",
                                               :full-name "warnings/invalid-protocol-symbol",
                                               :full-name-encode "warnings/invalid-protocol-symbol",
                                               :name-encode "invalid-protocol-symbol",
                                               :history [["+"
                                                          "0.0-2014"]]},
           "syntax/eval" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "eval",
                          :name-encode "eval",
                          :type "syntax",
                          :full-name-encode "syntax/eval",
                          :extra-sources ({:code "(defn- read-eval\n  [rdr _]\n  (when-not *read-eval*\n    (reader-error rdr \"#= not allowed when *read-eval* is false\"))\n  (eval (read rdr true nil true)))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [439 443]}
                                          {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [612 623]}),
                          :full-name "syntax/eval",
                          :history [["+" "0.0-1853"]]},
           "cljs.core/multi-stepper" {:ns "cljs.core",
                                      :name "multi-stepper",
                                      :signature ["[xform iters]"
                                                  "[xform iters nexts]"],
                                      :name-encode "multi-stepper",
                                      :type "function",
                                      :full-name-encode "cljs.core/multi-stepper",
                                      :source {:code "(defn multi-stepper\n  ([xform iters]\n     (multi-stepper xform iters\n       (make-array (alength iters))))\n  ([xform iters nexts]\n     (letfn [(stepfn\n               ([result]\n                  (let [lt (if (reduced? result)\n                             @result\n                             result)]\n                    (set! (.-stepper lt) nil)\n                    lt))\n               ([result input]\n                  (let [lt result]\n                    (set! (.-first lt) input)\n                    (set! (.-rest lt) (lazy-transformer (.-stepper lt)))\n                    (set! (.-stepper lt) nil)\n                    (.-rest lt))))]\n       (MultiStepper. (xform stepfn) iters nexts))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3181 3199]},
                                      :full-name "cljs.core/multi-stepper",
                                      :history [["+" "0.0-2301"]]},
           "clojure.core.reducers/cat" {:ns "clojure.core.reducers",
                                        :name "cat",
                                        :signature ["[]"
                                                    "[ctor]"
                                                    "[left right]"],
                                        :name-encode "cat",
                                        :history [["+" "0.0-1236"]],
                                        :type "function",
                                        :full-name-encode "clojure.core.reducers/cat",
                                        :source {:code "(defn cat\n  ([] (array))\n  ([ctor]\n     (fn\n       ([] (ctor))\n       ([left right] (cat left right))))\n  ([left right]\n     (cond\n       (zero? (count left)) right\n       (zero? (count right)) left\n       :else\n       (Cat. (+ (count left) (count right)) left right))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/core/reducers.cljs",
                                                 :lines [213 230]},
                                        :full-name "clojure.core.reducers/cat",
                                        :docstring "A high-performance combining fn that yields the catenation of the\nreduced values. The result is reducible, foldable, seqable and\ncounted, providing the identity collections are reducible, seqable\nand counted. The single argument version will build a combining fn\nwith the supplied identity constructor. Tests for identity\nwith (zero? (count x)). See also foldcat."},
           "cljs.core/unchecked-substract" {:return-type number,
                                            :ns "cljs.core",
                                            :name "unchecked-substract",
                                            :signature ["[x]"
                                                        "[x y]"
                                                        "[x y & more]"],
                                            :name-encode "unchecked-substract",
                                            :history [["+" "0.0-1798"]
                                                      ["-" "0.0-2277"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/unchecked-substract",
                                            :source {:code "(defn ^number unchecked-substract\n  ([x] (cljs.core/unchecked-subtract x))\n  ([x y] (cljs.core/unchecked-subtract x y))\n  ([x y & more] (reduce unchecked-substract (cljs.core/unchecked-subtract x y) more)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2268",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [1805
                                                             1810]},
                                            :full-name "cljs.core/unchecked-substract",
                                            :docstring "If no ys are supplied, returns the negation of x, else subtracts\nthe ys from x and returns the result.",
                                            :removed {:in "0.0-2277",
                                                      :last-seen "0.0-2268"}},
           "cljs.core/Iteration" {:protocols #{"ISeqable"
                                               "IReduce"
                                               "ISequential"
                                               "IPrintWithWriter"},
                                  :ns "cljs.core",
                                  :name "Iteration",
                                  :signature ["[xform coll]"],
                                  :name-encode "Iteration",
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "type",
                                  :full-name-encode "cljs.core/Iteration",
                                  :source {:code "(deftype Iteration [xform coll]\n   ISequential\n   \n   ISeqable\n   (-seq [_] (seq (sequence xform coll)))\n\n   IReduce\n   (-reduce [_ f init] (transduce xform f init coll))\n\n   IPrintWithWriter\n   (-pr-writer [coll writer opts]\n     (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8192 8203]},
                                  :full-name "cljs.core/Iteration",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "clojure.browser.repl/start-evaluator" {:ns "clojure.browser.repl",
                                                   :name "start-evaluator",
                                                   :signature ["[url]"],
                                                   :name-encode "start-evaluator",
                                                   :history [["+"
                                                              "0.0-927"]],
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.repl/start-evaluator",
                                                   :source {:code "(defn start-evaluator\n  [url]\n  (if-let [repl-connection (net/xpc-connection)]\n    (let [connection (net/xhr-connection)]\n      (event/listen connection\n                    :success\n                    (fn [e]\n                      (net/transmit\n                       repl-connection\n                       :evaluate-javascript\n                       (.getResponseText (.-currentTarget e)\n                                         ()))))\n\n      (net/register-service repl-connection\n                            :send-result\n                            (fn [data]\n                              (send-result connection url (wrap-message :result data))))\n\n      (net/register-service repl-connection\n                            :print\n                            (fn [data]\n                              (send-print url (wrap-message :print data))))\n      \n      (net/connect repl-connection\n                   (constantly nil))\n\n      (js/setTimeout #(send-result connection url (wrap-message :ready \"ready\")) 50))\n    (js/alert \"No 'xpc' param provided to child iframe.\")))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/clojure/browser/repl.cljs",
                                                            :lines [60
                                                                    88]},
                                                   :full-name "clojure.browser.repl/start-evaluator",
                                                   :docstring "Start the REPL server connection."},
           "cljs.repl.browser/send-for-eval" {:ns "cljs.repl.browser",
                                              :name "send-for-eval",
                                              :signature ["[form return-value-fn]"
                                                          "[conn form return-value-fn]"],
                                              :name-encode "send-for-eval",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/send-for-eval",
                                              :source {:code "(defn send-for-eval\n  ([form return-value-fn]\n    (send-for-eval @(server/connection) form return-value-fn))\n  ([conn form return-value-fn]\n    (set-return-value-fn return-value-fn)\n    (server/send-and-close conn 200 form \"text/javascript\")))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [35 43]},
                                              :full-name "cljs.repl.browser/send-for-eval",
                                              :docstring "Given a form and a return value function, send the form to the\nbrowser for evaluation. The return value function will be called\nwhen the return value is received."},
           "clojure.browser.event/unlisten" {:ns "clojure.browser.event",
                                             :name "unlisten",
                                             :signature ["[src type fn]"
                                                         "[src type fn capture?]"],
                                             :name-encode "unlisten",
                                             :type "function",
                                             :full-name-encode "clojure.browser.event/unlisten",
                                             :source {:code "(defn unlisten\n  ([src type fn]\n     (unlisten src type fn false))\n  ([src type fn capture?]\n     (events/unlisten src\n                      (get (event-types src) type type)\n                      fn\n                      capture?)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/clojure/browser/event.cljs",
                                                      :lines [64 71]},
                                             :full-name "clojure.browser.event/unlisten",
                                             :history [["+" "0.0-927"]]},
           "cljs.test/is" {:ns "cljs.test",
                           :name "is",
                           :signature ["[form]" "[form msg]"],
                           :name-encode "is",
                           :history [["+" "0.0-2496"]],
                           :type "macro",
                           :full-name-encode "cljs.test/is",
                           :source {:code "(defmacro is\n  ([form] `(cljs.test/is ~form nil))\n  ([form msg]\n   `(cljs.test/try-expr ~msg ~form)))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/clj/cljs/test.clj",
                                    :lines [149 165]},
                           :full-name "cljs.test/is",
                           :docstring "Generic assertion macro.  'form' is any predicate test.\n'msg' is an optional message to attach to the assertion.\n\nExample: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\nSpecial forms:\n\n(is (thrown? c body)) checks that an instance of c is thrown from\nbody, fails if not; then returns the thing thrown.\n\n(is (thrown-with-msg? c re body)) checks that an instance of c is\nthrown AND that the message on the exception matches (with\nre-find) the regular expression re."},
           "syntax/dot" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "dot",
                         :name-encode "dot",
                         :type "special character",
                         :full-name-encode "syntax/dot",
                         :full-name "syntax/dot",
                         :history [["+" "0.0-927"]]},
           "cljs.core/do" {:ns "cljs.core",
                           :name "do",
                           :type "special form",
                           :source {:code "(defmethod parse 'do\n  [op env [_ & exprs :as form] _ _]\n  (let [statements (disallowing-recur\n                     (seq (map #(analyze (assoc env :context :statement) %) (butlast exprs))))\n        ret (if (<= (count exprs) 1)\n              (analyze env (first exprs))\n              (analyze (assoc env :context (if (= :statement (:context env)) :statement :return)) (last exprs)))]\n    {:env env :op :do :form form\n     :statements statements :ret ret\n     :children (conj (vec statements) ret)}))",
                                    :title "Parser code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/clj/cljs/analyzer.clj",
                                    :lines [912 921]},
                           :extra-sources ({:code "(defmethod emit* :do\n  [{:keys [statements ret env]}]\n  (let [context (:context env)]\n    (when (and statements (= :expr context)) (emitln \"(function (){\"))\n    (doseq [s statements] (emitln s))\n    (emit ret)\n    (when (and statements (= :expr context)) (emitln \"})()\"))))",
                                            :title "Emitting code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/compiler.clj",
                                            :lines [640 646]}),
                           :full-name "cljs.core/do",
                           :full-name-encode "cljs.core/do",
                           :name-encode "do",
                           :history [["+" "0.0-927"]]},
           "syntax/unused" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "unused",
                            :name-encode "unused",
                            :type "convention",
                            :full-name-encode "syntax/unused",
                            :full-name "syntax/unused",
                            :history [["+" "0.0-927"]]},
           "cljs.test/use-fixtures" {:ns "cljs.test",
                                     :name "use-fixtures",
                                     :signature ["[type & fns]"],
                                     :name-encode "use-fixtures",
                                     :type "macro",
                                     :full-name-encode "cljs.test/use-fixtures",
                                     :source {:code "(defmacro use-fixtures [type & fns]\n  (condp = type\n    :once\n    `(def ~'cljs-test-once-fixtures\n       [~@fns])\n    :each\n    `(def ~'cljs-test-each-fixtures\n       [~@fns])\n    :else\n    (throw\n      (Exception. \"First argument to cljs.test/use-fixtures must be :once or :each\"))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/test.clj",
                                              :lines [329 339]},
                                     :full-name "cljs.test/use-fixtures",
                                     :history [["+" "0.0-2498"]]},
           "cljs.core/PersistentHashMap.fromArrays" {:ns "cljs.core",
                                                     :name "PersistentHashMap.fromArrays",
                                                     :signature ["[ks vs]"],
                                                     :name-encode "PersistentHashMapDOTfromArrays",
                                                     :history [["+"
                                                                "0.0-1211"]],
                                                     :parent-type "PersistentHashMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentHashMapDOTfromArrays",
                                                     :source {:code "(set! (.-fromArrays PersistentHashMap)\n  (fn [ks vs]\n    (let [len (alength ks)]\n      (loop [i 0 ^not-native out (transient (.-EMPTY PersistentHashMap))]\n        (if (< i len)\n          (recur (inc i) (-assoc! out (aget ks i) (aget vs i)))\n          (persistent! out))))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2760",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [6341
                                                                      6347]},
                                                     :full-name "cljs.core/PersistentHashMap.fromArrays"},
           "cljs.core/special-symbol?" {:return-type boolean,
                                        :ns "cljs.core",
                                        :name "special-symbol?",
                                        :signature ["[x]"],
                                        :name-encode "special-symbolQMARK",
                                        :history [["+" "0.0-1803"]],
                                        :type "function",
                                        :full-name-encode "cljs.core/special-symbolQMARK",
                                        :source {:code "(defn ^boolean special-symbol? [x]\n  (contains?\n    '#{if def fn* do let* loop* letfn* throw try\n       recur new set! ns deftype* defrecord* . js* & quote}\n    x))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [9231 9235]},
                                        :full-name "cljs.core/special-symbol?"},
           "cljs.repl.browser/constrain-order" {:ns "cljs.repl.browser",
                                                :name "constrain-order",
                                                :signature ["[order f]"],
                                                :name-encode "constrain-order",
                                                :history [["+"
                                                           "0.0-927"]],
                                                :type "function",
                                                :full-name-encode "cljs.repl.browser/constrain-order",
                                                :source {:code "(defn constrain-order\n  [order f]\n  (send-off ordering add-in-order order f)\n  (send-off ordering run-in-order))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/repl/browser.clj",
                                                         :lines [144
                                                                 149]},
                                                :full-name "cljs.repl.browser/constrain-order",
                                                :docstring "Elements to be printed in the REPL will arrive out of order. Ensure\nthat they are printed in the correct order."},
           "cljs.core/case*" {:ns "cljs.core",
                              :name "case*",
                              :type "special form",
                              :source {:code "(defmethod parse 'case*\n  [op env [_ sym tests thens default :as form] name _]\n  (assert (symbol? sym) \"case* must switch on symbol\")\n  (assert (every? vector? tests) \"case* tests must be grouped in vectors\")\n  (let [expr-env (assoc env :context :expr)\n        v        (disallowing-recur (analyze expr-env sym))\n        tests    (mapv #(mapv (fn [t] (analyze expr-env t)) %) tests)\n        thens    (mapv #(analyze env %) thens)\n        default  (analyze env default)]\n    (assert (every? (fn [t] (and (= :constant (:op t))\n                              ((some-fn number? string? char?) (:form t))))\n              (apply concat tests))\n      \"case* tests must be numbers or strings\")\n    {:env env :op :case* :form form\n     :v v :tests tests :thens thens :default default\n     :children (vec (concat [v] tests thens (if default [default])))}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [575 590]},
                              :extra-sources ({:code "(defmethod emit* :case*\n  [{:keys [v tests thens default env]}]\n  (when (= (:context env) :expr)\n    (emitln \"(function(){\"))\n  (let [gs (gensym \"caseval__\")]\n    (when (= :expr (:context env))\n      (emitln \"var \" gs \";\"))\n    (emitln \"switch (\" v \") {\")\n    (doseq [[ts then] (partition 2 (interleave tests thens))]\n      (doseq [test ts]\n        (emitln \"case \" test \":\"))\n      (if (= :expr (:context env))\n        (emitln gs \"=\" then)\n        (emitln then))\n      (emitln \"break;\"))\n    (when default\n      (emitln \"default:\")\n      (if (= :expr (:context env))\n        (emitln gs \"=\" default)\n        (emitln default)))\n    (emitln \"}\")\n    (when (= :expr (:context env))\n      (emitln \"return \" gs \";})()\"))))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [380 402]}),
                              :full-name "cljs.core/case*",
                              :full-name-encode "cljs.core/caseSTAR",
                              :name-encode "caseSTAR",
                              :history [["+" "0.0-2227"]]},
           "cljs.core/js-debugger" {:ns "cljs.core",
                                    :name "js-debugger",
                                    :signature ["[]"],
                                    :name-encode "js-debugger",
                                    :type "macro",
                                    :full-name-encode "cljs.core/js-debugger",
                                    :source {:code "(defmacro js-debugger []\n  (core/list 'js* \"debugger;\"))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [293 294]},
                                    :full-name "cljs.core/js-debugger",
                                    :history [["+" "0.0-2496"]]},
           "cljs.repl/default-special-fns" {:ns "cljs.repl",
                                            :name "default-special-fns",
                                            :name-encode "default-special-fns",
                                            :type "var",
                                            :full-name-encode "cljs.repl/default-special-fns",
                                            :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n         (when-not (and (= quote 'quote) (symbol? ns-name))\n           (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n         (when-not (ana/get-namespace ns-name)\n           (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n           (-evaluate repl-env \"<cljs repl>\" 1\n             (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n         (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require-macros\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n         (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [275 336]},
                                            :full-name "cljs.repl/default-special-fns",
                                            :history [["+" "0.0-993"]]},
           "cljs.core/format" {:ns "cljs.core",
                               :name "format",
                               :signature ["[fmt & args]"],
                               :name-encode "format",
                               :history [["+" "0.0-1443"]
                                         ["-" "0.0-1885"]],
                               :type "function",
                               :full-name-encode "cljs.core/format",
                               :source {:code "(defn format\n  [fmt & args]\n  (apply gstring/format fmt args))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1878",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1771 1774]},
                               :full-name "cljs.core/format",
                               :docstring "Formats a string using goog.string.format.",
                               :removed {:in "0.0-1885",
                                         :last-seen "0.0-1878"}},
           "cljs.core/sorted-set" {:ns "cljs.core",
                                   :name "sorted-set",
                                   :signature ["[& keys]"],
                                   :name-encode "sorted-set",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/sorted-set",
                                   :source {:code "(defn sorted-set\n  ([& keys]\n   (reduce -conj (.-EMPTY PersistentTreeSet) keys)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7603 7606]},
                                   :full-name "cljs.core/sorted-set",
                                   :docstring "Returns a new sorted set with supplied keys."},
           "cljs.core/fnil" {:ns "cljs.core",
                             :name "fnil",
                             :signature ["[f x]"
                                         "[f x y]"
                                         "[f x y z]"],
                             :name-encode "fnil",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/fnil",
                             :source {:code "(defn fnil\n  ([f x]\n   (fn\n     ([a] (f (if (nil? a) x a)))\n     ([a b] (f (if (nil? a) x a) b))\n     ([a b c] (f (if (nil? a) x a) b c))\n     ([a b c & ds] (apply f (if (nil? a) x a) b c ds))))\n  ([f x y]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) c))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) c ds))))\n  ([f x y z]\n   (fn\n     ([a b] (f (if (nil? a) x a) (if (nil? b) y b)))\n     ([a b c] (f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c)))\n     ([a b c & ds] (apply f (if (nil? a) x a) (if (nil? b) y b) (if (nil? c) z c) ds)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3401 3422]},
                             :full-name "cljs.core/fnil",
                             :docstring "Takes a function f, and returns a function that calls f, replacing\na nil first argument to f with the supplied value x. Higher arity\nversions can replace arguments in the second and third\npositions (y, z). Note that the function f can take any number of\narguments, not just the one(s) being nil-patched."},
           "cljs.core/update" {:ns "cljs.core",
                               :name "update",
                               :signature ["[m k f]"
                                           "[m k f x]"
                                           "[m k f x y]"
                                           "[m k f x y z]"
                                           "[m k f x y z & more]"],
                               :name-encode "update",
                               :history [["+" "0.0-2411"]],
                               :type "function",
                               :full-name-encode "cljs.core/update",
                               :source {:code "(defn update\n  ([m k f]\n   (assoc m k (f (get m k))))\n  ([m k f x]\n   (assoc m k (f (get m k) x)))\n  ([m k f x y]\n   (assoc m k (f (get m k) x y)))\n  ([m k f x y z]\n   (assoc m k (f (get m k) x y z)))\n  ([m k f x y z & more]\n   (assoc m k (apply f (get m k) x y z more))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4135 4149]},
                               :full-name "cljs.core/update",
                               :docstring "'Updates' a value in an associative structure, where k is a\nkey and f is a function that will take the old value\nand any supplied args and return the new value, and returns a new\nstructure.  If the key does not exist, nil is passed as the old value."},
           "warnings/fn-arity" {:ns "warnings",
                                :name "fn-arity",
                                :type "warning",
                                :full-name "warnings/fn-arity",
                                :full-name-encode "warnings/fn-arity",
                                :name-encode "fn-arity",
                                :history [["+" "0.0-1853"]]},
           "cljs.core/this-as" {:ns "cljs.core",
                                :name "this-as",
                                :signature ["[name & body]"],
                                :name-encode "this-as",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/this-as",
                                :source {:code "(defmacro this-as\n  [name & body]\n  `(let [~name (js-this)]\n     ~@body))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [644 648]},
                                :full-name "cljs.core/this-as",
                                :docstring "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided."},
           "cljs.repl.rhino/rhino-eval" {:ns "cljs.repl.rhino",
                                         :name "rhino-eval",
                                         :signature ["[repl-env filename line js]"],
                                         :name-encode "rhino-eval",
                                         :type "function",
                                         :full-name-encode "cljs.repl.rhino/rhino-eval",
                                         :source {:code "(defn rhino-eval\n  [repl-env filename line js]\n  (try\n    (let [linenum (or line Integer/MIN_VALUE)]\n      {:status :success\n       :value (eval-result (-eval js repl-env filename linenum))})\n    (catch Throwable ex\n      {:status :exception\n       :value (.toString ex)\n       :stacktrace (stacktrace ex)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [67 76]},
                                         :full-name "cljs.repl.rhino/rhino-eval",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueueSeq" {:protocols #{"ISeqable"
                                                        "IMeta"
                                                        "IWithMeta"
                                                        "IEmptyableCollection"
                                                        "ISequential"
                                                        "ISeq"
                                                        "ICollection"
                                                        "IHash"
                                                        "IPrintWithWriter"
                                                        "IEquiv"},
                                           :ns "cljs.core",
                                           :name "PersistentQueueSeq",
                                           :signature ["[meta front rear __hash]"],
                                           :name-encode "PersistentQueueSeq",
                                           :history [["+" "0.0-927"]],
                                           :type "type",
                                           :full-name-encode "cljs.core/PersistentQueueSeq",
                                           :source {:code "(deftype PersistentQueueSeq [meta front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueueSeq. meta front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest  [coll]\n    (if-let [f1 (next front)]\n      (PersistentQueueSeq. meta f1 rear nil)\n      (if (nil? rear)\n        (-empty coll)\n        (PersistentQueueSeq. meta rear nil nil))))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [4879 4915]},
                                           :full-name "cljs.core/PersistentQueueSeq"},
           "cljs.core/counted?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "counted?",
                                 :signature ["[x]"],
                                 :name-encode "countedQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/countedQMARK",
                                 :source {:code "(defn ^boolean counted?\n  [x] (satisfies? ICounted x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [986 988]},
                                 :full-name "cljs.core/counted?",
                                 :docstring "Returns true if coll implements count in constant time"},
           "compiler-options/use-only-custom-externs" {:ns "compiler-options",
                                                       :name "use-only-custom-externs",
                                                       :name-encode "use-only-custom-externs",
                                                       :type "option",
                                                       :full-name-encode "compiler-options/use-only-custom-externs",
                                                       :full-name "compiler-options/use-only-custom-externs",
                                                       :history [["+"
                                                                  "0.0-971"]]},
           "cljs.repl.browser/read-headers" {:ns "cljs.repl.browser",
                                             :name "read-headers",
                                             :signature ["[rdr]"],
                                             :name-encode "read-headers",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/read-headers",
                                             :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr)\n         header-lines []]\n    (if (= \"\" next-line)\n      header-lines                      ;we're done reading headers\n      (recur (.readLine rdr) (conj header-lines next-line)))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [136 141]},
                                             :full-name "cljs.repl.browser/read-headers",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "clojure.string/trimr" {:ns "clojure.string",
                                   :name "trimr",
                                   :signature ["[s]"],
                                   :name-encode "trimr",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/trimr",
                                   :source {:code "(defn trimr\n    [s]\n    (gstring/trimRight s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [157 160]},
                                   :full-name "clojure.string/trimr",
                                   :docstring "Removes whitespace from the right side of string."},
           "clojure.core.reducers/take" {:ns "clojure.core.reducers",
                                         :name "take",
                                         :signature ["[n]" "[n coll]"],
                                         :name-encode "take",
                                         :history [["+" "0.0-1236"]],
                                         :type "function",
                                         :full-name-encode "clojure.core.reducers/take",
                                         :source {:code "(defcurried take\n  \"Ends the reduction of coll after consuming n values.\"\n  {}\n  [n coll]\n  (reducer coll\n   (fn [f1]\n     (let [cnt (atom n)]\n       (rfn [f1 k]\n         ([ret k v]\n            (swap! cnt dec)\n            (if (neg? @cnt)\n              (reduced ret)\n              (f1 ret k v))))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/clojure/core/reducers.cljs",
                                                  :lines [164 176]},
                                         :full-name "clojure.core.reducers/take",
                                         :docstring "Ends the reduction of coll after consuming n values."},
           "cljs.repl/IReplEnvOptions" {:ns "cljs.repl",
                                        :name "IReplEnvOptions",
                                        :name-encode "IReplEnvOptions",
                                        :type "protocol",
                                        :full-name-encode "cljs.repl/IReplEnvOptions",
                                        :source {:code "(defprotocol IReplEnvOptions\n  (-repl-options [this] \"Return default REPL options for a REPL Env\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [90 91]},
                                        :methods [{:name "-repl-options",
                                                   :signature ["[this]"],
                                                   :docstring "Return default REPL options for a REPL Env"}],
                                        :full-name "cljs.repl/IReplEnvOptions",
                                        :history [["+" "0.0-2719"]]},
           "cljs.core/force" {:ns "cljs.core",
                              :name "force",
                              :signature ["[x]"],
                              :name-encode "force",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/force",
                              :source {:code "(defn force\n  [x]\n  (if (delay? x)\n    (deref x)\n    x))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8535 8540]},
                              :full-name "cljs.core/force",
                              :docstring "If x is a Delay, returns the (possibly cached) value of its expression, else returns x"},
           "cljs.core/compare-and-set!" {:ns "cljs.core",
                                         :name "compare-and-set!",
                                         :signature ["[a oldval newval]"],
                                         :name-encode "compare-and-setBANG",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/compare-and-setBANG",
                                         :source {:code "(defn compare-and-set!\n  [^not-native a oldval newval]\n  (if (= (-deref a) oldval)\n    (do (reset! a newval) true)\n    false))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [3572 3579]},
                                         :full-name "cljs.core/compare-and-set!",
                                         :docstring "Atomically sets the value of atom to newval if and only if the\ncurrent value of the atom is equal to oldval. Returns true if\nset happened, else false."},
           "cljs.core/set?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "set?",
                             :signature ["[x]"],
                             :name-encode "setQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/setQMARK",
                             :source {:code "(defn ^boolean set?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? ISet x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1507 1512]},
                             :full-name "cljs.core/set?",
                             :docstring "Returns true if x satisfies ISet"},
           "cljs.core/hash-string" {:ns "cljs.core",
                                    :name "hash-string",
                                    :signature ["[k]"],
                                    :name-encode "hash-string",
                                    :type "function",
                                    :full-name-encode "cljs.core/hash-string",
                                    :source {:code "(defn hash-string [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [530 537]},
                                    :full-name "cljs.core/hash-string",
                                    :history [["+" "0.0-2261"]]},
           "cljs.repl.server/set-connection" {:ns "cljs.repl.server",
                                              :name "set-connection",
                                              :signature ["[conn]"],
                                              :name-encode "set-connection",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/set-connection",
                                              :source {:code "(defn set-connection\n  [conn]\n  (if-let [promised-conn (:promised-conn @state)]\n    (do\n      (swap! state\n        (fn [old]\n          (-> old\n            (assoc :connection nil)\n            (assoc :promised-conn nil))))\n      (deliver promised-conn conn))\n    (swap! state (fn [old] (assoc old :connection conn)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/repl/server.clj",
                                                       :lines [28 41]},
                                              :full-name "cljs.repl.server/set-connection",
                                              :docstring "Given a new available connection, either use it to deliver the\nconnection which was promised or store the connection for later\nuse."},
           "cljs.core/load-file" {:ns "cljs.core",
                                  :name "load-file",
                                  :name-encode "load-file",
                                  :type "special form (repl)",
                                  :full-name-encode "cljs.core/load-file",
                                  :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n         (when-not (and (= quote 'quote) (symbol? ns-name))\n           (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n         (when-not (ana/get-namespace ns-name)\n           (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n           (-evaluate repl-env \"<cljs repl>\" 1\n             (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n         (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require-macros\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n         (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))}))",
                                           :title "repl specials table",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [275 336]},
                                  :full-name "cljs.core/load-file",
                                  :repl-only? true,
                                  :history [["+" "0.0-927"]]},
           "syntax/unquote-splicing" {:syntax-equiv {:edn-url nil,
                                                     :clj-url nil},
                                      :ns "syntax",
                                      :name "unquote-splicing",
                                      :name-encode "unquote-splicing",
                                      :type "syntax",
                                      :full-name-encode "syntax/unquote-splicing",
                                      :extra-sources ({:code "(defn- read-unquote\n  [rdr comma]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~))))",
                                                       :title "Reader code",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-0.8.10",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [447
                                                               452]}
                                                      {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                       :title "Reader table",
                                                       :repo "tools.reader",
                                                       :tag "tools.reader-0.8.10",
                                                       :filename "src/main/clojure/clojure/tools/reader.clj",
                                                       :lines [591
                                                               610]}),
                                      :full-name "syntax/unquote-splicing",
                                      :history [["+" "0.0-1853"]]},
           "cljs.core/unchecked-dec" {:ns "cljs.core",
                                      :name "unchecked-dec",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-dec",
                                      :history [["+" "0.0-1798"]],
                                      :type "function/macro",
                                      :full-name-encode "cljs.core/unchecked-dec",
                                      :source {:code "(defn unchecked-dec [x]\n  (cljs.core/unchecked-dec x))",
                                               :title "Function code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [1969 1970]},
                                      :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-dec\n  ([x] `(dec ~x)))",
                                                       :title "Macro code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/core.clj",
                                                       :lines [378
                                                               379]}],
                                      :full-name "cljs.core/unchecked-dec"},
           "cljs.core/PersistentVector.EMPTY-NODE" {:ns "cljs.core",
                                                    :name "PersistentVector.EMPTY-NODE",
                                                    :name-encode "PersistentVectorDOTEMPTY-NODE",
                                                    :parent-type "PersistentVector",
                                                    :type "var",
                                                    :full-name-encode "cljs.core/PersistentVectorDOTEMPTY-NODE",
                                                    :source {:code "(set! (.-EMPTY-NODE PersistentVector) (VectorNode. nil (make-array 32)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [4454]},
                                                    :full-name "cljs.core/PersistentVector.EMPTY-NODE",
                                                    :history [["+"
                                                               "0.0-2301"]]},
           "clojure.string/escape" {:ns "clojure.string",
                                    :name "escape",
                                    :signature ["[s cmap]"],
                                    :name-encode "escape",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/escape",
                                    :source {:code "(defn escape\n  [s cmap]\n  (let [buffer (StringBuffer.)\n        length (.-length s)]\n    (loop [index 0]\n      (if (= length index)\n        (. buffer (toString))\n        (let [ch (.charAt s index)]\n          (if-let [replacement (get cmap ch)]\n            (.append buffer (str replacement))\n            (.append buffer ch))\n          (recur (inc index)))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [179 195]},
                                    :full-name "clojure.string/escape",
                                    :docstring "Return a new string, using cmap to escape each character ch\nfrom s as follows:\n\nIf (cmap ch) is nil, append ch to the new string.\nIf (cmap ch) is non-nil, append (str (cmap ch)) instead."},
           "cljs.core/remove-watch" {:ns "cljs.core",
                                     :name "remove-watch",
                                     :signature ["[iref key]"],
                                     :name-encode "remove-watch",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/remove-watch",
                                     :source {:code "(defn remove-watch\n  [iref key]\n  (-remove-watch iref key)\n  iref)",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [8490 8496]},
                                     :full-name "cljs.core/remove-watch",
                                     :docstring "Alpha - subject to change.\n\nRemoves a watch (set by add-watch) from a reference"},
           "cljs.core/m3-hash-unencoded-chars" {:return-type number,
                                                :ns "cljs.core",
                                                :name "m3-hash-unencoded-chars",
                                                :signature ["[in]"],
                                                :name-encode "m3-hash-unencoded-chars",
                                                :history [["+"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/m3-hash-unencoded-chars",
                                                :source {:code "(defn ^number m3-hash-unencoded-chars [in]\n  (let [h1 (loop [i 1 h1 m3-seed]\n             (if (< i (alength in))\n               (recur (+ i 2)\n                 (m3-mix-H1 h1\n                   (m3-mix-K1\n                     (bit-or (.charCodeAt in (dec i))\n                       (bit-shift-left (.charCodeAt in i) 16)))))\n               h1))\n        h1 (if (== (bit-and (alength in) 1) 1)\n             (bit-xor h1 (m3-mix-K1 (.charCodeAt in (dec (alength in)))))\n             h1)]\n    (m3-fmix h1 (imul 2 (alength in)))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [490
                                                                 502]},
                                                :full-name "cljs.core/m3-hash-unencoded-chars"},
           "closure-warnings/check-useless-code" {:ns "closure-warnings",
                                                  :name "check-useless-code",
                                                  :type "warning",
                                                  :full-name "closure-warnings/check-useless-code",
                                                  :full-name-encode "closure-warnings/check-useless-code",
                                                  :name-encode "check-useless-code",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "syntax/true" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "true",
                          :name-encode "true",
                          :type "special symbol",
                          :full-name-encode "syntax/true",
                          :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [275 301]}),
                          :full-name "syntax/true",
                          :history [["+" "0.0-1853"]]},
           "cljs.core/es6-iterator-seq" {:ns "cljs.core",
                                         :name "es6-iterator-seq",
                                         :signature ["[iter]"],
                                         :name-encode "es6-iterator-seq",
                                         :type "function",
                                         :full-name-encode "cljs.core/es6-iterator-seq",
                                         :source {:code "(defn es6-iterator-seq [iter]\n  (let [v (.next iter)]\n    (if (.-done v)\n      ()\n      (ES6IteratorSeq. (.-value v) iter nil))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [801 805]},
                                         :full-name "cljs.core/es6-iterator-seq",
                                         :history [["+" "0.0-2411"]]},
           "cljs.core/IMultiFn" {:ns "cljs.core",
                                 :name "IMultiFn",
                                 :name-encode "IMultiFn",
                                 :implementations #{"MultiFn"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/IMultiFn",
                                 :source {:code "(defprotocol IMultiFn\n  (-reset [mf])\n  (-add-method [mf dispatch-val method])\n  (-remove-method [mf dispatch-val])\n  (-prefer-method [mf dispatch-val dispatch-val-y])\n  (-get-method [mf dispatch-val])\n  (-methods [mf])\n  (-prefers [mf]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8918 8925]},
                                 :methods [{:name "-reset",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-add-method",
                                            :signature ["[mf dispatch-val method]"],
                                            :docstring nil}
                                           {:name "-remove-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-prefer-method",
                                            :signature ["[mf dispatch-val dispatch-val-y]"],
                                            :docstring nil}
                                           {:name "-get-method",
                                            :signature ["[mf dispatch-val]"],
                                            :docstring nil}
                                           {:name "-methods",
                                            :signature ["[mf]"],
                                            :docstring nil}
                                           {:name "-prefers",
                                            :signature ["[mf]"],
                                            :docstring nil}],
                                 :full-name "cljs.core/IMultiFn"},
           "clojure.browser.event/IEventType" {:ns "clojure.browser.event",
                                               :name "IEventType",
                                               :name-encode "IEventType",
                                               :type "protocol",
                                               :full-name-encode "clojure.browser.event/IEventType",
                                               :source {:code "(defprotocol IEventType\n  (event-types [this]))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/clojure/browser/event.cljs",
                                                        :lines [16 17]},
                                               :methods [{:name "event-types",
                                                          :signature ["[this]"],
                                                          :docstring nil}],
                                               :full-name "clojure.browser.event/IEventType",
                                               :history [["+"
                                                          "0.0-2301"]]},
           "clojure.zip/end?" {:ns "clojure.zip",
                               :name "end?",
                               :signature ["[loc]"],
                               :name-encode "endQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/endQMARK",
                               :source {:code "(defn end?\n  [loc]\n    (= :end (loc 1)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [232 235]},
                               :full-name "clojure.zip/end?",
                               :docstring "Returns true if loc represents the end of a depth-first walk"},
           "cljs.test/clear-env!" {:ns "cljs.test",
                                   :name "clear-env!",
                                   :signature ["[]"],
                                   :name-encode "clear-envBANG",
                                   :type "function",
                                   :full-name-encode "cljs.test/clear-envBANG",
                                   :source {:code "(defn clear-env! []\n  (set! *current-env* nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/test.cljs",
                                            :lines [235 236]},
                                   :full-name "cljs.test/clear-env!",
                                   :history [["+" "0.0-2496"]]},
           "cljs.analyzer.api/ns-resolve" {:ns "cljs.analyzer.api",
                                           :name "ns-resolve",
                                           :signature ["[ns sym]"],
                                           :name-encode "ns-resolve",
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-resolve",
                                           :source {:code "(defn ns-resolve\n  [ns sym]\n  {:pre [(symbol? ns) (symbol? sym)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :defs sym]))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/analyzer/api.clj",
                                                    :lines [44 49]},
                                           :full-name "cljs.analyzer.api/ns-resolve",
                                           :docstring "Given a namespace and a symbol return the corresponding var analysis map.\nAnalagous to clojure.core/ns-resolve but returns var analysis map not Var."},
           "cljs.repl/update-require-spec" {:ns "cljs.repl",
                                            :name "update-require-spec",
                                            :signature ["[specs & additions]"],
                                            :name-encode "update-require-spec",
                                            :history [["+" "0.0-2629"]
                                                      ["-" "0.0-2655"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl/update-require-spec",
                                            :source {:code "(defn update-require-spec\n  [specs & additions]\n  (let [[before [requires & other-specs]]\n        (split-with\n          (fn [[x _]] (not= :require x))\n          specs)\n        requires'\n        `(:require\n           ~@(reduce\n               (fn [requires spec]\n                 (merge-require requires spec))\n               (rest requires)\n               additions))]\n    (concat before [requires'] other-specs)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2644",
                                                     :filename "src/clj/cljs/repl.clj",
                                                     :lines [226 241]},
                                            :full-name "cljs.repl/update-require-spec",
                                            :docstring "Given the specification portion of a ns form and require spec additions\nreturn an updated specification.",
                                            :removed {:in "0.0-2655",
                                                      :last-seen "0.0-2644"}},
           "clojure.set/superset?" {:ns "clojure.set",
                                    :name "superset?",
                                    :signature ["[set1 set2]"],
                                    :name-encode "supersetQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.set/supersetQMARK",
                                    :source {:code "(defn superset? \n  [set1 set2]\n  (and (>= (count set1) (count set2))\n       (every? #(contains? set1 %) set2)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/clojure/set.cljs",
                                             :lines [137 141]},
                                    :full-name "clojure.set/superset?",
                                    :docstring "Is set1 a superset of set2?"},
           "cljs.repl/repl" {:ns "cljs.repl",
                             :name "repl",
                             :signature ["[repl-env & {:as opts}]"],
                             :name-encode "repl",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.repl/repl",
                             :source {:code "(defn repl\n  [repl-env & {:as opts}]\n  (repl* repl-env opts))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/repl.clj",
                                      :lines [426 429]},
                             :full-name "cljs.repl/repl",
                             :docstring "Note - repl will reload core.cljs every time, even if supplied old repl-env"},
           "clojure.browser.net/IConnection" {:ns "clojure.browser.net",
                                              :name "IConnection",
                                              :name-encode "IConnection",
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.net/IConnection",
                                              :source {:code "(defprotocol IConnection\n  (connect\n    [this]\n    [this opt1]\n    [this opt1 opt2]\n    [this opt1 opt2 opt3])\n  (transmit\n    [this opt]\n    [this opt opt2]\n    [this opt opt2 opt3]\n    [this opt opt2 opt3 opt4]\n    [this opt opt2 opt3 opt4 opt5])\n  (close [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [30 42]},
                                              :methods [{:name "connect",
                                                         :signature ["[this]"
                                                                     "[this opt1]"
                                                                     "[this opt1 opt2]"
                                                                     "[this opt1 opt2 opt3]"],
                                                         :docstring nil}
                                                        {:name "transmit",
                                                         :signature ["[this opt]"
                                                                     "[this opt opt2]"
                                                                     "[this opt opt2 opt3]"
                                                                     "[this opt opt2 opt3 opt4]"
                                                                     "[this opt opt2 opt3 opt4 opt5]"],
                                                         :docstring nil}
                                                        {:name "close",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.net/IConnection",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/let" {:ns "cljs.core",
                            :name "let",
                            :signature ["[bindings & body]"],
                            :name-encode "let",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/let",
                            :source {:code "(defmacro let\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (even? (count bindings)) \"an even number of forms in binding vector\")\n  `(let* ~(destructure bindings) ~@body))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [147 157]},
                            :full-name "cljs.core/let",
                            :docstring "binding => binding-form init-expr\n\nEvaluates the exprs in a lexical context in which the symbols in\nthe binding-forms are bound to their respective init-exprs or parts\ntherein."},
           "cljs.core/unchecked-divide-int" {:return-type number,
                                             :ns "cljs.core",
                                             :name "unchecked-divide-int",
                                             :signature ["[x]"
                                                         "[x y]"
                                                         "[x y & more]"],
                                             :name-encode "unchecked-divide-int",
                                             :history [["+"
                                                        "0.0-1798"]],
                                             :type "function/macro",
                                             :full-name-encode "cljs.core/unchecked-divide-int",
                                             :source {:code "(defn ^number unchecked-divide-int\n  ([x] (unchecked-divide-int 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce unchecked-divide-int (unchecked-divide-int x y) more)))",
                                                      :title "Function code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [1975
                                                              1980]},
                                             :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-divide-int\n  ([& xs] `(/ ~@xs)))",
                                                              :title "Macro code",
                                                              :repo "clojurescript",
                                                              :tag "r2760",
                                                              :filename "src/clj/cljs/core.clj",
                                                              :lines [384
                                                                      385]}],
                                             :full-name "cljs.core/unchecked-divide-int",
                                             :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/dorun" {:ns "cljs.core",
                              :name "dorun",
                              :signature ["[coll]" "[n coll]"],
                              :name-encode "dorun",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/dorun",
                              :source {:code "(defn dorun\n  ([coll]\n   (when (seq coll)\n     (recur (next coll))))\n  ([n coll]\n   (when (and (seq coll) (pos? n))\n     (recur (dec n) (next coll)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8029 8040]},
                              :full-name "cljs.core/dorun",
                              :docstring "When lazy sequences are produced via functions that have side\neffects, any effects other than those needed to produce the first\nelement in the seq do not occur until the seq is consumed. dorun can\nbe used to force any effects. Walks through the successive nexts of\nthe seq, does not retain the head and returns nil."},
           "cljs.core/with-redefs" {:ns "cljs.core",
                                    :name "with-redefs",
                                    :signature ["[bindings & body]"],
                                    :name-encode "with-redefs",
                                    :history [["+" "0.0-1806"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/with-redefs",
                                    :source {:code "(defmacro with-redefs\n  [bindings & body]\n  (let [names (take-nth 2 bindings)\n        vals (take-nth 2 (drop 1 bindings))\n        tempnames (map (comp gensym name) names)\n        binds (map core/vector names vals)\n        resets (reverse (map core/vector names tempnames))\n        bind-value (fn [[k v]] (core/list 'set! k v))]\n    `(let [~@(interleave tempnames names)]\n       ~@(map bind-value binds)\n       (try\n         ~@body\n        (finally\n          ~@(map bind-value resets))))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1104 1124]},
                                    :full-name "cljs.core/with-redefs",
                                    :docstring "binding => var-symbol temp-value-expr\n\nTemporarily redefines vars while executing the body.  The\ntemp-value-exprs will be evaluated and each resulting value will\nreplace in parallel the root value of its var.  After the body is\nexecuted, the root values of all the vars will be set back to their\nold values. Useful for mocking out functions during testing."},
           "cljs.core/SeqIter" {:ns "cljs.core",
                                :name "SeqIter",
                                :signature ["[_seq _next]"],
                                :name-encode "SeqIter",
                                :type "type",
                                :full-name-encode "cljs.core/SeqIter",
                                :source {:code "(deftype SeqIter [^:mutable _seq ^:mutable _next]\n  Object\n  (hasNext [_]\n    (if (identical? _seq INIT)\n      (do\n        (set! _seq START)\n        (set! _next (seq _next)))\n      (if (identical? _seq _next)\n        (set! _next (next _seq))))\n    (not (nil? _next)))\n  (next [this]\n    (if-not (.hasNext this)\n      (throw (js/Error. \"No such element\"))\n      (do\n        (set! _seq _next)\n        (first _next))))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3092 3108]},
                                :full-name "cljs.core/SeqIter",
                                :history [["+" "0.0-2301"]]},
           "cljs.core/unsigned-bit-shift-right" {:ns "cljs.core",
                                                 :name "unsigned-bit-shift-right",
                                                 :signature ["[x n]"],
                                                 :name-encode "unsigned-bit-shift-right",
                                                 :history [["+"
                                                            "0.0-2080"]],
                                                 :type "function/macro",
                                                 :full-name-encode "cljs.core/unsigned-bit-shift-right",
                                                 :source {:code "(defn unsigned-bit-shift-right\n  [x n] (cljs.core/unsigned-bit-shift-right x n))",
                                                          :title "Function code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [2143
                                                                  2145]},
                                                 :extra-sources [{:code "(defmacro ^::ana/numeric unsigned-bit-shift-right [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                  :title "Macro code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2760",
                                                                  :filename "src/clj/cljs/core.clj",
                                                                  :lines [535
                                                                          536]}],
                                                 :full-name "cljs.core/unsigned-bit-shift-right",
                                                 :docstring "Bitwise shift right with zero fill"},
           "cljs.core/iterable?" {:ns "cljs.core",
                                  :name "iterable?",
                                  :signature ["[x]"],
                                  :name-encode "iterableQMARK",
                                  :type "function",
                                  :full-name-encode "cljs.core/iterableQMARK",
                                  :source {:code "(defn iterable? [x]\n  (satisfies? IIterable x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [693 694]},
                                  :full-name "cljs.core/iterable?",
                                  :history [["+" "0.0-2356"]]},
           "cljs.core/pr-str" {:ns "cljs.core",
                               :name "pr-str",
                               :signature ["[& objs]"],
                               :name-encode "pr-str",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/pr-str",
                               :source {:code "(defn pr-str\n  [& objs]\n  (pr-str-with-opts objs (pr-opts)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8267 8270]},
                               :full-name "cljs.core/pr-str",
                               :docstring "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter."},
           "cljs.core/IPrintable" {:ns "cljs.core",
                                   :name "IPrintable",
                                   :name-encode "IPrintable",
                                   :implementations #{"Subvec"
                                                      "boolean"
                                                      "string"
                                                      "PersistentQueue"
                                                      "PersistentHashMap"
                                                      "PersistentTreeSet"
                                                      "js/Date"
                                                      "RedNode"
                                                      "EmptyList"
                                                      "ObjMap"
                                                      "BlackNode"
                                                      "PersistentVector"
                                                      "ChunkedCons"
                                                      "Range"
                                                      "ChunkedSeq"
                                                      "ArrayNodeSeq"
                                                      "IndexedSeq"
                                                      "number"
                                                      "PersistentTreeMap"
                                                      "PersistentTreeMapSeq"
                                                      "RSeq"
                                                      "Vector"
                                                      "function"
                                                      "PersistentArrayMap"
                                                      "PersistentHashSet"
                                                      "HashMap"
                                                      "NodeSeq"
                                                      "List"
                                                      "Atom"
                                                      "nil"
                                                      "Cons"
                                                      "LazySeq"
                                                      "array"
                                                      "UUID"},
                                   :history [["+" "0.0-927"]
                                             ["-" "0.0-1798"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/IPrintable",
                                   :source {:code "(defprotocol ^:deprecated IPrintable\n  \"Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.\"\n  (-pr-seq [o opts]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r1586",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [253 257]},
                                   :methods [{:name "-pr-seq",
                                              :signature ["[o opts]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/IPrintable",
                                   :docstring "Do not use this.  It is kept for backwards compatibility with existing\n   user code that depends on it, but it has been superceded by IPrintWithWriter\n   User code that depends on this should be changed to use -pr-writer instead.",
                                   :removed {:in "0.0-1798",
                                             :last-seen "0.0-1586"}},
           "cljs.build.api/src-file->target-file" {:return-type File,
                                                   :ns "cljs.build.api",
                                                   :name "src-file->target-file",
                                                   :signature ["[src]"
                                                               "[src opts]"],
                                                   :name-encode "src-file-GTtarget-file",
                                                   :history [["+"
                                                              "0.0-2629"]],
                                                   :type "function",
                                                   :full-name-encode "cljs.build.api/src-file-GTtarget-file",
                                                   :source {:code "(defn ^File src-file->target-file\n  ([src] (closure/src-file->target-file src))\n  ([src opts] (closure/src-file->target-file src opts)))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/clj/cljs/build/api.clj",
                                                            :lines [80
                                                                    84]},
                                                   :full-name "cljs.build.api/src-file->target-file",
                                                   :docstring "Given a ClojureScript source file return the target file. May optionally\nprovide build options with :output-dir specified."},
           "cljs.core/defprotocol" {:ns "cljs.core",
                                    :name "defprotocol",
                                    :signature ["[psym & doc+methods]"],
                                    :name-encode "defprotocol",
                                    :type "macro",
                                    :full-name-encode "cljs.core/defprotocol",
                                    :source {:code "(defmacro defprotocol [psym & doc+methods]\n  (let [p (:name (cljs.analyzer/resolve-var (dissoc &env :locals) psym))\n        psym (vary-meta psym assoc :protocol-symbol true)\n        ns-name (-> &env :ns :name)\n        fqn (fn [n] (symbol (core/str ns-name \".\" n)))\n        prefix (protocol-prefix p)\n        methods (if (core/string? (first doc+methods)) (next doc+methods) doc+methods)\n        _ (core/doseq [[mname & arities] methods]\n            (when (some #{0} (map count (filter vector? arities)))\n              (throw (Exception. (core/str \"Invalid protocol, \" psym \" defines method \" mname \" with arity 0\")))))\n        expand-sig (fn [fname slot sig]\n                     `(~sig\n                       (if (and ~(first sig) (. ~(first sig) ~(symbol (core/str \"-\" slot)))) ;; Property access needed here.\n                         (. ~(first sig) ~slot ~@sig)\n                         (let [x# (if (nil? ~(first sig)) nil ~(first sig))]\n                           ((or\n                             (aget ~(fqn fname) (goog/typeOf x#))\n                             (aget ~(fqn fname) \"_\")\n                             (throw (missing-protocol\n                                     ~(core/str psym \".\" fname) ~(first sig))))\n                            ~@sig)))))\n        psym   (vary-meta psym assoc-in [:protocol-info :methods]\n                 (into {}\n                   (map\n                     (fn [[fname & sigs]]\n                       (let [sigs (take-while vector? sigs)]\n                         [fname (vec sigs)]))\n                     methods)))\n        method (fn [[fname & sigs]]\n                 (let [sigs (take-while vector? sigs)\n                       slot (symbol (core/str prefix (name fname)))\n                       fname (vary-meta fname assoc :protocol p)]\n                   `(defn ~fname ~@(map (fn [sig]\n                                          (expand-sig fname\n                                                      (symbol (core/str slot \"$arity$\" (count sig)))\n                                                      sig))\n                                        sigs))))]\n    `(do\n       (set! ~'*unchecked-if* true)\n       (def ~psym (js-obj))\n       ~@(map method methods)\n       (set! ~'*unchecked-if* false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1009 1050]},
                                    :full-name "cljs.core/defprotocol",
                                    :history [["+" "0.0-927"]]},
           "warnings/protocol-duped-method" {:ns "warnings",
                                             :name "protocol-duped-method",
                                             :type "warning",
                                             :full-name "warnings/protocol-duped-method",
                                             :full-name-encode "warnings/protocol-duped-method",
                                             :name-encode "protocol-duped-method",
                                             :history [["+"
                                                        "0.0-2341"]]},
           "cljs.core/ints" {:ns "cljs.core",
                             :name "ints",
                             :signature ["[x]"],
                             :name-encode "ints",
                             :type "function",
                             :full-name-encode "cljs.core/ints",
                             :source {:code "(defn ints [x] x)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2056]},
                             :full-name "cljs.core/ints",
                             :history [["+" "0.0-1798"]]},
           "cljs.core/assert" {:ns "cljs.core",
                               :name "assert",
                               :signature ["[x]" "[x message]"],
                               :name-encode "assert",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/assert",
                               :source {:code "(defmacro assert\n  ([x]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" (cljs.core/pr-str '~x)))))))\n  ([x message]\n     (when *assert*\n       `(when-not ~x\n          (throw (js/Error.\n                  (cljs.core/str \"Assert failed: \" ~message \"\\n\" (cljs.core/pr-str '~x))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [1240 1252]},
                               :full-name "cljs.core/assert",
                               :docstring "Evaluates expr and throws an exception if it does not evaluate to\nlogical true."},
           "cljs.core/declare" {:ns "cljs.core",
                                :name "declare",
                                :signature ["[& names]"],
                                :name-encode "declare",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/declare",
                                :source {:code "(defmacro declare\n  [& names] `(do ~@(map #(list 'def (vary-meta % assoc :declared true)) names)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [2795 2798]},
                                :full-name "cljs.core/declare",
                                :docstring "defs the supplied var names with no bindings, useful for making forward declarations."},
           "cljs.core/PersistentTreeMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeMap.EMPTY",
                                                :name-encode "PersistentTreeMapDOTEMPTY",
                                                :parent-type "PersistentTreeMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeMap) (PersistentTreeMap. compare nil 0 nil empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [7122]},
                                                :full-name "cljs.core/PersistentTreeMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/fn?" {:return-type boolean,
                            :ns "cljs.core",
                            :name "fn?",
                            :signature ["[f]"],
                            :name-encode "fnQMARK",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/fnQMARK",
                            :source {:code "(defn ^boolean fn? [f]\n  (or ^boolean (goog/isFunction f) (satisfies? Fn f)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1393 1394]},
                            :full-name "cljs.core/fn?"},
           "cljs.core/associative?" {:return-type boolean,
                                     :ns "cljs.core",
                                     :name "associative?",
                                     :signature ["[x]"],
                                     :name-encode "associativeQMARK",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/associativeQMARK",
                                     :source {:code "(defn ^boolean associative?\n  [x] (satisfies? IAssociative x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1514 1516]},
                                     :full-name "cljs.core/associative?",
                                     :docstring "Returns true if coll implements Associative"},
           "cljs.repl.rhino/load-javascript" {:ns "cljs.repl.rhino",
                                              :name "load-javascript",
                                              :signature ["[repl-env ns url]"],
                                              :name-encode "load-javascript",
                                              :type "function",
                                              :full-name-encode "cljs.repl.rhino/load-javascript",
                                              :source {:code "(defn load-javascript [repl-env ns url]\n  (try\n    (with-open [reader (io/reader url)]\n      (-eval reader repl-env (.toString url) 1))\n    ;; TODO: don't show errors for goog/base.js line number 105\n    (catch Throwable ex (println (.getMessage ex)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/repl/rhino.clj",
                                                       :lines [111
                                                               116]},
                                              :full-name "cljs.repl.rhino/load-javascript",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/IList" {:ns "cljs.core",
                              :name "IList",
                              :name-encode "IList",
                              :implementations #{"EmptyList"
                                                 "List"
                                                 "Cons"},
                              :history [["+" "0.0-1211"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IList",
                              :source {:code "(defprotocol IList\n  \"Marker interface indicating a persistent list\")",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [338 339]},
                              :full-name "cljs.core/IList",
                              :docstring "Marker interface indicating a persistent list"},
           "cljs.core/list*" {:ns "cljs.core",
                              :name "list*",
                              :signature ["[args]"
                                          "[a args]"
                                          "[a b args]"
                                          "[a b c args]"
                                          "[a b c d & more]"],
                              :name-encode "listSTAR",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/listSTAR",
                              :source {:code "(defn list*\n  ([args] (seq args))\n  ([a args] (cons a args))\n  ([a b args] (cons a (cons b args)))\n  ([a b c args] (cons a (cons b (cons c args))))\n  ([a b c d & more]\n     (cons a (cons b (cons c (cons d (spread more)))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2898 2906]},
                              :full-name "cljs.core/list*",
                              :docstring "Creates a new list containing the items prepended to the rest, the\nlast of which will be treated as a sequence."},
           "cljs.core/PersistentArrayMap.fromArray" {:ns "cljs.core",
                                                     :name "PersistentArrayMap.fromArray",
                                                     :signature ["[arr no-clone no-check]"],
                                                     :name-encode "PersistentArrayMapDOTfromArray",
                                                     :history [["+"
                                                                "0.0-1798"]],
                                                     :parent-type "PersistentArrayMap",
                                                     :type "function",
                                                     :full-name-encode "cljs.core/PersistentArrayMapDOTfromArray",
                                                     :source {:code "(set! (.-fromArray PersistentArrayMap)\n  (fn [arr ^boolean no-clone ^boolean no-check]\n    (let [arr (if no-clone arr (aclone arr))]\n      (if no-check\n        (let [cnt (/ (alength arr) 2)]\n          (PersistentArrayMap. nil cnt arr nil))\n        (let [len (alength arr)]\n          (loop [i 0\n                 ret (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (+ i 2)\n                (-assoc! ret (aget arr i) (aget arr (inc i))))\n              (-persistent! ret))))))))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2760",
                                                              :filename "src/cljs/cljs/core.cljs",
                                                              :lines [5491
                                                                      5503]},
                                                     :full-name "cljs.core/PersistentArrayMap.fromArray"},
           "cljs.core/reduce" {:ns "cljs.core",
                               :name "reduce",
                               :signature ["[f coll]" "[f val coll]"],
                               :name-encode "reduce",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/reduce",
                               :source {:code "(defn reduce\n  ([f coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f)\n\n       (array? coll)\n       (array-reduce coll f)\n\n       (string? coll)\n       (array-reduce coll f)\n       \n       (native-satisfies? IReduce coll)\n       (-reduce coll f)\n\n       :else\n       (seq-reduce f coll)))\n  ([f val coll]\n     (cond\n       (implements? IReduce coll)\n       (-reduce ^not-native coll f val)\n\n       (array? coll)\n       (array-reduce coll f val)\n      \n       (string? coll)\n       (array-reduce coll f val)\n       \n       (native-satisfies? IReduce coll)\n       (-reduce coll f val)\n\n       :else\n       (seq-reduce f val coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1755 1796]},
                               :full-name "cljs.core/reduce",
                               :docstring "f should be a function of 2 arguments. If val is not supplied,\nreturns the result of applying f to the first 2 items in coll, then\napplying f to that result and the 3rd item, etc. If coll contains no\nitems, f must accept no arguments as well, and reduce returns the\nresult of calling f with no arguments.  If coll has only 1 item, it\nis returned and f is not called.  If val is supplied, returns the\nresult of applying f to val and the first item in coll, then\napplying f to that result and the 2nd item, etc. If coll contains no\nitems, returns val and f is not called."},
           "cljs.repl/merge-require" {:ns "cljs.repl",
                                      :name "merge-require",
                                      :signature ["[requires [lib :as spec]]"],
                                      :name-encode "merge-require",
                                      :history [["+" "0.0-2629"]
                                                ["-" "0.0-2655"]],
                                      :type "function",
                                      :full-name-encode "cljs.repl/merge-require",
                                      :source {:code "(defn merge-require [requires [lib :as spec]]\n  (let [[before [match & after]]\n        (split-with\n          (fn [[lib' & _]]\n            (not= lib lib'))\n          requires)]\n    (if (nil? match)\n      ;; no match, append to end\n      (concat requires [spec])\n      (if (= match spec)\n        ;; dupe\n        requires\n        ;; merge\n        (concat before [(merge-spec match spec)] after)))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2644",
                                               :filename "src/clj/cljs/repl.clj",
                                               :lines [211 224]},
                                      :full-name "cljs.repl/merge-require",
                                      :removed {:in "0.0-2655",
                                                :last-seen "0.0-2644"}},
           "clojure.browser.event/has-listener" {:ns "clojure.browser.event",
                                                 :name "has-listener",
                                                 :signature ["[obj opt_type opt_capture]"],
                                                 :name-encode "has-listener",
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/has-listener",
                                                 :source {:code "(defn has-listener [obj opt_type opt_capture])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [96]},
                                                 :full-name "clojure.browser.event/has-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/unchecked-dec-int" {:ns "cljs.core",
                                          :name "unchecked-dec-int",
                                          :signature ["[x]"],
                                          :name-encode "unchecked-dec-int",
                                          :history [["+" "0.0-1798"]],
                                          :type "function/macro",
                                          :full-name-encode "cljs.core/unchecked-dec-int",
                                          :source {:code "(defn unchecked-dec-int [x]\n  (cljs.core/unchecked-dec-int x))",
                                                   :title "Function code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [1972 1973]},
                                          :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-dec-int\n  ([x] `(dec ~x)))",
                                                           :title "Macro code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/clj/cljs/core.clj",
                                                           :lines [381
                                                                   382]}],
                                          :full-name "cljs.core/unchecked-dec-int"},
           "cljs.core/PersistentHashMap.EMPTY" {:ns "cljs.core",
                                                :name "PersistentHashMap.EMPTY",
                                                :name-encode "PersistentHashMapDOTEMPTY",
                                                :parent-type "PersistentHashMap",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentHashMapDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentHashMap) (PersistentHashMap. nil 0 nil false nil empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [6329]},
                                                :full-name "cljs.core/PersistentHashMap.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/compare" {:return-type number,
                                :ns "cljs.core",
                                :name "compare",
                                :signature ["[x y]"],
                                :name-encode "compare",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/compare",
                                :source {:code "(defn ^number compare\n  [x y]\n  (cond\n   (identical? x y) 0\n\n   (nil? x) -1\n\n   (nil? y) 1\n\n   (identical? (type x) (type y))\n   (if (implements? IComparable x)\n     (-compare ^not-native x y)\n     (garray/defaultCompare x y))\n\n   :else\n   (throw (js/Error. \"compare on non-nil objects of different types\"))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1655 1674]},
                                :full-name "cljs.core/compare",
                                :docstring "Comparator. Returns a negative number, zero, or a positive number\n when x is logically 'less than', 'equal to', or 'greater than'\n y. Uses IComparable if available and google.array.defaultCompare for objects\nof the same type and special-cases nil to be less than any other object."},
           "cljs.core/contains?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "contains?",
                                  :signature ["[coll v]"],
                                  :name-encode "containsQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/containsQMARK",
                                  :source {:code "(defn ^boolean contains?\n  [coll v]\n  (if (identical? (get coll v lookup-sentinel) lookup-sentinel)\n    false\n    true))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1618 1627]},
                                  :full-name "cljs.core/contains?",
                                  :docstring "Returns true if key is present in the given collection, otherwise\nreturns false.  Note that for numerically indexed collections like\nvectors and arrays, this tests if the numeric key is within the\nrange of indexes. 'contains?' operates constant or logarithmic time;\nit will not perform a linear search for a value.  See also 'some'."},
           "cljs.core/Stepper" {:ns "cljs.core",
                                :name "Stepper",
                                :signature ["[xform iter]"],
                                :name-encode "Stepper",
                                :type "type",
                                :full-name-encode "cljs.core/Stepper",
                                :source {:code "(deftype Stepper [xform iter]\n  Object\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext iter))\n        (if (reduced? (xform lt (.next iter)))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3127 3138]},
                                :full-name "cljs.core/Stepper",
                                :history [["+" "0.0-2301"]]},
           "cljs.core/prefer-method" {:ns "cljs.core",
                                      :name "prefer-method",
                                      :signature ["[multifn dispatch-val-x dispatch-val-y]"],
                                      :name-encode "prefer-method",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/prefer-method",
                                      :source {:code "(defn prefer-method\n  [multifn dispatch-val-x dispatch-val-y]\n  (-prefer-method multifn dispatch-val-x dispatch-val-y))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [9125 9129]},
                                      :full-name "cljs.core/prefer-method",
                                      :docstring "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\nwhen there is a conflict"},
           "cljs.core/array-seq" {:ns "cljs.core",
                                  :name "array-seq",
                                  :signature ["[array]" "[array i]"],
                                  :name-encode "array-seq",
                                  :type "function",
                                  :full-name-encode "cljs.core/array-seq",
                                  :source {:code "(defn array-seq\n  ([array]\n     (prim-seq array 0))\n  ([array i]\n     (prim-seq array i)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1080 1084]},
                                  :full-name "cljs.core/array-seq",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/to-array-2d" {:ns "cljs.core",
                                    :name "to-array-2d",
                                    :signature ["[coll]"],
                                    :name-encode "to-array-2d",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/to-array-2d",
                                    :source {:code "(defn to-array-2d\n  [coll]\n    (let [ret (make-array (count coll))]\n      (loop [i 0 xs (seq coll)]\n        (when xs\n          (aset ret i (to-array (first xs)))\n          (recur (inc i) (next xs))))\n      ret))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2766 2775]},
                                    :full-name "cljs.core/to-array-2d",
                                    :docstring "Returns a (potentially-ragged) 2-dimensional array\ncontaining the contents of coll."},
           "cljs.core/ICloneable" {:ns "cljs.core",
                                   :name "ICloneable",
                                   :name-encode "ICloneable",
                                   :implementations #{"Subvec"
                                                      "PersistentQueue"
                                                      "PersistentHashMap"
                                                      "PersistentTreeSet"
                                                      "EmptyList"
                                                      "PersistentVector"
                                                      "Range"
                                                      "IndexedSeq"
                                                      "PersistentTreeMap"
                                                      "RSeq"
                                                      "PersistentArrayMap"
                                                      "PersistentHashSet"
                                                      "List"
                                                      "Cons"},
                                   :history [["+" "0.0-2134"]],
                                   :type "protocol",
                                   :full-name-encode "cljs.core/ICloneable",
                                   :source {:code "(defprotocol ICloneable\n  (^clj -clone [value]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [255 256]},
                                   :methods [{:name "-clone",
                                              :signature ["[value]"],
                                              :docstring nil}],
                                   :full-name "cljs.core/ICloneable"},
           "warnings/multiple-variadic-overloads" {:ns "warnings",
                                                   :name "multiple-variadic-overloads",
                                                   :type "warning",
                                                   :full-name "warnings/multiple-variadic-overloads",
                                                   :full-name-encode "warnings/multiple-variadic-overloads",
                                                   :name-encode "multiple-variadic-overloads",
                                                   :history [["+"
                                                              "0.0-2014"]]},
           "cljs.repl.browser/create-client-js-file" {:ns "cljs.repl.browser",
                                                      :name "create-client-js-file",
                                                      :signature ["[opts file-path]"],
                                                      :name-encode "create-client-js-file",
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/create-client-js-file",
                                                      :source {:code "(defn create-client-js-file [opts file-path]\n  (let [file (io/file file-path)]\n    (when (not (.exists file))\n      (spit file (compile-client-js opts)))\n    file))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r2760",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [225
                                                                       229]},
                                                      :full-name "cljs.repl.browser/create-client-js-file",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "cljs.core/*print-length*" {:ns "cljs.core",
                                       :name "*print-length*",
                                       :name-encode "STARprint-lengthSTAR",
                                       :type "dynamic var",
                                       :full-name-encode "cljs.core/STARprint-lengthSTAR",
                                       :source {:code "(def ^:dynamic *print-length* nil)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [37]},
                                       :full-name "cljs.core/*print-length*",
                                       :history [["+" "0.0-2060"]]},
           "cljs.repl/*cljs-verbose*" {:ns "cljs.repl",
                                       :name "*cljs-verbose*",
                                       :name-encode "STARcljs-verboseSTAR",
                                       :type "dynamic var",
                                       :full-name-encode "cljs.repl/STARcljs-verboseSTAR",
                                       :source {:code "(def ^:dynamic *cljs-verbose* false)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [25]},
                                       :full-name "cljs.repl/*cljs-verbose*",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue" {:protocols #{"ISeqable"
                                                     "IMeta"
                                                     "IWithMeta"
                                                     "IStack"
                                                     "IEmptyableCollection"
                                                     "ICounted"
                                                     "ISequential"
                                                     "ISeq"
                                                     "ICollection"
                                                     "IHash"
                                                     "IPrintWithWriter"
                                                     "IEquiv"
                                                     "ICloneable"},
                                        :ns "cljs.core",
                                        :name "PersistentQueue",
                                        :signature ["[meta count front rear __hash]"],
                                        :name-encode "PersistentQueue",
                                        :history [["+" "0.0-927"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/PersistentQueue",
                                        :source {:code "(deftype PersistentQueue [meta count front rear ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [coll] (PersistentQueue. meta count front rear __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentQueue. meta count front rear __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll] (first front))\n  (-rest [coll] (rest (seq coll)))\n\n  IStack\n  (-peek [coll] (first front))\n  (-pop [coll]\n    (if front\n      (if-let [f1 (next front)]\n        (PersistentQueue. meta (dec count) f1 rear nil)\n        (PersistentQueue. meta (dec count) (seq rear) [] nil))\n      coll))\n\n  ICollection\n  (-conj [coll o]\n    (if front\n      (PersistentQueue. meta (inc count) front (conj (or rear []) o) nil)\n      (PersistentQueue. meta (inc count) (conj front o) [] nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentQueue) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (let [rear (seq rear)]\n      (if (or front rear)\n        (PersistentQueueSeq. nil front (seq rear) nil))))\n\n  ICounted\n  (-count [coll] count))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4919 4971]},
                                        :full-name "cljs.core/PersistentQueue"},
           "compiler-options/hashbang" {:ns "compiler-options",
                                        :name "hashbang",
                                        :name-encode "hashbang",
                                        :type "option",
                                        :full-name-encode "compiler-options/hashbang",
                                        :full-name "compiler-options/hashbang",
                                        :history [["+" "0.0-2197"]]},
           "cljs.repl.server/read-post" {:ns "cljs.repl.server",
                                         :name "read-post",
                                         :signature ["[line rdr]"],
                                         :name-encode "read-post",
                                         :type "function",
                                         :full-name-encode "cljs.repl.server/read-post",
                                         :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n      {:method :post\n       :path path\n       :headers headers\n       :content (String. content)})))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/repl/server.clj",
                                                  :lines [78 87]},
                                         :full-name "cljs.repl.server/read-post",
                                         :history [["+" "0.0-1503"]]},
           "cljs.core/drop-last" {:ns "cljs.core",
                                  :name "drop-last",
                                  :signature ["[s]" "[n s]"],
                                  :name-encode "drop-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/drop-last",
                                  :source {:code "(defn drop-last\n  ([s] (drop-last 1 s))\n  ([n s] (map (fn [x _] x) s (drop n s))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3827 3830]},
                                  :full-name "cljs.core/drop-last",
                                  :docstring "Return a lazy sequence of all but the last n (default 1) items in coll"},
           "closure-warnings/strict-module-dep-check" {:ns "closure-warnings",
                                                       :name "strict-module-dep-check",
                                                       :type "warning",
                                                       :full-name "closure-warnings/strict-module-dep-check",
                                                       :full-name-encode "closure-warnings/strict-module-dep-check",
                                                       :name-encode "strict-module-dep-check",
                                                       :history [["+"
                                                                  "0.0-2120"]]},
           "cljs.core/array?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "array?",
                               :signature ["[x]"],
                               :name-encode "arrayQMARK",
                               :history [["+" "0.0-1798"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/arrayQMARK",
                               :source {:code "(defn ^boolean array? [x]\n  (cljs.core/array? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [90 91]},
                               :extra-sources [{:code "(defmacro array? [x]\n  (if (= :nodejs (-> @env/*compiler* :options :target))\n    (bool-expr `(.isArray js/Array ~x))\n    (bool-expr (core/list 'js* \"~{} instanceof Array\" x))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [302 305]}],
                               :full-name "cljs.core/array?"},
           "cljs.core/PersistentVector.fromArray" {:ns "cljs.core",
                                                   :name "PersistentVector.fromArray",
                                                   :signature ["[xs no-clone]"],
                                                   :name-encode "PersistentVectorDOTfromArray",
                                                   :history [["+"
                                                              "0.0-1006"]],
                                                   :parent-type "PersistentVector",
                                                   :type "function",
                                                   :full-name-encode "cljs.core/PersistentVectorDOTfromArray",
                                                   :source {:code "(set! (.-fromArray PersistentVector)\n  (fn [xs ^boolean no-clone]\n    (let [l (alength xs)\n          xs (if no-clone xs (aclone xs))]\n      (if (< l 32)\n        (PersistentVector. nil l 5 (.-EMPTY-NODE PersistentVector) xs nil)\n        (let [node (.slice xs 0 32)\n              v (PersistentVector. nil 32 5 (.-EMPTY-NODE PersistentVector) node nil)]\n          (loop [i 32 out (-as-transient v)]\n            (if (< i l)\n              (recur (inc i) (conj! out (aget xs i)))\n              (persistent! out))))))))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/cljs/core.cljs",
                                                            :lines [4459
                                                                    4470]},
                                                   :full-name "cljs.core/PersistentVector.fromArray"},
           "compiler-options/warnings" {:ns "compiler-options",
                                        :name "warnings",
                                        :name-encode "warnings",
                                        :type "option",
                                        :full-name-encode "compiler-options/warnings",
                                        :full-name "compiler-options/warnings",
                                        :sub-options-ns "warnings",
                                        :history [["+" "0.0-1443"]]},
           "cljs.core/filterv" {:ns "cljs.core",
                                :name "filterv",
                                :signature ["[pred coll]"],
                                :name-encode "filterv",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/filterv",
                                :source {:code "(defn filterv\n  [pred coll]\n  (-> (reduce (fn [v o] (if (pred o) (conj! v o) v))\n              (transient [])\n              coll)\n      persistent!))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4047 4054]},
                                :full-name "cljs.core/filterv",
                                :docstring "Returns a vector of the items in coll for which\n(pred item) returns true. pred must be free of side-effects."},
           "cljs.core/IComparable" {:ns "cljs.core",
                                    :name "IComparable",
                                    :name-encode "IComparable",
                                    :implementations #{"Subvec"
                                                       "Symbol"
                                                       "PersistentVector"
                                                       "Keyword"},
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IComparable",
                                    :source {:code "(defprotocol IComparable\n  (^number -compare [x y]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [393 394]},
                                    :methods [{:name "-compare",
                                               :signature ["[x y]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IComparable"},
           "cljs.reader/read-string" {:ns "cljs.reader",
                                      :name "read-string",
                                      :signature ["[s]"],
                                      :name-encode "read-string",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.reader/read-string",
                                      :source {:code "(defn read-string\n  [s]\n  (let [r (push-back-reader s)]\n    (read r false nil false)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [443 447]},
                                      :full-name "cljs.reader/read-string",
                                      :docstring "Reads one object from the string s"},
           "cljs.reader/unicode-2-pattern" {:ns "cljs.reader",
                                            :name "unicode-2-pattern",
                                            :name-encode "unicode-2-pattern",
                                            :type "var",
                                            :full-name-encode "cljs.reader/unicode-2-pattern",
                                            :source {:code "(def unicode-2-pattern (re-pattern \"^[0-9A-Fa-f]{2}$\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [181]},
                                            :full-name "cljs.reader/unicode-2-pattern",
                                            :history [["+" "0.0-1424"]]},
           "cljs.core/Volatile" {:protocols #{"IVolatile"
                                              "IDeref"
                                              "IPrintWithWriter"},
                                 :ns "cljs.core",
                                 :name "Volatile",
                                 :signature ["[state]"],
                                 :name-encode "Volatile",
                                 :history [["+" "0.0-2496"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Volatile",
                                 :source {:code "(deftype Volatile [^:mutable state]\n  IVolatile\n  (-vreset! [_ new-state]\n    (set! state new-state))\n\n  IDeref\n  (-deref [_] state))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3596 3602]},
                                 :full-name "cljs.core/Volatile"},
           "cljs.core/check-string-hash-cache" {:ns "cljs.core",
                                                :name "check-string-hash-cache",
                                                :signature ["[k]"],
                                                :name-encode "check-string-hash-cache",
                                                :history [["+"
                                                           "0.0-1424"]
                                                          ["-"
                                                           "0.0-2261"]],
                                                :type "function",
                                                :full-name-encode "cljs.core/check-string-hash-cache",
                                                :source {:code "(defn check-string-hash-cache [k]\n  (when (> string-hash-cache-count 255)\n    (set! string-hash-cache (js-obj))\n    (set! string-hash-cache-count 0))\n  (let [h (aget string-hash-cache k)]\n    (if (number? h)\n      h\n      (add-to-string-hash-cache k))))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2234",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [1147
                                                                 1154]},
                                                :full-name "cljs.core/check-string-hash-cache",
                                                :removed {:in "0.0-2261",
                                                          :last-seen "0.0-2234"}},
           "cljs.core/vector?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "vector?",
                                :signature ["[x]"],
                                :name-encode "vectorQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/vectorQMARK",
                                :source {:code "(defn ^boolean vector?\n  [x] (satisfies? IVector x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1537 1539]},
                                :full-name "cljs.core/vector?",
                                :docstring "Return true if x satisfies IVector"},
           "cljs.core/defmulti" {:ns "cljs.core",
                                 :name "defmulti",
                                 :signature ["[mm-name & options]"],
                                 :name-encode "defmulti",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/defmulti",
                                 :source {:code "(defmacro defmulti\n  [mm-name & options]\n  (let [docstring   (if (core/string? (first options))\n                      (first options)\n                      nil)\n        options     (if (core/string? (first options))\n                      (next options)\n                      options)\n        m           (if (map? (first options))\n                      (first options)\n                      {})\n        options     (if (map? (first options))\n                      (next options)\n                      options)\n        dispatch-fn (first options)\n        options     (next options)\n        m           (if docstring\n                      (assoc m :doc docstring)\n                      m)\n        m           (if (meta mm-name)\n                      (conj (meta mm-name) m)\n                      m)\n        mm-ns (-> &env :ns :name core/str)] \n    (when (= (count options) 1)\n      (throw (Exception. \"The syntax for defmulti has changed. Example: (defmulti name dispatch-fn :default dispatch-value)\")))\n    (let [options   (apply core/hash-map options)\n          default   (core/get options :default :default)]\n      (check-valid-options options :default :hierarchy)\n      `(def ~(with-meta mm-name m)\n         (let [method-table# (atom {})\n               prefer-table# (atom {})\n               method-cache# (atom {})\n               cached-hierarchy# (atom {})\n               hierarchy# (get ~options :hierarchy (cljs.core/get-global-hierarchy))]\n           (cljs.core/MultiFn. (cljs.core/symbol ~mm-ns ~(name mm-name)) ~dispatch-fn ~default hierarchy#\n                               method-table# prefer-table# method-cache# cached-hierarchy#))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1546 1588]},
                                 :full-name "cljs.core/defmulti",
                                 :docstring "Creates a new multimethod with the associated dispatch function.\nThe docstring and attribute-map are optional.\n\nOptions are key-value pairs and may be one of:\n  :default    the default dispatch value, defaults to :default\n  :hierarchy  the isa? hierarchy to use for dispatching\n              defaults to the global hierarchy"},
           "syntax/rest" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "rest",
                          :name-encode "rest",
                          :type "special character",
                          :full-name-encode "syntax/rest",
                          :full-name "syntax/rest",
                          :history [["+" "0.0-927"]]},
           "cljs.core/Keyword" {:protocols #{"IFn"
                                             "IHash"
                                             "INamed"
                                             "IComparable"
                                             "IPrintWithWriter"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "Keyword",
                                :signature ["[ns name fqn _hash]"],
                                :name-encode "Keyword",
                                :history [["+" "0.0-1424"]],
                                :type "type",
                                :full-name-encode "cljs.core/Keyword",
                                :source {:code "(deftype Keyword [ns name fqn ^:mutable _hash]\n  Object\n  (toString [_] (str \":\" fqn))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IEquiv\n  (-equiv [_ other]\n    (if (instance? Keyword other)\n      (identical? fqn (.-fqn other))\n      false))\n  IFn\n  (-invoke [kw coll]\n    (get coll kw))\n  (-invoke [kw coll not-found]\n    (get coll kw not-found))\n\n  IHash\n  (-hash [this]\n    (caching-hash this hash-keyword _hash))\n\n  INamed\n  (-name [_] name)\n  (-namespace [_] ns)\n\n  IPrintWithWriter\n  (-pr-writer [o writer _] (-write writer (str \":\" fqn))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2490 2516]},
                                :full-name "cljs.core/Keyword"},
           "cljs.core/List.EMPTY" {:ns "cljs.core",
                                   :name "List.EMPTY",
                                   :name-encode "ListDOTEMPTY",
                                   :parent-type "List",
                                   :type "var",
                                   :full-name-encode "cljs.core/ListDOTEMPTY",
                                   :source {:code "(set! (.-EMPTY List) (EmptyList. nil))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2383]},
                                   :full-name "cljs.core/List.EMPTY",
                                   :history [["+" "0.0-927"]]},
           "clojure.browser.event/dispatch-event" {:ns "clojure.browser.event",
                                                   :name "dispatch-event",
                                                   :signature ["[src event]"],
                                                   :name-encode "dispatch-event",
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/dispatch-event",
                                                   :source {:code "(defn dispatch-event\n  [src event]\n  (events/dispatchEvent src event))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [77
                                                                    79]},
                                                   :full-name "clojure.browser.event/dispatch-event",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/ns-interns" {:ns "cljs.core",
                                   :name "ns-interns",
                                   :signature ["[[quote ns]]"],
                                   :name-encode "ns-interns",
                                   :history [["+" "0.0-2496"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/ns-interns",
                                   :source {:code "(defmacro ns-interns\n  [[quote ns]]\n  (core/assert (core/and (= quote 'quote) (core/symbol? ns))\n    \"Argument to ns-interns must be a quoted symbol\")\n  `(into {}\n     [~@(map\n          (fn [[sym _]]\n            `[(symbol ~(name sym)) (var ~(symbol (name ns) (name sym)))])\n          (get-in @env/*compiler* [:cljs.analyzer/namespaces ns :defs]))]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1676 1685]},
                                   :full-name "cljs.core/ns-interns",
                                   :docstring "Returns a map of the intern mappings for the namespace."},
           "clojure.string/split-lines" {:ns "clojure.string",
                                         :name "split-lines",
                                         :signature ["[s]"],
                                         :name-encode "split-lines",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "clojure.string/split-lines",
                                         :source {:code "(defn split-lines\n  [s]\n  (split s #\"\\n|\\r\\n\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/clojure/string.cljs",
                                                  :lines [142 145]},
                                         :full-name "clojure.string/split-lines",
                                         :docstring "Splits s on \n or \r\n."},
           "cljs.test/mapped-line-and-column" {:ns "cljs.test",
                                               :name "mapped-line-and-column",
                                               :signature ["[filename line column]"],
                                               :name-encode "mapped-line-and-column",
                                               :type "function",
                                               :full-name-encode "cljs.test/mapped-line-and-column",
                                               :source {:code "(defn mapped-line-and-column [filename line column]\n  (let [default [filename line column]]\n    (if-let [source-map (:source-map (get-current-env))]\n      ;; source maps are 0 indexed for lines\n      (if-let [columns (get-in source-map [filename (dec line)])]\n        (vec\n          (map\n            ;; source maps are 0 indexed for columns\n            ;; multiple segments may exist at column\n            ;; just take first\n            (first\n              (if-let [mapping (get columns (dec column))]\n                mapping\n                (second (first columns))))\n            [:source :line :col]))\n        default)\n      default)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/test.cljs",
                                                        :lines [314
                                                                330]},
                                               :full-name "cljs.test/mapped-line-and-column",
                                               :history [["+"
                                                          "0.0-2496"]]},
           "cljs.repl.browser/loaded-libs" {:ns "cljs.repl.browser",
                                            :name "loaded-libs",
                                            :name-encode "loaded-libs",
                                            :type "var",
                                            :full-name-encode "cljs.repl.browser/loaded-libs",
                                            :source {:code "(def loaded-libs (atom #{}))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [25]},
                                            :full-name "cljs.repl.browser/loaded-libs",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/areduce" {:ns "cljs.core",
                                :name "areduce",
                                :signature ["[a idx ret init expr]"],
                                :name-encode "areduce",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/areduce",
                                :source {:code "(defmacro areduce\n  [a idx ret init expr]\n  `(let [a# ~a]\n     (loop  [~idx 0 ~ret ~init]\n       (if (< ~idx  (alength a#))\n         (recur (inc ~idx) ~expr)\n         ~ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [1511 1520]},
                                :full-name "cljs.core/areduce",
                                :docstring "Reduces an expression across an array a, using an index named idx,\nand return value named ret, initialized to init, setting ret to the\nevaluation of expr at each step, returning ret."},
           "cljs.core/disj" {:ns "cljs.core",
                             :name "disj",
                             :signature ["[coll]"
                                         "[coll k]"
                                         "[coll k & ks]"],
                             :name-encode "disj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/disj",
                             :source {:code "(defn disj\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-disjoin coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (disj coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1480 1492]},
                             :full-name "cljs.core/disj",
                             :docstring "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "compiler-options/main" {:ns "compiler-options",
                                    :name "main",
                                    :name-encode "main",
                                    :type "option",
                                    :full-name-encode "compiler-options/main",
                                    :full-name "compiler-options/main",
                                    :history [["+" "0.0-971"]]},
           "cljs.core/IEditableCollection" {:ns "cljs.core",
                                            :name "IEditableCollection",
                                            :name-encode "IEditableCollection",
                                            :implementations #{"PersistentHashMap"
                                                               "ObjMap"
                                                               "PersistentVector"
                                                               "PersistentArrayMap"
                                                               "PersistentHashSet"},
                                            :history [["+" "0.0-1211"]],
                                            :type "protocol",
                                            :full-name-encode "cljs.core/IEditableCollection",
                                            :source {:code "(defprotocol IEditableCollection\n  (^clj -as-transient [coll]))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [373 374]},
                                            :methods [{:name "-as-transient",
                                                       :signature ["[coll]"],
                                                       :docstring nil}],
                                            :full-name "cljs.core/IEditableCollection"},
           "cljs.core/unchecked-char" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-char",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-char",
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-char",
                                       :source {:code "(defn ^number unchecked-char [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1950]},
                                       :extra-sources [{:code "(defmacro unchecked-char [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [367]}],
                                       :full-name "cljs.core/unchecked-char"},
           "cljs.core/keyword-identical?" {:return-type boolean,
                                           :ns "cljs.core",
                                           :name "keyword-identical?",
                                           :signature ["[x y]"],
                                           :name-encode "keyword-identicalQMARK",
                                           :history [["+" "0.0-1877"]],
                                           :type "function",
                                           :full-name-encode "cljs.core/keyword-identicalQMARK",
                                           :source {:code "(defn ^boolean keyword-identical? [x y]\n  (if (identical? x y)\n    true\n    (if (and (keyword? x)\n             (keyword? y))\n      (identical? (.-fqn x) (.-fqn y))\n      false)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [2521 2527]},
                                           :full-name "cljs.core/keyword-identical?"},
           "clojure.browser.net/event-types" {:ns "clojure.browser.net",
                                              :name "event-types",
                                              :name-encode "event-types",
                                              :type "var",
                                              :full-name-encode "clojure.browser.net/event-types",
                                              :source {:code "(def event-types\n  (into {}\n        (map\n         (fn [[k v]]\n           [(keyword (.toLowerCase k))\n            v])\n         (merge\n          (js->clj EventType)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/clojure/browser/net.cljs",
                                                       :lines [21 28]},
                                              :full-name "clojure.browser.net/event-types",
                                              :history [["+"
                                                         "0.0-927"]]},
           "clojure.string/lower-case" {:ns "clojure.string",
                                        :name "lower-case",
                                        :signature ["[s]"],
                                        :name-encode "lower-case",
                                        :history [["+" "0.0-927"]],
                                        :type "function",
                                        :full-name-encode "clojure.string/lower-case",
                                        :source {:code "(defn lower-case\n  [s]\n  (.toLowerCase s))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/string.cljs",
                                                 :lines [73 76]},
                                        :full-name "clojure.string/lower-case",
                                        :docstring "Converts string to all lower-case."},
           "cljs.core/*print-fn*" {:ns "cljs.core",
                                   :name "*print-fn*",
                                   :name-encode "STARprint-fnSTAR",
                                   :type "dynamic var",
                                   :full-name-encode "cljs.core/STARprint-fnSTAR",
                                   :source {:code "(defonce\n  ^{:doc \"Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.\" :dynamic true}\n  *print-fn*\n  (fn [_]\n    (throw (js/Error. \"No *print-fn* fn set for evaluation environment\"))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [20 26]},
                                   :full-name "cljs.core/*print-fn*",
                                   :docstring "Each runtime environment provides a different way to print output.\nWhatever function *print-fn* is bound to will be passed any\nStrings which should be printed.",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/str" {:ns "cljs.core",
                            :name "str",
                            :signature ["[]" "[x]" "[x & ys]"],
                            :name-encode "str",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/str",
                            :source {:code "(defn str\n  ([] \"\")\n  ([x] (if (nil? x)\n         \"\"\n         (gstring/buildString x)))\n  ([x & ys]\n    (loop [sb (StringBuffer. (str x)) more ys]\n      (if more\n        (recur (. sb  (append (str (first more)))) (next more))\n        (.toString sb)))))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2190 2202]},
                            :extra-sources [{:code "(defmacro str [& xs]\n  (let [strs (->> (repeat (count xs) \"cljs.core.str(~{})\")\n               (interpose \",\")\n               (apply core/str))]\n    (list* 'js* (core/str \"[\" strs \"].join('')\") xs)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [208 212]}],
                            :full-name "cljs.core/str",
                            :docstring "With no args, returns the empty string. With one arg x, returns\nx.toString().  (str nil) returns the empty string. With more than\none arg, returns the concatenation of the str values of the args."},
           "cljs.core/ISequential" {:ns "cljs.core",
                                    :name "ISequential",
                                    :name-encode "ISequential",
                                    :implementations #{"Subvec"
                                                       "PersistentQueue"
                                                       "PersistentArrayMapSeq"
                                                       "RedNode"
                                                       "EmptyList"
                                                       "LazyTransformer"
                                                       "BlackNode"
                                                       "PersistentVector"
                                                       "ValSeq"
                                                       "ChunkedCons"
                                                       "Range"
                                                       "PersistentQueueSeq"
                                                       "ChunkedSeq"
                                                       "ArrayNodeSeq"
                                                       "KeySeq"
                                                       "IndexedSeq"
                                                       "PersistentTreeMapSeq"
                                                       "RSeq"
                                                       "NodeSeq"
                                                       "List"
                                                       "Cons"
                                                       "LazySeq"
                                                       "Eduction"},
                                    :history [["+" "0.0-927"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/ISequential",
                                    :source {:code "(defprotocol ISequential\n  \"Marker interface indicating a persistent collection of sequential items\")",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [335 336]},
                                    :full-name "cljs.core/ISequential",
                                    :docstring "Marker interface indicating a persistent collection of sequential items"},
           "cljs.core/try*" {:ns "cljs.core",
                             :name "try*",
                             :type "special form",
                             :source {:code "(defmethod parse 'try*\n  [op env [_ & body :as form] name]\n  (let [body (vec body)\n        catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        tail (peek body)\n        fblock (when (and (seq? tail) (= 'finally (first tail)))\n                  (rest tail))\n        finally (when fblock\n                  (analyze (assoc env :context :statement) `(do ~@fblock)))\n        body (if finally (pop body) body)\n        tail (peek body)\n        cblock (when (and (seq? tail)\n                          (= 'catch (first tail)))\n                 (rest tail))\n        name (first cblock)\n        locals (:locals catchenv)\n        locals (if name\n                 (assoc locals name\n                   {:name name\n                    :line (get-line name env)\n                    :column (get-col name env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) `(do ~@(rest cblock))))\n        body (if name (pop body) body)\n        try (analyze (if (or name finally) catchenv env) `(do ~@body))]\n    (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n    {:env env :op :try* :form form\n     :try try\n     :finally finally\n     :name name\n     :catch catch\n     :children [try catch finally]}))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r1913",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [280 312]},
                             :full-name "cljs.core/try*",
                             :full-name-encode "cljs.core/trySTAR",
                             :name-encode "trySTAR",
                             :history [["+" "0.0-927"]
                                       ["-" "0.0-1933"]],
                             :removed {:in "0.0-1933",
                                       :last-seen "0.0-1913"}},
           "closure-warnings/non-standard-jsdoc" {:ns "closure-warnings",
                                                  :name "non-standard-jsdoc",
                                                  :type "warning",
                                                  :full-name "closure-warnings/non-standard-jsdoc",
                                                  :full-name-encode "closure-warnings/non-standard-jsdoc",
                                                  :name-encode "non-standard-jsdoc",
                                                  :history [["+"
                                                             "0.0-2120"]]},
           "cljs.core/key-test" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "key-test",
                                 :signature ["[key other]"],
                                 :name-encode "key-test",
                                 :history [["+" "0.0-1424"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/key-test",
                                 :source {:code "(defn ^boolean key-test [key other]\n  (cond\n    (identical? key other) true\n    (keyword-identical? key other) true\n    :else (= key other)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [5592 5596]},
                                 :full-name "cljs.core/key-test"},
           "cljs.core/set" {:ns "cljs.core",
                            :name "set",
                            :signature ["[coll]"],
                            :name-encode "set",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/set",
                            :source {:code "(defn set\n  [coll]\n  (let [^not-native in (seq coll)]\n    (cond\n      (nil? in) #{}\n\n      (and (instance? IndexedSeq in) (zero? (.-i in)))\n      (set-from-indexed-seq in)\n\n      :else\n      (loop [in in\n              ^not-native out (-as-transient #{})]\n        (if-not (nil? in)\n          (recur (-next in) (-conj! out (-first in)))\n          (-persistent! out))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [7582 7597]},
                            :full-name "cljs.core/set",
                            :docstring "Returns a set of the distinct elements of coll."},
           "cljs.core/obj-map" {:ns "cljs.core",
                                :name "obj-map",
                                :signature ["[& keyvals]"],
                                :name-encode "obj-map",
                                :history [["+" "0.0-1443"]],
                                :type "function",
                                :full-name-encode "cljs.core/obj-map",
                                :source {:code "(defn obj-map\n  [& keyvals]\n  (let [ks  (array)\n        obj (js-obj)]\n    (loop [kvs (seq keyvals)]\n      (if kvs\n        (do (.push ks (first kvs))\n            (aset obj (first kvs) (second kvs))\n            (recur (nnext kvs)))\n        (.fromObject ObjMap ks obj)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7141 7152]},
                                :full-name "cljs.core/obj-map",
                                :docstring "keyval => key val\nReturns a new object map with supplied mappings."},
           "cljs.core/print" {:ns "cljs.core",
                              :name "print",
                              :name-encode "print",
                              :type "function",
                              :full-name-encode "cljs.core/print",
                              :source {:code "(def ^{:doc\n  \"Prints the object(s) using string-print.\n  print and println produce output for human consumption.\"}\n  print\n  (fn cljs-core-print [& objs]\n    (pr-with-opts objs (assoc (pr-opts) :readably false))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8285 8290]},
                              :full-name "cljs.core/print",
                              :docstring "Prints the object(s) using string-print.\nprint and println produce output for human consumption.",
                              :history [["+" "0.0-927"]]},
           "cljs.core/ArrayNode" {:ns "cljs.core",
                                  :name "ArrayNode",
                                  :signature ["[edit cnt arr]"],
                                  :name-encode "ArrayNode",
                                  :type "type",
                                  :full-name-encode "cljs.core/ArrayNode",
                                  :source {:code "(deftype ArrayNode [edit ^:mutable cnt ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (ArrayNode. nil (inc cnt) (clone-and-set arr idx (.inode-assoc (.-EMPTY BitmapIndexedNode) (+ shift 5) hash key val added-leaf?)))\n        (let [n (.inode-assoc node (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (ArrayNode. nil cnt (clone-and-set arr idx n)))))))\n\n  (inode-without [inode shift hash key]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (let [n (.inode-without node (+ shift 5) hash key)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode nil idx)\n              (ArrayNode. nil (dec cnt) (clone-and-set arr idx n)))\n\n            :else\n            (ArrayNode. nil cnt (clone-and-set arr idx n))))\n        inode)))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-lookup node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if-not (nil? node)\n        (.inode-find node (+ shift 5) hash key not-found)\n        not-found)))\n\n  (inode-seq [inode]\n    (create-array-node-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (ArrayNode. e cnt (aclone arr))))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        (let [editable (edit-and-set inode edit idx (.inode-assoc! (.-EMPTY BitmapIndexedNode) edit (+ shift 5) hash key val added-leaf?))]\n          (set! (.-cnt editable) (inc (.-cnt editable)))\n          editable)\n        (let [n (.inode-assoc! node edit (+ shift 5) hash key val added-leaf?)]\n          (if (identical? n node)\n            inode\n            (edit-and-set inode edit idx n))))))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx  (mask hash shift)\n          node (aget arr idx)]\n      (if (nil? node)\n        inode\n        (let [n (.inode-without! node edit (+ shift 5) hash key removed-leaf?)]\n          (cond\n            (identical? n node)\n            inode\n\n            (nil? n)\n            (if (<= cnt 8)\n              (pack-array-node inode edit idx)\n              (let [editable (edit-and-set inode edit idx n)]\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))\n\n            :else\n            (edit-and-set inode edit idx n))))))\n\n  (kv-reduce [inode f init]\n    (let [len (alength arr)]           ; actually 32\n      (loop [i 0 init init]\n        (if (< i len)\n          (let [node (aget arr i)]\n            (if-not (nil? node)\n              (let [init (.kv-reduce node f init)]\n                (if (reduced? init)\n                  @init\n                  (recur (inc i) init)))\n              (recur (inc i) init)))\n          init)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [5862 5957]},
                                  :full-name "cljs.core/ArrayNode",
                                  :history [["+" "0.0-1211"]]},
           "cljs.core/type" {:ns "cljs.core",
                             :name "type",
                             :signature ["[x]"],
                             :name-encode "type",
                             :type "function",
                             :full-name-encode "cljs.core/type",
                             :source {:code "(defn type [x]\n  (when-not (nil? x)\n    (.-constructor x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [133 135]},
                             :full-name "cljs.core/type",
                             :history [["+" "0.0-971"]]},
           "clojure.string/blank?" {:ns "clojure.string",
                                    :name "blank?",
                                    :signature ["[s]"],
                                    :name-encode "blankQMARK",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.string/blankQMARK",
                                    :source {:code "(defn blank?\n  [s]\n  (gstring/isEmptySafe s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/clojure/string.cljs",
                                             :lines [174 177]},
                                    :full-name "clojure.string/blank?",
                                    :docstring "True is s is nil, empty, or contains only whitespace."},
           "syntax/keyword" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "keyword",
                             :name-encode "keyword",
                             :type "syntax",
                             :full-name-encode "syntax/keyword",
                             :extra-sources ({:code "(defn- read-keyword\n  [reader initch]\n  (let [ch (read-char reader)]\n    (if-not (whitespace? ch)\n      (let [token (read-token reader ch)\n            s (parse-symbol token)]\n        (if s\n          (let [^String ns (s 0)\n                ^String name (s 1)]\n            (if (identical? \\: (nth token 0))\n              (if ns\n                (let [ns (resolve-ns (symbol (subs ns 1)))]\n                  (if ns\n                    (keyword (str ns) name)\n                    (reader-error reader \"Invalid token: :\" token)))\n                (keyword (str *ns*) (subs name 1)))\n              (keyword ns name)))\n          (reader-error reader \"Invalid token: :\" token)))\n      (reader-error reader \"Invalid token: :\"))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [315 333]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [591 610]}),
                             :full-name "syntax/keyword",
                             :history [["+" "0.0-1853"]]},
           "cljs.reader/maybe-read-tagged-type" {:ns "cljs.reader",
                                                 :name "maybe-read-tagged-type",
                                                 :signature ["[rdr initch]"],
                                                 :name-encode "maybe-read-tagged-type",
                                                 :type "function",
                                                 :full-name-encode "cljs.reader/maybe-read-tagged-type",
                                                 :source {:code "(defn maybe-read-tagged-type\n  [rdr initch]\n  (let [tag (read-symbol rdr initch)\n        pfn (get @*tag-table* (str tag))\n        dfn @*default-data-reader-fn*]\n    (cond\n     pfn (pfn (read rdr true nil false))\n     dfn (dfn tag (read rdr true nil false))\n     :else (reader-error rdr\n                         \"Could not find tag parser for \" (str tag)\n                         \" in \" (pr-str (keys @*tag-table*))))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/reader.cljs",
                                                          :lines [576
                                                                  586]},
                                                 :full-name "cljs.reader/maybe-read-tagged-type",
                                                 :history [["+"
                                                            "0.0-1236"]]},
           "cljs.core/IChunkedSeq" {:ns "cljs.core",
                                    :name "IChunkedSeq",
                                    :name-encode "IChunkedSeq",
                                    :implementations #{"ChunkedCons"
                                                       "ChunkedSeq"},
                                    :history [["+" "0.0-1424"]],
                                    :type "protocol",
                                    :full-name-encode "cljs.core/IChunkedSeq",
                                    :source {:code "(defprotocol IChunkedSeq\n  (-chunked-first [coll])\n  (-chunked-rest [coll]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [399 401]},
                                    :methods [{:name "-chunked-first",
                                               :signature ["[coll]"],
                                               :docstring nil}
                                              {:name "-chunked-rest",
                                               :signature ["[coll]"],
                                               :docstring nil}],
                                    :full-name "cljs.core/IChunkedSeq"},
           "clojure.browser.dom/append" {:ns "clojure.browser.dom",
                                         :name "append",
                                         :signature ["[parent & children]"],
                                         :name-encode "append",
                                         :type "function",
                                         :full-name-encode "clojure.browser.dom/append",
                                         :source {:code "(defn append [parent & children]\n  (apply gdom/append parent children)\n  parent)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/clojure/browser/dom.cljs",
                                                  :lines [13 15]},
                                         :full-name "clojure.browser.dom/append",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/take-last" {:ns "cljs.core",
                                  :name "take-last",
                                  :signature ["[n coll]"],
                                  :name-encode "take-last",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/take-last",
                                  :source {:code "(defn take-last\n  [n coll]\n  (loop [s (seq coll), lead (seq (drop n coll))]\n    (if lead\n      (recur (next s) (next lead))\n      s)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3832 3839]},
                                  :full-name "cljs.core/take-last",
                                  :docstring "Returns a seq of the last n items in coll.  Depending on the type\nof coll may be no better than linear time.  For vectors, see also subvec."},
           "cljs.core/key->js" {:ns "cljs.core",
                                :name "key->js",
                                :signature ["[k]"],
                                :name-encode "key-GTjs",
                                :type "function",
                                :full-name-encode "cljs.core/key-GTjs",
                                :source {:code "(defn key->js [k]\n  (if (satisfies? IEncodeJS k)\n    (-clj->js k)\n    (if (or (string? k)\n            (number? k)\n            (keyword? k)\n            (symbol? k))\n      (clj->js k)\n      (pr-str k))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8628 8636]},
                                :full-name "cljs.core/key->js",
                                :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/setup" {:ns "cljs.repl.browser",
                                      :name "setup",
                                      :signature ["[repl-env opts]"],
                                      :name-encode "setup",
                                      :type "function",
                                      :full-name-encode "cljs.repl.browser/setup",
                                      :source {:code "(defn setup [repl-env opts]\n  (when (:src repl-env)\n    (repl/analyze-source (:src repl-env)))\n  (comp/with-core-cljs nil\n    (fn [] (server/start repl-env))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/repl/browser.clj",
                                               :lines [194 198]},
                                      :full-name "cljs.repl.browser/setup",
                                      :history [["+" "0.0-2665"]]},
           "cljs.core/TransientHashMap" {:protocols #{"ITransientCollection"
                                                      "ICounted"
                                                      "ILookup"
                                                      "ITransientAssociative"
                                                      "ITransientMap"},
                                         :ns "cljs.core",
                                         :name "TransientHashMap",
                                         :signature ["[edit root count has-nil? nil-val]"],
                                         :name-encode "TransientHashMap",
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashMap",
                                         :source {:code "(deftype TransientHashMap [^:mutable ^boolean edit\n                           ^:mutable root\n                           ^:mutable count\n                           ^:mutable ^boolean has-nil?\n                           ^:mutable nil-val]\n  Object\n  (conj! [tcoll o]\n    (if edit\n      (if (satisfies? IMapEntry o)\n        (.assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (.assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent\"))))\n\n  (assoc! [tcoll k v]\n    (if edit\n      (if (nil? k)\n        (do (if (identical? nil-val v)\n              nil\n              (set! nil-val v))\n            (if has-nil?\n              nil\n              (do (set! count (inc count))\n                  (set! has-nil? true)))\n            tcoll)\n        (let [added-leaf? (Box. false)\n              node        (-> (if (nil? root)\n                                (.-EMPTY BitmapIndexedNode)\n                                root)\n                              (.inode-assoc! edit 0 (hash k) k v added-leaf?))]\n          (if (identical? node root)\n            nil\n            (set! root node))\n          (if ^boolean (.-val added-leaf?)\n            (set! count (inc count)))\n          tcoll))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (without! [tcoll k]\n    (if edit\n      (if (nil? k)\n        (if has-nil?\n          (do (set! has-nil? false)\n              (set! nil-val nil)\n              (set! count (dec count))\n              tcoll)\n          tcoll)\n        (if (nil? root)\n          tcoll\n          (let [removed-leaf? (Box. false)\n                node (.inode-without! root edit 0 (hash k) k removed-leaf?)]\n            (if (identical? node root)\n              nil\n              (set! root node))\n            (if (aget removed-leaf? 0)\n              (set! count (dec count)))\n            tcoll)))\n      (throw (js/Error. \"dissoc! after persistent!\"))))\n\n  (persistent! [tcoll]\n    (if edit\n      (do (set! edit nil)\n          (PersistentHashMap. nil count root has-nil? nil-val nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ICounted\n  (-count [coll]\n    (if edit\n      count\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (if (nil? k)\n      (if has-nil?\n        nil-val)\n      (if (nil? root)\n        nil\n        (.inode-lookup root 0 (hash k) k))))\n\n  (-lookup [tcoll k not-found]\n    (if (nil? k)\n      (if has-nil?\n        nil-val\n        not-found)\n      (if (nil? root)\n        not-found\n        (.inode-lookup root 0 (hash k) k not-found))))\n\n  ITransientCollection\n  (-conj! [tcoll val] (.conj! tcoll val))\n\n  (-persistent! [tcoll] (.persistent! tcoll))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val] (.assoc! tcoll key val))\n\n  ITransientMap\n  (-dissoc! [tcoll key] (.without! tcoll key)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [6351 6452]},
                                         :full-name "cljs.core/TransientHashMap"},
           "clojure.set/intersection" {:ns "clojure.set",
                                       :name "intersection",
                                       :signature ["[s1]"
                                                   "[s1 s2]"
                                                   "[s1 s2 & sets]"],
                                       :name-encode "intersection",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.set/intersection",
                                       :source {:code "(defn intersection\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s2) (count s1))\n       (recur s2 s1)\n       (reduce (fn [result item]\n                   (if (contains? s2 item)\n\t\t     result\n                     (disj result item)))\n\t       s1 s1)))\n  ([s1 s2 & sets] \n     (let [bubbled-sets (bubble-max-key #(- (count %)) (conj sets s2 s1))]\n       (reduce intersection (first bubbled-sets) (rest bubbled-sets)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/clojure/set.cljs",
                                                :lines [31 44]},
                                       :full-name "clojure.set/intersection",
                                       :docstring "Return a set that is the intersection of the input sets"},
           "warnings/invalid-arithmetic" {:ns "warnings",
                                          :name "invalid-arithmetic",
                                          :type "warning",
                                          :full-name "warnings/invalid-arithmetic",
                                          :full-name-encode "warnings/invalid-arithmetic",
                                          :name-encode "invalid-arithmetic",
                                          :history [["+" "0.0-2067"]]},
           "cljs.core/fnext" {:ns "cljs.core",
                              :name "fnext",
                              :signature ["[coll]"],
                              :name-encode "fnext",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/fnext",
                              :source {:code "(defn fnext\n  [coll]\n  (first (next coll)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [1158 1161]},
                              :full-name "cljs.core/fnext",
                              :docstring "Same as (first (next x))"},
           "cljs.core/apply" {:ns "cljs.core",
                              :name "apply",
                              :signature ["[f args]"
                                          "[f x args]"
                                          "[f x y args]"
                                          "[f x y z args]"
                                          "[f a b c d & args]"],
                              :name-encode "apply",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/apply",
                              :source {:code "(defn apply\n  ([f args]\n     (let [fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count args (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc args)\n            (.cljs$lang$applyTo f args)))\n         (.apply f f (to-array args)))))\n  ([f x args]\n     (let [arglist (list* x args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y args]\n     (let [arglist (list* x y args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f x y z args]\n     (let [arglist (list* x y z args)\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist)))))\n  ([f a b c d & args]\n     (let [arglist (cons a (cons b (cons c (cons d (spread args)))))\n           fixed-arity (.-cljs$lang$maxFixedArity f)]\n       (if (.-cljs$lang$applyTo f)\n         (let [bc (bounded-count arglist (inc fixed-arity))]\n          (if (<= bc fixed-arity)\n            (apply-to f bc arglist)\n            (.cljs$lang$applyTo f arglist)))\n         (.apply f f (to-array arglist))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2982 3028]},
                              :full-name "cljs.core/apply",
                              :docstring "Applies fn f to the argument list formed by prepending intervening arguments to args.\nFirst cut.  Not lazy.  Needs to use emitted toApply."},
           "clojure.walk/prewalk" {:ns "clojure.walk",
                                   :name "prewalk",
                                   :signature ["[f form]"],
                                   :name-encode "prewalk",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.walk/prewalk",
                                   :source {:code "(defn prewalk\n  [f form]\n  (walk (partial prewalk f) identity (f form)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/walk.cljs",
                                            :lines [58 62]},
                                   :full-name "clojure.walk/prewalk",
                                   :docstring "Like postwalk, but does pre-order traversal."},
           "cljs.core/flatten" {:ns "cljs.core",
                                :name "flatten",
                                :signature ["[x]"],
                                :name-encode "flatten",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/flatten",
                                :source {:code "(defn flatten\n  [x]\n  (filter #(not (sequential? %))\n          (rest (tree-seq sequential? seq x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [4009 4015]},
                                :full-name "cljs.core/flatten",
                                :docstring "Takes any nested combination of sequential things (lists, vectors,\netc.) and returns their contents as a single, flat sequence.\n(flatten nil) returns nil."},
           "cljs.core/get" {:ns "cljs.core",
                            :name "get",
                            :signature ["[o k]" "[o k not-found]"],
                            :name-encode "get",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/get",
                            :source {:code "(defn get\n  ([o k]\n    (when-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k)\n\n        (array? o)\n        (when (< k (.-length o))\n          (aget o k))\n        \n        (string? o)\n        (when (< k (.-length o))\n          (aget o k))\n\n        (native-satisfies? ILookup o)\n        (-lookup o k)\n        \n        :else nil)))\n  ([o k not-found]\n    (if-not (nil? o)\n      (cond\n        (implements? ILookup o)\n        (-lookup ^not-native o k not-found)\n\n        (array? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n        \n        (string? o)\n        (if (< k (.-length o))\n          (aget o k)\n          not-found)\n\n        (native-satisfies? ILookup o)\n        (-lookup o k not-found)\n\n        :else not-found)\n      not-found)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1320 1360]},
                            :full-name "cljs.core/get",
                            :docstring "Returns the value mapped to key, not-found or nil if key not present."},
           "cljs.repl/skip-whitespace" {:ns "cljs.repl",
                                        :name "skip-whitespace",
                                        :signature ["[s]"],
                                        :name-encode "skip-whitespace",
                                        :history [["+" "0.0-2719"]],
                                        :type "function",
                                        :full-name-encode "cljs.repl/skip-whitespace",
                                        :source {:code "(defn skip-whitespace\n  [s]\n  (loop [c (.read s)]\n    (cond\n      (= c (int \\newline)) :line-start\n      (= c -1) :stream-end\n      (= c (int \\;)) (do (.readLine s) :line-start)\n      (or (Character/isWhitespace (char c)) (= c (int \\,))) (recur (.read s))\n      :else (do (.unread s c) :body))))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/repl.clj",
                                                 :lines [44 60]},
                                        :full-name "cljs.repl/skip-whitespace",
                                        :docstring "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\nor :body to indicate the relative location of the next character on s.\nInterprets comma as whitespace and semicolon as comment to end of line.\nDoes not interpret #! as comment to end of line because only one\ncharacter of lookahead is available. The stream must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF to a single\n\\newline."},
           "cljs.core/char" {:ns "cljs.core",
                             :name "char",
                             :signature ["[x]"],
                             :name-encode "char",
                             :history [["+" "0.0-1798"]],
                             :type "function",
                             :full-name-encode "cljs.core/char",
                             :source {:code "(defn char\n  [x]\n  (cond\n    (number? x) (.fromCharCode js/String x)\n    (and (string? x) (== (.-length x) 1)) x\n    :else (throw (js/Error. \"Argument to char must be a character or number\"))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1937 1943]},
                             :full-name "cljs.core/char",
                             :docstring "Coerce to char"},
           "cljs.core/.." {:ns "cljs.core",
                           :name "..",
                           :signature ["[x form]" "[x form & more]"],
                           :name-encode "DOTDOT",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/DOTDOT",
                           :source {:code "(defmacro ..\n  ([x form] `(. ~x ~form))\n  ([x form & more] `(.. (. ~x ~form) ~@more)))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.6.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [1540 1556]},
                           :full-name "cljs.core/..",
                           :docstring "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\nExpands into a member access (.) of the first member on the first\nargument, followed by the next member on the result, etc. For\ninstance:\n\n(.. System (getProperties) (get \"os.name\"))\n\nexpands to:\n\n(. (. System (getProperties)) (get \"os.name\"))\n\nbut is easier to write, read, and understand."},
           "cljs.core/floats" {:ns "cljs.core",
                               :name "floats",
                               :signature ["[x]"],
                               :name-encode "floats",
                               :type "function",
                               :full-name-encode "cljs.core/floats",
                               :source {:code "(defn floats [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2057]},
                               :full-name "cljs.core/floats",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/Range" {:protocols #{"ISeqable"
                                           "IMeta"
                                           "IWithMeta"
                                           "IEmptyableCollection"
                                           "ICounted"
                                           "IReduce"
                                           "ISequential"
                                           "ISeq"
                                           "ICollection"
                                           "IHash"
                                           "IPrintWithWriter"
                                           "IIndexed"
                                           "IIterable"
                                           "INext"
                                           "IEquiv"
                                           "ICloneable"},
                              :ns "cljs.core",
                              :name "Range",
                              :signature ["[meta start end step __hash]"],
                              :name-encode "Range",
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Range",
                              :source {:code "(deftype Range [meta start end step ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (Range. meta start end step __hash))\n\n  IWithMeta\n  (-with-meta [rng meta] (Range. meta start end step __hash))\n\n  IMeta\n  (-meta [rng] meta)\n\n  ISeqable\n  (-seq [rng]\n    (if (pos? step)\n      (when (< start end)\n        rng)\n      (when (> start end)\n        rng)))\n\n  ISeq\n  (-first [rng]\n    (when-not (nil? (-seq rng)) start))\n  (-rest [rng]\n    (if-not (nil? (-seq rng))\n      (Range. meta (+ start step) end step nil)\n      ()))\n\n  IIterable\n  (-iterator [_]\n    (RangeIterator. start end step))\n\n  INext\n  (-next [rng]\n    (if (pos? step)\n      (when (< (+ start step) end)\n        (Range. meta (+ start step) end step nil))\n      (when (> (+ start step) end)\n        (Range. meta (+ start step) end step nil))))\n\n  ICollection\n  (-conj [rng o] (cons o rng))\n\n  IEmptyableCollection\n  (-empty [rng] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [rng other] (equiv-sequential rng other))\n\n  IHash\n  (-hash [rng] (caching-hash rng hash-ordered-coll __hash))\n\n  ICounted\n  (-count [rng]\n    (if-not (-seq rng)\n      0\n      (Math/ceil (/ (- end start) step))))\n\n  IIndexed\n  (-nth [rng n]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        (throw (js/Error. \"Index out of bounds\")))))\n  (-nth [rng n not-found]\n    (if (< n (-count rng))\n      (+ start (* n step))\n      (if (and (> start end) (zero? step))\n        start\n        not-found)))\n\n  IReduce\n  (-reduce [rng f] (ci-reduce rng f))\n  (-reduce [rng f init]\n    (loop [i start ret init]\n      (if (if (pos? step) (< i end) (> i end))\n        (let [ret (f ret i)]\n          (if (reduced? ret)\n            @ret\n            (recur (+ i step) ret)))\n        ret))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7806 7892]},
                              :full-name "cljs.core/Range"},
           "cljs.core/zero?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "zero?",
                              :signature ["[n]"],
                              :name-encode "zeroQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/zeroQMARK",
                              :source {:code "(defn ^boolean zero? [n]\n  (cljs.core/zero? n))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2171 2172]},
                              :extra-sources [{:code "(defmacro ^::ana/numeric zero? [x]\n  `(== ~x 0))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [466 467]}],
                              :full-name "cljs.core/zero?"},
           "cljs.core/identity" {:ns "cljs.core",
                                 :name "identity",
                                 :signature ["[x]"],
                                 :name-encode "identity",
                                 :type "function",
                                 :full-name-encode "cljs.core/identity",
                                 :source {:code "(defn identity [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1810]},
                                 :full-name "cljs.core/identity",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/first" {:ns "cljs.core",
                              :name "first",
                              :signature ["[coll]"],
                              :name-encode "first",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/first",
                              :source {:code "(defn first\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? ISeq coll)\n      (-first ^not-native coll)\n      (let [s (seq coll)]\n        (when-not (nil? s)\n          (-first s))))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [725 734]},
                              :full-name "cljs.core/first",
                              :docstring "Returns the first item in the collection. Calls seq on its\nargument. If coll is nil, returns nil."},
           "cljs.reader/ratio-pattern" {:ns "cljs.reader",
                                        :name "ratio-pattern",
                                        :name-encode "ratio-pattern",
                                        :type "var",
                                        :full-name-encode "cljs.reader/ratio-pattern",
                                        :source {:code "(def ratio-pattern (re-pattern \"^([-+]?[0-9]+)/([0-9]+)$\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [99]},
                                        :full-name "cljs.reader/ratio-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/println-str" {:ns "cljs.core",
                                    :name "println-str",
                                    :signature ["[& objs]"],
                                    :name-encode "println-str",
                                    :history [["+" "0.0-1011"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/println-str",
                                    :source {:code "(defn println-str\n  [& objs]\n  (prn-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8304 8307]},
                                    :full-name "cljs.core/println-str",
                                    :docstring "println to a string, returning it"},
           "cljs.core/>" {:return-type boolean,
                          :ns "cljs.core",
                          :name ">",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "GT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/GT",
                          :source {:code "(defn ^boolean >\n  ([x] true)\n  ([x y] (cljs.core/> x y))\n  ([x y & more]\n   (if (cljs.core/> x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/> y (first more)))\n     false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1893 1903]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric >\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} > ~{})\" x y)))\n  ([x y & more] `(and (> ~x ~y) (> ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [445 448]}],
                          :full-name "cljs.core/>",
                          :docstring "Returns non-nil if nums are in monotonically decreasing order,\notherwise false."},
           "cljs.core/juxt" {:ns "cljs.core",
                             :name "juxt",
                             :signature ["[f]"
                                         "[f g]"
                                         "[f g h]"
                                         "[f g h & fs]"],
                             :name-encode "juxt",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/juxt",
                             :source {:code "(defn juxt\n  ([f]\n     (fn\n       ([] (vector (f)))\n       ([x] (vector (f x)))\n       ([x y] (vector (f x y)))\n       ([x y z] (vector (f x y z)))\n       ([x y z & args] (vector (apply f x y z args)))))\n  ([f g]\n     (fn\n       ([] (vector (f) (g)))\n       ([x] (vector (f x) (g x)))\n       ([x y] (vector (f x y) (g x y)))\n       ([x y z] (vector (f x y z) (g x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args)))))\n  ([f g h]\n     (fn\n       ([] (vector (f) (g) (h)))\n       ([x] (vector (f x) (g x) (h x)))\n       ([x y] (vector (f x y) (g x y) (h x y)))\n       ([x y z] (vector (f x y z) (g x y z) (h x y z)))\n       ([x y z & args] (vector (apply f x y z args) (apply g x y z args) (apply h x y z args)))))\n  ([f g h & fs]\n     (let [fs (list* f g h fs)]\n       (fn\n         ([] (reduce #(conj %1 (%2)) [] fs))\n         ([x] (reduce #(conj %1 (%2 x)) [] fs))\n         ([x y] (reduce #(conj %1 (%2 x y)) [] fs))\n         ([x y z] (reduce #(conj %1 (%2 x y z)) [] fs))\n         ([x y z & args] (reduce #(conj %1 (apply %2 x y z args)) [] fs))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7993 8027]},
                             :full-name "cljs.core/juxt",
                             :docstring "Takes a set of functions and returns a fn that is the juxtaposition\nof those fns.  The returned fn takes a variable number of args, and\nreturns a vector containing the result of applying each fn to the\nargs (left-to-right).\n((juxt a b c) x) => [(a x) (b x) (c x)]"},
           "cljs.core/max" {:return-type number,
                            :ns "cljs.core",
                            :name "max",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "max",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/max",
                            :source {:code "(defn ^number max\n  ([x] x)\n  ([x y] (cljs.core/max x y))\n  ([x y & more]\n   (reduce max (cljs.core/max x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1921 1926]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric max\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} > ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(max (max ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [475 479]}],
                            :full-name "cljs.core/max",
                            :docstring "Returns the greatest of the nums."},
           "cljs.core/completing" {:ns "cljs.core",
                                   :name "completing",
                                   :signature ["[f]" "[f cf]"],
                                   :name-encode "completing",
                                   :type "function",
                                   :full-name-encode "cljs.core/completing",
                                   :source {:code "(defn completing\n  ([f] (completing f identity))\n  ([f cf]\n    (fn\n      ([] (f))\n      ([x] (cf x))\n      ([x y] (f x y)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1812 1818]},
                                   :full-name "cljs.core/completing",
                                   :history [["+" "0.0-2341"]]},
           "cljs.core/transduce" {:ns "cljs.core",
                                  :name "transduce",
                                  :signature ["[xform f coll]"
                                              "[xform f init coll]"],
                                  :name-encode "transduce",
                                  :history [["+" "0.0-2301"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/transduce",
                                  :source {:code "(defn transduce\n  ([xform f coll] (transduce xform f (f) coll))\n  ([xform f init coll]\n     (let [f (xform f)\n           ret (reduce f init coll)]\n       (f ret))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1820 1833]},
                                  :full-name "cljs.core/transduce",
                                  :docstring "reduce with a transformation of f (xf). If init is not\nsupplied, (f) will be called to produce it. f should be a reducing\nstep function that accepts both 1 and 2 arguments, if it accepts\nonly 2 you can add the arity-1 with 'completing'. Returns the result\nof applying (the transformed) xf to init and the first item in coll,\nthen applying xf to that result and the 2nd item, etc. If coll\ncontains no items, returns init and f is not called. Note that\ncertain transforms may inject or skip items."},
           "cljs.test/test-var" {:ns "cljs.test",
                                 :name "test-var",
                                 :signature ["[v]"],
                                 :name-encode "test-var",
                                 :history [["+" "0.0-2496"]],
                                 :type "function",
                                 :full-name-encode "cljs.test/test-var",
                                 :source {:code "(defn test-var\n  [v]\n  {:pre [(instance? Var v)]}\n  (if-let [t (:test (meta v))]\n    (do\n      (update-current-env! [:testing-vars] conj v)\n      (update-current-env! [:report-counters :test] inc)\n      (do-report {:type :begin-test-var :var v})\n      (try\n        (t)\n        (catch :default e\n          (do-report\n            {:type :error\n             :message \"Uncaught exception, not in assertion.\"\n             :expected nil\n             :actual e})))\n      (do-report {:type :end-test-var :var v})\n      (update-current-env! [:testing-vars] rest))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/test.cljs",
                                          :lines [357 376]},
                                 :full-name "cljs.test/test-var",
                                 :docstring "If v has a function in its :test metadata, calls that function,\nadd v to :testing-vars property of env."},
           "cljs.core/with-out-str" {:ns "cljs.core",
                                     :name "with-out-str",
                                     :signature ["[& body]"],
                                     :name-encode "with-out-str",
                                     :history [["+" "0.0-1535"]],
                                     :type "macro",
                                     :full-name-encode "cljs.core/with-out-str",
                                     :source {:code "(defmacro with-out-str\n  [& body]\n  `(let [sb# (goog.string.StringBuffer.)]\n     (binding [cljs.core/*print-fn* (fn [x#] (.append sb# x#))]\n       ~@body)\n     (cljs.core/str sb#)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1648 1656]},
                                     :full-name "cljs.core/with-out-str",
                                     :docstring "Evaluates exprs in a context in which *print-fn* is bound to .append\non a fresh StringBuffer.  Returns the string created by any nested\nprinting calls."},
           "cljs.core/*3" {:ns "cljs.core",
                           :name "*3",
                           :name-encode "STAR3",
                           :type "var",
                           :full-name-encode "cljs.core/STAR3",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the third most recent value printed\"}\n  *3)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [67 69]},
                           :full-name "cljs.core/*3",
                           :docstring "bound in a repl thread to the third most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.core/memfn" {:ns "cljs.core",
                              :name "memfn",
                              :signature ["[name & args]"],
                              :name-encode "memfn",
                              :history [["+" "0.0-1443"]],
                              :type "macro",
                              :full-name-encode "cljs.core/memfn",
                              :source {:code "(defmacro memfn\n  [name & args]\n  (let [t (with-meta (gensym \"target\")\n            (meta name))]\n    `(fn [~t ~@args]\n       (. ~t (~name ~@args)))))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [3550 3561]},
                              :full-name "cljs.core/memfn",
                              :docstring "Expands into code that creates a fn that expects to be passed an\nobject and any args and calls the named instance method on the\nobject passing the args. Use when you want to treat a Java method as\na first-class fn. name may be type-hinted with the method receiver's\ntype in order to avoid reflective calls."},
           "cljs.core/IEncodeClojure" {:ns "cljs.core",
                                       :name "IEncodeClojure",
                                       :name-encode "IEncodeClojure",
                                       :type "protocol",
                                       :full-name-encode "cljs.core/IEncodeClojure",
                                       :source {:code "(defprotocol IEncodeClojure\n  (-js->clj [x options] \"Transforms JavaScript values to Clojure\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [8659 8660]},
                                       :methods [{:name "-js->clj",
                                                  :signature ["[x options]"],
                                                  :docstring "Transforms JavaScript values to Clojure"}],
                                       :full-name "cljs.core/IEncodeClojure",
                                       :history [["+" "0.0-1552"]]},
           "cljs.core/TransientArrayMap" {:protocols #{"ITransientCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ITransientAssociative"
                                                       "ITransientMap"},
                                          :ns "cljs.core",
                                          :name "TransientArrayMap",
                                          :signature ["[editable? len arr]"],
                                          :name-encode "TransientArrayMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/TransientArrayMap",
                                          :source {:code "(deftype TransientArrayMap [^:mutable editable?\n                            ^:mutable len\n                            arr]\n  ICounted\n  (-count [tcoll]\n    (if editable?\n      (quot len 2)\n      (throw (js/Error. \"count after persistent!\"))))\n\n  ILookup\n  (-lookup [tcoll k]\n    (-lookup tcoll k nil))\n\n  (-lookup [tcoll k not-found]\n    (if editable?\n      (let [idx (array-map-index-of tcoll k)]\n        (if (== idx -1)\n          not-found\n          (aget arr (inc idx))))\n      (throw (js/Error. \"lookup after persistent!\"))))\n\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if editable?\n      (if (satisfies? IMapEntry o)\n        (-assoc! tcoll (key o) (val o))\n        (loop [es (seq o) tcoll tcoll]\n          (if-let [e (first es)]\n            (recur (next es)\n                   (-assoc! tcoll (key e) (val e)))\n            tcoll)))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if editable?\n      (do (set! editable? false)\n          (PersistentArrayMap. nil (quot len 2) arr nil))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (if (== idx -1)\n          (if (<= (+ len 2) (* 2 (.-HASHMAP-THRESHOLD PersistentArrayMap)))\n            (do (set! len (+ len 2))\n                (.push arr key)\n                (.push arr val)\n                tcoll)\n            (assoc! (array->transient-hash-map len arr) key val))\n          (if (identical? val (aget arr (inc idx)))\n            tcoll\n            (do (aset arr (inc idx) val)\n                tcoll))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  ITransientMap\n  (-dissoc! [tcoll key]\n    (if editable?\n      (let [idx (array-map-index-of tcoll key)]\n        (when (>= idx 0)\n          (aset arr idx (aget arr (- len 2)))\n          (aset arr (inc idx) (aget arr (dec len)))\n          (doto arr .pop .pop)\n          (set! len (- len 2)))\n        tcoll)\n      (throw (js/Error. \"dissoc! after persistent!\")))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5509 5575]},
                                          :full-name "cljs.core/TransientArrayMap"},
           "cljs.core/cond->>" {:ns "cljs.core",
                                :name "cond->>",
                                :signature ["[expr & clauses]"],
                                :name-encode "cond-GTGT",
                                :history [["+" "0.0-1798"]],
                                :type "macro",
                                :full-name-encode "cljs.core/cond-GTGT",
                                :source {:code "(defmacro cond->>\n  [expr & clauses]\n  (assert (even? (count clauses)))\n  (let [g (gensym)\n        pstep (fn [[test step]] `(if ~test (->> ~g ~step) ~g))]\n    `(let [~g ~expr\n           ~@(interleave (repeat g) (map pstep (partition 2 clauses)))]\n       ~g)))",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [6899 6911]},
                                :full-name "cljs.core/cond->>",
                                :docstring "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\nthrough each form for which the corresponding test expression\nis true.  Note that, unlike cond branching, cond->> threading does not short circuit\nafter the first true test expression."},
           "cljs.core/number?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "number?",
                                :signature ["[n]"],
                                :name-encode "numberQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/numberQMARK",
                                :source {:code "(defn ^boolean number? [n]\n  (cljs.core/number? n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [93 94]},
                                :extra-sources [{:code "(defmacro number? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'number'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [331 332]}],
                                :full-name "cljs.core/number?"},
           "cljs.core/array" {:return-type array,
                              :ns "cljs.core",
                              :name "array",
                              :signature ["[var-args]"],
                              :name-encode "array",
                              :history [["+" "0.0-927"]],
                              :type "function/macro",
                              :full-name-encode "cljs.core/array",
                              :source {:code "(defn ^array array\n  [var-args]            ;; [& items]\n  (let [a (js/Array. (alength (cljs.core/js-arguments)))]\n    (loop [i 0]\n      (if (< i (alength a))\n        (do\n          (aset a i (aget (cljs.core/js-arguments) i))\n          (recur (inc i)))\n        a))))",
                                       :title "Function code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [178 188]},
                              :extra-sources [{:code "(defmacro array [& rest]\n  (let [xs-str (->> (repeat \"~{}\")\n                    (take (count rest))\n                    (interpose \",\")\n                    (apply core/str))]\n    (vary-meta\n      (list* 'js* (core/str \"[\" xs-str \"]\") rest)\n      assoc :tag 'array)))",
                                               :title "Macro code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/core.clj",
                                               :lines [1397 1404]}],
                              :full-name "cljs.core/array",
                              :docstring "Creates a new javascript array.\n@param {...*} var_args"},
           "cljs.core/nthnext" {:ns "cljs.core",
                                :name "nthnext",
                                :signature ["[coll n]"],
                                :name-encode "nthnext",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/nthnext",
                                :source {:code "(defn nthnext\n  [coll n]\n  (loop [n n xs (seq coll)]\n    (if (and xs (pos? n))\n      (recur (dec n) (next xs))\n      xs)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2180 2186]},
                                :full-name "cljs.core/nthnext",
                                :docstring "Returns the nth next of coll, (seq coll) when n is 0."},
           "cljs.core/re-pattern" {:ns "cljs.core",
                                   :name "re-pattern",
                                   :signature ["[s]"],
                                   :name-encode "re-pattern",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/re-pattern",
                                   :source {:code "(defn re-pattern\n  [s]\n  (if (instance? js/RegExp s)\n    s\n    (let [[_ flags pattern] (re-find #\"^(?:\\(\\?([idmsux]*)\\))?(.*)\" s)]\n      (js/RegExp. pattern flags))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [8096 8102]},
                                   :full-name "cljs.core/re-pattern",
                                   :docstring "Returns an instance of RegExp which has compiled the provided string."},
           "cljs.core/missing-protocol" {:ns "cljs.core",
                                         :name "missing-protocol",
                                         :signature ["[proto obj]"],
                                         :name-encode "missing-protocol",
                                         :type "function",
                                         :full-name-encode "cljs.core/missing-protocol",
                                         :source {:code "(defn missing-protocol [proto obj]\n  (let [ty (type obj)\n        ty (if (and ty (.-cljs$lang$type ty))\n             (.-cljs$lang$ctorStr ty)\n             (goog/typeOf obj))]\n   (js/Error.\n     (.join (array \"No protocol method \" proto\n                   \" defined for type \" ty \": \" obj) \"\"))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [137 144]},
                                         :full-name "cljs.core/missing-protocol",
                                         :history [["+" "0.0-927"]]},
           "clojure.browser.dom/set-text" {:ns "clojure.browser.dom",
                                           :name "set-text",
                                           :signature ["[e s]"],
                                           :name-encode "set-text",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.dom/set-text",
                                           :source {:code "(defn set-text\n  [e s]\n  (gdom/setTextContent (ensure-element e) s))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/browser/dom.cljs",
                                                    :lines [124 129]},
                                           :full-name "clojure.browser.dom/set-text",
                                           :docstring "Set the text content for the passed element returning the\nelement. If a keyword is passed in the place of e, the element with\nthat id will be used and returned."},
           "cljs.test/js-line-and-column" {:ns "cljs.test",
                                           :name "js-line-and-column",
                                           :signature ["[stack-element]"],
                                           :name-encode "js-line-and-column",
                                           :type "function",
                                           :full-name-encode "cljs.test/js-line-and-column",
                                           :source {:code "(defn js-line-and-column [stack-element]\n  (let [parts (.split stack-element \":\")\n        cnt   (count parts)]\n    [(js/parseInt (nth parts (- cnt 2)))\n     (js/parseInt (nth parts (dec cnt)))]))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/test.cljs",
                                                    :lines [305 309]},
                                           :full-name "cljs.test/js-line-and-column",
                                           :history [["+" "0.0-2496"]]},
           "clojure.zip/up" {:ns "clojure.zip",
                             :name "up",
                             :signature ["[loc]"],
                             :name-encode "up",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "clojure.zip/up",
                             :source {:code "(defn up\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes r :r, changed? :changed?, :as path}] loc]\n      (when pnodes\n        (let [pnode (peek pnodes)]\n          (with-meta (if changed?\n                       [(make-node loc pnode (concat l (cons node r))) \n                        (and ppath (assoc ppath :changed? true))]\n                       [pnode ppath])\n                     (meta loc))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [111 122]},
                             :full-name "clojure.zip/up",
                             :docstring "Returns the loc of the parent of the node at this loc, or nil if at\nthe top"},
           "cljs.core/IWithMeta" {:ns "cljs.core",
                                  :name "IWithMeta",
                                  :name-encode "IWithMeta",
                                  :implementations #{"Subvec"
                                                     "Symbol"
                                                     "PersistentQueue"
                                                     "PersistentHashMap"
                                                     "PersistentTreeSet"
                                                     "PersistentArrayMapSeq"
                                                     "RedNode"
                                                     "EmptyList"
                                                     "LazyTransformer"
                                                     "ObjMap"
                                                     "MetaFn"
                                                     "BlackNode"
                                                     "PersistentVector"
                                                     "ValSeq"
                                                     "ChunkedCons"
                                                     "Range"
                                                     "PersistentQueueSeq"
                                                     "ChunkedSeq"
                                                     "ArrayNodeSeq"
                                                     "KeySeq"
                                                     "PersistentTreeMap"
                                                     "PersistentTreeMapSeq"
                                                     "RSeq"
                                                     "PersistentArrayMap"
                                                     "PersistentHashSet"
                                                     "NodeSeq"
                                                     "List"
                                                     "Cons"
                                                     "LazySeq"},
                                  :history [["+" "0.0-927"]],
                                  :type "protocol",
                                  :full-name-encode "cljs.core/IWithMeta",
                                  :source {:code "(defprotocol IWithMeta\n  (^clj -with-meta [o meta]))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [317 318]},
                                  :methods [{:name "-with-meta",
                                             :signature ["[o meta]"],
                                             :docstring nil}],
                                  :full-name "cljs.core/IWithMeta"},
           "cljs.core/bit-and-not" {:ns "cljs.core",
                                    :name "bit-and-not",
                                    :signature ["[x y]"
                                                "[x y & more]"],
                                    :name-encode "bit-and-not",
                                    :history [["+" "0.0-927"]],
                                    :type "function/macro",
                                    :full-name-encode "cljs.core/bit-and-not",
                                    :source {:code "(defn bit-and-not\n  ([x y] (cljs.core/bit-and-not x y))\n  ([x y & more]\n     (reduce bit-and-not (cljs.core/bit-and-not x y) more)))",
                                             :title "Function code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2101 2105]},
                                    :extra-sources [{:code "(defmacro ^::ana/numeric bit-and-not\n  ([x y] (core/list 'js* \"(~{} & ~~{})\" x y))\n  ([x y & more] `(bit-and-not (bit-and-not ~x ~y) ~@more)))",
                                                     :title "Macro code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/core.clj",
                                                     :lines [513 515]}],
                                    :full-name "cljs.core/bit-and-not",
                                    :docstring "Bitwise and"},
           "clojure.string/triml" {:ns "clojure.string",
                                   :name "triml",
                                   :signature ["[s]"],
                                   :name-encode "triml",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/triml",
                                   :source {:code "(defn triml\n    [s]\n    (gstring/trimLeft s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [152 155]},
                                   :full-name "clojure.string/triml",
                                   :docstring "Removes whitespace from the left side of string."},
           "cljs.core/chunk-append" {:ns "cljs.core",
                                     :name "chunk-append",
                                     :signature ["[b x]"],
                                     :name-encode "chunk-append",
                                     :type "function",
                                     :full-name-encode "cljs.core/chunk-append",
                                     :source {:code "(defn chunk-append [b x]\n  (.add b x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2737 2738]},
                                     :full-name "cljs.core/chunk-append",
                                     :history [["+" "0.0-1424"]]},
           "compiler-options/output-dir" {:ns "compiler-options",
                                          :name "output-dir",
                                          :name-encode "output-dir",
                                          :type "option",
                                          :full-name-encode "compiler-options/output-dir",
                                          :full-name "compiler-options/output-dir",
                                          :history [["+" "0.0-971"]]},
           "syntax/character" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "character",
                               :name-encode "character",
                               :type "syntax",
                               :full-name-encode "syntax/character",
                               :extra-sources ({:code "(defn- read-char*\n  [rdr backslash]\n  (let [ch (read-char rdr)]\n    (if-not (nil? ch)\n      (let [token (if (or (macro-terminating? ch)\n                          (whitespace? ch))\n                    (str ch)\n                    (read-token rdr ch))\n            token-len (count token)]\n        (cond\n\n         (== 1 token-len)  (Character/valueOf (nth token 0))\n\n         (= token \"newline\") \\newline\n         (= token \"space\") \\space\n         (= token \"tab\") \\tab\n         (= token \"backspace\") \\backspace\n         (= token \"formfeed\") \\formfeed\n         (= token \"return\") \\return\n\n         (.startsWith token \"u\")\n         (let [c (read-unicode-char token 1 4 16)\n               ic (int c)]\n           (if (and (> ic upper-limit)\n                    (< ic lower-limit))\n             (reader-error rdr \"Invalid character constant: \\\\u\" (Integer/toString ic 16))\n             c))\n\n         (.startsWith token \"x\")\n         (read-unicode-char token 1 2 16)\n\n         (.startsWith token \"o\")\n         (let [len (dec token-len)]\n           (if (> len 3)\n             (reader-error rdr \"Invalid octal escape sequence length: \" len)\n             (let [uc (read-unicode-char token 1 len 8)]\n               (if (> (int uc) 0377)\n                 (reader-error rdr \"Octal escape sequence must be in range [0, 377]\")\n                 uc))))\n\n         :else (reader-error rdr \"Unsupported character: \\\\\" token)))\n      (reader-error rdr \"EOF while reading character\"))))",
                                                :title "Reader code",
                                                :repo "tools.reader",
                                                :tag "tools.reader-0.8.10",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [107 148]}
                                               {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                :title "Reader table",
                                                :repo "tools.reader",
                                                :tag "tools.reader-0.8.10",
                                                :filename "src/main/clojure/clojure/tools/reader.clj",
                                                :lines [591 610]}),
                               :full-name "syntax/character",
                               :history [["+" "0.0-1853"]]},
           "syntax/unreadable" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "unreadable",
                                :name-encode "unreadable",
                                :type "syntax",
                                :full-name-encode "syntax/unreadable",
                                :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                                 :title "Reader table",
                                                 :repo "tools.reader",
                                                 :tag "tools.reader-0.8.10",
                                                 :filename "src/main/clojure/clojure/tools/reader.clj",
                                                 :lines [612 623]}),
                                :full-name "syntax/unreadable",
                                :history [["+" "0.0-1853"]]},
           "cljs.core/regexp?" {:ns "cljs.core",
                                :name "regexp?",
                                :signature ["[o]"],
                                :name-encode "regexpQMARK",
                                :type "function",
                                :full-name-encode "cljs.core/regexpQMARK",
                                :source {:code "(defn regexp? [o]\n  (instance? js/RegExp o))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8058 8059]},
                                :full-name "cljs.core/regexp?",
                                :history [["+" "0.0-1424"]]},
           "clojure.string/split" {:ns "clojure.string",
                                   :name "split",
                                   :signature ["[s re]"
                                               "[s re limit]"],
                                   :name-encode "split",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.string/split",
                                   :source {:code "(defn split\n  ([s re]\n     (split s re 0))\n    ([s re limit]\n     (discard-trailing-if-needed limit\n       (if (= (str re) \"/(?:)/\")\n         (split-with-empty-regex s limit)\n         (if (< limit 1)\n           (vec (.split (str s) re))\n           (loop [s s\n                  limit limit\n                  parts []]\n             (if (= limit 1)\n               (conj parts s)\n               (if-let [m (re-find re s)]\n                 (let [index (.indexOf s m)]\n                   (recur (.substring s (+ index (count m)))\n                          (dec limit)\n                          (conj parts (.substring s 0 index))))\n                 (conj parts s)))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/string.cljs",
                                            :lines [119 140]},
                                   :full-name "clojure.string/split",
                                   :docstring "Splits string on a regular expression. Optional argument limit is\nthe maximum number of splits. Not lazy. Returns vector of the splits."},
           "cljs.reader/read-4-chars" {:ns "cljs.reader",
                                       :name "read-4-chars",
                                       :signature ["[reader]"],
                                       :name-encode "read-4-chars",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-4-chars",
                                       :source {:code "(defn read-4-chars [reader]\n  (.toString\n    (StringBuffer.\n      (read-char reader)\n      (read-char reader)\n      (read-char reader)\n      (read-char reader))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [173 179]},
                                       :full-name "cljs.reader/read-4-chars",
                                       :history [["+" "0.0-1424"]]},
           "cljs.core/iteration" {:ns "cljs.core",
                                  :name "iteration",
                                  :signature ["[xform coll]"],
                                  :name-encode "iteration",
                                  :history [["+" "0.0-2301"]
                                            ["-" "0.0-2371"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/iteration",
                                  :source {:code "(defn iteration\n  [xform coll]\n  (Iteration. xform coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2356",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8205 8210]},
                                  :full-name "cljs.core/iteration",
                                  :docstring "Returns an iterable/seqable/reducible sequence of applications of\nthe transducer to the items in coll. Note that these applications\nwill be performed every time iterator/seq/reduce is called.",
                                  :removed {:in "0.0-2371",
                                            :last-seen "0.0-2356"}},
           "cljs.core/hash-map" {:ns "cljs.core",
                                 :name "hash-map",
                                 :signature ["[& keyvals]"],
                                 :name-encode "hash-map",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/hash-map",
                                 :source {:code "(defn hash-map\n  [& keyvals]\n  (loop [in (seq keyvals), out (transient (.-EMPTY PersistentHashMap))]\n    (if in\n      (recur (nnext in) (assoc! out (first in) (second in)))\n      (persistent! out))))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7126 7133]},
                                 :extra-sources [{:code "(defmacro hash-map\n  ([] `(.-EMPTY cljs.core/PersistentHashMap))\n  ([& kvs]\n    (let [pairs (partition 2 kvs)\n          ks    (map first pairs)\n          vs    (map second pairs)]\n      (vary-meta\n        `(.fromArrays cljs.core/PersistentHashMap (array ~@ks) (array ~@vs))\n        assoc :tag 'cljs.core/PersistentHashMap))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1440 1448]}],
                                 :full-name "cljs.core/hash-map",
                                 :docstring "keyval => key val\nReturns a new hash map with supplied mappings."},
           "cljs.core/mapv" {:ns "cljs.core",
                             :name "mapv",
                             :signature ["[f coll]"
                                         "[f c1 c2]"
                                         "[f c1 c2 c3]"
                                         "[f c1 c2 c3 & colls]"],
                             :name-encode "mapv",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapv",
                             :source {:code "(defn mapv\n  ([f coll]\n     (-> (reduce (fn [v o] (conj! v (f o))) (transient []) coll)\n         persistent!))\n  ([f c1 c2]\n     (into [] (map f c1 c2)))\n  ([f c1 c2 c3]\n     (into [] (map f c1 c2 c3)))\n  ([f c1 c2 c3 & colls]\n     (into [] (apply map f c1 c2 c3 colls))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [4031 4045]},
                             :full-name "cljs.core/mapv",
                             :docstring "Returns a vector consisting of the result of applying f to the\nset of first items of each coll, followed by applying f to the set\nof second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments."},
           "cljs.core/rem" {:ns "cljs.core",
                            :name "rem",
                            :signature ["[n d]"],
                            :name-encode "rem",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/rem",
                            :source {:code "(defn rem\n  [n d]\n  (let [q (quot n d)]\n    (- n (* d q))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2077 2081]},
                            :full-name "cljs.core/rem",
                            :docstring "remainder of dividing numerator by denominator."},
           "cljs.core/IRecord" {:ns "cljs.core",
                                :name "IRecord",
                                :name-encode "IRecord",
                                :type "protocol",
                                :full-name-encode "cljs.core/IRecord",
                                :source {:code "(defprotocol IRecord\n  \"Marker interface indicating a record object\")",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [341 342]},
                                :full-name "cljs.core/IRecord",
                                :docstring "Marker interface indicating a record object",
                                :history [["+" "0.0-927"]]},
           "cljs.core/RangedIterator" {:ns "cljs.core",
                                       :name "RangedIterator",
                                       :signature ["[i base arr v start end]"],
                                       :name-encode "RangedIterator",
                                       :type "type",
                                       :full-name-encode "cljs.core/RangedIterator",
                                       :source {:code "(deftype RangedIterator [^:mutable i ^:mutable base ^:mutable arr v start end]\n  Object\n  (hasNext [this]\n    (< i end))\n  (next [this]\n    (when (== (- i base) 32)\n      (set! arr (unchecked-array-for v i))\n      (set! base (+ base 32)))\n    (let [ret (aget arr (bit-and i 0x01f))]\n      (set! i (inc i))\n      ret)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [4250 4260]},
                                       :full-name "cljs.core/RangedIterator",
                                       :history [["+" "0.0-2371"]]},
           "cljs.core/volatile!" {:ns "cljs.core",
                                  :name "volatile!",
                                  :signature ["[val]"],
                                  :name-encode "volatileBANG",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/volatileBANG",
                                  :source {:code "(defn volatile!\n  [val]\n  (Volatile. val))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3604 3607]},
                                  :full-name "cljs.core/volatile!",
                                  :docstring "Creates and returns a Volatile with an initial value of val."},
           "cljs.core/constantly" {:ns "cljs.core",
                                   :name "constantly",
                                   :signature ["[x]"],
                                   :name-encode "constantly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/constantly",
                                   :source {:code "(defn constantly\n  [x] (fn [& args] x))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3339 3341]},
                                   :full-name "cljs.core/constantly",
                                   :docstring "Returns a function that takes any number of arguments and returns x."},
           "cljs.test/*current-env*" {:ns "cljs.test",
                                      :name "*current-env*",
                                      :name-encode "STARcurrent-envSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.test/STARcurrent-envSTAR",
                                      :source {:code "(def ^:dynamic *current-env* nil)",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/test.cljs",
                                               :lines [224]},
                                      :full-name "cljs.test/*current-env*",
                                      :history [["+" "0.0-2496"]]},
           "clojure.browser.dom/get-element" {:ns "clojure.browser.dom",
                                              :name "get-element",
                                              :signature ["[id]"],
                                              :name-encode "get-element",
                                              :type "function",
                                              :full-name-encode "clojure.browser.dom/get-element",
                                              :source {:code "(defn get-element [id]\n  (gdom/getElement (name id)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/clojure/browser/dom.cljs",
                                                       :lines [98 99]},
                                              :full-name "clojure.browser.dom/get-element",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/UUID" {:protocols #{"IHash"
                                          "IPrintWithWriter"
                                          "IEquiv"},
                             :ns "cljs.core",
                             :name "UUID",
                             :signature ["[uuid]"],
                             :name-encode "UUID",
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/UUID",
                             :source {:code "(deftype UUID [uuid]\n  Object\n  (toString [_] uuid)\n  (equiv [this other]\n    (-equiv this other))\n\n  IEquiv\n  (-equiv [_ other]\n    (and (instance? UUID other) (identical? uuid (.-uuid other))))\n\n  IPrintWithWriter\n  (-pr-writer [_ writer _]\n    (-write writer (str \"#uuid \\\"\" uuid \"\\\"\")))\n\n  IHash\n  (-hash [this]\n    (goog.string/hashCode (pr-str this))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [9146 9162]},
                             :full-name "cljs.core/UUID"},
           "warnings/overload-arity" {:ns "warnings",
                                      :name "overload-arity",
                                      :type "warning",
                                      :full-name "warnings/overload-arity",
                                      :full-name-encode "warnings/overload-arity",
                                      :name-encode "overload-arity",
                                      :history [["+" "0.0-2014"]]},
           "clojure.core.reducers/reduce" {:ns "clojure.core.reducers",
                                           :name "reduce",
                                           :signature ["[f coll]"
                                                       "[f init coll]"],
                                           :name-encode "reduce",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/reduce",
                                           :source {:code "(defn reduce\n  ([f coll] (reduce f (f) coll))\n  ([f init coll]\n     (if (map? coll)\n       (-kv-reduce coll f init)\n       (cond\n         (nil? coll) init\n         (array? coll) (array-reduce coll f init)\n         :else (-reduce coll f init)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [33 44]},
                                           :full-name "clojure.core.reducers/reduce",
                                           :docstring "Like core/reduce except:\n  When init is not provided, (f) is used.\n  Maps are reduced with reduce-kv"},
           "cljs.core/and" {:ns "cljs.core",
                            :name "and",
                            :signature ["[]" "[x]" "[x & next]"],
                            :name-encode "and",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/and",
                            :source {:code "(defmacro and\n  ([] true)\n  ([x] x)\n  ([x & next]\n    (let [forms (concat [x] next)]\n      (if (every? #(simple-test-expr? &env %)\n            (map #(cljs.analyzer/analyze &env %) forms))\n        (let [and-str (->> (repeat (count forms) \"(~{})\")\n                        (interpose \" && \")\n                        (apply core/str))]\n          (bool-expr `(~'js* ~and-str ~@forms)))\n        `(let [and# ~x]\n           (if and# (and ~@next) and#))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/core.clj",
                                     :lines [222 238]},
                            :full-name "cljs.core/and",
                            :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns logical false (nil or false), and returns that value and\ndoesn't evaluate any of the other expressions, otherwise it returns\nthe value of the last expr. (and) returns true."},
           "clojure.browser.repl/wrap-message" {:ns "clojure.browser.repl",
                                                :name "wrap-message",
                                                :signature ["[t data]"],
                                                :name-encode "wrap-message",
                                                :type "function",
                                                :full-name-encode "clojure.browser.repl/wrap-message",
                                                :source {:code "(defn wrap-message [t data]\n  (pr-str {:type t :content data :order (swap! order inc)}))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/clojure/browser/repl.cljs",
                                                         :lines [57
                                                                 58]},
                                                :full-name "clojure.browser.repl/wrap-message",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.reader/deregister-tag-parser!" {:ns "cljs.reader",
                                                 :name "deregister-tag-parser!",
                                                 :signature ["[tag]"],
                                                 :name-encode "deregister-tag-parserBANG",
                                                 :type "function",
                                                 :full-name-encode "cljs.reader/deregister-tag-parserBANG",
                                                 :source {:code "(defn deregister-tag-parser!\n  [tag]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* dissoc tag)\n    old-parser))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/reader.cljs",
                                                          :lines [595
                                                                  600]},
                                                 :full-name "cljs.reader/deregister-tag-parser!",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "clojure.reflect/print-doc" {:ns "clojure.reflect",
                                        :name "print-doc",
                                        :signature ["[{:keys [name method-params doc]}]"],
                                        :name-encode "print-doc",
                                        :type "function",
                                        :full-name-encode "clojure.reflect/print-doc",
                                        :source {:code "(defn print-doc [{:keys [name method-params doc]}]\n  (when-not (empty? name)\n    (println name)\n    (println method-params)\n    (println doc)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/clojure/reflect.cljs",
                                                 :lines [38 42]},
                                        :full-name "clojure.reflect/print-doc",
                                        :history [["+" "0.0-1503"]]},
           "clojure.browser.event/unlisten-by-key" {:ns "clojure.browser.event",
                                                    :name "unlisten-by-key",
                                                    :signature ["[key]"],
                                                    :name-encode "unlisten-by-key",
                                                    :type "function",
                                                    :full-name-encode "clojure.browser.event/unlisten-by-key",
                                                    :source {:code "(defn unlisten-by-key\n  [key]\n  (events/unlistenByKey key))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/clojure/browser/event.cljs",
                                                             :lines [73
                                                                     75]},
                                                    :full-name "clojure.browser.event/unlisten-by-key",
                                                    :history [["+"
                                                               "0.0-927"]]},
           "cljs.core/new" {:ns "cljs.core",
                            :name "new",
                            :type "special form",
                            :source {:code "(defmethod parse 'new\n  [_ env [_ ctor & args :as form] _ _]\n  (when-not (symbol? ctor) \n    (throw (error env \"First arg to new must be a symbol\")))\n  (disallowing-recur\n   (let [enve (assoc env :context :expr)\n         ctorexpr (analyze enve ctor)\n         ctor-var (resolve-existing-var env ctor)\n         record-args\n         (when (and (:record ctor-var) (not (-> ctor meta :internal-ctor)))\n           (repeat 3 (analyze enve nil)))\n         argexprs (into (vec (map #(analyze enve %) args)) record-args)\n         known-num-fields (:num-fields ctor-var)\n         argc (count args)]\n     (when (and (not (-> ctor meta :internal-ctor))\n                known-num-fields (not= known-num-fields argc))\n       (warning :fn-arity env {:argc argc :ctor ctor}))\n     {:env env :op :new :form form :ctor ctorexpr :args argexprs\n      :children (into [ctorexpr] argexprs)\n      :tag (let [name (-> ctorexpr :info :name)]\n             (or ('{js/Object object\n                    js/String string\n                    js/Array  array\n                    js/Number number\n                    js/Function function\n                    js/Boolean boolean} name)\n                 name))})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [1007 1033]},
                            :extra-sources ({:code "(defmethod emit* :new\n  [{:keys [ctor args env]}]\n  (emit-wrap env\n             (emits \"(new \" ctor \"(\"\n                    (comma-sep args)\n                    \"))\")))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [796 801]}),
                            :full-name "cljs.core/new",
                            :full-name-encode "cljs.core/new",
                            :name-encode "new",
                            :history [["+" "0.0-927"]]},
           "cljs.core/try" {:ns "cljs.core",
                            :name "try",
                            :type "special form",
                            :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [599 658]},
                            :extra-sources ({:code "(defmethod emit* :try\n  [{:keys [env try catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :constant (:op finally)) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [648 663]}),
                            :full-name "cljs.core/try",
                            :full-name-encode "cljs.core/try",
                            :name-encode "try",
                            :history [["+" "0.0-927"]]},
           "cljs.core/iterate" {:ns "cljs.core",
                                :name "iterate",
                                :signature ["[f x]"],
                                :name-encode "iterate",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/iterate",
                                :source {:code "(defn iterate\n  [f x] (cons x (lazy-seq (iterate f (f x)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3893 3896]},
                                :full-name "cljs.core/iterate",
                                :docstring "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects"},
           "cljs.core/lazy-seq" {:ns "cljs.core",
                                 :name "lazy-seq",
                                 :signature ["[& body]"],
                                 :name-encode "lazy-seq",
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-seq",
                                 :source {:code "(defmacro lazy-seq [& body]\n  `(new cljs.core/LazySeq nil (fn [] ~@body) nil nil))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1094 1095]},
                                 :full-name "cljs.core/lazy-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.test/update-current-env!" {:ns "cljs.test",
                                            :name "update-current-env!",
                                            :signature ["[ks f & args]"],
                                            :name-encode "update-current-envBANG",
                                            :type "function",
                                            :full-name-encode "cljs.test/update-current-envBANG",
                                            :source {:code "(defn update-current-env! [ks f & args]\n  (set! *current-env* (apply update-in (get-current-env) ks f args)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/test.cljs",
                                                     :lines [229 230]},
                                            :full-name "cljs.test/update-current-env!",
                                            :history [["+" "0.0-2496"]]},
           "cljs.core/IndexedSeq" {:protocols #{"ISeqable"
                                                "IReversible"
                                                "IEmptyableCollection"
                                                "ICounted"
                                                "IReduce"
                                                "ISequential"
                                                "ISeq"
                                                "ICollection"
                                                "IHash"
                                                "ASeq"
                                                "IPrintWithWriter"
                                                "IIndexed"
                                                "IIterable"
                                                "INext"
                                                "IEquiv"
                                                "ICloneable"},
                                   :ns "cljs.core",
                                   :name "IndexedSeq",
                                   :signature ["[arr i]"],
                                   :name-encode "IndexedSeq",
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/IndexedSeq",
                                   :source {:code "(deftype IndexedSeq [arr i]\n  Object\n  (toString [coll]\n   (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (IndexedSeq. arr i))\n\n  ISeqable\n  (-seq [this] this)\n\n  ASeq\n  ISeq\n  (-first [_] (aget arr i))\n  (-rest [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               (list)))\n\n  INext\n  (-next [_] (if (< (inc i) (alength arr))\n               (IndexedSeq. arr (inc i))\n               nil))\n\n  ICounted\n  (-count [_] (- (alength arr) i))\n\n  IIndexed\n  (-nth [coll n]\n    (let [i (+ n i)]\n      (when (< i (alength arr))\n        (aget arr i))))\n  (-nth [coll n not-found]\n    (let [i (+ n i)]\n      (if (< i (alength arr))\n        (aget arr i)\n        not-found)))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IIterable\n  (-iterator [coll]\n    (IndexedSeqIterator. arr i))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (.-EMPTY List))\n\n  IReduce\n  (-reduce [coll f]\n    (array-reduce arr f (aget arr i) (inc i)))\n  (-reduce [coll f start]\n    (array-reduce arr f start i))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReversible\n  (-rseq [coll]\n    (let [c (-count coll)]\n      (if (pos? c)\n        (RSeq. coll (dec c) nil)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1003 1069]},
                                   :full-name "cljs.core/IndexedSeq"},
           "cljs.repl.server/parse-headers" {:ns "cljs.repl.server",
                                             :name "parse-headers",
                                             :signature ["[header-lines]"],
                                             :name-encode "parse-headers",
                                             :history [["+"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.server/parse-headers",
                                             :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n    (mapcat\n      (fn [line]\n        (let [[k v] (str/split line #\":\" 2)]\n          [(keyword (str/lower-case k)) (str/triml v)]))\n      header-lines)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/clj/cljs/repl/server.clj",
                                                      :lines [60 68]},
                                             :full-name "cljs.repl.server/parse-headers",
                                             :docstring "Parse the headers of an HTTP POST request."},
           "cljs.core/KeySeq" {:protocols #{"ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IEmptyableCollection"
                                            "IReduce"
                                            "ISequential"
                                            "ISeq"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "INext"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "KeySeq",
                               :signature ["[mseq _meta]"],
                               :name-encode "KeySeq",
                               :history [["+" "0.0-1820"]],
                               :type "type",
                               :full-name-encode "cljs.core/KeySeq",
                               :source {:code "(deftype KeySeq [^not-native mseq _meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] _meta)\n\n  IWithMeta\n  (-with-meta [coll new-meta] (KeySeq. mseq new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) _meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n  \n  ISeq\n  (-first [coll]\n    (let [^not-native me (-first mseq)]\n      (-key me)))\n\n  (-rest [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (if-not (nil? nseq)\n        (KeySeq. nseq _meta)\n        ())))\n\n  INext\n  (-next [coll]\n    (let [nseq (if (satisfies? INext mseq)\n                 (-next mseq)\n                 (next mseq))]\n      (when-not (nil? nseq)\n        (KeySeq. nseq _meta))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7173 7226]},
                               :full-name "cljs.core/KeySeq"},
           "cljs.core/next" {:return-type seq,
                             :ns "cljs.core",
                             :name "next",
                             :signature ["[coll]"],
                             :name-encode "next",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/next",
                             :source {:code "(defn ^seq next\n  [coll]\n  (when-not (nil? coll)\n    (if (implements? INext coll)\n      (-next ^not-native coll)\n      (seq (rest coll)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [749 756]},
                             :full-name "cljs.core/next",
                             :docstring "Returns a seq of the items after the first. Calls seq on its\nargument.  If there are no more items, returns nil"},
           "cljs.core/*print-readably*" {:ns "cljs.core",
                                         :name "*print-readably*",
                                         :name-encode "STARprint-readablySTAR",
                                         :type "dynamic var",
                                         :full-name-encode "cljs.core/STARprint-readablySTAR",
                                         :source {:code "(def ^:dynamic *print-readably* true)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [34]},
                                         :full-name "cljs.core/*print-readably*",
                                         :history [["+" "0.0-927"]]},
           "cljs.repl.node/read-response" {:ns "cljs.repl.node",
                                           :name "read-response",
                                           :signature ["[in]"],
                                           :name-encode "read-response",
                                           :type "function",
                                           :full-name-encode "cljs.repl.node/read-response",
                                           :source {:code "(defn read-response [^BufferedReader in]\n  (let [sb (StringBuilder.)]\n    (loop [sb sb c (.read in)]\n      (cond\n       (= c 1) (let [ret (str sb)]\n                 (print ret)\n                 (recur (StringBuilder.) (.read in)))\n       (= c 0) (str sb)\n       :else (do\n               (.append sb (char c))\n               (recur sb (.read in)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/repl/node.clj",
                                                    :lines [38 48]},
                                           :full-name "cljs.repl.node/read-response",
                                           :history [["+" "0.0-2629"]]},
           "cljs.repl.browser/repl-client-js" {:ns "cljs.repl.browser",
                                               :name "repl-client-js",
                                               :signature ["[]"],
                                               :name-encode "repl-client-js",
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/repl-client-js",
                                               :source {:code "(defn repl-client-js []\n  (slurp (:client-js @browser-state)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [51 52]},
                                               :full-name "cljs.repl.browser/repl-client-js",
                                               :history [["+"
                                                          "0.0-927"]]},
           "compiler-options/source-map" {:ns "compiler-options",
                                          :name "source-map",
                                          :name-encode "source-map",
                                          :type "option",
                                          :full-name-encode "compiler-options/source-map",
                                          :full-name "compiler-options/source-map",
                                          :history [["+" "0.0-1798"]]},
           "cljs.core/booleans" {:ns "cljs.core",
                                 :name "booleans",
                                 :signature ["[x]"],
                                 :name-encode "booleans",
                                 :type "function",
                                 :full-name-encode "cljs.core/booleans",
                                 :source {:code "(defn booleans [x] x)",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2052]},
                                 :full-name "cljs.core/booleans",
                                 :history [["+" "0.0-1798"]]},
           "cljs.core/not-native" {:ns "cljs.core",
                                   :name "not-native",
                                   :name-encode "not-native",
                                   :type "var",
                                   :full-name-encode "cljs.core/not-native",
                                   :source {:code "(def not-native nil)",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [76]},
                                   :full-name "cljs.core/not-native",
                                   :history [["+" "0.0-1798"]]},
           "cljs.repl.browser/parse-headers" {:ns "cljs.repl.browser",
                                              :name "parse-headers",
                                              :signature ["[header-lines]"],
                                              :name-encode "parse-headers",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.browser/parse-headers",
                                              :source {:code "(defn parse-headers\n  [header-lines]\n  (apply hash-map\n   (mapcat\n    (fn [line]\n      (let [[k v] (str/split line #\":\" 2)]\n        [(keyword (str/lower-case k)) (str/triml v)]))\n    header-lines)))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r1450",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [116
                                                               124]},
                                              :full-name "cljs.repl.browser/parse-headers",
                                              :docstring "Parse the headers of an HTTP POST request.",
                                              :removed {:in "0.0-1503",
                                                        :last-seen "0.0-1450"}},
           "cljs.core/last" {:ns "cljs.core",
                             :name "last",
                             :signature ["[s]"],
                             :name-encode "last",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/last",
                             :source {:code "(defn last\n  [s]\n  (let [sn (next s)]\n    (if-not (nil? sn)\n      (recur sn)\n      (first s))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1168 1174]},
                             :full-name "cljs.core/last",
                             :docstring "Return the last item in coll, in linear time"},
           "cljs.core/pr-str*" {:ns "cljs.core",
                                :name "pr-str*",
                                :signature ["[obj]"],
                                :name-encode "pr-strSTAR",
                                :history [["+" "0.0-1806"]],
                                :type "function",
                                :full-name-encode "cljs.core/pr-strSTAR",
                                :source {:code "(defn pr-str*\n  [^not-native obj]\n  (let [sb (StringBuffer.)\n        writer (StringBufferWriter. sb)]\n    (-pr-writer obj writer (pr-opts))\n    (-flush writer)\n    (str sb)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [431 439]},
                                :full-name "cljs.core/pr-str*",
                                :docstring "Support so that collections can implement toString without\nloading all the printing machinery."},
           "cljs.core/letfn*" {:ns "cljs.core",
                               :name "letfn*",
                               :type "special form",
                               :source {:code "(defmethod parse 'letfn*\n  [op env [_ bindings & exprs :as form] name _]\n  (when-not (and (vector? bindings) (even? (count bindings)))\n    (throw (error env \"bindings must be vector of even number of elements\")))\n  (let [n->fexpr (into {} (map (juxt first second) (partition 2 bindings)))\n        names    (keys n->fexpr)\n        context  (:context env)\n        ;; first pass to collect information for recursive references\n        [meth-env bes]\n        (reduce (fn [[{:keys [locals] :as env} bes] n]\n                  (let [ret-tag (-> n meta :tag)\n                        fexpr (no-warn (analyze env (n->fexpr n)))\n                        be (cond->\n                             {:name n\n                              :fn-var true\n                              :line (get-line n env)\n                              :column (get-col n env)\n                              :local true\n                              :shadow (locals n)\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :methods (:methods fexpr)}\n                             ret-tag (assoc :ret-tag ret-tag))]\n                    [(assoc-in env [:locals n] be)\n                     (conj bes be)]))\n                [env []] names)\n        meth-env (assoc meth-env :context :expr)\n        ;; the real pass\n        [meth-env bes]\n        (reduce (fn [[meth-env bes] {:keys [name shadow] :as be}]\n                  (let [env (assoc-in meth-env [:locals name] shadow)\n                        fexpr (analyze env (n->fexpr name))\n                        be' (assoc be\n                              :init fexpr\n                              :variadic (:variadic fexpr)\n                              :max-fixed-arity (:max-fixed-arity fexpr)\n                              :method-params (map :params (:methods fexpr))\n                              :methods (:methods fexpr))]\n                    [(assoc-in env [:locals name] be')\n                     (conj bes be')]))\n          [meth-env []] bes)\n        expr (analyze (assoc meth-env :context (if (= :expr context) :return context)) `(do ~@exprs))]\n    {:env env :op :letfn :bindings bes :expr expr :form form\n     :children (conj (vec (map :init bes)) expr)}))",
                                        :title "Parser code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/clj/cljs/analyzer.clj",
                                        :lines [866 910]},
                               :extra-sources ({:code "(defmethod emit* :letfn\n  [{:keys [bindings expr env]}]\n  (let [context (:context env)]\n    (when (= :expr context) (emits \"(function (){\"))\n    (doseq [{:keys [init] :as binding} bindings]\n      (emitln \"var \" (munge binding) \" = \" init \";\"))\n    (emits expr)\n    (when (= :expr context) (emits \"})()\"))))",
                                                :title "Emitting code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/compiler.clj",
                                                :lines [701 708]}),
                               :full-name "cljs.core/letfn*",
                               :full-name-encode "cljs.core/letfnSTAR",
                               :name-encode "letfnSTAR",
                               :history [["+" "0.0-1236"]]},
           "cljs.core/bit-shift-left" {:ns "cljs.core",
                                       :name "bit-shift-left",
                                       :signature ["[x n]"],
                                       :name-encode "bit-shift-left",
                                       :history [["+" "0.0-927"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/bit-shift-left",
                                       :source {:code "(defn bit-shift-left\n  [x n] (cljs.core/bit-shift-left x n))",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [2131 2133]},
                                       :extra-sources [{:code "(defmacro ^::ana/numeric bit-shift-left [x n]\n  (core/list 'js* \"(~{} << ~{})\" x n))",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [526
                                                                527]}],
                                       :full-name "cljs.core/bit-shift-left",
                                       :docstring "Bitwise shift left"},
           "clojure.string/reverse" {:ns "clojure.string",
                                     :name "reverse",
                                     :signature ["[s]"],
                                     :name-encode "reverse",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/reverse",
                                     :source {:code "(defn reverse\n  [s]\n  (-> (.replace s re-surrogate-pair \"$2$1\")\n      (.. (split \"\") (reverse) (join \"\"))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [21 25]},
                                     :full-name "clojure.string/reverse",
                                     :docstring "Returns s with its characters reversed."},
           "cljs.core/min" {:return-type number,
                            :ns "cljs.core",
                            :name "min",
                            :signature ["[x]" "[x y]" "[x y & more]"],
                            :name-encode "min",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/min",
                            :source {:code "(defn ^number min\n  ([x] x)\n  ([x y] (cljs.core/min x y))\n  ([x y & more]\n   (reduce min (cljs.core/min x y) more)))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1928 1933]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric min\n  ([x] x)\n  ([x y] `(let [x# ~x, y# ~y]\n            (~'js* \"((~{} < ~{}) ? ~{} : ~{})\" x# y# x# y#)))\n  ([x y & more] `(min (min ~x ~y) ~@more)))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [481 485]}],
                            :full-name "cljs.core/min",
                            :docstring "Returns the least of the nums."},
           "cljs.reader/escape-char" {:ns "cljs.reader",
                                      :name "escape-char",
                                      :signature ["[buffer reader]"],
                                      :name-encode "escape-char",
                                      :type "function",
                                      :full-name-encode "cljs.reader/escape-char",
                                      :source {:code "(defn escape-char\n  [buffer reader]\n  (let [ch (read-char reader)\n        mapresult (escape-char-map ch)]\n    (if mapresult\n      mapresult\n      (cond\n        (identical? ch \\x)\n        (->> (read-2-chars reader)\n          (validate-unicode-escape unicode-2-pattern reader ch)\n          (make-unicode-char))\n\n        (identical? ch \\u)\n        (->> (read-4-chars reader)\n          (validate-unicode-escape unicode-4-pattern reader ch)\n          (make-unicode-char))\n\n        (numeric? ch)\n        (.fromCharCode js/String ch)\n\n        :else\n        (reader-error reader \"Unexpected unicode escape \\\\\" ch )))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [193 214]},
                                      :full-name "cljs.reader/escape-char",
                                      :history [["+" "0.0-927"]]},
           "cljs.reader/read-raw-string*" {:ns "cljs.reader",
                                           :name "read-raw-string*",
                                           :signature ["[reader _]"],
                                           :name-encode "read-raw-stringSTAR",
                                           :type "function",
                                           :full-name-encode "cljs.reader/read-raw-stringSTAR",
                                           :source {:code "(defn read-raw-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n      (nil? ch) (reader-error reader \"EOF while reading\")\n      (identical? \"\\\\\" ch) (do (.append buffer ch)\n                             (let [nch (read-char reader)]\n                               (if (nil? nch)\n                                 (reader-error reader \"EOF while reading\")\n                                 (recur (doto buffer (.append nch))\n                                        (read-char reader)))))\n      (identical? \"\\\"\" ch) (.toString buffer)\n      :else (recur (doto buffer (.append ch)) (read-char reader)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/reader.cljs",
                                                    :lines [304 317]},
                                           :full-name "cljs.reader/read-raw-string*",
                                           :history [["+" "0.0-2261"]]},
           "cljs.core/INext" {:ns "cljs.core",
                              :name "INext",
                              :name-encode "INext",
                              :implementations #{"PersistentArrayMapSeq"
                                                 "EmptyList"
                                                 "LazyTransformer"
                                                 "ValSeq"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "ChunkedSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "RSeq"
                                                 "List"
                                                 "Cons"
                                                 "LazySeq"},
                              :history [["+" "0.0-1424"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/INext",
                              :source {:code "(defprotocol INext\n  (^clj-or-nil -next [coll]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [279 280]},
                              :methods [{:name "-next",
                                         :signature ["[coll]"],
                                         :docstring nil}],
                              :full-name "cljs.core/INext"},
           "syntax/auto-gensym" {:syntax-equiv {:edn-url nil,
                                                :clj-url nil},
                                 :ns "syntax",
                                 :name "auto-gensym",
                                 :name-encode "auto-gensym",
                                 :type "special character",
                                 :full-name-encode "syntax/auto-gensym",
                                 :full-name "syntax/auto-gensym",
                                 :history [["+" "0.0-927"]]},
           "cljs.reader/read-map" {:ns "cljs.reader",
                                   :name "read-map",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-map",
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-map",
                                   :source {:code "(defn read-map\n  [rdr _]\n  (let [l (read-delimited-list \"}\" rdr true)]\n    (when (odd? (count l))\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (apply hash-map l)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [274 279]},
                                   :full-name "cljs.reader/read-map",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/seq" {:return-type seq,
                            :ns "cljs.core",
                            :name "seq",
                            :signature ["[coll]"],
                            :name-encode "seq",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/seq",
                            :source {:code "(defn ^seq seq\n  [coll]\n  (when-not (nil? coll)\n    (cond\n      (implements? ISeqable coll)\n      (-seq ^not-native coll)\n\n      (array? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (string? coll)\n      (when-not (zero? (alength coll))\n        (IndexedSeq. coll 0))\n\n      (native-satisfies? ISeqable coll)\n      (-seq coll)\n\n      :else (throw (js/Error. (str coll \" is not ISeqable\"))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [702 723]},
                            :full-name "cljs.core/seq",
                            :docstring "Returns a seq on the collection. If the collection is\nempty, returns nil.  (seq nil) returns nil. seq also works on\nStrings."},
           "cljs.core/defrecord*" {:ns "cljs.core",
                                   :name "defrecord*",
                                   :type "special form",
                                   :source {:code "(defmethod parse 'defrecord*\n  [_ env form _ _]\n  (parse-type :defrecord* env form) )",
                                            :title "Parser code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/analyzer.clj",
                                            :lines [1401 1403]},
                                   :full-name "cljs.core/defrecord*",
                                   :full-name-encode "cljs.core/defrecordSTAR",
                                   :name-encode "defrecordSTAR",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/*print-newline*" {:ns "cljs.core",
                                        :name "*print-newline*",
                                        :name-encode "STARprint-newlineSTAR",
                                        :type "dynamic var",
                                        :full-name-encode "cljs.core/STARprint-newlineSTAR",
                                        :source {:code "(def ^:dynamic *print-newline* true)",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [33]},
                                        :full-name "cljs.core/*print-newline*",
                                        :history [["+" "0.0-2060"]]},
           "cljs.core/long" {:ns "cljs.core",
                             :name "long",
                             :signature ["[x]"],
                             :name-encode "long",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/long",
                             :source {:code "(defn long\n  [x]\n  (fix x))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2042 2045]},
                             :full-name "cljs.core/long",
                             :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.core/es6-iterator" {:ns "cljs.core",
                                     :name "es6-iterator",
                                     :signature ["[coll]"],
                                     :name-encode "es6-iterator",
                                     :type "function",
                                     :full-name-encode "cljs.core/es6-iterator",
                                     :source {:code "(defn es6-iterator [coll]\n  (ES6Iterator. (seq coll)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [786 787]},
                                     :full-name "cljs.core/es6-iterator",
                                     :history [["+" "0.0-2371"]]},
           "cljs.core/not-empty" {:ns "cljs.core",
                                  :name "not-empty",
                                  :signature ["[coll]"],
                                  :name-encode "not-empty",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/not-empty",
                                  :source {:code "(defn not-empty\n  [coll] (when (seq coll) coll))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3054 3056]},
                                  :full-name "cljs.core/not-empty",
                                  :docstring "If coll is empty, returns nil, else coll"},
           "cljs.core/println" {:ns "cljs.core",
                                :name "println",
                                :signature ["[& objs]"],
                                :name-encode "println",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/println",
                                :source {:code "(defn println\n  [& objs]\n  (pr-with-opts objs (assoc (pr-opts) :readably false))\n  (when *print-newline*\n    (newline (pr-opts))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8297 8302]},
                                :full-name "cljs.core/println",
                                :docstring "Same as print followed by (newline)"},
           "clojure.browser.repl/connect" {:ns "clojure.browser.repl",
                                           :name "connect",
                                           :signature ["[repl-server-url]"],
                                           :name-encode "connect",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.browser.repl/connect",
                                           :source {:code "(defn connect\n  [repl-server-url]\n  (let [repl-connection\n        (net/xpc-connection\n          {:peer_uri repl-server-url})]\n    (swap! xpc-connection (constantly repl-connection))\n    (net/register-service repl-connection\n      :evaluate-javascript\n      (fn [js]\n        (net/transmit\n          repl-connection\n          :send-result\n          (evaluate-javascript repl-connection js))))\n    (net/connect repl-connection\n      (constantly nil)\n      (fn [iframe]\n        (set! (.-display (.-style iframe))\n          \"none\")))\n    ;; Monkey-patch goog.require if running under optimizations :none - David\n    (when-not js/COMPILED\n      (set! *loaded-libs*\n        (let [gntp (.. js/goog -dependencies_ -nameToPath)]\n          (into #{}\n            (filter\n              (fn [name]\n                (aget (.. js/goog -dependencies_ -visited) (aget gntp name)))\n              (js-keys gntp)))))\n      (set! (.-isProvided_ js/goog) (fn [_] false))\n      (set! (.-require js/goog)\n        (fn [name reload]\n          (when (or (not (contains? *loaded-libs* name)) reload)\n            (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n            (.appendChild js/document.body\n              (let [script (.createElement js/document \"script\")]\n                (set! (.-type script) \"text/javascript\")\n                (set! (.-src script)\n                  (str js/goog.basePath\n                    (aget (.. js/goog -dependencies_ -nameToPath) name)))\n                script))))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/browser/repl.cljs",
                                                    :lines [90 131]},
                                           :full-name "clojure.browser.repl/connect",
                                           :docstring "Connects to a REPL server from an HTML document. After the\nconnection is made, the REPL will evaluate forms in the context of\nthe document that called this function."},
           "cljs.core/bytes" {:ns "cljs.core",
                              :name "bytes",
                              :signature ["[x]"],
                              :name-encode "bytes",
                              :type "function",
                              :full-name-encode "cljs.core/bytes",
                              :source {:code "(defn bytes [x] x)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2053]},
                              :full-name "cljs.core/bytes",
                              :history [["+" "0.0-1798"]]},
           "cljs.core/unchecked-byte" {:return-type number,
                                       :ns "cljs.core",
                                       :name "unchecked-byte",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-byte",
                                       :history [["+" "0.0-1798"]],
                                       :type "function/macro",
                                       :full-name-encode "cljs.core/unchecked-byte",
                                       :source {:code "(defn ^number unchecked-byte [x] x)",
                                                :title "Function code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [1949]},
                                       :extra-sources [{:code "(defmacro unchecked-byte [x] x)",
                                                        :title "Macro code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/clj/cljs/core.clj",
                                                        :lines [366]}],
                                       :full-name "cljs.core/unchecked-byte"},
           "clojure.browser.dom/insert-at" {:ns "clojure.browser.dom",
                                            :name "insert-at",
                                            :signature ["[parent child index]"],
                                            :name-encode "insert-at",
                                            :type "function",
                                            :full-name-encode "clojure.browser.dom/insert-at",
                                            :source {:code "(defn insert-at [parent child index]\n  (gdom/insertChildAt parent child index))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/browser/dom.cljs",
                                                     :lines [104 105]},
                                            :full-name "clojure.browser.dom/insert-at",
                                            :history [["+" "0.0-927"]]},
           "cljs.core/quot" {:ns "cljs.core",
                             :name "quot",
                             :signature ["[n d]"],
                             :name-encode "quot",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/quot",
                             :source {:code "(defn quot\n  [n d]\n  (let [rem (js-mod n d)]\n    (fix (/ (- n rem) d))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2071 2075]},
                             :full-name "cljs.core/quot",
                             :docstring "quot[ient] of dividing numerator by denominator."},
           "cljs.repl.reflect/handle-reflect-query" {:ns "cljs.repl.reflect",
                                                     :name "handle-reflect-query",
                                                     :signature ["[[param _] & _]"],
                                                     :name-encode "handle-reflect-query",
                                                     :history [["+"
                                                                "0.0-1503"]],
                                                     :type "multimethod",
                                                     :full-name-encode "cljs.repl.reflect/handle-reflect-query",
                                                     :source {:code "(defmulti handle-reflect-query (fn [[param _] & _] param))",
                                                              :title "Source code",
                                                              :repo "clojurescript",
                                                              :tag "r2760",
                                                              :filename "src/clj/cljs/repl/reflect.clj",
                                                              :lines [60]},
                                                     :extra-sources ({:code "(defmethod handle-reflect-query \"var\"\n  [[_ sym] req conn opts]\n  (let [sym (read-url-string sym)]\n    (compile-and-return conn (get-meta sym))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r2760",
                                                                      :filename "src/clj/cljs/repl/reflect.clj",
                                                                      :lines [62
                                                                              65]}
                                                                     {:code "(defmethod handle-reflect-query \"macroform\"\n  [[_ mform] req conn opts]\n  (let [mform (-> mform read-url-string macroexpand)]\n    (server/send-and-close conn 200 (with-out-str (pprint/pprint mform)))))",
                                                                      :title "Dispatch method",
                                                                      :repo "clojurescript",
                                                                      :tag "r2760",
                                                                      :filename "src/clj/cljs/repl/reflect.clj",
                                                                      :lines [67
                                                                              70]}),
                                                     :full-name "cljs.repl.reflect/handle-reflect-query"},
           "clojure.browser.event/get-listener" {:ns "clojure.browser.event",
                                                 :name "get-listener",
                                                 :signature ["[src type listener opt_capt opt_handler]"],
                                                 :name-encode "get-listener",
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.event/get-listener",
                                                 :source {:code "(defn get-listener [src type listener opt_capt opt_handler])",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/clojure/browser/event.cljs",
                                                          :lines [91]},
                                                 :full-name "clojure.browser.event/get-listener",
                                                 :history [["+"
                                                            "0.0-927"]]},
           "cljs.core/filter" {:ns "cljs.core",
                               :name "filter",
                               :signature ["[pred]" "[pred coll]"],
                               :name-encode "filter",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/filter",
                               :source {:code "(defn filter\n  ([pred]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (if (pred input)\n             (rf result input)\n             result)))))\n  ([pred coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (when (pred (-nth c i))\n                (chunk-append b (-nth c i))))\n          (chunk-cons (chunk b) (filter pred (chunk-rest s))))\n        (let [f (first s) r (rest s)]\n          (if (pred f)\n            (cons f (filter pred r))\n            (filter pred r))))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3957 3984]},
                               :full-name "cljs.core/filter",
                               :docstring "Returns a lazy sequence of the items in coll for which\n(pred item) returns true. pred must be free of side-effects.\nReturns a transducer when no collection is provided."},
           "warnings/fn-var" {:ns "warnings",
                              :name "fn-var",
                              :type "warning",
                              :full-name "warnings/fn-var",
                              :full-name-encode "warnings/fn-var",
                              :name-encode "fn-var",
                              :history [["+" "0.0-1835"]]},
           "cljs.core/RSeq" {:protocols #{"ISeqable"
                                          "IMeta"
                                          "IWithMeta"
                                          "IEmptyableCollection"
                                          "ICounted"
                                          "IReduce"
                                          "ISequential"
                                          "ISeq"
                                          "ICollection"
                                          "IHash"
                                          "IPrintWithWriter"
                                          "INext"
                                          "IEquiv"
                                          "ICloneable"},
                             :ns "cljs.core",
                             :name "RSeq",
                             :signature ["[ci i meta]"],
                             :name-encode "RSeq",
                             :history [["+" "0.0-1424"]],
                             :type "type",
                             :full-name-encode "cljs.core/RSeq",
                             :source {:code "(deftype RSeq [ci i meta]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (RSeq. ci i meta))\n\n  IMeta\n  (-meta [coll] meta)\n  IWithMeta\n  (-with-meta [coll new-meta]\n    (RSeq. ci i new-meta))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeq\n  (-first [coll]\n    (-nth ci i))\n  (-rest [coll]\n    (if (pos? i)\n      (RSeq. ci (dec i) nil)\n      ()))\n  \n  INext\n  (-next [coll]\n    (when (pos? i)\n      (RSeq. ci (dec i) nil)))\n\n  ICounted\n  (-count [coll] (inc i))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (hash-ordered-coll coll))\n\n  IReduce\n  (-reduce [col f] (seq-reduce f col))\n  (-reduce [col f start] (seq-reduce f start col)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1088 1139]},
                             :full-name "cljs.core/RSeq"},
           "clojure.zip/branch?" {:ns "clojure.zip",
                                  :name "branch?",
                                  :signature ["[loc]"],
                                  :name-encode "branchQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/branchQMARK",
                                  :source {:code "(defn branch?\n  [loc]\n    ((:zip/branch? (meta loc)) (node loc)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [64 67]},
                                  :full-name "clojure.zip/branch?",
                                  :docstring "Returns true if the node at loc is a branch"},
           "cljs.core/ObjMap" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMap"
                                            "IMeta"
                                            "IWithMeta"
                                            "IKVReduce"
                                            "IEditableCollection"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "ILookup"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "IAssociative"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "ObjMap",
                               :signature ["[meta keys strobj update-count __hash]"],
                               :name-encode "ObjMap",
                               :history [["+" "0.0-927"]],
                               :type "type",
                               :full-name-encode "cljs.core/ObjMap",
                               :source {:code "(deftype ObjMap [meta keys strobj update-count ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll meta] (ObjMap. meta keys strobj update-count __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (reduce -conj\n              coll\n              entry)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY ObjMap) meta))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (pos? (alength keys))\n      (map #(vector % (aget strobj %))\n           (.sort keys obj-map-compare-keys))))\n\n  ICounted\n  (-count [coll] (alength keys))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (aget strobj k)\n      not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if ^boolean (goog/isString k)\n        (if (or (> update-count (.-HASHMAP_THRESHOLD ObjMap))\n                (>= (alength keys) (.-HASHMAP_THRESHOLD ObjMap)))\n          (obj-map->hash-map coll k v)\n          (if-not (nil? (scan-array 1 k keys))\n            (let [new-strobj (obj-clone strobj keys)]\n              (aset new-strobj k v)\n              (ObjMap. meta keys new-strobj (inc update-count) nil)) ; overwrite\n            (let [new-strobj (obj-clone strobj keys) ; append\n                  new-keys (aclone keys)]\n              (aset new-strobj k v)\n              (.push new-keys k)\n              (ObjMap. meta new-keys new-strobj (inc update-count) nil))))\n        ;; non-string key. game over.\n        (obj-map->hash-map coll k v)))\n  (-contains-key? [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      true\n      false))\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (let [len (alength keys)]\n      (loop [keys (.sort keys obj-map-compare-keys)\n             init init]\n        (if (seq keys)\n          (let [k (first keys)\n                init (f init k (aget strobj k))]\n            (if (reduced? init)\n              @init\n              (recur (rest keys) init)))\n          init))))\n\n  IMap\n  (-dissoc [coll k]\n    (if (and ^boolean (goog/isString k)\n             (not (nil? (scan-array 1 k keys))))\n      (let [new-keys (aclone keys)\n            new-strobj (obj-clone strobj keys)]\n        (.splice new-keys (scan-array 1 k new-keys) 1)\n        (js-delete new-strobj k)\n        (ObjMap. meta new-keys new-strobj (inc update-count) nil))\n      coll)) ; key not found, return coll unchanged\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (transient (into (hash-map) coll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [5046 5148]},
                               :full-name "cljs.core/ObjMap"},
           "cljs.core/sequence" {:ns "cljs.core",
                                 :name "sequence",
                                 :signature ["[coll]"
                                             "[xform coll]"
                                             "[xform coll & colls]"],
                                 :name-encode "sequence",
                                 :history [["+" "0.0-2120"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/sequence",
                                 :source {:code "(defn sequence\n  ([coll]\n     (if (seq? coll)\n       coll\n       (or (seq coll) ())))\n  ([xform coll]\n     (.create LazyTransformer xform coll))\n  ([xform coll & colls]\n     (.createMulti LazyTransformer xform (to-array (cons coll colls)))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3273 3289]},
                                 :full-name "cljs.core/sequence",
                                 :docstring "Coerces coll to a (possibly empty) sequence, if it is not already\none. Will not force a lazy seq. (sequence nil) yields (), When a\ntransducer is supplied, returns a lazy sequence of applications of\nthe transform to the items in coll(s), i.e. to the set of first\nitems of each coll, followed by the set of second\nitems in each coll, until any one of the colls is exhausted.  Any\nremaining items in other colls are ignored. The transform should accept\nnumber-of-colls arguments"},
           "cljs.core/zipmap" {:ns "cljs.core",
                               :name "zipmap",
                               :signature ["[keys vals]"],
                               :name-encode "zipmap",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/zipmap",
                               :source {:code "(defn zipmap\n  [keys vals]\n    (loop [map (transient {})\n           ks (seq keys)\n           vs (seq vals)]\n      (if (and ks vs)\n        (recur (assoc! map (first ks) (first vs))\n               (next ks)\n               (next vs))\n        (persistent! map))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7672 7682]},
                               :full-name "cljs.core/zipmap",
                               :docstring "Returns a map with the keys mapped to the corresponding vals."},
           "cljs.core/hash-combine" {:ns "cljs.core",
                                     :name "hash-combine",
                                     :signature ["[seed hash]"],
                                     :name-encode "hash-combine",
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-combine",
                                     :source {:code "(defn hash-combine [seed hash]\n  ; a la boost\n  (bit-xor seed\n    (+ hash 0x9e3779b9\n      (bit-shift-left seed 6)\n      (bit-shift-right seed 2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [562 567]},
                                     :full-name "cljs.core/hash-combine",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/reversible?" {:return-type boolean,
                                    :ns "cljs.core",
                                    :name "reversible?",
                                    :signature ["[coll]"],
                                    :name-encode "reversibleQMARK",
                                    :history [["+" "0.0-1211"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/reversibleQMARK",
                                    :source {:code "(defn ^boolean reversible? [coll]\n  (satisfies? IReversible coll))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2387 2388]},
                                    :full-name "cljs.core/reversible?"},
           "syntax/arg" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "arg",
                         :name-encode "arg",
                         :type "syntax",
                         :full-name-encode "syntax/arg",
                         :extra-sources ({:code "(defn- read-arg\n  [rdr pct]\n  (if-not (thread-bound? #'arg-env)\n    (read-symbol rdr pct)\n    (let [ch (peek-char rdr)]\n      (cond\n       (or (whitespace? ch)\n           (macro-terminating? ch)\n           (nil? ch))\n       (register-arg 1)\n\n       (identical? ch \\&)\n       (do (read-char rdr)\n           (register-arg -1))\n\n       :else\n       (let [n (read rdr true nil true)]\n         (if-not (integer? n)\n           (throw (IllegalStateException. \"Arg literal must be %, %& or %integer\"))\n           (register-arg n)))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [418 437]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [591 610]}),
                         :full-name "syntax/arg",
                         :history [["+" "0.0-1853"]]},
           "compiler-options/anon-fn-naming-policy" {:ns "compiler-options",
                                                     :name "anon-fn-naming-policy",
                                                     :name-encode "anon-fn-naming-policy",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/anon-fn-naming-policy",
                                                     :full-name "compiler-options/anon-fn-naming-policy",
                                                     :history [["+"
                                                                "0.0-2411"]]},
           "warnings/dynamic" {:ns "warnings",
                               :name "dynamic",
                               :type "warning",
                               :full-name "warnings/dynamic",
                               :full-name-encode "warnings/dynamic",
                               :name-encode "dynamic",
                               :history [["+" "0.0-1835"]]},
           "warnings/undeclared-ns-form" {:ns "warnings",
                                          :name "undeclared-ns-form",
                                          :type "warning",
                                          :full-name "warnings/undeclared-ns-form",
                                          :full-name-encode "warnings/undeclared-ns-form",
                                          :name-encode "undeclared-ns-form",
                                          :history [["+" "0.0-2014"]]},
           "clojure.core.reducers/flatten" {:ns "clojure.core.reducers",
                                            :name "flatten",
                                            :signature ["[]" "[coll]"],
                                            :name-encode "flatten",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/flatten",
                                            :source {:code "(defcurried flatten\n  \"Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.\"\n  {}\n  [coll]\n  (folder coll\n   (fn [f1]\n     (fn\n       ([] (f1))\n       ([ret v]\n          (if (sequential? v)\n            (-reduce (flatten v) f1 ret)\n            (f1 ret v)))))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [130 143]},
                                            :full-name "clojure.core.reducers/flatten",
                                            :docstring "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection."},
           "cljs.core/max-key" {:ns "cljs.core",
                                :name "max-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "max-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/max-key",
                                :source {:code "(defn max-key\n  ([k x] x)\n  ([k x y] (if (> (k x) (k y)) x y))\n  ([k x y & more]\n   (reduce #(max-key k %1 %2) (max-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7684 7689]},
                                :full-name "cljs.core/max-key",
                                :docstring "Returns the x for which (k x), a number, is greatest."},
           "clojure.zip/insert-child" {:ns "clojure.zip",
                                       :name "insert-child",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-child",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-child",
                                       :source {:code "(defn insert-child\n  [loc item]\n    (replace loc (make-node loc (node loc) (cons item (children loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [194 198]},
                                       :full-name "clojure.zip/insert-child",
                                       :docstring "Inserts the item as the leftmost child of the node at this loc,\nwithout moving"},
           "cljs.repl.browser/send-404" {:ns "cljs.repl.browser",
                                         :name "send-404",
                                         :signature ["[conn path]"],
                                         :name-encode "send-404",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1503"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/send-404",
                                         :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n                  (str \"<html><body>\"\n                       \"<h2>Page not found</h2>\"\n                       \"No page \" path \" found on this server.\"\n                       \"</body></html>\")\n                  \"text/html\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1450",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [92 98]},
                                         :full-name "cljs.repl.browser/send-404",
                                         :removed {:in "0.0-1503",
                                                   :last-seen "0.0-1450"}},
           "cljs.core/defrecord" {:ns "cljs.core",
                                  :name "defrecord",
                                  :signature ["[rsym fields & impls]"],
                                  :name-encode "defrecord",
                                  :type "macro",
                                  :full-name-encode "cljs.core/defrecord",
                                  :source {:code "(defmacro defrecord [rsym fields & impls]\n  (let [rsym (vary-meta rsym assoc :internal-ctor true)\n        r    (vary-meta\n               (:name (cljs.analyzer/resolve-var (dissoc &env :locals) rsym))\n               assoc :internal-ctor true)]\n    `(let []\n       ~(emit-defrecord &env rsym r fields impls)\n       (set! (.-cljs$lang$type ~r) true)\n       (set! (.-cljs$lang$ctorPrSeq ~r) (fn [this#] (core/list ~(core/str r))))\n       (set! (.-cljs$lang$ctorPrWriter ~r) (fn [this# writer#] (-write writer# ~(core/str r))))\n       ~(build-positional-factory rsym r fields)\n       ~(build-map-factory rsym r fields)\n       ~r)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [995 1007]},
                                  :full-name "cljs.core/defrecord",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/eduction" {:ns "cljs.core",
                                 :name "eduction",
                                 :signature ["[xform coll]"],
                                 :name-encode "eduction",
                                 :history [["+" "0.0-2371"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/eduction",
                                 :source {:code "(defn eduction\n  [xform coll]\n  (Eduction. xform coll))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8608 8613]},
                                 :full-name "cljs.core/eduction",
                                 :docstring "Returns a reducible/iterable/seqable application of\nthe transducer to the items in coll. Note that these applications\t\nwill be performed every time iterator/seq/reduce is called."},
           "cljs.core/ex-info" {:ns "cljs.core",
                                :name "ex-info",
                                :signature ["[msg data]"
                                            "[msg data cause]"],
                                :name-encode "ex-info",
                                :history [["+" "0.0-1576"]],
                                :type "function",
                                :full-name-encode "cljs.core/ex-info",
                                :source {:code "(defn ex-info\n  ([msg data] (ex-info msg data nil))\n  ([msg data cause]\n    ;; this way each new ExceptionInfo instance will inherit\n    ;; stack property from newly created Error\n    (set! (.-prototype ExceptionInfo) (js/Error msg))\n    (set! (.. ExceptionInfo -prototype -name) \"ExceptionInfo\")\n    (set! (.. ExceptionInfo -prototype -constructor) ExceptionInfo)\n\n    ;; since we've changed the prototype, we need to\n    ;; re-establish protocol implementations here\n    (set! (.. ExceptionInfo -prototype -toString) pr-str*)\n    (extend-type ExceptionInfo\n      IPrintWithWriter\n      (-pr-writer [obj writer opts]\n        (pr-writer-ex-info obj writer opts)))\n    (ExceptionInfo. msg data cause)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9179 9198]},
                                :full-name "cljs.core/ex-info",
                                :docstring "Alpha - subject to change.\nCreate an instance of ExceptionInfo, an Error type that carries a\nmap of additional data."},
           "closure-warnings/check-variables" {:ns "closure-warnings",
                                               :name "check-variables",
                                               :type "warning",
                                               :full-name "closure-warnings/check-variables",
                                               :full-name-encode "closure-warnings/check-variables",
                                               :name-encode "check-variables",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.repl.browser/repl-env" {:ns "cljs.repl.browser",
                                         :name "repl-env",
                                         :signature ["[& {:as opts}]"],
                                         :name-encode "repl-env",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.repl.browser/repl-env",
                                         :source {:code "(defn repl-env\n  [& {:as opts}]\n  (let [ups-deps (cljsc/get-upstream-deps)\n        opts (assoc opts\n               :ups-libs (:libs ups-deps)\n               :ups-foreign-libs (:foreign-libs ups-deps))\n        compiler-env (cljs.env/default-compiler-env opts)\n        opts (merge (BrowserEnv.)\n               {:port           9000\n                :optimizations  :simple\n                :working-dir    (->> [\".repl\" (util/clojurescript-version)]\n                                  (remove empty?) (string/join \"-\"))\n                :serve-static   true\n                :static-dir     [\".\" \"out/\"]\n                :preloaded-libs []\n                :src            \"src/\"\n                ::env/compiler  compiler-env\n                :source-map     false}\n               opts)]\n    (cljs.env/with-compiler-env compiler-env\n      (reset! preloaded-libs\n        (set (concat\n               (always-preload)\n               (map str (:preloaded-libs opts)))))\n      (reset! loaded-libs @preloaded-libs)\n      (println \"Compiling client js ...\")\n      (swap! browser-state\n        (fn [old]\n          (assoc old :client-js\n            (create-client-js-file\n              opts\n              (io/file (:working-dir opts) \"client.js\")))))\n      (println \"Waiting for browser to connect ...\")\n      opts)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [251 304]},
                                         :full-name "cljs.repl.browser/repl-env",
                                         :docstring "Create a browser-connected REPL environment.\n\nOptions:\n\nport:           The port on which the REPL server will run. Defaults to 9000.\nworking-dir:    The directory where the compiled REPL client JavaScript will\n                be stored. Defaults to \".repl\" with a ClojureScript version\n                suffix, eg. \".repl-0.0-2138\".\nserve-static:   Should the REPL server attempt to serve static content?\n                Defaults to true.\nstatic-dir:     List of directories to search for static content. Defaults to\n                [\".\" \"out/\"].\npreloaded-libs: List of namespaces that should not be sent from the REPL server\n                to the browser. This may be required if the browser is already\n                loading code and reloading it would cause a problem.\noptimizations:  The level of optimization to use when compiling the client\n                end of the REPL. Defaults to :simple.\nsrc:            The source directory containing user-defined cljs files. Used to\n                support reflection. Defaults to \"src/\".\n"},
           "compiler-options/optimize-constants" {:ns "compiler-options",
                                                  :name "optimize-constants",
                                                  :name-encode "optimize-constants",
                                                  :type "option",
                                                  :full-name-encode "compiler-options/optimize-constants",
                                                  :full-name "compiler-options/optimize-constants",
                                                  :history [["+"
                                                             "0.0-1877"]]},
           "cljs.core/butlast" {:ns "cljs.core",
                                :name "butlast",
                                :signature ["[s]"],
                                :name-encode "butlast",
                                :type "function",
                                :full-name-encode "cljs.core/butlast",
                                :source {:code "(defn butlast [s]\n  (loop [ret [] s s]\n    (if (next s)\n      (recur (conj ret (first s)) (next s))\n      (seq ret))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7657 7661]},
                                :full-name "cljs.core/butlast",
                                :history [["+" "0.0-927"]]},
           "cljs.core/array-iter" {:ns "cljs.core",
                                   :name "array-iter",
                                   :signature ["[x]"],
                                   :name-encode "array-iter",
                                   :type "function",
                                   :full-name-encode "cljs.core/array-iter",
                                   :source {:code "(defn array-iter [x]\n  (ArrayIter. x 0))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3086 3087]},
                                   :full-name "cljs.core/array-iter",
                                   :history [["+" "0.0-2301"]]},
           "cljs.core/print-str" {:ns "cljs.core",
                                  :name "print-str",
                                  :signature ["[& objs]"],
                                  :name-encode "print-str",
                                  :history [["+" "0.0-1011"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/print-str",
                                  :source {:code "(defn print-str\n  [& objs]\n  (pr-str-with-opts objs (assoc (pr-opts) :readably false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8292 8295]},
                                  :full-name "cljs.core/print-str",
                                  :docstring "print to a string, returning it"},
           "cljs.core/hash" {:ns "cljs.core",
                             :name "hash",
                             :signature ["[o]"],
                             :name-encode "hash",
                             :type "function",
                             :full-name-encode "cljs.core/hash",
                             :source {:code "(defn hash [o]\n  (cond\n    (implements? IHash o)\n    (-hash ^not-native o)\n\n    (number? o)\n    (js-mod (Math/floor o) 2147483647)\n\n    (true? o) 1\n\n    (false? o) 0\n\n    (string? o)\n    (m3-hash-int (hash-string o))\n\n    (instance? js/Date o)\n    (.valueOf o)\n\n    (nil? o) 0\n\n    :else\n    (-hash o)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [539 560]},
                             :full-name "cljs.core/hash",
                             :history [["+" "0.0-927"]]},
           "cljs.core/bit-set" {:ns "cljs.core",
                                :name "bit-set",
                                :signature ["[x n]"],
                                :name-encode "bit-set",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-set",
                                :source {:code "(defn bit-set\n  [x n]\n  (cljs.core/bit-set x n))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2121 2124]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-set [x n]\n  (core/list 'js* \"(~{} | (1 << ~{}))\" x n))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [538 539]}],
                                :full-name "cljs.core/bit-set",
                                :docstring "Set bit at index n"},
           "syntax/false" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "false",
                           :name-encode "false",
                           :type "special symbol",
                           :full-name-encode "syntax/false",
                           :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                            :title "Reader code",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [275 301]}),
                           :full-name "syntax/false",
                           :history [["+" "0.0-1853"]]},
           "cljs.core/clj->js" {:ns "cljs.core",
                                :name "clj->js",
                                :signature ["[x]"],
                                :name-encode "clj-GTjs",
                                :history [["+" "0.0-1552"]],
                                :type "function",
                                :full-name-encode "cljs.core/clj-GTjs",
                                :source {:code "(defn clj->js\n   [x]\n   (when-not (nil? x)\n     (if (satisfies? IEncodeJS x)\n       (-clj->js x)\n       (cond\n         (keyword? x) (name x)\n         (symbol? x) (str x)\n         (map? x) (let [m (js-obj)]\n                    (doseq [[k v] x]\n                      (aset m (key->js k) (clj->js v)))\n                    m)\n         (coll? x) (let [arr (array)]\n                     (doseq [x (map clj->js x)]\n                       (.push arr x))\n                     arr)\n         :else x))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8638 8657]},
                                :full-name "cljs.core/clj->js",
                                :docstring "Recursively transforms ClojureScript values to JavaScript.\nsets/vectors/lists become Arrays, Keywords and Symbol become Strings,\nMaps become Objects. Arbitrary keys are encoded to by key->js."},
           "repl-options/analyze-path" {:ns "repl-options",
                                        :name "analyze-path",
                                        :name-encode "analyze-path",
                                        :type "option",
                                        :full-name-encode "repl-options/analyze-path",
                                        :full-name "repl-options/analyze-path",
                                        :history [["+" "0.0-1552"]]},
           "cljs.core/concat" {:ns "cljs.core",
                               :name "concat",
                               :signature ["[]"
                                           "[x]"
                                           "[x y]"
                                           "[x y & zs]"],
                               :name-encode "concat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/concat",
                               :source {:code "(defn concat\n  ([] (lazy-seq nil))\n  ([x] (lazy-seq x))\n  ([x y]\n    (lazy-seq\n      (let [s (seq x)]\n        (if s\n          (if (chunked-seq? s)\n            (chunk-cons (chunk-first s) (concat (chunk-rest s) y))\n            (cons (first s) (concat (rest s) y)))\n          y))))\n  ([x y & zs]\n     (let [cat (fn cat [xys zs]\n                 (lazy-seq\n                   (let [xys (seq xys)]\n                     (if xys\n                       (if (chunked-seq? xys)\n                         (chunk-cons (chunk-first xys)\n                                     (cat (chunk-rest xys) zs))\n                         (cons (first xys) (cat (rest xys) zs)))\n                       (when zs\n                         (cat (first zs) (next zs)))))))]\n       (cat (concat x y) zs))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2873 2896]},
                               :full-name "cljs.core/concat",
                               :docstring "Returns a lazy seq representing the concatenation of the elements in the supplied colls."},
           "cljs.core/conj" {:ns "cljs.core",
                             :name "conj",
                             :signature ["[]"
                                         "[coll]"
                                         "[coll x]"
                                         "[coll x & xs]"],
                             :name-encode "conj",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/conj",
                             :source {:code "(defn conj\n  ([] [])\n  ([coll] coll)\n  ([coll x]\n    (if-not (nil? coll)\n      (-conj coll x)\n      (list x)))\n  ([coll x & xs]\n    (if xs\n      (recur (conj coll x) (first xs) (next xs))\n      (conj coll x))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1180 1193]},
                             :full-name "cljs.core/conj",
                             :docstring "conj[oin]. Returns a new collection with the xs\n'added'. (conj nil item) returns (item).  The 'addition' may\nhappen at different 'places' depending on the concrete type."},
           "cljs.core/unchecked-short" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-short",
                                        :signature ["[x]"],
                                        :name-encode "unchecked-short",
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-short",
                                        :source {:code "(defn ^number unchecked-short [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1951]},
                                        :extra-sources [{:code "(defmacro unchecked-short [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [368]}],
                                        :full-name "cljs.core/unchecked-short"},
           "clojure.set/difference" {:ns "clojure.set",
                                     :name "difference",
                                     :signature ["[s1]"
                                                 "[s1 s2]"
                                                 "[s1 s2 & sets]"],
                                     :name-encode "difference",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/difference",
                                     :source {:code "(defn difference\n  ([s1] s1)\n  ([s1 s2] \n     (if (< (count s1) (count s2))\n       (reduce (fn [result item] \n                   (if (contains? s2 item) \n                     (disj result item) \n                     result))\n               s1 s1)\n       (reduce disj s1 s2)))\n  ([s1 s2 & sets] \n     (reduce difference s1 (conj sets s2))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [46 58]},
                                     :full-name "clojure.set/difference",
                                     :docstring "Return a set that is the first set without elements of the remaining sets"},
           "cljs.core/byte" {:return-type number,
                             :ns "cljs.core",
                             :name "byte",
                             :signature ["[x]"],
                             :name-encode "byte",
                             :history [["+" "0.0-1798"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/byte",
                             :source {:code "(defn ^number byte [x] x)",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1935]},
                             :extra-sources [{:code "(defmacro byte [x] x)",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [361]}],
                             :full-name "cljs.core/byte"},
           "cljs.core/when-first" {:ns "cljs.core",
                                   :name "when-first",
                                   :signature ["[bindings & body]"],
                                   :name-encode "when-first",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/when-first",
                                   :source {:code "(defmacro when-first\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n  (let [[x xs] bindings]\n    `(when-let [xs# (seq ~xs)]\n       (let [~x (first xs#)]\n           ~@body))))",
                                            :title "Source code",
                                            :repo "clojure",
                                            :tag "clojure-1.6.0",
                                            :filename "src/clj/clojure/core.clj",
                                            :lines [4230 4242]},
                                   :full-name "cljs.core/when-first",
                                   :docstring "bindings => x xs\n\nRoughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once"},
           "cljs.reader/*tag-table*" {:ns "cljs.reader",
                                      :name "*tag-table*",
                                      :name-encode "STARtag-tableSTAR",
                                      :type "dynamic var",
                                      :full-name-encode "cljs.reader/STARtag-tableSTAR",
                                      :source {:code "(def ^:dynamic *tag-table*\n  (atom {\"inst\"  read-date\n         \"uuid\"  read-uuid\n         \"queue\" read-queue\n         \"js\"    read-js}))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/reader.cljs",
                                               :lines [567 571]},
                                      :full-name "cljs.reader/*tag-table*",
                                      :history [["+" "0.0-1236"]]},
           "cljs.core/distinct?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "distinct?",
                                  :signature ["[x]"
                                              "[x y]"
                                              "[x y & more]"],
                                  :name-encode "distinctQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/distinctQMARK",
                                  :source {:code "(defn ^boolean distinct?\n  ([x] true)\n  ([x y] (not (= x y)))\n  ([x y & more]\n     (if (not (= x y))\n     (loop [s #{x y} xs more]\n       (let [x (first xs)\n             etc (next xs)]\n         (if xs\n           (if (contains? s x)\n             false\n             (recur (conj s x) etc))\n           true)))\n     false)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1637 1651]},
                                  :full-name "cljs.core/distinct?",
                                  :docstring "Returns true if no two of the arguments are ="},
           "clojure.core.reducers/filter" {:ns "clojure.core.reducers",
                                           :name "filter",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :name-encode "filter",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/filter",
                                           :source {:code "(defcurried filter\n  \"Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               ret))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [117 128]},
                                           :full-name "clojure.core.reducers/filter",
                                           :docstring "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.core/INamed" {:ns "cljs.core",
                               :name "INamed",
                               :name-encode "INamed",
                               :implementations #{"Symbol"
                                                  "Keyword"
                                                  "MultiFn"},
                               :history [["+" "0.0-1798"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/INamed",
                               :source {:code "(defprotocol INamed\n  (^string -name [x])\n  (^string -namespace [x]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [406 408]},
                               :methods [{:name "-name",
                                          :signature ["[x]"],
                                          :docstring nil}
                                         {:name "-namespace",
                                          :signature ["[x]"],
                                          :docstring nil}],
                               :full-name "cljs.core/INamed"},
           "cljs.repl/merge-spec" {:ns "cljs.repl",
                                   :name "merge-spec",
                                   :signature ["[[lib & {:as aindex}] [_ & {:as bindex}]]"],
                                   :name-encode "merge-spec",
                                   :history [["+" "0.0-2629"]
                                             ["-" "0.0-2655"]],
                                   :type "function",
                                   :full-name-encode "cljs.repl/merge-spec",
                                   :source {:code "(defn merge-spec [[lib & {:as aindex}] [_ & {:as bindex}]]\n  (let [merged-map\n        (merge-with\n          (fn [x y]\n            (if (vector? x)\n              (vec (distinct (into x y)))\n              y))\n          aindex bindex)]\n    (apply vector lib\n      (apply concat\n        (sort\n          (fn [[sa] [sb]]\n            (compare (spec-sort sa) (spec-sort sb)))\n          merged-map)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2644",
                                            :filename "src/clj/cljs/repl.clj",
                                            :lines [196 209]},
                                   :full-name "cljs.repl/merge-spec",
                                   :removed {:in "0.0-2655",
                                             :last-seen "0.0-2644"}},
           "syntax/set" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "set",
                         :name-encode "set",
                         :type "syntax",
                         :full-name-encode "syntax/set",
                         :extra-sources ({:code "(defn- read-set\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-set (PersistentHashSet/createWithCheck (read-delimited \\} rdr true))\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta the-set\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [358 373]}
                                         {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [612 623]}),
                         :full-name "syntax/set",
                         :history [["+" "0.0-1853"]]},
           "cljs.core/add-to-string-hash-cache" {:ns "cljs.core",
                                                 :name "add-to-string-hash-cache",
                                                 :signature ["[k]"],
                                                 :name-encode "add-to-string-hash-cache",
                                                 :type "function",
                                                 :full-name-encode "cljs.core/add-to-string-hash-cache",
                                                 :source {:code "(defn add-to-string-hash-cache [k]\n  (let [h (hash-string* k)]\n    (aset string-hash-cache k h)\n    (set! string-hash-cache-count (inc string-hash-cache-count))\n    h))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [524
                                                                  528]},
                                                 :full-name "cljs.core/add-to-string-hash-cache",
                                                 :history [["+"
                                                            "0.0-1424"]]},
           "cljs.repl.rhino/repl-env" {:ns "cljs.repl.rhino",
                                       :name "repl-env",
                                       :signature ["[]"],
                                       :name-encode "repl-env",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.rhino/repl-env",
                                       :source {:code "(defn repl-env\n  []\n  (let [cx (Context/enter)\n        scope (.initStandardObjects cx)\n        base (io/resource \"goog/base.js\")\n        deps (io/resource \"goog/deps.js\")\n        new-repl-env (merge (RhinoEnv.) {:cx cx :scope scope})]\n    (assert base \"Can't find goog/base.js in classpath\")\n    (assert deps \"Can't find goog/deps.js in classpath\")\n    (ScriptableObject/putProperty scope\n      \"___repl_env\" (Context/javaToJS new-repl-env scope))\n    (with-open [r (io/reader base)]\n      (-eval r new-repl-env \"goog/base.js\" 1))\n    (-eval bootjs new-repl-env \"bootjs\" 1)\n    ;; Load deps.js line-by-line to avoid 64K method limit\n    (with-open [reader (io/reader deps)]\n      (doseq [^String line (line-seq reader)]\n        (-eval line new-repl-env \"goog/deps.js\" 1)))\n    new-repl-env))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl/rhino.clj",
                                                :lines [147 167]},
                                       :full-name "cljs.repl.rhino/repl-env",
                                       :docstring "Returns a fresh JS environment, suitable for passing to repl.\nHang on to return for use across repl calls."},
           "cljs.core/HashCollisionNode" {:ns "cljs.core",
                                          :name "HashCollisionNode",
                                          :signature ["[edit collision-hash cnt arr]"],
                                          :name-encode "HashCollisionNode",
                                          :type "type",
                                          :full-name-encode "cljs.core/HashCollisionNode",
                                          :source {:code "(deftype HashCollisionNode [edit\n                            ^:mutable collision-hash\n                            ^:mutable cnt\n                            ^:mutable arr]\n  Object\n  (inode-assoc [inode shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (let [len     (* 2 cnt)\n                new-arr (make-array (+ len 2))]\n            (array-copy arr 0 new-arr 0 len)\n            (aset new-arr len key)\n            (aset new-arr (inc len) val)\n            (set! (.-val added-leaf?) true)\n            (HashCollisionNode. nil collision-hash (inc cnt) new-arr))\n          (if (= (aget arr idx) val)\n            inode\n            (HashCollisionNode. nil collision-hash cnt (clone-and-set arr (inc idx) val)))))\n      (.inode-assoc (BitmapIndexedNode. nil (bitpos collision-hash shift) (array nil inode))\n                    shift hash key val added-leaf?)))\n\n  (inode-without [inode shift hash key]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (== idx -1) inode\n            (== cnt 1)  nil\n            :else (HashCollisionNode. nil collision-hash (dec cnt) (remove-pair arr (quot idx 2))))))\n\n  (inode-lookup [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) (aget arr (inc idx))\n            :else                  not-found)))\n\n  (inode-find [inode shift hash key not-found]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (cond (< idx 0)              not-found\n            (key-test key (aget arr idx)) [(aget arr idx) (aget arr (inc idx))]\n            :else                  not-found)))\n\n  (inode-seq [inode]\n    (create-inode-seq arr))\n\n  (ensure-editable [inode e]\n    (if (identical? e edit)\n      inode\n      (let [new-arr (make-array (* 2 (inc cnt)))]\n        (array-copy arr 0 new-arr 0 (* 2 cnt))\n        (HashCollisionNode. e collision-hash cnt new-arr))))\n\n  (ensure-editable-array [inode e count array]\n    (if (identical? e edit)\n      (do (set! arr array)\n          (set! cnt count)\n          inode)\n      (HashCollisionNode. edit collision-hash count array)))\n\n  (inode-assoc! [inode edit shift hash key val added-leaf?]\n    (if (== hash collision-hash)\n      (let [idx (hash-collision-node-find-index arr cnt key)]\n        (if (== idx -1)\n          (if (> (alength arr) (* 2 cnt))\n            (let [editable (edit-and-set inode edit (* 2 cnt) key (inc (* 2 cnt)) val)]\n              (set! (.-val added-leaf?) true)\n              (set! (.-cnt editable) (inc (.-cnt editable)))\n              editable)\n            (let [len     (alength arr)\n                  new-arr (make-array (+ len 2))]\n              (array-copy arr 0 new-arr 0 len)\n              (aset new-arr len key)\n              (aset new-arr (inc len) val)\n              (set! (.-val added-leaf?) true)\n              (.ensure-editable-array inode edit (inc cnt) new-arr)))\n          (if (identical? (aget arr (inc idx)) val)\n            inode\n            (edit-and-set inode edit (inc idx) val))))\n      (.inode-assoc! (BitmapIndexedNode. edit (bitpos collision-hash shift) (array nil inode nil nil))\n                     edit shift hash key val added-leaf?)))\n\n  (inode-without! [inode edit shift hash key removed-leaf?]\n    (let [idx (hash-collision-node-find-index arr cnt key)]\n      (if (== idx -1)\n        inode\n        (do (aset removed-leaf? 0 true)\n            (if (== cnt 1)\n              nil\n              (let [editable (.ensure-editable inode edit)\n                    earr     (.-arr editable)]\n                (aset earr idx (aget earr (- (* 2 cnt) 2)))\n                (aset earr (inc idx) (aget earr (dec (* 2 cnt))))\n                (aset earr (dec (* 2 cnt)) nil)\n                (aset earr (- (* 2 cnt) 2) nil)\n                (set! (.-cnt editable) (dec (.-cnt editable)))\n                editable))))))\n\n  (kv-reduce [inode f init]\n    (inode-kv-reduce arr f init)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [5968 6064]},
                                          :full-name "cljs.core/HashCollisionNode",
                                          :history [["+" "0.0-1211"]]},
           "cljs.core/m3-mix-K1" {:return-type number,
                                  :ns "cljs.core",
                                  :name "m3-mix-K1",
                                  :signature ["[k1]"],
                                  :name-encode "m3-mix-K1",
                                  :history [["+" "0.0-2261"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/m3-mix-K1",
                                  :source {:code "(defn ^number m3-mix-K1 [k1]\n  (-> k1 (imul m3-C1) (int-rotate-left 15) (imul m3-C2)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [468 469]},
                                  :full-name "cljs.core/m3-mix-K1"},
           "cljs.core/object?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "object?",
                                :signature ["[x]"],
                                :name-encode "objectQMARK",
                                :history [["+" "0.0-2120"]],
                                :type "function",
                                :full-name-encode "cljs.core/objectQMARK",
                                :source {:code "(defn ^boolean object? [x]\n  (if-not (nil? x)\n    (identical? (.-constructor x) js/Object)\n    false))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [104 107]},
                                :full-name "cljs.core/object?"},
           "cljs.core/pos?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "pos?",
                             :signature ["[n]"],
                             :name-encode "posQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/posQMARK",
                             :source {:code "(defn ^boolean pos?\n  [n] (cljs.core/pos? n))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2167 2169]},
                             :extra-sources [{:code "(defmacro ^::ana/numeric pos? [x]\n  `(> ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [469 470]}],
                             :full-name "cljs.core/pos?",
                             :docstring "Returns true if num is greater than zero, else false"},
           "compiler-options/source-map-path" {:ns "compiler-options",
                                               :name "source-map-path",
                                               :name-encode "source-map-path",
                                               :type "option",
                                               :full-name-encode "compiler-options/source-map-path",
                                               :full-name "compiler-options/source-map-path",
                                               :history [["+"
                                                          "0.0-2060"]]},
           "cljs.core/into-array" {:return-type array,
                                   :ns "cljs.core",
                                   :name "into-array",
                                   :signature ["[aseq]" "[type aseq]"],
                                   :name-encode "into-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/into-array",
                                   :source {:code "(defn ^array into-array\n  ([aseq]\n     (into-array nil aseq))\n  ([type aseq]\n     (reduce (fn [a x] (.push a x) a) (array) aseq)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [213 217]},
                                   :full-name "cljs.core/into-array"},
           "syntax/tagged-literal" {:syntax-equiv {:edn-url nil,
                                                   :clj-url nil},
                                    :ns "syntax",
                                    :name "tagged-literal",
                                    :name-encode "tagged-literal",
                                    :type "syntax",
                                    :full-name-encode "syntax/tagged-literal",
                                    :extra-sources ({:code "(defn- read-tagged [rdr initch]\n  (let [tag (read rdr true nil false)]\n    (if-not (symbol? tag)\n      (reader-error rdr \"Reader tag must be a symbol\"))\n    (if-let [f (or (*data-readers* tag)\n                   (default-data-readers tag))]\n      (read-tagged* rdr tag f)\n      (if (.contains (name tag) \".\")\n        (read-ctor rdr tag)\n        (if-let [f *default-data-reader-fn*]\n          (f tag (read rdr true nil true))\n          (reader-error rdr \"No reader function for tag \" (name tag)))))))",
                                                     :title "Reader code",
                                                     :repo "tools.reader",
                                                     :tag "tools.reader-0.8.10",
                                                     :filename "src/main/clojure/clojure/tools/reader.clj",
                                                     :lines [662 673]}),
                                    :full-name "syntax/tagged-literal",
                                    :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentVector" {:protocols #{"IFn"
                                                      "ISeqable"
                                                      "IMeta"
                                                      "IWithMeta"
                                                      "IKVReduce"
                                                      "IReversible"
                                                      "IEditableCollection"
                                                      "IStack"
                                                      "IEmptyableCollection"
                                                      "ICounted"
                                                      "IReduce"
                                                      "ILookup"
                                                      "ISequential"
                                                      "ICollection"
                                                      "IHash"
                                                      "IComparable"
                                                      "IPrintWithWriter"
                                                      "IIndexed"
                                                      "IIterable"
                                                      "IAssociative"
                                                      "IVector"
                                                      "IEquiv"
                                                      "ICloneable"
                                                      "IMapEntry"},
                                         :ns "cljs.core",
                                         :name "PersistentVector",
                                         :signature ["[meta cnt shift root tail __hash]"],
                                         :name-encode "PersistentVector",
                                         :history [["+" "0.0-1006"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/PersistentVector",
                                         :source {:code "(deftype PersistentVector [meta cnt shift root tail ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ICloneable\n  (-clone [_] (PersistentVector. meta cnt shift root tail __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentVector. meta cnt shift root tail __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (when (> cnt 0)\n      (-nth coll (dec cnt))))\n  (-pop [coll]\n    (cond\n     (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n     (== 1 cnt) (-with-meta (.-EMPTY PersistentVector) meta)\n     (< 1 (- cnt (tail-off coll)))\n      (PersistentVector. meta (dec cnt) shift root (.slice tail 0 -1) nil)\n      :else (let [new-tail (unchecked-array-for coll (- cnt 2))\n                  nr (pop-tail coll shift root)\n                  new-root (if (nil? nr) (.-EMPTY-NODE PersistentVector) nr)\n                  cnt-1 (dec cnt)]\n              (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n                (PersistentVector. meta cnt-1 (- shift 5) (pv-aget new-root 0) new-tail nil)\n                (PersistentVector. meta cnt-1 shift new-root new-tail nil)))))\n\n  ICollection\n  (-conj [coll o]\n    (if (< (- cnt (tail-off coll)) 32)\n      (let [len (alength tail)\n            new-tail (make-array (inc len))]\n        (dotimes [i len]\n          (aset new-tail i (aget tail i)))\n        (aset new-tail len o)\n        (PersistentVector. meta (inc cnt) shift root new-tail nil))\n      (let [root-overflow? (> (bit-shift-right-zero-fill cnt 5) (bit-shift-left 1 shift))\n            new-shift (if root-overflow? (+ shift 5) shift)\n            new-root (if root-overflow?\n                       (let [n-r (pv-fresh-node nil)]\n                           (pv-aset n-r 0 root)\n                           (pv-aset n-r 1 (new-path nil shift (VectorNode. nil tail)))\n                           n-r)\n                       (push-tail coll shift root (VectorNode. nil tail)))]\n        (PersistentVector. meta (inc cnt) new-shift new-root (array o) nil))))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentVector) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other]\n    (if (instance? PersistentVector other)\n      (if (== cnt (count other))\n        (let [me-iter  (-iterator coll)\n              you-iter (-iterator other)]\n          (loop []\n            (if (.hasNext me-iter)\n              (let [x (.next me-iter)\n                    y (.next you-iter)]\n                (if (= x y)\n                  (recur)\n                  false))\n              true)))\n        false)\n      (equiv-sequential coll other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (cond\n      (zero? cnt) nil\n      (<= cnt 32) (IndexedSeq. tail 0)\n      :else (chunked-seq coll (first-array-for-longvec coll) 0 0)))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IIndexed\n  (-nth [coll n]\n    (aget (array-for coll n) (bit-and n 0x01f)))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (aget (unchecked-array-for coll n) (bit-and n 0x01f))\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IMapEntry\n  (-key [coll]\n    (-nth coll 0))\n  (-val [coll]\n    (-nth coll 1))\n\n  IAssociative\n  (-assoc [coll k v]\n    (if (number? k)\n      (-assoc-n coll k v)\n      (throw (js/Error. \"Vector's key for assoc must be a number.\"))))\n\n  IVector\n  (-assoc-n [coll n val]\n    (cond\n       (and (<= 0 n) (< n cnt))\n       (if (<= (tail-off coll) n)\n         (let [new-tail (aclone tail)]\n           (aset new-tail (bit-and n 0x01f) val)\n           (PersistentVector. meta cnt shift root new-tail nil))\n         (PersistentVector. meta cnt shift (do-assoc coll shift root n val) tail nil))\n       (== n cnt) (-conj coll val)\n       :else (throw (js/Error. (str \"Index \" n \" out of bounds  [0,\" cnt \"]\")))))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce v f))\n  (-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IKVReduce\n  (-kv-reduce [v f init]\n    (loop [i 0 init init]\n      (if (< i cnt)\n        (let [arr  (unchecked-array-for v i)\n              len  (alength arr)\n              init (loop [j 0 init init]\n                     (if (< j len)\n                       (let [init (f init (+ j i) (aget arr j))]\n                         (if (reduced? init)\n                           init\n                           (recur (inc j) init)))\n                       init))]\n          (if (reduced? init)\n            @init\n            (recur (+ i len) init)))\n        init)))\n\n  IFn\n  (-invoke [coll k]\n    (-nth coll k))\n  (-invoke [coll k not-found]\n    (-nth coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll]\n    (TransientVector. cnt shift (tv-editable-root root) (tv-editable-tail tail)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (RSeq. coll (dec cnt) nil)))\n\n  IIterable\n  (-iterator [this]\n    (ranged-iterator this 0 cnt)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4272 4452]},
                                         :full-name "cljs.core/PersistentVector"},
           "cljs.core/IHash" {:ns "cljs.core",
                              :name "IHash",
                              :name-encode "IHash",
                              :implementations #{"Subvec"
                                                 "Symbol"
                                                 "PersistentQueue"
                                                 "PersistentHashMap"
                                                 "PersistentTreeSet"
                                                 "PersistentArrayMapSeq"
                                                 "RedNode"
                                                 "EmptyList"
                                                 "LazyTransformer"
                                                 "ObjMap"
                                                 "BlackNode"
                                                 "PersistentVector"
                                                 "ValSeq"
                                                 "ChunkedCons"
                                                 "Range"
                                                 "PersistentQueueSeq"
                                                 "ChunkedSeq"
                                                 "ArrayNodeSeq"
                                                 "KeySeq"
                                                 "IndexedSeq"
                                                 "PersistentTreeMap"
                                                 "PersistentTreeMapSeq"
                                                 "RSeq"
                                                 "PersistentArrayMap"
                                                 "Keyword"
                                                 "PersistentHashSet"
                                                 "NodeSeq"
                                                 "List"
                                                 "Atom"
                                                 "MultiFn"
                                                 "Cons"
                                                 "default"
                                                 "LazySeq"
                                                 "UUID"},
                              :history [["+" "0.0-927"]],
                              :type "protocol",
                              :full-name-encode "cljs.core/IHash",
                              :source {:code "(defprotocol IHash\n  (-hash [o]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [329 330]},
                              :methods [{:name "-hash",
                                         :signature ["[o]"],
                                         :docstring nil}],
                              :full-name "cljs.core/IHash"},
           "clojure.reflect/doc" {:ns "clojure.reflect",
                                  :name "doc",
                                  :signature ["[sym]"],
                                  :name-encode "doc",
                                  :history [["+" "0.0-1503"]],
                                  :type "function",
                                  :full-name-encode "clojure.reflect/doc",
                                  :source {:code "(defn doc\n  [sym]\n  (meta sym print-doc))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/reflect.cljs",
                                           :lines [44 48]},
                                  :full-name "clojure.reflect/doc",
                                  :docstring "Queries the reflection api with a fully qualified symbol, then prints\ndocumentation information at the repl."},
           "cljs.core/is_proto_" {:ns "cljs.core",
                                  :name "is_proto_",
                                  :signature ["[x]"],
                                  :name-encode "is_proto_",
                                  :type "function",
                                  :full-name-encode "cljs.core/is_proto_",
                                  :source {:code "(defn is_proto_\n  [x]\n  (identical? (.-prototype (.-constructor x)) x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [123 125]},
                                  :full-name "cljs.core/is_proto_",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/shorts" {:ns "cljs.core",
                               :name "shorts",
                               :signature ["[x]"],
                               :name-encode "shorts",
                               :type "function",
                               :full-name-encode "cljs.core/shorts",
                               :source {:code "(defn shorts [x] x)",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2055]},
                               :full-name "cljs.core/shorts",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/TransientVector" {:protocols #{"IFn"
                                                     "ITransientCollection"
                                                     "ICounted"
                                                     "ILookup"
                                                     "IIndexed"
                                                     "ITransientAssociative"
                                                     "ITransientVector"},
                                        :ns "cljs.core",
                                        :name "TransientVector",
                                        :signature ["[cnt shift root tail]"],
                                        :name-encode "TransientVector",
                                        :history [["+" "0.0-1211"]],
                                        :type "type",
                                        :full-name-encode "cljs.core/TransientVector",
                                        :source {:code "(deftype TransientVector [^:mutable cnt\n                          ^:mutable shift\n                          ^:mutable root\n                          ^:mutable tail]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (if ^boolean (.-edit root)\n      (if (< (- cnt (tail-off tcoll)) 32)\n        (do (aset tail (bit-and cnt 0x01f) o)\n            (set! cnt (inc cnt))\n            tcoll)\n        (let [tail-node (VectorNode. (.-edit root) tail)\n              new-tail  (make-array 32)]\n          (aset new-tail 0 o)\n          (set! tail new-tail)\n          (if (> (bit-shift-right-zero-fill cnt 5)\n                 (bit-shift-left 1 shift))\n            (let [new-root-array (make-array 32)\n                  new-shift      (+ shift 5)]\n              (aset new-root-array 0 root)\n              (aset new-root-array 1 (new-path (.-edit root) shift tail-node))\n              (set! root  (VectorNode. (.-edit root) new-root-array))\n              (set! shift new-shift)\n              (set! cnt   (inc cnt))\n              tcoll)\n            (let [new-root (tv-push-tail tcoll shift root tail-node)]\n              (set! root new-root)\n              (set! cnt  (inc cnt))\n              tcoll))))\n      (throw (js/Error. \"conj! after persistent!\"))))\n\n  (-persistent! [tcoll]\n    (if ^boolean (.-edit root)\n      (do (set! (.-edit root) nil)\n          (let [len (- cnt (tail-off tcoll))\n                trimmed-tail (make-array len)]\n            (array-copy tail 0 trimmed-tail 0 len)\n            (PersistentVector. nil cnt shift root trimmed-tail nil)))\n      (throw (js/Error. \"persistent! called twice\"))))\n\n  ITransientAssociative\n  (-assoc! [tcoll key val]\n    (if (number? key)\n      (-assoc-n! tcoll key val)\n      (throw (js/Error. \"TransientVector's key for assoc! must be a number.\"))))\n\n  ITransientVector\n  (-assoc-n! [tcoll n val]\n    (if ^boolean (.-edit root)\n      (cond\n        (and (<= 0 n) (< n cnt))\n        (if (<= (tail-off tcoll) n)\n          (do (aset tail (bit-and n 0x01f) val)\n              tcoll)\n          (let [new-root\n                ((fn go [level node]\n                   (let [node (tv-ensure-editable (.-edit root) node)]\n                     (if (zero? level)\n                       (do (pv-aset node (bit-and n 0x01f) val)\n                           node)\n                       (let [subidx (bit-and (bit-shift-right-zero-fill n level)\n                                             0x01f)]\n                         (pv-aset node subidx\n                                  (go (- level 5) (pv-aget node subidx)))\n                         node))))\n                 shift root)]\n            (set! root new-root)\n            tcoll))\n        (== n cnt) (-conj! tcoll val)\n        :else\n        (throw\n         (js/Error.\n          (str \"Index \" n \" out of bounds for TransientVector of length\" cnt))))\n      (throw (js/Error. \"assoc! after persistent!\"))))\n\n  (-pop! [tcoll]\n    (if ^boolean (.-edit root)\n      (cond\n        (zero? cnt) (throw (js/Error. \"Can't pop empty vector\"))\n        (== 1 cnt)                       (do (set! cnt 0) tcoll)\n        (pos? (bit-and (dec cnt) 0x01f)) (do (set! cnt (dec cnt)) tcoll)\n        :else\n        (let [new-tail (unchecked-editable-array-for tcoll (- cnt 2))\n              new-root (let [nr (tv-pop-tail tcoll shift root)]\n                         (if-not (nil? nr)\n                           nr\n                           (VectorNode. (.-edit root) (make-array 32))))]\n          (if (and (< 5 shift) (nil? (pv-aget new-root 1)))\n            (let [new-root (tv-ensure-editable (.-edit root) (pv-aget new-root 0))]\n              (set! root  new-root)\n              (set! shift (- shift 5))\n              (set! cnt   (dec cnt))\n              (set! tail  new-tail)\n              tcoll)\n            (do (set! root new-root)\n                (set! cnt  (dec cnt))\n                (set! tail new-tail)\n                tcoll))))\n      (throw (js/Error. \"pop! after persistent!\"))))\n\n  ICounted\n  (-count [coll]\n    (if ^boolean (.-edit root)\n      cnt\n      (throw (js/Error. \"count after persistent!\"))))\n\n  IIndexed\n  (-nth [coll n]\n    (if ^boolean (.-edit root)\n      (aget (array-for coll n) (bit-and n 0x01f))\n      (throw (js/Error. \"nth after persistent!\"))))\n\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n cnt))\n      (-nth coll n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-lookup coll k nil))\n\n  (-lookup [coll k not-found] (if (number? k)\n                                (-nth coll k not-found)\n                                not-found))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4746 4875]},
                                        :full-name "cljs.core/TransientVector"},
           "cljs.core/keep-indexed" {:ns "cljs.core",
                                     :name "keep-indexed",
                                     :signature ["[f]" "[f coll]"],
                                     :name-encode "keep-indexed",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/keep-indexed",
                                     :source {:code "(defn keep-indexed\n  ([f]\n   (fn [rf]\n     (let [ia (volatile! -1)]\n       (fn\n         ([] (rf))\n         ([result] (rf result))\n         ([result input]\n            (let [i (vswap! ia inc)\n                  v (f i input)]\n              (if (nil? v)\n                result\n                (rf result v))))))))\n  ([f coll]\n     (letfn [(keepi [idx coll]\n               (lazy-seq\n                (when-let [s (seq coll)]\n                  (if (chunked-seq? s)\n                    (let [c (chunk-first s)\n                          size (count c)\n                          b (chunk-buffer size)]\n                      (dotimes [i size]\n                        (let [x (f (+ idx i) (-nth c i))]\n                          (when-not (nil? x)\n                            (chunk-append b x))))\n                      (chunk-cons (chunk b) (keepi (+ idx size) (chunk-rest s))))\n                    (let [x (f idx (first s))]\n                      (if (nil? x)\n                        (keepi (inc idx) (rest s))\n                        (cons x (keepi (inc idx) (rest s)))))))))]\n       (keepi 0 coll))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3618 3652]},
                                     :full-name "cljs.core/keep-indexed",
                                     :docstring "Returns a lazy sequence of the non-nil results of (f index item). Note,\nthis means false return values will be included.  f must be free of\nside-effects.  Returns a stateful transducer when no collection is\nprovided."},
           "cljs.core/bit-shift-right" {:ns "cljs.core",
                                        :name "bit-shift-right",
                                        :signature ["[x n]"],
                                        :name-encode "bit-shift-right",
                                        :history [["+" "0.0-927"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/bit-shift-right",
                                        :source {:code "(defn bit-shift-right\n  [x n] (cljs.core/bit-shift-right x n))",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [2135 2137]},
                                        :extra-sources [{:code "(defmacro ^::ana/numeric bit-shift-right [x n]\n  (core/list 'js* \"(~{} >> ~{})\" x n))",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [529
                                                                 530]}],
                                        :full-name "cljs.core/bit-shift-right",
                                        :docstring "Bitwise shift right"},
           "cljs.repl.server/stop" {:ns "cljs.repl.server",
                                    :name "stop",
                                    :signature ["[]"],
                                    :name-encode "stop",
                                    :type "function",
                                    :full-name-encode "cljs.repl.server/stop",
                                    :source {:code "(defn stop []\n  (.close (:socket @state)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/repl/server.clj",
                                             :lines [175 176]},
                                    :full-name "cljs.repl.server/stop",
                                    :history [["+" "0.0-1503"]]},
           "cljs.core/comparator" {:ns "cljs.core",
                                   :name "comparator",
                                   :signature ["[pred]"],
                                   :name-encode "comparator",
                                   :history [["+" "0.0-1586"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/comparator",
                                   :source {:code "(defn comparator\n  [pred]\n  (fn [x y]\n    (cond (pred x y) -1 (pred y x) 1 :else 0)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [9225 9229]},
                                   :full-name "cljs.core/comparator",
                                   :docstring "Returns an JavaScript compatible comparator based upon pred."},
           "cljs.core/ES6Iterator" {:ns "cljs.core",
                                    :name "ES6Iterator",
                                    :signature ["[s]"],
                                    :name-encode "ES6Iterator",
                                    :type "type",
                                    :full-name-encode "cljs.core/ES6Iterator",
                                    :source {:code "(deftype ES6Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [777 784]},
                                    :full-name "cljs.core/ES6Iterator",
                                    :history [["+" "0.0-2371"]]},
           "compiler-options/print-input-delimiter" {:ns "compiler-options",
                                                     :name "print-input-delimiter",
                                                     :name-encode "print-input-delimiter",
                                                     :type "option",
                                                     :full-name-encode "compiler-options/print-input-delimiter",
                                                     :full-name "compiler-options/print-input-delimiter",
                                                     :history [["+"
                                                                "0.0-971"]]},
           "cljs.core/PersistentTreeSet" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IReversible"
                                                       "IEmptyableCollection"
                                                       "ISet"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ISorted"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentTreeSet",
                                          :signature ["[meta tree-map __hash]"],
                                          :name-encode "PersistentTreeSet",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeSet",
                                          :source {:code "(deftype PersistentTreeSet [meta tree-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentTreeSet. meta tree-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeSet. meta tree-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentTreeSet. meta (assoc tree-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeSet. meta (-empty tree-map) 0))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys tree-map))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (map key (-sorted-seq tree-map ascending?)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (map key (-sorted-seq-from tree-map k ascending?)))\n\n  (-entry-key [coll entry] entry)\n\n  (-comparator [coll] (-comparator tree-map))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? (count tree-map))\n      (map key (rseq tree-map))))\n\n  ICounted\n  (-count [coll] (count tree-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (let [n (.entry-at tree-map v)]\n      (if-not (nil? n)\n        (.-key n)\n        not-found)))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentTreeSet. meta (dissoc tree-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [7483 7569]},
                                          :full-name "cljs.core/PersistentTreeSet"},
           "clojure.zip/insert-right" {:ns "clojure.zip",
                                       :name "insert-right",
                                       :signature ["[loc item]"],
                                       :name-encode "insert-right",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "clojure.zip/insert-right",
                                       :source {:code "(defn insert-right\n  [loc item]\n    (let [[node {r :r :as path}] loc]\n      (if (nil? path)\n        (throw \"Insert at top\")\n        (with-meta [node (assoc path :r (cons item r) :changed? true)] (meta loc)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/clojure/zip.cljs",
                                                :lines [174 181]},
                                       :full-name "clojure.zip/insert-right",
                                       :docstring "Inserts the item as the right sibling of the node at this loc,\nwithout moving"},
           "cljs.core/make-hierarchy" {:ns "cljs.core",
                                       :name "make-hierarchy",
                                       :signature ["[]"],
                                       :name-encode "make-hierarchy",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/make-hierarchy",
                                       :source {:code "(defn make-hierarchy\n  [] {:parents {} :descendants {} :ancestors {}})",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [8752 8754]},
                                       :full-name "cljs.core/make-hierarchy",
                                       :docstring "Creates a hierarchy object for use with derive, isa? etc."},
           "cljs.core/repeat" {:ns "cljs.core",
                               :name "repeat",
                               :signature ["[x]" "[n x]"],
                               :name-encode "repeat",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/repeat",
                               :source {:code "(defn repeat\n  ([x] (lazy-seq (cons x (repeat x))))\n  ([n x] (take n (repeat x))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [3877 3880]},
                               :full-name "cljs.core/repeat",
                               :docstring "Returns a lazy (infinite!, or length n if supplied) sequence of xs."},
           "syntax/destructure-map" {:syntax-equiv {:edn-url nil,
                                                    :clj-url nil},
                                     :ns "syntax",
                                     :name "destructure-map",
                                     :name-encode "destructure-map",
                                     :type "binding",
                                     :full-name-encode "syntax/destructure-map",
                                     :source {:code "(defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n         pb (fn pb [bvec b v]\n              (core/let [pvec\n                     (fn [bvec b val]\n                       (core/let [gvec (gensym \"vec__\")]\n                         (core/loop [ret (-> bvec (conj gvec) (conj val))\n                                     n 0\n                                     bs b\n                                     seen-rest? false]\n                           (if (seq bs)\n                             (core/let [firstb (first bs)]\n                               (core/cond\n                                 (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                      n\n                                                      (nnext bs)\n                                                      true)\n                                 (= firstb :as) (pb ret (second bs) gvec)\n                                 :else (if seen-rest?\n                                         (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                         (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                (core/inc n)\n                                                (next bs)\n                                                seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (core/let [gmap (gensym \"map__\")\n                                  defaults (:or b)]\n                         (core/loop [ret (-> bvec (conj gmap) (conj v)\n                                             (conj gmap) (conj `(if (seq? ~gmap) (apply core/hash-map ~gmap) ~gmap))\n                                             ((fn [ret]\n                                                (if (:as b)\n                                                  (conj ret (:as b) gmap)\n                                                  ret))))\n                                     bes (reduce\n                                          (fn [bes entry]\n                                            (reduce #(assoc %1 %2 ((val entry) %2))\n                                                    (dissoc bes (key entry))\n                                                    ((key entry) bes)))\n                                          (dissoc b :as :or)\n                                          {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                           :strs core/str, :syms #(core/list `quote %)})]\n                           (if (seq bes)\n                             (core/let [bb (key (first bes))\n                                        bk (val (first bes))\n                                        has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (core/list `get gmap bk (defaults bb))\n                                                   (core/list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                    (core/cond\n                      (core/symbol? b) (-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw (new Exception (core/str \"Unsupported binding form: \" b))))))\n         process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n        (if (every? core/symbol? (map first bents))\n          bindings\n          (if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n            (throw (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs))))\n            (reduce process-entry [] bents)))))",
                                              :title "Parser code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [82 145]},
                                     :full-name "syntax/destructure-map",
                                     :history [["+" "0.0-927"]]},
           "syntax/syntax-quote" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "syntax-quote",
                                  :name-encode "syntax-quote",
                                  :type "syntax",
                                  :full-name-encode "syntax/syntax-quote",
                                  :extra-sources ({:code "(defn- read-syntax-quote\n  [rdr backquote]\n  (binding [gensym-env {}]\n    (-> (read rdr true nil true)\n      syntax-quote*)))",
                                                   :title "Reader code",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-0.8.10",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [585 589]}
                                                  {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                                   :title "Reader table",
                                                   :repo "tools.reader",
                                                   :tag "tools.reader-0.8.10",
                                                   :filename "src/main/clojure/clojure/tools/reader.clj",
                                                   :lines [591 610]}),
                                  :full-name "syntax/syntax-quote",
                                  :history [["+" "0.0-1853"]]},
           "cljs.core/array-list" {:ns "cljs.core",
                                   :name "array-list",
                                   :signature ["[]"],
                                   :name-encode "array-list",
                                   :type "function",
                                   :full-name-encode "cljs.core/array-list",
                                   :source {:code "(defn array-list []\n  (ArrayList. (array)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7706 7707]},
                                   :full-name "cljs.core/array-list",
                                   :history [["+" "0.0-2301"]]},
           "cljs.repl.rhino/goog-require" {:ns "cljs.repl.rhino",
                                           :name "goog-require",
                                           :signature ["[repl-env opts rule]"],
                                           :name-encode "goog-require",
                                           :type "function",
                                           :full-name-encode "cljs.repl.rhino/goog-require",
                                           :source {:code "(defn goog-require [repl-env opts rule]\n  (let [path        (string/replace (comp/munge rule) \\. File/separatorChar)\n        output-dir  (util/output-directory opts)\n        cljsc-path  (str output-dir File/separator (str path \".js\"))\n        cljs-path   (str path \".cljs\")\n        gpath       (-eval (str \"goog.dependencies_.nameToPath['\" rule \"']\")\n                      repl-env \"<cljs repl>\" 1)\n        js-path     (str \"goog/\" gpath)\n        js-out-path (io/file output-dir \"goog\"\n                      (string/replace gpath \\/ File/separatorChar))]\n    (let [compiled (io/file cljsc-path)]\n      (if (.exists compiled)\n        ;; TODO: only take this path if analysis cache is available\n        ;; - David\n        (do\n          (with-open [reader (io/reader compiled)]\n            (-eval reader repl-env cljsc-path 1)))\n        (if-let [res (io/resource cljs-path)]\n          (binding [ana/*cljs-ns* 'cljs.user]\n            (repl/load-stream repl-env cljs-path res))\n          (if-let [res (io/resource js-path)]\n            (with-open [reader (io/reader res)]\n              (-eval reader repl-env js-path 1))\n            (if (.exists js-out-path)\n              (with-open [reader (io/reader js-out-path)]\n                (-eval reader repl-env js-path 1))\n              (throw\n               (Exception.\n                 (str \"Cannot find \"\n                   cljs-path \" or \"\n                   js-path \" or \"\n                   (.getName js-out-path) \" in classpath\"))))))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/repl/rhino.clj",
                                                    :lines [78 109]},
                                           :full-name "cljs.repl.rhino/goog-require",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/prn-str-with-opts" {:ns "cljs.core",
                                          :name "prn-str-with-opts",
                                          :signature ["[objs opts]"],
                                          :name-encode "prn-str-with-opts",
                                          :history [["+" "0.0-1011"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/prn-str-with-opts",
                                          :source {:code "(defn prn-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\\n\"\n    (let [sb (pr-sb-with-opts objs opts)]\n      (.append sb \\newline)\n      (str sb))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [8247 8254]},
                                          :full-name "cljs.core/prn-str-with-opts",
                                          :docstring "Same as pr-str-with-opts followed by (newline)"},
           "cljs.core/MultiFn" {:protocols #{"IFn"
                                             "IMultiFn"
                                             "IHash"
                                             "INamed"},
                                :ns "cljs.core",
                                :name "MultiFn",
                                :signature ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"],
                                :name-encode "MultiFn",
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/MultiFn",
                                :source {:code "(deftype MultiFn [name dispatch-fn default-dispatch-val hierarchy\n                  method-table prefer-table method-cache cached-hierarchy]\n  IFn\n  (-invoke [mf]\n    (let [dispatch-val (dispatch-fn)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn)))\n  (-invoke [mf a]\n    (let [dispatch-val (dispatch-fn a)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a)))\n  (-invoke [mf a b]\n    (let [dispatch-val (dispatch-fn a b)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b)))\n  (-invoke [mf a b c]\n    (let [dispatch-val (dispatch-fn a b c)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c)))\n  (-invoke [mf a b c d]\n    (let [dispatch-val (dispatch-fn a b c d)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d)))\n  (-invoke [mf a b c d e]\n    (let [dispatch-val (dispatch-fn a b c d e)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e)))\n  (-invoke [mf a b c d e f]\n    (let [dispatch-val (dispatch-fn a b c d e f)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f)))\n  (-invoke [mf a b c d e f g]\n    (let [dispatch-val (dispatch-fn a b c d e f g)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g)))\n  (-invoke [mf a b c d e f g h]\n    (let [dispatch-val (dispatch-fn a b c d e f g h)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h)))\n  (-invoke [mf a b c d e f g h i]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i)))\n  (-invoke [mf a b c d e f g h i j]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j)))\n  (-invoke [mf a b c d e f g h i j k]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k)))\n  (-invoke [mf a b c d e f g h i j k l]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l)))\n  (-invoke [mf a b c d e f g h i j k l m]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m)))\n  (-invoke [mf a b c d e f g h i j k l m n]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n)))\n  (-invoke [mf a b c d e f g h i j k l m n o]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o)))\n  (-invoke [mf a b c d e f g h i j k l m n o p]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t]\n    (let [dispatch-val (dispatch-fn a b c d e f g h i j k l m n o p q r s t)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (target-fn a b c d e f g h i j k l m n o p q r s t)))\n  (-invoke [mf a b c d e f g h i j k l m n o p q r s t rest]\n    (let [dispatch-val (apply dispatch-fn a b c d e f g h i j k l m n o p q r s t rest)\n          target-fn (-get-method mf dispatch-val)]\n      (when-not target-fn\n        (throw-no-method-error name dispatch-val))\n      (apply target-fn a b c d e f g h i j k l m n o p q r s t rest)))\n    \n  IMultiFn\n  (-reset [mf]\n    (swap! method-table (fn [mf] {}))\n    (swap! method-cache (fn [mf] {}))\n    (swap! prefer-table (fn [mf] {}))\n    (swap! cached-hierarchy (fn [mf] nil))\n    mf)\n\n  (-add-method [mf dispatch-val method]\n    (swap! method-table assoc dispatch-val method)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-remove-method [mf dispatch-val]\n    (swap! method-table dissoc dispatch-val)\n    (reset-cache method-cache method-table cached-hierarchy hierarchy)\n    mf)\n\n  (-get-method [mf dispatch-val]\n    (when-not (= @cached-hierarchy @hierarchy)\n      (reset-cache method-cache method-table cached-hierarchy hierarchy))\n    (if-let [target-fn (@method-cache dispatch-val)]\n      target-fn\n      (if-let [target-fn (find-and-cache-best-method name dispatch-val hierarchy method-table\n                                                     prefer-table method-cache cached-hierarchy)]\n        target-fn\n        (@method-table default-dispatch-val))))\n\n  (-prefer-method [mf dispatch-val-x dispatch-val-y]\n    (when (prefers* dispatch-val-x dispatch-val-y prefer-table)\n      (throw (js/Error. (str \"Preference conflict in multimethod '\" name \"': \" dispatch-val-y\n                   \" is already preferred to \" dispatch-val-x))))\n    (swap! prefer-table\n           (fn [old]\n             (assoc old dispatch-val-x\n                    (conj (get old dispatch-val-x #{})\n                          dispatch-val-y))))\n    (reset-cache method-cache method-table cached-hierarchy hierarchy))\n\n  (-methods [mf] @method-table)\n  (-prefers [mf] @prefer-table)\n  \n  INamed\n  (-name [this] (-name name))\n  (-namespace [this] (-namespace name))\n\n  IHash\n  (-hash [this] (goog/getUid this)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8930 9113]},
                                :full-name "cljs.core/MultiFn"},
           "cljs.test/successful?" {:ns "cljs.test",
                                    :name "successful?",
                                    :signature ["[summary]"],
                                    :name-encode "successfulQMARK",
                                    :history [["+" "0.0-2496"]],
                                    :type "function",
                                    :full-name-encode "cljs.test/successfulQMARK",
                                    :source {:code "(defn successful?\n  [summary]\n  (and (zero? (:fail summary 0))\n       (zero? (:error summary 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/test.cljs",
                                             :lines [413 418]},
                                    :full-name "cljs.test/successful?",
                                    :docstring "Returns true if the given test summary indicates all tests\nwere successful, false otherwise."},
           "cljs.core/hash-keyword" {:ns "cljs.core",
                                     :name "hash-keyword",
                                     :signature ["[k]"],
                                     :name-encode "hash-keyword",
                                     :type "function",
                                     :full-name-encode "cljs.core/hash-keyword",
                                     :source {:code "(defn hash-keyword [k]\n  (int (+ (hash-symbol k) 0x9e3779b9)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2475 2476]},
                                     :full-name "cljs.core/hash-keyword",
                                     :history [["+" "0.0-2261"]]},
           "cljs.core/Reduced" {:protocols #{"IDeref"},
                                :ns "cljs.core",
                                :name "Reduced",
                                :signature ["[val]"],
                                :name-encode "Reduced",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/Reduced",
                                :source {:code "(deftype Reduced [val]\n  IDeref\n  (-deref [o] val))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [890 892]},
                                :full-name "cljs.core/Reduced"},
           "cljs.core/not-any?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "not-any?",
                                 :signature ["[pred coll]"],
                                 :name-encode "not-anyQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/not-anyQMARK",
                                 :source {:code "(defn ^boolean not-any?\n  [pred coll] (not (some pred coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3314 3317]},
                                 :full-name "cljs.core/not-any?",
                                 :docstring "Returns false if (pred x) is logical true for any x in coll,\nelse true."},
           "cljs.reader/read-regex" {:ns "cljs.reader",
                                     :name "read-regex",
                                     :signature ["[rdr ch]"],
                                     :name-encode "read-regex",
                                     :type "function",
                                     :full-name-encode "cljs.reader/read-regex",
                                     :source {:code "(defn read-regex\n  [rdr ch]\n  (-> (read-raw-string* rdr ch) re-pattern))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/reader.cljs",
                                              :lines [385 387]},
                                     :full-name "cljs.reader/read-regex",
                                     :history [["+" "0.0-927"]]},
           "cljs.repl/spec-sort" {:ns "cljs.repl",
                                  :name "spec-sort",
                                  :name-encode "spec-sort",
                                  :type "var",
                                  :full-name-encode "cljs.repl/spec-sort",
                                  :source {:code "(def spec-sort\n  {:as 0\n   :refer 1\n   :refer-macros 2\n   :include-macros 3})",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2644",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [190 194]},
                                  :full-name "cljs.repl/spec-sort",
                                  :history [["+" "0.0-2629"]
                                            ["-" "0.0-2655"]],
                                  :removed {:in "0.0-2655",
                                            :last-seen "0.0-2644"}},
           "clojure.zip/next" {:ns "clojure.zip",
                               :name "next",
                               :signature ["[loc]"],
                               :name-encode "next",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/next",
                               :source {:code "(defn next\n  [loc]\n    (if (= :end (loc 1))\n      loc\n      (or \n       (and (branch? loc) (down loc))\n       (right loc)\n       (loop [p loc]\n         (if (up p)\n           (or (right (up p)) (recur (up p)))\n           [(node p) :end])))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [206 219]},
                               :full-name "clojure.zip/next",
                               :docstring "Moves to the next loc in the hierarchy, depth-first. When reaching\nthe end, returns a distinguished loc detectable via end?. If already\nat the end, stays there."},
           "syntax/dispatch" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "dispatch",
                              :name-encode "dispatch",
                              :type "syntax",
                              :full-name-encode "syntax/dispatch",
                              :extra-sources ({:code "(defn- read-dispatch\n  [rdr _]\n  (if-let [ch (read-char rdr)]\n    (if-let [dm (dispatch-macros ch)]\n      (dm rdr ch)\n      (if-let [obj (read-tagged (doto rdr (unread ch)) ch)] ;; ctor reader is implemented as a taggged literal\n        obj\n        (reader-error rdr \"No dispatch macro for \" ch)))\n    (reader-error rdr \"EOF while reading character\")))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [53 61]}
                                              {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [591 610]}),
                              :full-name "syntax/dispatch",
                              :history [["+" "0.0-1853"]]},
           "cljs.core/IFn" {:ns "cljs.core",
                            :name "IFn",
                            :name-encode "IFn",
                            :implementations #{"Subvec"
                                               "Symbol"
                                               "PersistentHashMap"
                                               "PersistentTreeSet"
                                               "RedNode"
                                               "ObjMap"
                                               "MetaFn"
                                               "BlackNode"
                                               "PersistentVector"
                                               "TransientVector"
                                               "PersistentTreeMap"
                                               "PersistentArrayMap"
                                               "Keyword"
                                               "PersistentHashSet"
                                               "MultiFn"
                                               "Var"
                                               "TransientHashSet"},
                            :history [["+" "0.0-971"]],
                            :type "protocol",
                            :full-name-encode "cljs.core/IFn",
                            :source {:code "(defprotocol IFn\n  (-invoke\n    [this]\n    [this a]\n    [this a b]\n    [this a b c]\n    [this a b c d]\n    [this a b c d e]\n    [this a b c d e f]\n    [this a b c d e f g]\n    [this a b c d e f g h]\n    [this a b c d e f g h i]\n    [this a b c d e f g h i j]\n    [this a b c d e f g h i j k]\n    [this a b c d e f g h i j k l]\n    [this a b c d e f g h i j k l m]\n    [this a b c d e f g h i j k l m n]\n    [this a b c d e f g h i j k l m n o]\n    [this a b c d e f g h i j k l m n o p]\n    [this a b c d e f g h i j k l m n o p q]\n    [this a b c d e f g h i j k l m n o p q r]\n    [this a b c d e f g h i j k l m n o p q r s]\n    [this a b c d e f g h i j k l m n o p q r s t]\n    [this a b c d e f g h i j k l m n o p q r s t rest]))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [230 253]},
                            :methods [{:name "-invoke",
                                       :signature ["[this]"
                                                   "[this a]"
                                                   "[this a b]"
                                                   "[this a b c]"
                                                   "[this a b c d]"
                                                   "[this a b c d e]"
                                                   "[this a b c d e f]"
                                                   "[this a b c d e f g]"
                                                   "[this a b c d e f g h]"
                                                   "[this a b c d e f g h i]"
                                                   "[this a b c d e f g h i j]"
                                                   "[this a b c d e f g h i j k]"
                                                   "[this a b c d e f g h i j k l]"
                                                   "[this a b c d e f g h i j k l m]"
                                                   "[this a b c d e f g h i j k l m n]"
                                                   "[this a b c d e f g h i j k l m n o]"
                                                   "[this a b c d e f g h i j k l m n o p]"
                                                   "[this a b c d e f g h i j k l m n o p q]"
                                                   "[this a b c d e f g h i j k l m n o p q r]"
                                                   "[this a b c d e f g h i j k l m n o p q r s]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t]"
                                                   "[this a b c d e f g h i j k l m n o p q r s t rest]"],
                                       :docstring nil}],
                            :full-name "cljs.core/IFn"},
           "cljs.core/aget" {:ns "cljs.core",
                             :name "aget",
                             :signature ["[array i]"
                                         "[array i & idxs]"],
                             :name-encode "aget",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aget",
                             :source {:code "(defn aget\n  ([array i]\n     (cljs.core/aget array i))\n  ([array i & idxs]\n     (apply aget (aget array i) idxs)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [192 197]},
                             :extra-sources [{:code "(defmacro aget\n  ([a i]\n     (core/list 'js* \"(~{}[~{}])\" a i))\n  ([a i & idxs]\n     (let [astr (apply core/str (repeat (count idxs) \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}]\" astr \")\") ~a ~i ~@idxs))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [340 345]}],
                             :full-name "cljs.core/aget",
                             :docstring "Returns the value at the index."},
           "cljs.core/if-let" {:ns "cljs.core",
                               :name "if-let",
                               :signature ["[bindings then]"
                                           "[bindings then else & oldform]"],
                               :name-encode "if-let",
                               :history [["+" "0.0-927"]],
                               :type "macro",
                               :full-name-encode "cljs.core/if-let",
                               :source {:code "(defmacro if-let\n  ([bindings then]\n   `(if-let ~bindings ~then nil))\n  ([bindings then else & oldform]\n   (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (nil? oldform) \"1 or 2 forms after binding vector\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n     `(let [temp# ~tst]\n        (if temp#\n          (let [~form temp#]\n            ~then)\n          ~else)))))",
                                        :title "Source code",
                                        :repo "clojure",
                                        :tag "clojure-1.6.0",
                                        :filename "src/clj/clojure/core.clj",
                                        :lines [1721 1739]},
                               :full-name "cljs.core/if-let",
                               :docstring "bindings => binding-form test\n\nIf test is true, evaluates then with binding-form bound to the value of \ntest, if not, yields else"},
           "cljs.core//" {:return-type number,
                          :ns "cljs.core",
                          :name "/",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "SLASH",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/SLASH",
                          :source {:code "(defn ^number /\n  ([x] (/ 1 x))\n  ([x y] (cljs.core/divide x y)) ;; FIXME: waiting on cljs.core//\n  ([x y & more] (reduce / (/ x y) more)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1862 1867]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric /\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [425 428]}],
                          :full-name "cljs.core//",
                          :docstring "If no denominators are supplied, returns 1/numerator,\nelse returns numerator divided by all of the denominators."},
           "cljs.core/unchecked-int" {:ns "cljs.core",
                                      :name "unchecked-int",
                                      :signature ["[x]"],
                                      :name-encode "unchecked-int",
                                      :history [["+" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/unchecked-int",
                                      :source {:code "(defn unchecked-int\n  [x]\n  (fix x))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [2037 2040]},
                                      :full-name "cljs.core/unchecked-int",
                                      :docstring "Coerce to int by stripping decimal places."},
           "cljs.repl.server/read-get" {:ns "cljs.repl.server",
                                        :name "read-get",
                                        :signature ["[line rdr]"],
                                        :name-encode "read-get",
                                        :type "function",
                                        :full-name-encode "cljs.repl.server/read-get",
                                        :source {:code "(defn read-get [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))]\n    {:method :get\n     :path path\n     :headers headers}))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [89 94]},
                                        :full-name "cljs.repl.server/read-get",
                                        :history [["+" "0.0-1503"]]},
           "cljs.core/min-key" {:ns "cljs.core",
                                :name "min-key",
                                :signature ["[k x]"
                                            "[k x y]"
                                            "[k x y & more]"],
                                :name-encode "min-key",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/min-key",
                                :source {:code "(defn min-key\n  ([k x] x)\n  ([k x y] (if (< (k x) (k y)) x y))\n  ([k x y & more]\n     (reduce #(min-key k %1 %2) (min-key k x y) more)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7691 7696]},
                                :full-name "cljs.core/min-key",
                                :docstring "Returns the x for which (k x), a number, is least."},
           "compiler-options/closure-defines" {:ns "compiler-options",
                                               :name "closure-defines",
                                               :name-encode "closure-defines",
                                               :type "option",
                                               :full-name-encode "compiler-options/closure-defines",
                                               :full-name "compiler-options/closure-defines",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "clojure.zip/root" {:ns "clojure.zip",
                               :name "root",
                               :signature ["[loc]"],
                               :name-encode "root",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/root",
                               :source {:code "(defn root\n  [loc]\n    (if (= :end (loc 1))\n      (node loc)\n      (let [p (up loc)]\n        (if p\n          (recur p)\n          (node loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [124 133]},
                               :full-name "clojure.zip/root",
                               :docstring "zips all the way up and returns the root node, reflecting any\nchanges."},
           "cljs.core/drop-while" {:ns "cljs.core",
                                   :name "drop-while",
                                   :signature ["[pred]" "[pred coll]"],
                                   :name-encode "drop-while",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/drop-while",
                                   :source {:code "(defn drop-while\n  ([pred]\n     (fn [rf]\n       (let [da (volatile! true)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [drop? @da]\n                (if (and drop? (pred input))\n                  result\n                  (do\n                    (vreset! da nil)\n                    (rf result input)))))))))\n  ([pred coll]\n     (let [step (fn [pred coll]\n                  (let [s (seq coll)]\n                    (if (and s (pred (first s)))\n                      (recur pred (rest s))\n                      s)))]\n       (lazy-seq (step pred coll)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3841 3864]},
                                   :full-name "cljs.core/drop-while",
                                   :docstring "Returns a lazy sequence of the items in coll starting from the\nfirst item for which (pred item) returns logical false.  Returns a\nstateful transducer when no collection is provided."},
           "cljs.repl.browser/send-repl-client-page" {:ns "cljs.repl.browser",
                                                      :name "send-repl-client-page",
                                                      :signature ["[request conn opts]"],
                                                      :name-encode "send-repl-client-page",
                                                      :type "function",
                                                      :full-name-encode "cljs.repl.browser/send-repl-client-page",
                                                      :source {:code "(defn send-repl-client-page\n  [request conn opts]\n  (server/send-and-close conn 200\n    (str \"<html><head><meta charset=\\\"UTF-8\\\"></head><body>\n          <script type=\\\"text/javascript\\\">\"\n         (repl-client-js)\n         \"</script>\"\n         \"<script type=\\\"text/javascript\\\">\n          clojure.browser.repl.client.start(\\\"http://\" (-> request :headers :host) \"\\\");\n          </script>\"\n         \"</body></html>\")\n    \"text/html\"))",
                                                               :title "Source code",
                                                               :repo "clojurescript",
                                                               :tag "r2760",
                                                               :filename "src/clj/cljs/repl/browser.clj",
                                                               :lines [54
                                                                       65]},
                                                      :full-name "cljs.repl.browser/send-repl-client-page",
                                                      :history [["+"
                                                                 "0.0-927"]]},
           "clojure.browser.repl/evaluate-javascript" {:ns "clojure.browser.repl",
                                                       :name "evaluate-javascript",
                                                       :signature ["[conn block]"],
                                                       :name-encode "evaluate-javascript",
                                                       :history [["+"
                                                                  "0.0-927"]],
                                                       :type "function",
                                                       :full-name-encode "clojure.browser.repl/evaluate-javascript",
                                                       :source {:code "(defn evaluate-javascript\n  [conn block]\n  (let [result (try {:status :success :value (str (js* \"eval(~{block})\"))}\n                    (catch :default e\n                      {:status :exception :value (pr-str e)\n                       :stacktrace (if (.hasOwnProperty e \"stack\")\n                                     (.-stack e)\n                                     \"No stacktrace available.\")}))]\n    (pr-str result)))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r2760",
                                                                :filename "src/cljs/clojure/browser/repl.cljs",
                                                                :lines [27
                                                                        36]},
                                                       :full-name "clojure.browser.repl/evaluate-javascript",
                                                       :docstring "Process a single block of JavaScript received from the server"},
           "closure-warnings/visiblity" {:ns "closure-warnings",
                                         :name "visiblity",
                                         :type "warning",
                                         :full-name "closure-warnings/visiblity",
                                         :full-name-encode "closure-warnings/visiblity",
                                         :name-encode "visiblity",
                                         :history [["+" "0.0-2120"]]},
           "cljs.core/set-validator!" {:ns "cljs.core",
                                       :name "set-validator!",
                                       :signature ["[iref val]"],
                                       :name-encode "set-validatorBANG",
                                       :history [["+" "0.0-927"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/set-validatorBANG",
                                       :source {:code "(defn set-validator!\n  [iref val]\n  (set! (.-validator iref) val))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [3581 3589]},
                                       :full-name "cljs.core/set-validator!",
                                       :docstring "Sets the validator-fn for an atom. validator-fn must be nil or a\nside-effect-free fn of one argument, which will be passed the intended\nnew state on any state change. If the new state is unacceptable, the\nvalidator-fn should return false or throw an Error. If the current state\nis not acceptable to the new validator, an Error will be thrown and the\nvalidator will not be changed."},
           "syntax/queue-literal" {:syntax-equiv {:edn-url nil,
                                                  :clj-url nil},
                                   :ns "syntax",
                                   :name "queue-literal",
                                   :name-encode "queue-literal",
                                   :type "tagged literal",
                                   :full-name-encode "syntax/queue-literal",
                                   :extra-sources ({:code "(defn read-queue\n  [form]\n  (when-not (vector? form)\n    (throw (RuntimeException. \"Queue literal expects a vector for its elements.\")))\n  (list 'cljs.core/into 'cljs.core.PersistentQueue.EMPTY form))",
                                                    :title "Reader code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/tagged_literals.clj",
                                                    :lines [4 8]}
                                                   {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                    :title "Reader table",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/tagged_literals.clj",
                                                    :lines [44 48]}),
                                   :full-name "syntax/queue-literal",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/<" {:return-type boolean,
                          :ns "cljs.core",
                          :name "<",
                          :signature ["[x]" "[x y]" "[x y & more]"],
                          :name-encode "LT",
                          :history [["+" "0.0-927"]],
                          :type "function/macro",
                          :full-name-encode "cljs.core/LT",
                          :source {:code "(defn ^boolean <\n  ([x] true)\n  ([x y] (cljs.core/< x y))\n  ([x y & more]\n     (if (cljs.core/< x y)\n       (if (next more)\n         (recur y (first more) (next more))\n         (cljs.core/< y (first more)))\n       false)))",
                                   :title "Function code",
                                   :repo "clojurescript",
                                   :tag "r2760",
                                   :filename "src/cljs/cljs/core.cljs",
                                   :lines [1869 1879]},
                          :extra-sources [{:code "(defmacro ^::ana/numeric <\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} < ~{})\" x y)))\n  ([x y & more] `(and (< ~x ~y) (< ~y ~@more))))",
                                           :title "Macro code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/core.clj",
                                           :lines [435 438]}],
                          :full-name "cljs.core/<",
                          :docstring "Returns non-nil if nums are in monotonically increasing order,\notherwise false."},
           "cljs.core/catch" {:ns "cljs.core",
                              :name "catch",
                              :type "special form",
                              :source {:code "(defmethod parse 'try\n  [op env [_ & body :as form] name _]\n  (let [catchenv (update-in env [:context] #(if (= :expr %) :return %))\n        catch? (every-pred seq? #(= (first %) 'catch))\n        default? (every-pred catch? #(= (second %) :default))\n        finally? (every-pred seq? #(= (first %) 'finally))\n\n        {:keys [body cblocks dblock fblock]}\n        (loop [parser {:state :start :forms body\n                       :body [] :cblocks [] :dblock nil :fblock nil}]\n          (if (seq? (:forms parser))\n            (let [[form & forms*] (:forms parser)\n                  parser* (assoc parser :forms forms*)]\n              (case (:state parser)\n                :start (cond\n                         (catch? form) (recur (assoc parser :state :catches))\n                         (finally? form) (recur (assoc parser :state :finally))\n                         :else (recur (update-in parser* [:body] conj form)))\n                :catches (cond\n                           (default? form) (recur (assoc parser* :dblock form :state :finally))\n                           (catch? form) (recur (update-in parser* [:cblocks] conj form))\n                           (finally? form) (recur (assoc parser :state :finally))\n                           :else (throw (error env \"Invalid try form\")))\n                :finally (recur (assoc parser* :fblock form :state :done))\n                :done (throw (error env \"Unexpected form after finally\"))))\n            parser))\n\n        finally (when (seq fblock)\n                  (analyze (assoc env :context :statement) `(do ~@(rest fblock))))\n        e (when (or (seq cblocks) dblock) (gensym \"e\"))\n        default (if-let [[_ _ name & cb] dblock]\n                  `(cljs.core/let [~name ~e] ~@cb)\n                  `(throw ~e))\n        cblock (if (seq cblocks)\n                 `(cljs.core/cond\n                   ~@(mapcat\n                      (fn [[_ type name & cb]]\n                        (when name (assert (not (namespace name)) \"Can't qualify symbol in catch\"))\n                        `[(cljs.core/instance? ~type ~e)\n                          (cljs.core/let [~name ~e] ~@cb)])\n                      cblocks)\n                   :else ~default)\n                 default)\n        locals (:locals catchenv)\n        locals (if e\n                 (assoc locals e\n                        {:name e\n                         :line (get-line e env)\n                         :column (get-col e env)})\n                 locals)\n        catch (when cblock\n                (analyze (assoc catchenv :locals locals) cblock))\n        try (analyze (if (or e finally) catchenv env) `(do ~@body))]\n\n    {:env env :op :try :form form\n     :try try\n     :finally finally\n     :name e\n     :catch catch\n     :children [try catch finally]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [599 658]},
                              :extra-sources ({:code "(defmethod emit* :try\n  [{:keys [env try catch name finally]}]\n  (let [context (:context env)]\n    (if (or name finally)\n      (do\n        (when (= :expr context)\n          (emits \"(function (){\"))\n        (emits \"try{\" try \"}\")\n        (when name\n          (emits \"catch (\" (munge name) \"){\" catch \"}\"))\n        (when finally\n          (assert (not= :constant (:op finally)) \"finally block cannot contain constant\")\n          (emits \"finally {\" finally \"}\"))\n        (when (= :expr context)\n          (emits \"})()\")))\n      (emits try))))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [648 663]}),
                              :full-name "cljs.core/catch",
                              :full-name-encode "cljs.core/catch",
                              :name-encode "catch",
                              :history [["+" "0.0-927"]]},
           "syntax/shebang" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "shebang",
                             :name-encode "shebang",
                             :type "syntax",
                             :full-name-encode "syntax/shebang",
                             :extra-sources ({:code "(defn read-comment\n  [rdr & _]\n  (skip-line rdr))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader/impl/commons.clj",
                                              :lines [120 122]}
                                             {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [612 623]}),
                             :full-name "syntax/shebang",
                             :history [["+" "0.0-1853"]]},
           "cljs.repl.reflect/read-url-string" {:ns "cljs.repl.reflect",
                                                :name "read-url-string",
                                                :name-encode "read-url-string",
                                                :type "var",
                                                :full-name-encode "cljs.repl.reflect/read-url-string",
                                                :source {:code "(def read-url-string (comp read-string url-decode))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/repl/reflect.clj",
                                                         :lines [42]},
                                                :full-name "cljs.repl.reflect/read-url-string",
                                                :history [["+"
                                                           "0.0-1503"]]},
           "cljs.core/deftype*" {:ns "cljs.core",
                                 :name "deftype*",
                                 :type "special form",
                                 :source {:code "(defmethod parse 'deftype*\n  [_ env form _ _]\n  (parse-type :deftype* env form))",
                                          :title "Parser code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/analyzer.clj",
                                          :lines [1397 1399]},
                                 :full-name "cljs.core/deftype*",
                                 :full-name-encode "cljs.core/deftypeSTAR",
                                 :name-encode "deftypeSTAR",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/fn" {:ns "cljs.core",
                           :name "fn",
                           :signature ["[& sigs]"],
                           :name-encode "fn",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/fn",
                           :source {:code "(defmacro fn\n  [& sigs]\n    (let [name (if (symbol? (first sigs)) (first sigs) nil)\n          sigs (if name (next sigs) sigs)\n          sigs (if (vector? (first sigs)) \n                 (list sigs) \n                 (if (seq? (first sigs))\n                   sigs\n                   ;; Assume single arity syntax\n                   (throw (IllegalArgumentException. \n                            (if (seq sigs)\n                              (str \"Parameter declaration \" \n                                   (first sigs)\n                                   \" should be a vector\")\n                              (str \"Parameter declaration missing\"))))))\n          psig (fn* [sig]\n                 ;; Ensure correct type before destructuring sig\n                 (when (not (seq? sig))\n                   (throw (IllegalArgumentException.\n                            (str \"Invalid signature \" sig\n                                 \" should be a list\"))))\n                 (let [[params & body] sig\n                       _ (when (not (vector? params))\n                           (throw (IllegalArgumentException. \n                                    (if (seq? (first sigs))\n                                      (str \"Parameter declaration \" params\n                                           \" should be a vector\")\n                                      (str \"Invalid signature \" sig\n                                           \" should be a list\")))))\n                       conds (when (and (next body) (map? (first body))) \n                                           (first body))\n                       body (if conds (next body) body)\n                       conds (or conds (meta params))\n                       pre (:pre conds)\n                       post (:post conds)                       \n                       body (if post\n                              `((let [~'% ~(if (< 1 (count body)) \n                                            `(do ~@body) \n                                            (first body))]\n                                 ~@(map (fn* [c] `(assert ~c)) post)\n                                 ~'%))\n                              body)\n                       body (if pre\n                              (concat (map (fn* [c] `(assert ~c)) pre) \n                                      body)\n                              body)]\n                   (maybe-destructured params body)))\n          new-sigs (map psig sigs)]\n      (with-meta\n        (if name\n          (list* 'fn* name new-sigs)\n          (cons 'fn* new-sigs))\n        (meta &form))))",
                                    :title "Source code",
                                    :repo "clojure",
                                    :tag "clojure-1.6.0",
                                    :filename "src/clj/clojure/core.clj",
                                    :lines [4143 4203]},
                           :full-name "cljs.core/fn",
                           :docstring "params => positional-params* , or positional-params* & next-param\npositional-param => binding-form\nnext-param => binding-form\nname => symbol\n\nDefines a function"},
           "cljs.core/split-with" {:ns "cljs.core",
                                   :name "split-with",
                                   :signature ["[pred coll]"],
                                   :name-encode "split-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/split-with",
                                   :source {:code "(defn split-with\n  [pred coll]\n  [(take-while pred coll) (drop-while pred coll)])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7924 7927]},
                                   :full-name "cljs.core/split-with",
                                   :docstring "Returns a vector of [(take-while pred coll) (drop-while pred coll)]"},
           "closure-warnings/internet-explorer-checks" {:ns "closure-warnings",
                                                        :name "internet-explorer-checks",
                                                        :type "warning",
                                                        :full-name "closure-warnings/internet-explorer-checks",
                                                        :full-name-encode "closure-warnings/internet-explorer-checks",
                                                        :name-encode "internet-explorer-checks",
                                                        :history [["+"
                                                                   "0.0-2120"]]},
           "cljs.core/IWriter" {:ns "cljs.core",
                                :name "IWriter",
                                :name-encode "IWriter",
                                :implementations #{"StringBufferWriter"},
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IWriter",
                                :source {:code "(defprotocol IWriter\n  (-write [writer s])\n  (-flush [writer]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [353 355]},
                                :methods [{:name "-write",
                                           :signature ["[writer s]"],
                                           :docstring nil}
                                          {:name "-flush",
                                           :signature ["[writer]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IWriter"},
           "cljs.repl.browser/preloaded-libs" {:ns "cljs.repl.browser",
                                               :name "preloaded-libs",
                                               :name-encode "preloaded-libs",
                                               :type "var",
                                               :full-name-encode "cljs.repl.browser/preloaded-libs",
                                               :source {:code "(def preloaded-libs (atom #{}))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [27]},
                                               :full-name "cljs.repl.browser/preloaded-libs",
                                               :history [["+"
                                                          "0.0-1424"]]},
           "cljs.core/IReduce" {:ns "cljs.core",
                                :name "IReduce",
                                :name-encode "IReduce",
                                :implementations #{"Subvec"
                                                   "PersistentArrayMapSeq"
                                                   "RedNode"
                                                   "EmptyList"
                                                   "ArrayChunk"
                                                   "BlackNode"
                                                   "PersistentVector"
                                                   "ValSeq"
                                                   "Range"
                                                   "ChunkedSeq"
                                                   "ArrayNodeSeq"
                                                   "KeySeq"
                                                   "IndexedSeq"
                                                   "PersistentTreeMapSeq"
                                                   "RSeq"
                                                   "PersistentArrayMap"
                                                   "NodeSeq"
                                                   "List"
                                                   "Cons"
                                                   "LazySeq"
                                                   "Eduction"},
                                :history [["+" "0.0-927"]],
                                :type "protocol",
                                :full-name-encode "cljs.core/IReduce",
                                :source {:code "(defprotocol IReduce\n  (-reduce [coll f] [coll f start]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [320 321]},
                                :methods [{:name "-reduce",
                                           :signature ["[coll f]"
                                                       "[coll f start]"],
                                           :docstring nil}],
                                :full-name "cljs.core/IReduce"},
           "cljs.reader/symbol-pattern" {:ns "cljs.reader",
                                         :name "symbol-pattern",
                                         :name-encode "symbol-pattern",
                                         :type "var",
                                         :full-name-encode "cljs.reader/symbol-pattern",
                                         :source {:code "(def symbol-pattern (re-pattern \"^[:]?([^0-9/].*/)?([^0-9/][^/]*)$\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [101]},
                                         :full-name "cljs.reader/symbol-pattern",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/PersistentHashSet.fromArray" {:ns "cljs.core",
                                                    :name "PersistentHashSet.fromArray",
                                                    :signature ["[items no-clone]"],
                                                    :name-encode "PersistentHashSetDOTfromArray",
                                                    :history [["+"
                                                               "0.0-1443"]],
                                                    :parent-type "PersistentHashSet",
                                                    :type "function",
                                                    :full-name-encode "cljs.core/PersistentHashSetDOTfromArray",
                                                    :source {:code "(set! (.-fromArray PersistentHashSet)\n  (fn [items ^boolean no-clone]\n    (let [len (alength items)]\n      (if (<= len (.-HASHMAP-THRESHOLD PersistentArrayMap))\n        (let [arr (if no-clone items (aclone items))]\n          (loop [i 0\n                 out (transient (.-EMPTY PersistentArrayMap))]\n            (if (< i len)\n              (recur (inc i) (-assoc! out (aget items i) nil))\n              (PersistentHashSet. nil (-persistent! out) nil))))\n       (loop [i 0\n              out (transient (.-EMPTY PersistentHashSet))]\n         (if (< i len)\n           (recur (inc i) (-conj! out (aget items i)))\n           (-persistent! out)))))))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/cljs/cljs/core.cljs",
                                                             :lines [7428
                                                                     7442]},
                                                    :full-name "cljs.core/PersistentHashSet.fromArray"},
           "cljs.core/repeatedly" {:ns "cljs.core",
                                   :name "repeatedly",
                                   :signature ["[f]" "[n f]"],
                                   :name-encode "repeatedly",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/repeatedly",
                                   :source {:code "(defn repeatedly\n  ([f] (lazy-seq (cons (f) (repeatedly f))))\n  ([n f] (take n (repeatedly f))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3886 3891]},
                                   :full-name "cljs.core/repeatedly",
                                   :docstring "Takes a function of no args, presumably with side effects, and\nreturns an infinite (or length n if supplied) lazy sequence of calls\nto it"},
           "cljs.build.api/mark-cljs-ns-for-recompile!" {:ns "cljs.build.api",
                                                         :name "mark-cljs-ns-for-recompile!",
                                                         :signature ["[ns-sym]"
                                                                     "[ns-sym output-dir]"],
                                                         :name-encode "mark-cljs-ns-for-recompileBANG",
                                                         :history [["+"
                                                                    "0.0-2496"]],
                                                         :type "function",
                                                         :full-name-encode "cljs.build.api/mark-cljs-ns-for-recompileBANG",
                                                         :source {:code "(defn mark-cljs-ns-for-recompile!\n  ([ns-sym] (mark-cljs-ns-for-recompile! ns-sym nil))\n  ([ns-sym output-dir]\n    (let [s (target-file-for-cljs-ns output-dir ns-sym)]\n      (when (.exists s)\n        (.setLastModified s 5000)))))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2760",
                                                                  :filename "src/clj/cljs/build/api.clj",
                                                                  :lines [37
                                                                          43]},
                                                         :full-name "cljs.build.api/mark-cljs-ns-for-recompile!",
                                                         :docstring "Backdates a cljs target file so that it the cljs compiler will recompile it."},
           "cljs.reader/read-delimited-list" {:ns "cljs.reader",
                                              :name "read-delimited-list",
                                              :signature ["[delim rdr recursive?]"],
                                              :name-encode "read-delimited-list",
                                              :type "function",
                                              :full-name-encode "cljs.reader/read-delimited-list",
                                              :source {:code "(defn read-delimited-list\n  [delim rdr recursive?]\n  (loop [a (transient [])]\n    (let [ch (read-past whitespace? rdr)]\n      (when-not ch (reader-error rdr \"EOF while reading\"))\n      (if (identical? delim ch)\n        (persistent! a)\n        (if-let [macrofn (macros ch)]\n          (let [mret (macrofn rdr ch)]\n            (recur (if (identical? mret rdr) a (conj! a mret))))\n          (do\n            (unread rdr ch)\n            (let [o (read rdr true nil recursive?)]\n              (recur (if (identical? o rdr) a (conj! a o))))))))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/cljs/reader.cljs",
                                                       :lines [225
                                                               238]},
                                              :full-name "cljs.reader/read-delimited-list",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.test/inc-report-counter!" {:ns "cljs.test",
                                            :name "inc-report-counter!",
                                            :signature ["[name]"],
                                            :name-encode "inc-report-counterBANG",
                                            :history [["+" "0.0-2496"]],
                                            :type "function",
                                            :full-name-encode "cljs.test/inc-report-counterBANG",
                                            :source {:code "(defn inc-report-counter!\n  [name]\n  (if (:report-counters (get-current-env))\n    (update-current-env! [:report-counters name] (fnil inc 0))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/test.cljs",
                                                     :lines [254 259]},
                                            :full-name "cljs.test/inc-report-counter!",
                                            :docstring "Increments the named counter in *report-counters*, a ref to a map.\nDoes nothing if *report-counters* is nil."},
           "cljs.core/undefined?" {:return-type boolean,
                                   :ns "cljs.core",
                                   :name "undefined?",
                                   :signature ["[x]"],
                                   :name-encode "undefinedQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/undefinedQMARK",
                                   :source {:code "(defn ^boolean undefined? [x]\n  (cljs.core/undefined? x))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [1589 1590]},
                                   :extra-sources [{:code "(defmacro undefined? [x]\n  (bool-expr (core/list 'js* \"(void 0 === ~{})\" x)))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [316 317]}],
                                   :full-name "cljs.core/undefined?"},
           "clojure.zip/prev" {:ns "clojure.zip",
                               :name "prev",
                               :signature ["[loc]"],
                               :name-encode "prev",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/prev",
                               :source {:code "(defn prev\n  [loc]\n    (if-let [lloc (left loc)]\n      (loop [loc lloc]\n        (if-let [child (and (branch? loc) (down loc))]\n          (recur (rightmost child))\n          loc))\n      (up loc)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [221 230]},
                               :full-name "clojure.zip/prev",
                               :docstring "Moves to the previous loc in the hierarchy, depth-first. If already\nat the root, returns nil."},
           "cljs.core/seq?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "seq?",
                             :signature ["[s]"],
                             :name-encode "seqQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/seqQMARK",
                             :source {:code "(defn ^boolean seq?\n  [s]\n  (if (nil? s)\n    false\n    (satisfies? ISeq s)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1592 1597]},
                             :full-name "cljs.core/seq?",
                             :docstring "Return true if s satisfies ISeq"},
           "cljs.repl.browser/browser-state" {:ns "cljs.repl.browser",
                                              :name "browser-state",
                                              :name-encode "browser-state",
                                              :type "var",
                                              :full-name-encode "cljs.repl.browser/browser-state",
                                              :source {:code "(defonce browser-state\n  (atom {:return-value-fn nil\n         :client-js nil}))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/repl/browser.clj",
                                                       :lines [21 23]},
                                              :full-name "cljs.repl.browser/browser-state",
                                              :history [["+"
                                                         "0.0-1503"]]},
           "cljs.core/prn-str" {:ns "cljs.core",
                                :name "prn-str",
                                :signature ["[& objs]"],
                                :name-encode "prn-str",
                                :history [["+" "0.0-1011"]],
                                :type "function",
                                :full-name-encode "cljs.core/prn-str",
                                :source {:code "(defn prn-str\n  [& objs]\n  (prn-str-with-opts objs (pr-opts)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8272 8275]},
                                :full-name "cljs.core/prn-str",
                                :docstring "Same as pr-str followed by (newline)"},
           "cljs.core/chunk-buffer" {:ns "cljs.core",
                                     :name "chunk-buffer",
                                     :signature ["[capacity]"],
                                     :name-encode "chunk-buffer",
                                     :type "function",
                                     :full-name-encode "cljs.core/chunk-buffer",
                                     :source {:code "(defn chunk-buffer [capacity]\n  (ChunkBuffer. (make-array capacity) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2633 2634]},
                                     :full-name "cljs.core/chunk-buffer",
                                     :history [["+" "0.0-1424"]]},
           "cljs.core/odd?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "odd?",
                             :signature ["[n]"],
                             :name-encode "oddQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/oddQMARK",
                             :source {:code "(defn ^boolean odd?\n  [n] (not (even? n)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3325 3327]},
                             :full-name "cljs.core/odd?",
                             :docstring "Returns true if n is odd, throws an exception if n is not an integer"},
           "cljs.core/cons" {:ns "cljs.core",
                             :name "cons",
                             :signature ["[x coll]"],
                             :name-encode "cons",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/cons",
                             :source {:code "(defn cons\n  [x coll]\n  (if (or (nil? coll)\n          (implements? ISeq coll))\n    (Cons. nil x coll nil)\n    (Cons. nil x (seq coll) nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2464 2470]},
                             :full-name "cljs.core/cons",
                             :docstring "Returns a new seq where x is the first element and seq is the rest."},
           "syntax/function" {:syntax-equiv {:edn-url nil,
                                             :clj-url nil},
                              :ns "syntax",
                              :name "function",
                              :name-encode "function",
                              :type "syntax",
                              :full-name-encode "syntax/function",
                              :extra-sources ({:code "(defn- read-fn\n  [rdr _]\n  (if (thread-bound? #'arg-env)\n    (throw (IllegalStateException. \"Nested #()s are not allowed\")))\n  (binding [arg-env (sorted-map)]\n    (let [form (read (doto rdr (unread \\()) true nil true) ;; this sets bindings\n          rargs (rseq arg-env)\n          args (if rargs\n                 (let [higharg (key (first rargs))]\n                   (let [args (loop [i 1 args (transient [])]\n                                (if (> i higharg)\n                                  (persistent! args)\n                                  (recur (inc i) (conj! args (or (get arg-env i)\n                                                                 (garg i))))))\n                         args (if (arg-env -1)\n                                (conj args '& (arg-env -1))\n                                args)]\n                     args))\n                 [])]\n      (list 'fn* args form))))",
                                               :title "Reader code",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [386 405]}
                                              {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                               :title "Reader table",
                                               :repo "tools.reader",
                                               :tag "tools.reader-0.8.10",
                                               :filename "src/main/clojure/clojure/tools/reader.clj",
                                               :lines [612 623]}),
                              :full-name "syntax/function",
                              :history [["+" "0.0-1853"]]},
           "cljs.reader/read-set" {:ns "cljs.reader",
                                   :name "read-set",
                                   :signature ["[rdr _]"],
                                   :name-encode "read-set",
                                   :type "function",
                                   :full-name-encode "cljs.reader/read-set",
                                   :source {:code "(defn read-set\n  [rdr _]\n  (set (read-delimited-list \"}\" rdr true)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/reader.cljs",
                                            :lines [381 383]},
                                   :full-name "cljs.reader/read-set",
                                   :history [["+" "0.0-927"]]},
           "cljs.core/descendants" {:ns "cljs.core",
                                    :name "descendants",
                                    :signature ["[tag]" "[h tag]"],
                                    :name-encode "descendants",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/descendants",
                                    :source {:code "(defn descendants\n  ([tag] (descendants @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:descendants h) tag))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8802 8809]},
                                    :full-name "cljs.core/descendants",
                                    :docstring "Returns the immediate and indirect children of tag, through a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy. Note: does not work on JavaScript type inheritance\nrelationships."},
           "syntax/nil" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "nil",
                         :name-encode "nil",
                         :type "special symbol",
                         :full-name-encode "syntax/nil",
                         :extra-sources ({:code "(defn- read-symbol\n  [rdr initch]\n  (let [[line column] (when (indexing-reader? rdr)\n                        [(get-line-number rdr) (int (dec (get-column-number rdr)))])]\n    (when-let [token (read-token rdr initch)]\n      (case token\n\n        ;; special symbols\n        \"nil\" nil\n        \"true\" true\n        \"false\" false\n        \"/\" '/\n        \"NaN\" Double/NaN\n        \"-Infinity\" Double/NEGATIVE_INFINITY\n        (\"Infinity\" \"+Infinity\") Double/POSITIVE_INFINITY\n\n        (or (when-let [p (parse-symbol token)]\n              (with-meta (symbol (p 0) (p 1))\n                (when line\n                  (merge\n                   (when-let [file (get-file-name rdr)]\n                     {:file file})\n                   {:line line\n                    :column column\n                    :end-line (get-line-number rdr)\n                    :end-column (int (inc (get-column-number rdr)))}))))\n            (reader-error rdr \"Invalid token: \" token))))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [275 301]}),
                         :full-name "syntax/nil",
                         :history [["+" "0.0-1853"]]},
           "syntax/map" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "map",
                         :name-encode "map",
                         :type "syntax",
                         :full-name-encode "syntax/map",
                         :extra-sources ({:code "(defn- read-map\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-map (read-delimited \\} rdr true)\n        map-count (count the-map)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (when (odd? map-count)\n      (reader-error rdr \"Map literal must contain an even number of forms\"))\n    (with-meta\n      (if (zero? map-count)\n        {}\n        (RT/map (to-array the-map)))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                          :title "Reader code",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [205 226]}
                                         {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [591 610]}),
                         :full-name "syntax/map",
                         :history [["+" "0.0-1853"]]},
           "cljs.core/take-nth" {:ns "cljs.core",
                                 :name "take-nth",
                                 :signature ["[n]" "[n coll]"],
                                 :name-encode "take-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/take-nth",
                                 :source {:code "(defn take-nth\n  ([n]\n     (fn [rf]\n       (let [ia (volatile! -1)]\n         (fn\n           ([] (rf))\n           ([result] (rf result))\n           ([result input]\n              (let [i (vswap! ia inc)]\n                (if (zero? (rem i n))\n                  (rf result input)\n                  result)))))))\n  ([n coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (cons (first s) (take-nth n (drop n s)))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7905 7922]},
                                 :full-name "cljs.core/take-nth",
                                 :docstring "Returns a lazy seq of every nth item in coll.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.reader/throwing-reader" {:ns "cljs.reader",
                                          :name "throwing-reader",
                                          :signature ["[msg]"],
                                          :name-encode "throwing-reader",
                                          :type "function",
                                          :full-name-encode "cljs.reader/throwing-reader",
                                          :source {:code "(defn throwing-reader\n  [msg]\n  (fn [rdr _]\n    (reader-error rdr msg)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [366 369]},
                                          :full-name "cljs.reader/throwing-reader",
                                          :history [["+" "0.0-927"]]},
           "cljs.repl.browser/send-static" {:ns "cljs.repl.browser",
                                            :name "send-static",
                                            :signature ["[{path :path, :as request} conn opts]"],
                                            :name-encode "send-static",
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/send-static",
                                            :source {:code "(defn send-static [{path :path :as request} conn opts]\n  (if (and (:static-dir opts)\n           (not= \"/favicon.ico\" path))\n    (let [path   (if (= \"/\" path) \"/index.html\" path)\n          st-dir (:static-dir opts)\n          local-path\n          (cond->\n            (seq (for [x (if (string? st-dir) [st-dir] st-dir)\n                       :when (.exists (io/file (str x path)))]\n                   (str x path)))\n            (complement nil?) first)\n          local-path\n          (if (nil? local-path)\n            (cond\n              (re-find #\".jar\" path)\n              (io/resource (second (string/split path #\".jar!/\")))\n              (re-find (Pattern/compile (System/getProperty \"user.dir\")) path)\n              (io/file (string/replace path (str (System/getProperty \"user.dir\") \"/\") \"\"))\n              :else nil)\n            local-path)]\n      (if local-path\n        (server/send-and-close conn 200 (slurp local-path)\n          (condp #(.endsWith %2 %1) path\n            \".html\" \"text/html\"\n            \".css\" \"text/css\"\n            \".html\" \"text/html\"\n            \".jpg\" \"image/jpeg\"\n            \".js\" \"text/javascript\"\n            \".cljs\" \"text/x-clojure\"\n            \".map\" \"application/json\"\n            \".png\" \"image/png\"\n            \"text/plain\"))\n        (server/send-404 conn path)))\n    (server/send-404 conn path)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [67 100]},
                                            :full-name "cljs.repl.browser/send-static",
                                            :history [["+" "0.0-1211"]]},
           "cljs.core/double" {:return-type number,
                               :ns "cljs.core",
                               :name "double",
                               :signature ["[x]"],
                               :name-encode "double",
                               :history [["+" "0.0-1798"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/double",
                               :source {:code "(defn ^number double [x] x)",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1947]},
                               :extra-sources [{:code "(defmacro double [x] x)",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [364]}],
                               :full-name "cljs.core/double"},
           "cljs.core/even?" {:return-type boolean,
                              :ns "cljs.core",
                              :name "even?",
                              :signature ["[n]"],
                              :name-encode "evenQMARK",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/evenQMARK",
                              :source {:code "(defn ^boolean even?\n   [n] (if (integer? n)\n        (zero? (bit-and n 1))\n        (throw (js/Error. (str \"Argument must be an integer: \" n)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3319 3323]},
                              :full-name "cljs.core/even?",
                              :docstring "Returns true if n is even, throws an exception if n is not an integer"},
           "compiler-options/foreign-libs" {:ns "compiler-options",
                                            :name "foreign-libs",
                                            :name-encode "foreign-libs",
                                            :type "option",
                                            :full-name-encode "compiler-options/foreign-libs",
                                            :full-name "compiler-options/foreign-libs",
                                            :history [["+" "0.0-971"]]},
           "cljs.core/simple-benchmark" {:ns "cljs.core",
                                         :name "simple-benchmark",
                                         :signature ["[bindings expr iterations & {:keys [print-fn], :or {print-fn (quote println)}}]"],
                                         :name-encode "simple-benchmark",
                                         :history [["+" "0.0-1236"]],
                                         :type "macro",
                                         :full-name-encode "cljs.core/simple-benchmark",
                                         :source {:code "(defmacro simple-benchmark\n  [bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]\n  (let [bs-str   (pr-str bindings)\n        expr-str (pr-str expr)]\n    `(let ~bindings\n       (let [start#   (.getTime (js/Date.))\n             ret#     (dotimes [_# ~iterations] ~expr)\n             end#     (.getTime (js/Date.))\n             elapsed# (- end# start#)]\n         (~print-fn (str ~bs-str \", \" ~expr-str \", \"\n                         ~iterations \" runs, \" elapsed# \" msecs\"))))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1603 1619]},
                                         :full-name "cljs.core/simple-benchmark",
                                         :docstring "Runs expr iterations times in the context of a let expression with\nthe given bindings, then prints out the bindings and the expr\nfollowed by number of iterations and total time. The optional\nargument print-fn, defaulting to println, sets function used to\nprint the result. expr's string representation will be produced\nusing pr-str in any case."},
           "cljs.build.api/cljs-ns-dependents" {:ns "cljs.build.api",
                                                :name "cljs-ns-dependents",
                                                :signature ["[ns]"],
                                                :name-encode "cljs-ns-dependents",
                                                :history [["+"
                                                           "0.0-2629"]],
                                                :type "function",
                                                :full-name-encode "cljs.build.api/cljs-ns-dependents",
                                                :source {:code "(defn cljs-ns-dependents\n  [ns]\n  (ana/ns-dependents ns))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/build/api.clj",
                                                         :lines [66
                                                                 71]},
                                                :full-name "cljs.build.api/cljs-ns-dependents",
                                                :docstring "Given a namespace symbol return a seq of all dependent\nnamespaces sorted in dependency order. Will include\ntransient dependents."},
           "syntax/number" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "number",
                            :name-encode "number",
                            :type "syntax",
                            :full-name-encode "syntax/number",
                            :extra-sources ({:code "(defn- read-number\n  [reader initch]\n  (loop [sb (doto (StringBuilder.) (.append initch))\n         ch (read-char reader)]\n    (if (or (whitespace? ch) (macros ch) (nil? ch))\n      (let [s (str sb)]\n        (unread reader ch)\n        (or (match-number s)\n            (reader-error reader \"Invalid number format [\" s \"]\")))\n      (recur (doto sb (.append ch)) (read-char reader)))))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [228 237]}),
                            :full-name "syntax/number",
                            :history [["+" "0.0-1853"]]},
           "cljs.core/persistent-array-map-seq" {:ns "cljs.core",
                                                 :name "persistent-array-map-seq",
                                                 :signature ["[arr i _meta]"],
                                                 :name-encode "persistent-array-map-seq",
                                                 :type "function",
                                                 :full-name-encode "cljs.core/persistent-array-map-seq",
                                                 :source {:code "(defn persistent-array-map-seq [arr i _meta]\n  (when (<= i (- (alength arr) 2))\n    (PersistentArrayMapSeq. arr i _meta)))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/cljs/core.cljs",
                                                          :lines [5314
                                                                  5316]},
                                                 :full-name "cljs.core/persistent-array-map-seq",
                                                 :history [["+"
                                                            "0.0-1820"]]},
           "cljs.analyzer.api/ns-specs" {:ns "cljs.analyzer.api",
                                         :name "ns-specs",
                                         :signature ["[ns]"],
                                         :name-encode "ns-specs",
                                         :history [["+" "0.0-2629"]
                                                   ["-" "0.0-2655"]],
                                         :type "function",
                                         :full-name-encode "cljs.analyzer.api/ns-specs",
                                         :source {:code "(defn ns-specs\n  [ns]\n  {:pre [(symbol? ns)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :specs]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2644",
                                                  :filename "src/clj/cljs/analyzer/api.clj",
                                                  :lines [48 53]},
                                         :full-name "cljs.analyzer.api/ns-specs",
                                         :docstring "Given a namespace return all the original specs for a namspace as originally\nprovided in the source.",
                                         :removed {:in "0.0-2655",
                                                   :last-seen "0.0-2644"}},
           "clojure.set/subset?" {:ns "clojure.set",
                                  :name "subset?",
                                  :signature ["[set1 set2]"],
                                  :name-encode "subsetQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.set/subsetQMARK",
                                  :source {:code "(defn subset? \n  [set1 set2]\n  (and (<= (count set1) (count set2))\n       (every? #(contains? set2 %) set1)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/set.cljs",
                                           :lines [131 135]},
                                  :full-name "clojure.set/subset?",
                                  :docstring "Is set1 a subset of set2?"},
           "cljs.core/flush" {:ns "cljs.core",
                              :name "flush",
                              :signature ["[]"],
                              :name-encode "flush",
                              :type "function",
                              :full-name-encode "cljs.core/flush",
                              :source {:code "(defn flush [] ;stub\n  nil)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8133 8134]},
                              :full-name "cljs.core/flush",
                              :history [["+" "0.0-927"]]},
           "cljs.core/long-array" {:ns "cljs.core",
                                   :name "long-array",
                                   :signature ["[size-or-seq]"
                                               "[size init-val-or-seq]"],
                                   :name-encode "long-array",
                                   :type "function",
                                   :full-name-encode "cljs.core/long-array",
                                   :source {:code "(defn long-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (long-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2797 2815]},
                                   :full-name "cljs.core/long-array",
                                   :history [["+" "0.0-1211"]]},
           "cljs.reader/reader-error" {:ns "cljs.reader",
                                       :name "reader-error",
                                       :signature ["[rdr & msg]"],
                                       :name-encode "reader-error",
                                       :type "function",
                                       :full-name-encode "cljs.reader/reader-error",
                                       :source {:code "(defn reader-error\n  [rdr & msg]\n  (throw (js/Error. (apply str msg))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [69 71]},
                                       :full-name "cljs.reader/reader-error",
                                       :history [["+" "0.0-927"]]},
           "compiler-options/externs" {:ns "compiler-options",
                                       :name "externs",
                                       :name-encode "externs",
                                       :type "option",
                                       :full-name-encode "compiler-options/externs",
                                       :full-name "compiler-options/externs",
                                       :history [["+" "0.0-971"]]},
           "clojure.walk/prewalk-replace" {:ns "clojure.walk",
                                           :name "prewalk-replace",
                                           :signature ["[smap form]"],
                                           :name-encode "prewalk-replace",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/prewalk-replace",
                                           :source {:code "(defn prewalk-replace\n  [smap form]\n  (prewalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [80 86]},
                                           :full-name "clojure.walk/prewalk-replace",
                                           :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the root of the tree first."},
           "cljs.core/*1" {:ns "cljs.core",
                           :name "*1",
                           :name-encode "STAR1",
                           :type "var",
                           :full-name-encode "cljs.core/STAR1",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the most recent value printed\"}\n  *1)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [59 61]},
                           :full-name "cljs.core/*1",
                           :docstring "bound in a repl thread to the most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.core/subseq" {:ns "cljs.core",
                               :name "subseq",
                               :signature ["[sc test key]"
                                           "[sc start-test start-key end-test end-key]"],
                               :name-encode "subseq",
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :full-name-encode "cljs.core/subseq",
                               :source {:code "(defn subseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{> >=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key true)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc true)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc start-key true)]\n       (take-while (mk-bound-fn sc end-test end-key)\n                   (if ((mk-bound-fn sc start-test start-key) e) s (next s))))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [7765 7778]},
                               :full-name "cljs.core/subseq",
                               :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/Eduction" {:protocols #{"ISeqable"
                                              "IReduce"
                                              "ISequential"
                                              "IPrintWithWriter"},
                                 :ns "cljs.core",
                                 :name "Eduction",
                                 :signature ["[xform coll]"],
                                 :name-encode "Eduction",
                                 :history [["+" "0.0-2371"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Eduction",
                                 :source {:code "(deftype Eduction [xform coll]\n   ISequential\n   \n   ISeqable\n   (-seq [_] (seq (sequence xform coll)))\n\n   IReduce\n   (-reduce [_ f init] (transduce xform f init coll))\n\n   IPrintWithWriter\n   (-pr-writer [coll writer opts]\n     (pr-sequential-writer writer pr-writer \"(\" \" \" \")\" opts coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8593 8604]},
                                 :full-name "cljs.core/Eduction"},
           "cljs.core/Set.EMPTY" {:ns "cljs.core",
                                  :name "Set.EMPTY",
                                  :name-encode "SetDOTEMPTY",
                                  :history [["+" "0.0-927"]
                                            ["-" "0.0-1211"]],
                                  :parent-type "Set",
                                  :type "var",
                                  :full-name-encode "cljs.core/SetDOTEMPTY",
                                  :source {:code "(set! cljs.core.Set/EMPTY (Set. nil (hash-map)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r1011",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2708]},
                                  :full-name "cljs.core/Set.EMPTY",
                                  :removed {:in "0.0-1211",
                                            :last-seen "0.0-1011"}},
           "cljs.reader/read-unicode-char" {:ns "cljs.reader",
                                            :name "read-unicode-char",
                                            :signature ["[reader initch]"],
                                            :name-encode "read-unicode-char",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1424"]],
                                            :type "function",
                                            :full-name-encode "cljs.reader/read-unicode-char",
                                            :source {:code "(defn read-unicode-char\n  [reader initch]\n  (reader-error reader \"Unicode characters not supported by reader (yet)\"))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1236",
                                                     :filename "src/cljs/cljs/reader.cljs",
                                                     :lines [171 173]},
                                            :full-name "cljs.reader/read-unicode-char",
                                            :removed {:in "0.0-1424",
                                                      :last-seen "0.0-1236"}},
           "cljs.core/dissoc" {:ns "cljs.core",
                               :name "dissoc",
                               :signature ["[coll]"
                                           "[coll k]"
                                           "[coll k & ks]"],
                               :name-encode "dissoc",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/dissoc",
                               :source {:code "(defn dissoc\n  ([coll] coll)\n  ([coll k]\n    (when-not (nil? coll)\n      (-dissoc coll k)))\n  ([coll k & ks]\n    (when-not (nil? coll)\n      (let [ret (dissoc coll k)]\n        (if ks\n          (recur ret (first ks) (next ks))\n          ret)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1379 1391]},
                               :full-name "cljs.core/dissoc",
                               :docstring "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\nthat does not contain a mapping for key(s)."},
           "cljs.core/exists?" {:ns "cljs.core",
                                :name "exists?",
                                :signature ["[x]"],
                                :name-encode "existsQMARK",
                                :type "macro",
                                :full-name-encode "cljs.core/existsQMARK",
                                :source {:code "(defmacro exists? [x]\n  (bool-expr\n    (core/list 'js* \"typeof ~{} !== 'undefined'\"\n      (vary-meta x assoc :cljs.analyzer/no-resolve true))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [311 314]},
                                :full-name "cljs.core/exists?",
                                :history [["+" "0.0-1798"]]},
           "cljs.core/ffirst" {:ns "cljs.core",
                               :name "ffirst",
                               :signature ["[coll]"],
                               :name-encode "ffirst",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/ffirst",
                               :source {:code "(defn ffirst\n  [coll]\n  (first (first coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1148 1151]},
                               :full-name "cljs.core/ffirst",
                               :docstring "Same as (first (first x))"},
           "clojure.zip/replace" {:ns "clojure.zip",
                                  :name "replace",
                                  :signature ["[loc node]"],
                                  :name-encode "replace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/replace",
                                  :source {:code "(defn replace\n  [loc node]\n    (let [[_ path] loc]\n      (with-meta [node (assoc path :changed? true)] (meta loc))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [183 187]},
                                  :full-name "clojure.zip/replace",
                                  :docstring "Replaces the node at this loc, without moving"},
           "cljs.core/vec" {:ns "cljs.core",
                            :name "vec",
                            :signature ["[coll]"],
                            :name-encode "vec",
                            :type "function",
                            :full-name-encode "cljs.core/vec",
                            :source {:code "(defn vec [coll]\n  (if (array? coll)\n    (.fromArray PersistentVector coll true)\n    (-persistent!\n      (reduce -conj!\n        (-as-transient (.-EMPTY PersistentVector))\n        coll))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [4474 4480]},
                            :full-name "cljs.core/vec",
                            :history [["+" "0.0-927"]]},
           "cljs.core/or" {:ns "cljs.core",
                           :name "or",
                           :signature ["[]" "[x]" "[x & next]"],
                           :name-encode "or",
                           :history [["+" "0.0-927"]],
                           :type "macro",
                           :full-name-encode "cljs.core/or",
                           :source {:code "(defmacro or\n  ([] nil)\n  ([x] x)\n  ([x & next]\n    (let [forms (concat [x] next)]\n      (if (every? #(simple-test-expr? &env %)\n            (map #(cljs.analyzer/analyze &env %) forms))\n        (let [or-str (->> (repeat (count forms) \"(~{})\")\n                        (interpose \" || \")\n                        (apply core/str))]\n          (bool-expr `(~'js* ~or-str ~@forms)))\n        `(let [or# ~x]\n           (if or# or# (or ~@next)))))))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/clj/cljs/core.clj",
                                    :lines [240 256]},
                           :full-name "cljs.core/or",
                           :docstring "Evaluates exprs one at a time, from left to right. If a form\nreturns a logical true value, or returns that value and doesn't\nevaluate any of the other expressions, otherwise it returns the\nvalue of the last expression. (or) returns nil."},
           "cljs.core/doubles" {:ns "cljs.core",
                                :name "doubles",
                                :signature ["[x]"],
                                :name-encode "doubles",
                                :type "function",
                                :full-name-encode "cljs.core/doubles",
                                :source {:code "(defn doubles [x] x)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2058]},
                                :full-name "cljs.core/doubles",
                                :history [["+" "0.0-1798"]]},
           "cljs.core/mod" {:ns "cljs.core",
                            :name "mod",
                            :signature ["[n d]"],
                            :name-encode "mod",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/mod",
                            :source {:code "(defn mod\n  [n d]\n  (js-mod (+ (js-mod n d) d) d))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [2066 2069]},
                            :full-name "cljs.core/mod",
                            :docstring "Modulus of num and div. Truncates toward negative infinity."},
           "cljs.core/aset" {:ns "cljs.core",
                             :name "aset",
                             :signature ["[array i val]"
                                         "[array idx idx2 & idxv]"],
                             :name-encode "aset",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/aset",
                             :source {:code "(defn aset\n  ([array i val]\n    (cljs.core/aset array i val))\n  ([array idx idx2 & idxv]\n    (apply aset (aget array idx) idx2 idxv)))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [199 204]},
                             :extra-sources [{:code "(defmacro aset\n  ([a i v]\n    (core/list 'js* \"(~{}[~{}] = ~{})\" a i v))\n  ([a idx idx2 & idxv]\n    (let [n    (core/dec (count idxv))\n          astr (apply core/str (repeat n \"[~{}]\"))]\n      `(~'js* ~(core/str \"(~{}[~{}][~{}]\" astr \" = ~{})\") ~a ~idx ~idx2 ~@idxv))))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [347 353]}],
                             :full-name "cljs.core/aset",
                             :docstring "Sets the value at the index."},
           "cljs.core/second" {:ns "cljs.core",
                               :name "second",
                               :signature ["[coll]"],
                               :name-encode "second",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/second",
                               :source {:code "(defn second\n  [coll]\n  (first (next coll)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1143 1146]},
                               :full-name "cljs.core/second",
                               :docstring "Same as (first (next x))"},
           "cljs.core/IChunkedNext" {:ns "cljs.core",
                                     :name "IChunkedNext",
                                     :name-encode "IChunkedNext",
                                     :implementations #{"ChunkedCons"
                                                        "ChunkedSeq"},
                                     :history [["+" "0.0-1424"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IChunkedNext",
                                     :source {:code "(defprotocol IChunkedNext\n  (-chunked-next [coll]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [403 404]},
                                     :methods [{:name "-chunked-next",
                                                :signature ["[coll]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IChunkedNext"},
           "closure-warnings/global-this" {:ns "closure-warnings",
                                           :name "global-this",
                                           :type "warning",
                                           :full-name "closure-warnings/global-this",
                                           :full-name-encode "closure-warnings/global-this",
                                           :name-encode "global-this",
                                           :history [["+" "0.0-2120"]]},
           "cljs.core/set!" {:ns "cljs.core",
                             :name "set!",
                             :type "special form",
                             :source {:code "(defmethod parse 'set!\n  [_ env [_ target val alt :as form] _ _]\n  (let [[target val] (if alt\n                       ;; (set! o -prop val)\n                       [`(. ~target ~val) alt]\n                       [target val])]\n    (disallowing-recur\n     (let [enve (assoc env :context :expr)\n           targetexpr (cond\n                       ;; TODO: proper resolve\n                       (= target '*unchecked-if*)\n                       (do\n                         (reset! *unchecked-if* val)\n                         ::set-unchecked-if)\n\n                       (symbol? target)\n                       (do\n                         (let [local (-> env :locals target)]\n                           (when-not (or (nil? local)\n                                         (and (:field local)\n                                              (or (:mutable local)\n                                                  (:unsynchronized-mutable local)\n                                                  (:volatile-mutable local))))\n                             (throw (error env \"Can't set! local var or non-mutable field\"))))\n                         (analyze-symbol enve target))\n\n                       :else\n                       (when (seq? target)\n                         (let [targetexpr (analyze-seq enve target nil)]\n                           (when (:field targetexpr)\n                             targetexpr))))\n           valexpr (analyze enve val)]\n       (when-not targetexpr \n         (throw (error env \"set! target must be a field or a symbol naming a var\")))\n       (cond\n        (= targetexpr ::set-unchecked-if) {:env env :op :no-op}\n        :else {:env env :op :set! :form form :target targetexpr :val valexpr\n               :children [targetexpr valexpr]})))))",
                                      :title "Parser code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/analyzer.clj",
                                      :lines [1035 1072]},
                             :extra-sources ({:code "(defmethod emit* :set!\n  [{:keys [target val env]}]\n  (emit-wrap env (emits target \" = \" val)))",
                                              :title "Emitting code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/compiler.clj",
                                              :lines [803 805]}),
                             :full-name "cljs.core/set!",
                             :full-name-encode "cljs.core/setBANG",
                             :name-encode "setBANG",
                             :history [["+" "0.0-927"]]},
           "cljs.core/bit-count" {:ns "cljs.core",
                                  :name "bit-count",
                                  :signature ["[v]"],
                                  :name-encode "bit-count",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/bit-count",
                                  :source {:code "(defn bit-count\n  [v]\n  (let [v (- v (bit-and (bit-shift-right v 1) 0x55555555))\n        v (+ (bit-and v 0x33333333) (bit-and (bit-shift-right v 2) 0x33333333))]\n    (bit-shift-right (* (bit-and (+ v (bit-shift-right v 4)) 0xF0F0F0F) 0x1010101) 24)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2147 2152]},
                                  :full-name "cljs.core/bit-count",
                                  :docstring "Counts the number of bits set in n"},
           "clojure.set/rename" {:ns "clojure.set",
                                 :name "rename",
                                 :signature ["[xrel kmap]"],
                                 :name-encode "rename",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.set/rename",
                                 :source {:code "(defn rename\n  [xrel kmap]\n    (set (map #(rename-keys % kmap) xrel)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/clojure/set.cljs",
                                          :lines [82 85]},
                                 :full-name "clojure.set/rename",
                                 :docstring "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/m3-hash-int" {:return-type number,
                                    :ns "cljs.core",
                                    :name "m3-hash-int",
                                    :signature ["[in]"],
                                    :name-encode "m3-hash-int",
                                    :history [["+" "0.0-2261"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/m3-hash-int",
                                    :source {:code "(defn ^number m3-hash-int [in]\n  (if (zero? in)\n    in\n    (let [k1 (m3-mix-K1 in)\n          h1 (m3-mix-H1 m3-seed k1)]\n      (m3-fmix h1 4))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [483 488]},
                                    :full-name "cljs.core/m3-hash-int"},
           "cljs.core/assoc!" {:ns "cljs.core",
                               :name "assoc!",
                               :signature ["[tcoll key val]"
                                           "[tcoll key val & kvs]"],
                               :name-encode "assocBANG",
                               :history [["+" "0.0-1211"]],
                               :type "function",
                               :full-name-encode "cljs.core/assocBANG",
                               :source {:code "(defn assoc!\n  ([tcoll key val]\n    (-assoc! tcoll key val))\n  ([tcoll key val & kvs]\n    (let [ntcoll (-assoc! tcoll key val)]\n      (if kvs\n        (recur ntcoll (first kvs) (second kvs) (nnext kvs))\n        ntcoll))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2936 2946]},
                               :full-name "cljs.core/assoc!",
                               :docstring "When applied to a transient map, adds mapping of key(s) to\nval(s). When applied to a transient vector, sets the val at index.\nNote - index must be <= (count vector). Returns coll."},
           "cljs.core/delay?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "delay?",
                               :signature ["[x]"],
                               :name-encode "delayQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/delayQMARK",
                               :source {:code "(defn ^boolean delay?\n  [x] (instance? Delay x))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8531 8533]},
                               :full-name "cljs.core/delay?",
                               :docstring "returns true if x is a Delay created with delay"},
           "clojure.zip/left" {:ns "clojure.zip",
                               :name "left",
                               :signature ["[loc]"],
                               :name-encode "left",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "clojure.zip/left",
                               :source {:code "(defn left\n  [loc]\n    (let [[node {l :l r :r :as path}] loc]\n      (when (and path (seq l))\n        (with-meta [(peek l) (assoc path :l (pop l) :r (cons node r))] (meta loc)))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/clojure/zip.cljs",
                                        :lines [150 155]},
                               :full-name "clojure.zip/left",
                               :docstring "Returns the loc of the left sibling of the node at this loc, or nil"},
           "cljs.reader/not-implemented" {:ns "cljs.reader",
                                          :name "not-implemented",
                                          :signature ["[rdr ch]"],
                                          :name-encode "not-implemented",
                                          :type "function",
                                          :full-name-encode "cljs.reader/not-implemented",
                                          :source {:code "(defn not-implemented\n  [rdr ch]\n  (reader-error rdr \"Reader for \" ch \" not implemented yet\"))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [244 246]},
                                          :full-name "cljs.reader/not-implemented",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/IAssociative" {:ns "cljs.core",
                                     :name "IAssociative",
                                     :name-encode "IAssociative",
                                     :implementations #{"Subvec"
                                                        "PersistentHashMap"
                                                        "RedNode"
                                                        "ObjMap"
                                                        "BlackNode"
                                                        "PersistentVector"
                                                        "PersistentTreeMap"
                                                        "PersistentArrayMap"},
                                     :history [["+" "0.0-927"]],
                                     :type "protocol",
                                     :full-name-encode "cljs.core/IAssociative",
                                     :source {:code "(defprotocol IAssociative\n  (^boolean -contains-key? [coll k])\n  #_(-entry-at [coll k])\n  (^clj -assoc [coll k v]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [285 288]},
                                     :methods [{:name "-contains-key?",
                                                :signature ["[coll k]"],
                                                :docstring nil}
                                               {:name "-assoc",
                                                :signature ["[coll k v]"],
                                                :docstring nil}],
                                     :full-name "cljs.core/IAssociative"},
           "cljs.core/ObjMap.EMPTY" {:ns "cljs.core",
                                     :name "ObjMap.EMPTY",
                                     :name-encode "ObjMapDOTEMPTY",
                                     :parent-type "ObjMap",
                                     :type "var",
                                     :full-name-encode "cljs.core/ObjMapDOTEMPTY",
                                     :source {:code "(set! (.-EMPTY ObjMap) (ObjMap. nil (array) (js-obj) 0 empty-unordered-hash))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [5150]},
                                     :full-name "cljs.core/ObjMap.EMPTY",
                                     :history [["+" "0.0-927"]]},
           "closure-warnings/deprecated" {:ns "closure-warnings",
                                          :name "deprecated",
                                          :type "warning",
                                          :full-name "closure-warnings/deprecated",
                                          :full-name-encode "closure-warnings/deprecated",
                                          :name-encode "deprecated",
                                          :history [["+" "0.0-2120"]]},
           "cljs.core/group-by" {:ns "cljs.core",
                                 :name "group-by",
                                 :signature ["[f coll]"],
                                 :name-encode "group-by",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/group-by",
                                 :source {:code "(defn group-by\n  [f coll]\n  (persistent!\n    (reduce\n      (fn [ret x]\n        (let [k (f x)]\n          (assoc! ret k (conj (get ret k []) x))))\n      (transient {}) coll)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8740 8750]},
                                 :full-name "cljs.core/group-by",
                                 :docstring "Returns a map of the elements of coll keyed by the result of\nf on each element. The value at each key will be a vector of the\ncorresponding elements, in the order they appeared in coll."},
           "compiler-options/language-out" {:ns "compiler-options",
                                            :name "language-out",
                                            :name-encode "language-out",
                                            :type "option",
                                            :full-name-encode "compiler-options/language-out",
                                            :full-name "compiler-options/language-out",
                                            :history [["+" "0.0-2197"]]},
           "cljs.reader/*default-data-reader-fn*" {:ns "cljs.reader",
                                                   :name "*default-data-reader-fn*",
                                                   :name-encode "STARdefault-data-reader-fnSTAR",
                                                   :type "dynamic var",
                                                   :full-name-encode "cljs.reader/STARdefault-data-reader-fnSTAR",
                                                   :source {:code "(def ^:dynamic *default-data-reader-fn*\n  (atom nil))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [573
                                                                    574]},
                                                   :full-name "cljs.reader/*default-data-reader-fn*",
                                                   :history [["+"
                                                              "0.0-1576"]]},
           "cljs.core/sorted-map-by" {:ns "cljs.core",
                                      :name "sorted-map-by",
                                      :signature ["[comparator & keyvals]"],
                                      :name-encode "sorted-map-by",
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/sorted-map-by",
                                      :source {:code "(defn sorted-map-by\n  ([comparator & keyvals]\n     (loop [in (seq keyvals)\n            out (PersistentTreeMap. (fn->comparator comparator) nil 0 nil 0)]\n       (if in\n         (recur (nnext in) (assoc out (first in) (second in)))\n         out))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7163 7171]},
                                      :full-name "cljs.core/sorted-map-by",
                                      :docstring "keyval => key val\nReturns a new sorted map with supplied mappings, using the supplied comparator."},
           "cljs.core/symbol" {:ns "cljs.core",
                               :name "symbol",
                               :signature ["[name]" "[ns name]"],
                               :name-encode "symbol",
                               :type "function",
                               :full-name-encode "cljs.core/symbol",
                               :source {:code "(defn symbol\n  ([name]\n     (if (symbol? name)\n       name\n       (symbol nil name)))\n  ([ns name]\n     (let [sym-str (if-not (nil? ns)\n                     (str ns \"/\" name)\n                     name)]\n       (Symbol. ns name sym-str nil nil))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [626 635]},
                               :full-name "cljs.core/symbol",
                               :history [["+" "0.0-927"]]},
           "cljs.core/volatile?" {:ns "cljs.core",
                                  :name "volatile?",
                                  :signature ["[x]"],
                                  :name-encode "volatileQMARK",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/volatileQMARK",
                                  :source {:code "(defn volatile?\n  [x] (instance? Volatile x))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [3609 3611]},
                                  :full-name "cljs.core/volatile?",
                                  :docstring "Returns true if x is a volatile."},
           "cljs.core/Delay" {:protocols #{"IDeref" "IPending"},
                              :ns "cljs.core",
                              :name "Delay",
                              :signature ["[f value]"],
                              :name-encode "Delay",
                              :history [["+" "0.0-927"]],
                              :type "type",
                              :full-name-encode "cljs.core/Delay",
                              :source {:code "(deftype Delay [^:mutable f ^:mutable value]\n  IDeref\n  (-deref [_]\n    (when f\n      (set! value (f))\n      (set! f nil))\n    value)\n\n  IPending\n  (-realized? [d]\n    (not f)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [8519 8529]},
                              :full-name "cljs.core/Delay"},
           "cljs.core/methods" {:ns "cljs.core",
                                :name "methods",
                                :signature ["[multifn]"],
                                :name-encode "methods",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/methods",
                                :source {:code "(defn methods\n  [multifn] (-methods multifn))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [9131 9133]},
                                :full-name "cljs.core/methods",
                                :docstring "Given a multimethod, returns a map of dispatch values -> dispatch fns"},
           "cljs.test/test-vars" {:ns "cljs.test",
                                  :name "test-vars",
                                  :signature ["[vars]"],
                                  :name-encode "test-vars",
                                  :history [["+" "0.0-2496"]],
                                  :type "function",
                                  :full-name-encode "cljs.test/test-vars",
                                  :source {:code "(defn test-vars\n  [vars]\n  (doseq [[ns vars] (group-by (comp :ns meta) vars)]\n    (let [env (get-current-env)\n          once-fixture-fn (join-fixtures (get-in env [:once-fixtures ns]))\n          each-fixture-fn (join-fixtures (get-in env [:each-fixtures ns]))]\n      (once-fixture-fn\n        (fn []\n          (doseq [v vars]\n            (when (:test (meta v))\n              (each-fixture-fn (fn [] (test-var v))))))))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [395 408]},
                                  :full-name "cljs.test/test-vars",
                                  :docstring "Groups vars by their namespace and runs test-vars on them with\nappropriate fixtures assuming they are present in the current\ntesting environment."},
           "cljs.core/lazy-cat" {:ns "cljs.core",
                                 :name "lazy-cat",
                                 :signature ["[& colls]"],
                                 :name-encode "lazy-cat",
                                 :history [["+" "0.0-1803"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/lazy-cat",
                                 :source {:code "(defmacro lazy-cat\n  [& colls]\n  `(concat ~@(map #(core/list `lazy-seq %) colls)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/core.clj",
                                          :lines [1658 1665]},
                                 :full-name "cljs.core/lazy-cat",
                                 :docstring "Expands to code which yields a lazy sequence of the concatenation\nof the supplied colls.  Each coll expr is not evaluated until it is\nneeded. \n\n(lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))"},
           "cljs.core/vector" {:ns "cljs.core",
                               :name "vector",
                               :signature ["[& args]"],
                               :name-encode "vector",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/vector",
                               :source {:code "(defn vector [& args]\n  (if (and (instance? IndexedSeq args) (zero? (.-i args)))\n    (.fromArray PersistentVector (.-arr args) true)\n    (vec args)))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4482 4485]},
                               :extra-sources [{:code "(defmacro vector\n  ([] '(.-EMPTY cljs.core/PersistentVector))\n  ([& xs]\n    (let [cnt (count xs)]\n      (if (core/< cnt 32)\n        `(cljs.core/PersistentVector. nil ~cnt 5\n           (.-EMPTY-NODE cljs.core/PersistentVector) (array ~@xs) nil)\n        (vary-meta\n          `(.fromArray cljs.core/PersistentVector (array ~@xs) true)\n          assoc :tag 'cljs.core/PersistentVector)))))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [1419 1428]}],
                               :full-name "cljs.core/vector"},
           "cljs.core/rand-int" {:ns "cljs.core",
                                 :name "rand-int",
                                 :signature ["[n]"],
                                 :name-encode "rand-int",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-int",
                                 :source {:code "(defn rand-int\n  [n] (Math/floor (* (Math/random) n)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8729 8731]},
                                 :full-name "cljs.core/rand-int",
                                 :docstring "Returns a random integer between 0 (inclusive) and n (exclusive)."},
           "cljs.core/m3-seed" {:ns "cljs.core",
                                :name "m3-seed",
                                :name-encode "m3-seed",
                                :type "var",
                                :full-name-encode "cljs.core/m3-seed",
                                :source {:code "(def m3-seed 0)",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [464]},
                                :full-name "cljs.core/m3-seed",
                                :history [["+" "0.0-2261"]]},
           "cljs.core/throw" {:ns "cljs.core",
                              :name "throw",
                              :type "special form",
                              :source {:code "(defmethod parse 'throw\n  [op env [_ throw :as form] name _]\n  (let [throw-expr (disallowing-recur (analyze (assoc env :context :expr) throw))]\n    {:env env :op :throw :form form\n     :throw throw-expr\n     :children [throw-expr]}))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [592 597]},
                              :extra-sources ({:code "(defmethod emit* :throw\n  [{:keys [throw env]}]\n  (if (= :expr (:context env))\n    (emits \"(function(){throw \" throw \"})()\")\n    (emitln \"throw \" throw \";\")))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [404 408]}),
                              :full-name "cljs.core/throw",
                              :full-name-encode "cljs.core/throw",
                              :name-encode "throw",
                              :history [["+" "0.0-927"]]},
           "cljs.core/PersistentQueue.EMPTY" {:ns "cljs.core",
                                              :name "PersistentQueue.EMPTY",
                                              :name-encode "PersistentQueueDOTEMPTY",
                                              :parent-type "PersistentQueue",
                                              :type "var",
                                              :full-name-encode "cljs.core/PersistentQueueDOTEMPTY",
                                              :source {:code "(set! (.-EMPTY PersistentQueue) (PersistentQueue. nil 0 nil [] empty-ordered-hash))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [4973]},
                                              :full-name "cljs.core/PersistentQueue.EMPTY",
                                              :history [["+"
                                                         "0.0-927"]]},
           "cljs.core/unchecked-float" {:return-type number,
                                        :ns "cljs.core",
                                        :name "unchecked-float",
                                        :signature ["[x]"],
                                        :name-encode "unchecked-float",
                                        :history [["+" "0.0-1798"]],
                                        :type "function/macro",
                                        :full-name-encode "cljs.core/unchecked-float",
                                        :source {:code "(defn ^number unchecked-float [x] x)",
                                                 :title "Function code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [1952]},
                                        :extra-sources [{:code "(defmacro unchecked-float [x] x)",
                                                         :title "Macro code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/clj/cljs/core.clj",
                                                         :lines [369]}],
                                        :full-name "cljs.core/unchecked-float"},
           "clojure.core.reducers/append!" {:ns "clojure.core.reducers",
                                            :name "append!",
                                            :signature ["[acc x]"],
                                            :name-encode "appendBANG",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/appendBANG",
                                            :source {:code "(defn append!\n  [acc x]\n  (doto acc (.push x)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [232 235]},
                                            :full-name "clojure.core.reducers/append!",
                                            :docstring ".adds x to acc and returns acc"},
           "syntax/js-literal" {:syntax-equiv {:edn-url nil,
                                               :clj-url nil},
                                :ns "syntax",
                                :name "js-literal",
                                :name-encode "js-literal",
                                :type "tagged literal",
                                :full-name-encode "syntax/js-literal",
                                :extra-sources ({:code "(defn read-js\n  [form]\n  (when-not (or (vector? form) (map? form))\n    (throw (RuntimeException. \"JavaScript literal must use map or vector notation\")))\n  (when-not (or (not (map? form))\n                (every? valid-js-literal-key? (keys form)))\n    (throw (RuntimeException. \"JavaScript literal keys must be strings or unqualified keywords\")))\n  (JSValue. form))",
                                                 :title "Reader code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/tagged_literals.clj",
                                                 :lines [35 42]}
                                                {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                 :title "Reader table",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/tagged_literals.clj",
                                                 :lines [44 48]}),
                                :full-name "syntax/js-literal",
                                :history [["+" "0.0-2120"]]},
           "cljs.core/NodeSeq" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "NodeSeq",
                                :signature ["[meta nodes i s __hash]"],
                                :name-encode "NodeSeq",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/NodeSeq",
                                :source {:code "(deftype NodeSeq [meta nodes i s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IWithMeta\n  (-with-meta [coll meta] (NodeSeq. meta nodes i s __hash))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  ISeq\n  (-first [coll]\n    (if (nil? s)\n      [(aget nodes i) (aget nodes (inc i))]\n      (first s)))\n\n  (-rest [coll]\n    (if (nil? s)\n      (create-inode-seq nodes (+ i 2) nil)\n      (create-inode-seq nodes i (next s))))\n\n  ISeqable\n  (-seq [this] this)\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6084 6126]},
                                :full-name "cljs.core/NodeSeq"},
           "cljs.core/letfn" {:ns "cljs.core",
                              :name "letfn",
                              :signature ["[fnspecs & body]"],
                              :name-encode "letfn",
                              :history [["+" "0.0-927"]],
                              :type "macro",
                              :full-name-encode "cljs.core/letfn",
                              :source {:code "(defmacro letfn \n  [fnspecs & body] \n  `(letfn* ~(vec (interleave (map first fnspecs) \n                             (map #(cons `fn %) fnspecs)))\n           ~@body))",
                                       :title "Source code",
                                       :repo "clojure",
                                       :tag "clojure-1.6.0",
                                       :filename "src/clj/clojure/core.clj",
                                       :lines [6033 6044]},
                              :full-name "cljs.core/letfn",
                              :docstring "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\nTakes a vector of function specs and a body, and generates a set of\nbindings of functions to their names. All of the names are available\nin all of the definitions of the functions, as well as the body."},
           "cljs.core/recur" {:ns "cljs.core",
                              :name "recur",
                              :type "special form",
                              :source {:code "(defmethod parse 'recur\n  [op env [_ & exprs :as form] _ _]\n  (let [context (:context env)\n        frame (first *recur-frames*)\n        exprs (disallowing-recur (vec (map #(analyze (assoc env :context :expr) %) exprs)))]\n    (when-not frame \n      (throw (error env \"Can't recur here\")))\n    (when-not (= (count exprs) (count (:params frame))) \n      (throw (error env \"recur argument count mismatch\")))\n    (reset! (:flag frame) true)\n    (assoc {:env env :op :recur :form form}\n      :frame frame\n      :exprs exprs\n      :children exprs)))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [988 1001]},
                              :extra-sources ({:code "(defmethod emit* :recur\n  [{:keys [frame exprs env]}]\n  (let [temps (vec (take (count exprs) (repeatedly gensym)))\n        params (:params frame)]\n    (dotimes [i (count exprs)]\n      (emitln \"var \" (temps i) \" = \" (exprs i) \";\"))\n    (dotimes [i (count exprs)]\n      (emitln (munge (params i)) \" = \" (temps i) \";\"))\n    (emitln \"continue;\")))",
                                               :title "Emitting code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/compiler.clj",
                                               :lines [691 699]}),
                              :full-name "cljs.core/recur",
                              :full-name-encode "cljs.core/recur",
                              :name-encode "recur",
                              :history [["+" "0.0-927"]]},
           "cljs.reader/read-discard" {:ns "cljs.reader",
                                       :name "read-discard",
                                       :signature ["[rdr _]"],
                                       :name-encode "read-discard",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-discard",
                                       :source {:code "(defn read-discard\n  [rdr _]\n  (read rdr true nil true)\n  rdr)",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [389 392]},
                                       :full-name "cljs.reader/read-discard",
                                       :history [["+" "0.0-927"]]},
           "cljs.repl.server/read-headers" {:ns "cljs.repl.server",
                                            :name "read-headers",
                                            :signature ["[rdr]"],
                                            :name-encode "read-headers",
                                            :type "function",
                                            :full-name-encode "cljs.repl.server/read-headers",
                                            :source {:code "(defn read-headers [rdr]\n  (loop [next-line (.readLine rdr) header-lines []]\n    (if (= \"\" next-line)\n      header-lines ;; we're done reading headers\n      (recur\n        (.readLine rdr)\n        (conj header-lines next-line)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/server.clj",
                                                     :lines [70 76]},
                                            :full-name "cljs.repl.server/read-headers",
                                            :history [["+" "0.0-1503"]]},
           "cljs.core/gen-apply-to" {:ns "cljs.core",
                                     :name "gen-apply-to",
                                     :signature ["[]"],
                                     :name-encode "gen-apply-to",
                                     :type "macro",
                                     :full-name-encode "cljs.core/gen-apply-to",
                                     :source {:code "(defmacro gen-apply-to []\n  `(do\n     (set! ~'*unchecked-if* true)\n     (defn ~'apply-to [~'f ~'argc ~'args]\n       (let [~'args (seq ~'args)]\n         (if (zero? ~'argc)\n           (~'f)\n           ~(gen-apply-to-helper))))\n     (set! ~'*unchecked-if* false)))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1638 1646]},
                                     :full-name "cljs.core/gen-apply-to",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/inc" {:ns "cljs.core",
                            :name "inc",
                            :signature ["[x]"],
                            :name-encode "inc",
                            :history [["+" "0.0-927"]],
                            :type "function/macro",
                            :full-name-encode "cljs.core/inc",
                            :source {:code "(defn inc\n  [x] (cljs.core/+ x 1))",
                                     :title "Function code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [884 886]},
                            :extra-sources [{:code "(defmacro ^::ana/numeric inc [x]\n  `(+ ~x 1))",
                                             :title "Macro code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [463 464]}],
                            :full-name "cljs.core/inc",
                            :docstring "Returns a number one greater than num."},
           "cljs.core/name" {:ns "cljs.core",
                             :name "name",
                             :signature ["[x]"],
                             :name-encode "name",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/name",
                             :source {:code "(defn name\n  [x]\n  (if (implements? INamed x)\n    (-name ^not-native x)\n    (if (string? x)\n      x\n      (throw (js/Error. (str \"Doesn't support name: \" x))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [7663 7670]},
                             :full-name "cljs.core/name",
                             :docstring "Returns the name String of a string, symbol or keyword."},
           "cljs.core/cycle" {:ns "cljs.core",
                              :name "cycle",
                              :signature ["[coll]"],
                              :name-encode "cycle",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/cycle",
                              :source {:code "(defn cycle\n  [coll] (lazy-seq\n          (when-let [s (seq coll)]\n            (concat s (cycle s)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [3866 3870]},
                              :full-name "cljs.core/cycle",
                              :docstring "Returns a lazy (infinite!) sequence of repetitions of the items in coll."},
           "warnings/unprovided" {:ns "warnings",
                                  :name "unprovided",
                                  :type "warning",
                                  :full-name "warnings/unprovided",
                                  :full-name-encode "warnings/unprovided",
                                  :name-encode "unprovided",
                                  :history [["+" "0.0-2173"]]},
           "cljs.core/rsubseq" {:ns "cljs.core",
                                :name "rsubseq",
                                :signature ["[sc test key]"
                                            "[sc start-test start-key end-test end-key]"],
                                :name-encode "rsubseq",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/rsubseq",
                                :source {:code "(defn rsubseq\n  ([sc test key]\n     (let [include (mk-bound-fn sc test key)]\n       (if (#{< <=} test)\n         (when-let [[e :as s] (-sorted-seq-from sc key false)]\n           (if (include e) s (next s)))\n         (take-while include (-sorted-seq sc false)))))\n  ([sc start-test start-key end-test end-key]\n     (when-let [[e :as s] (-sorted-seq-from sc end-key false)]\n       (take-while (mk-bound-fn sc start-test start-key)\n                   (if ((mk-bound-fn sc end-test end-key) e) s (next s))))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [7780 7793]},
                                :full-name "cljs.core/rsubseq",
                                :docstring "sc must be a sorted collection, test(s) one of <, <=, > or\n>=. Returns a reverse seq of those entries with keys ek for\nwhich (test (.. sc comparator (compare ek key)) 0) is true"},
           "cljs.core/divide" {:ns "cljs.core",
                               :name "divide",
                               :signature ["[x]"
                                           "[x y]"
                                           "[x y & more]"],
                               :name-encode "divide",
                               :type "macro",
                               :full-name-encode "cljs.core/divide",
                               :source {:code "(defmacro ^::ana/numeric divide\n  ([x] `(/ 1 ~x))\n  ([x y] (core/list 'js* \"(~{} / ~{})\" x y))\n  ([x y & more] `(/ (/ ~x ~y) ~@more)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/clj/cljs/core.clj",
                                        :lines [430 433]},
                               :full-name "cljs.core/divide",
                               :history [["+" "0.0-1798"]]},
           "cljs.core/hash-ordered-coll" {:return-type number,
                                          :ns "cljs.core",
                                          :name "hash-ordered-coll",
                                          :signature ["[coll]"],
                                          :name-encode "hash-ordered-coll",
                                          :history [["+" "0.0-2261"]],
                                          :type "function",
                                          :full-name-encode "cljs.core/hash-ordered-coll",
                                          :source {:code "(defn ^number hash-ordered-coll\n  [coll]\n  (loop [n 0 hash-code 1 coll (seq coll)]\n    (if-not (nil? coll)\n      (recur (inc n) (bit-or (+ (imul 31 hash-code) (hash (first coll))) 0)\n        (next coll))\n      (mix-collection-hash hash-code n))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [821 830]},
                                          :full-name "cljs.core/hash-ordered-coll",
                                          :docstring "Returns the hash code, consistent with =, for an external ordered\ncollection implementing Iterable.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "cljs.core/nil-iter" {:ns "cljs.core",
                                 :name "nil-iter",
                                 :signature ["[]"],
                                 :name-encode "nil-iter",
                                 :type "function",
                                 :full-name-encode "cljs.core/nil-iter",
                                 :source {:code "(defn nil-iter []\n  (reify\n    Object\n    (hasNext [_] false)\n    (next [_] (js/Error. \"No such element\"))\n    (remove [_] (js/Error. \"Unsupported operation\"))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3058 3063]},
                                 :full-name "cljs.core/nil-iter",
                                 :history [["+" "0.0-2301"]]},
           "cljs.analyzer.api/all-ns" {:ns "cljs.analyzer.api",
                                       :name "all-ns",
                                       :signature ["[]"],
                                       :name-encode "all-ns",
                                       :history [["+" "0.0-2496"]],
                                       :type "function",
                                       :full-name-encode "cljs.analyzer.api/all-ns",
                                       :source {:code "(defn all-ns\n  []\n  (keys (get @env/*compiler* ::ana/namespaces)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/analyzer/api.clj",
                                                :lines [24 28]},
                                       :full-name "cljs.analyzer.api/all-ns",
                                       :docstring "Return all the namespace analysis maps. Analagous to clojure.core/all-ns but\nreturns analysis maps not Namespace instances."},
           "cljs.core/fn*" {:ns "cljs.core",
                            :name "fn*",
                            :type "special form",
                            :source {:code "(defmethod parse 'fn*\n  [op env [_ & args :as form] name _]\n  (analyze-wrap-meta\n   (let [[name meths] (if (symbol? (first args))\n                        [(first args) (next args)]\n                        [name (seq args)])\n         ;;turn (fn [] ...) into (fn ([]...))\n         meths (if (vector? (first meths)) (list meths) meths)\n         locals (:locals env)\n         name-var (if name\n                    (merge\n                     {:name name\n                      :info {:shadow (or (locals name)\n                                         (get-in env [:js-globals name]))}}\n                     (when-let [tag (-> name meta :tag)]\n                       {:ret-tag tag})))\n         locals (if (and locals name) (assoc locals name name-var) locals)\n         type (-> form meta ::type)\n         protocol-impl (-> form meta ::protocol-impl)\n         protocol-inline (-> form meta ::protocol-inline)\n         menv (if (> (count meths) 1) (assoc env :context :expr) env)\n         menv (merge menv\n                     {:protocol-impl protocol-impl\n                      :protocol-inline protocol-inline})\n         methods (map #(analyze-fn-method menv locals % type) meths)\n         max-fixed-arity (apply max (map :max-fixed-arity methods))\n         variadic (boolean (some :variadic methods))\n         locals (if name\n                  (update-in locals [name] assoc\n                             ;; TODO: can we simplify? - David\n                             :fn-var true\n                             :variadic variadic\n                             :max-fixed-arity max-fixed-arity\n                             :method-params (map :params methods)\n                             :methods methods)\n                  locals)\n         methods (if name\n                   ;; a second pass with knowledge of our function-ness/arity\n                   ;; lets us optimize self calls\n                   (no-warn (doall (map #(analyze-fn-method menv locals % type) meths)))\n                   methods)\n         form (vary-meta form dissoc ::protocol-impl ::protocol-inline ::type)]\n     (let [variadic-methods (filter :variadic methods)\n           variadic-params (count (:params (first variadic-methods)))\n           param-counts (map (comp count :params) methods)]\n       (when (< 1 (count variadic-methods))\n         (warning :multiple-variadic-overloads env {:name name-var}))\n       (when (not (or (zero? variadic-params) (= variadic-params (+ 1 max-fixed-arity))))\n         (warning :variadic-max-arity env {:name name-var}))\n       (when (not= (distinct param-counts) param-counts)\n         (warning :overload-arity env {:name name-var})))\n     {:env env :op :fn :form form :name name-var :methods methods :variadic variadic\n      :tag 'function\n      :recur-frames *recur-frames* :loop-lets *loop-lets*\n      :jsdoc [(when variadic \"@param {...*} var_args\")]\n      :max-fixed-arity max-fixed-arity\n      :protocol-impl protocol-impl\n      :protocol-inline protocol-inline\n      :children (mapv :expr methods)})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [806 864]},
                            :extra-sources ({:code "(defmethod emit* :fn\n  [{:keys [name env methods max-fixed-arity variadic recur-frames loop-lets]}]\n  ;;fn statements get erased, serve no purpose and can pollute scope if named\n  (when-not (= :statement (:context env))\n    (let [loop-locals (->> (concat (mapcat :params (filter #(and % @(:flag %)) recur-frames))\n                                   (mapcat :params loop-lets))\n                           (map munge)\n                           seq)]\n      (when loop-locals\n        (when (= :return (:context env))\n            (emits \"return \"))\n        (emitln \"((function (\" (comma-sep (map munge loop-locals)) \"){\")\n        (when-not (= :return (:context env))\n            (emits \"return \")))\n      (if (= 1 (count methods))\n        (if variadic\n          (emit-variadic-fn-method (assoc (first methods) :name name))\n          (emit-fn-method (assoc (first methods) :name name)))\n        (let [name (or name (gensym))\n              mname (munge name)\n              maxparams (apply max-key count (map :params methods))\n              mmap (into {}\n                     (map (fn [method]\n                            [(munge (symbol (str mname \"__\" (count (:params method)))))\n                             method])\n                          methods))\n              ms (sort-by #(-> % second :params count) (seq mmap))]\n          (when (= :return (:context env))\n            (emits \"return \"))\n          (emitln \"(function() {\")\n          (emitln \"var \" mname \" = null;\")\n          (doseq [[n meth] ms]\n            (emits \"var \" n \" = \")\n            (if (:variadic meth)\n              (emit-variadic-fn-method meth)\n              (emit-fn-method meth))\n            (emitln \";\"))\n            (emitln mname \" = function(\" (comma-sep (if variadic\n                                                      (concat (butlast maxparams) ['var_args])\n                                                      maxparams)) \"){\")\n          (when variadic\n            (emits \"var \")\n            (emit (last maxparams))\n            (emitln \" = var_args;\"))\n          (emitln \"switch(arguments.length){\")\n          (doseq [[n meth] ms]\n            (if (:variadic meth)\n              (do (emitln \"default:\")\n                  (let [restarg (munge (gensym))]\n                    (emitln \"var \" restarg \" = null;\")\n                    (emitln \"if (arguments.length > \" max-fixed-arity \") {\")\n                    (let [a (emit-arguments-to-array max-fixed-arity)]\n                      (emitln restarg \" = new cljs.core.IndexedSeq(\" a \",0);\"))\n                    (emitln \"}\")\n                    (emitln \"return \" n \".cljs$core$IFn$_invoke$arity$variadic(\"\n                            (comma-sep (butlast maxparams))\n                            (when (> (count maxparams) 1) \", \")\n                            restarg \");\")))\n              (let [pcnt (count (:params meth))]\n                (emitln \"case \" pcnt \":\")\n                (emitln \"return \" n \".call(this\" (if (zero? pcnt) nil\n                                                     (list \",\" (comma-sep (take pcnt maxparams)))) \");\"))))\n          (emitln \"}\")\n          (emitln \"throw(new Error('Invalid arity: ' + arguments.length));\")\n          (emitln \"};\")\n          (when variadic\n            (emitln mname \".cljs$lang$maxFixedArity = \" max-fixed-arity \";\")\n            (emitln mname \".cljs$lang$applyTo = \" (some #(let [[n m] %] (when (:variadic m) n)) ms) \".cljs$lang$applyTo;\"))\n          (doseq [[n meth] ms]\n            (let [c (count (:params meth))]\n              (if (:variadic meth)\n                (emitln mname \".cljs$core$IFn$_invoke$arity$variadic = \" n \".cljs$core$IFn$_invoke$arity$variadic;\")\n                (emitln mname \".cljs$core$IFn$_invoke$arity$\" c \" = \" n \";\"))))\n          (emitln \"return \" mname \";\")\n          (emitln \"})()\")))\n      (when loop-locals\n        (emitln \";})(\" (comma-sep loop-locals) \"))\")))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [562 638]}),
                            :full-name "cljs.core/fn*",
                            :full-name-encode "cljs.core/fnSTAR",
                            :name-encode "fnSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.test/run-all-tests" {:ns "cljs.test",
                                      :name "run-all-tests",
                                      :signature ["[]" "[re]"],
                                      :name-encode "run-all-tests",
                                      :history [["+" "0.0-2496"]],
                                      :type "macro",
                                      :full-name-encode "cljs.test/run-all-tests",
                                      :source {:code "(defmacro run-all-tests\n  ([] `(cljs.test/run-all-tests nil))\n  ([re]\n   `(cljs.test/run-tests (cljs.test/empty-env)\n      ~@(map\n          (fn [ns] `(quote ~ns))\n          (cond->> (ana-api/all-ns)\n            re (filter #(re-matches re (name %))))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/test.clj",
                                               :lines [265 276]},
                                      :full-name "cljs.test/run-all-tests",
                                      :docstring "Runs all tests in all namespaces; prints results.\nOptional argument is a regular expression; only namespaces with\nnames matching the regular expression (with re-matches) will be\ntested."},
           "cljs.core/map" {:ns "cljs.core",
                            :name "map",
                            :signature ["[f]"
                                        "[f coll]"
                                        "[f c1 c2]"
                                        "[f c1 c2 c3]"
                                        "[f c1 c2 c3 & colls]"],
                            :name-encode "map",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/map",
                            :source {:code "(defn map\n  ([f]\n    (fn [rf]\n      (fn\n        ([] (rf))\n        ([result] (rf result))\n        ([result input]\n           (rf result (f input)))\n        ([result input & inputs]\n           (rf result (apply f input inputs))))))\n  ([f coll]\n   (lazy-seq\n    (when-let [s (seq coll)]\n      (if (chunked-seq? s)\n        (let [c (chunk-first s)\n              size (count c)\n              b (chunk-buffer size)]\n          (dotimes [i size]\n              (chunk-append b (f (-nth c i))))\n          (chunk-cons (chunk b) (map f (chunk-rest s))))\n        (cons (f (first s)) (map f (rest s)))))))\n  ([f c1 c2]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2)]\n      (when (and s1 s2)\n        (cons (f (first s1) (first s2))\n              (map f (rest s1) (rest s2)))))))\n  ([f c1 c2 c3]\n   (lazy-seq\n    (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]\n      (when (and  s1 s2 s3)\n        (cons (f (first s1) (first s2) (first s3))\n              (map f (rest s1) (rest s2) (rest s3)))))))\n  ([f c1 c2 c3 & colls]\n   (let [step (fn step [cs]\n                 (lazy-seq\n                  (let [ss (map seq cs)]\n                    (when (every? identity ss)\n                      (cons (map first ss) (step (map rest ss)))))))]\n     (map #(apply f %) (step (conj colls c3 c2 c1))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [3732 3777]},
                            :full-name "cljs.core/map",
                            :docstring "Returns a lazy sequence consisting of the result of applying f to\nthe set of first items of each coll, followed by applying f to the\nset of second items in each coll, until any one of the colls is\nexhausted.  Any remaining items in other colls are ignored. Function\nf should accept number-of-colls arguments. Returns a transducer when\nno collection is provided."},
           "cljs.core/ChunkBuffer" {:protocols #{"ICounted"},
                                    :ns "cljs.core",
                                    :name "ChunkBuffer",
                                    :signature ["[buf end]"],
                                    :name-encode "ChunkBuffer",
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkBuffer",
                                    :source {:code "(deftype ChunkBuffer [^:mutable buf ^:mutable end]\n  Object\n  (add [_ o]\n    (aset buf end o)\n    (set! end (inc end)))\n\n  (chunk [_ o]\n    (let [ret (ArrayChunk. buf 0 end)]\n      (set! buf nil)\n      ret))\n\n  ICounted\n  (-count [_] end))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2619 2631]},
                                    :full-name "cljs.core/ChunkBuffer"},
           "cljs.repl/repl-read" {:ns "cljs.repl",
                                  :name "repl-read",
                                  :signature ["[request-prompt request-exit]"],
                                  :name-encode "repl-read",
                                  :history [["+" "0.0-2719"]],
                                  :type "function",
                                  :full-name-encode "cljs.repl/repl-read",
                                  :source {:code "(defn repl-read\n  [request-prompt request-exit]\n  (or ({:line-start request-prompt :stream-end request-exit}\n        (skip-whitespace *in*))\n    (let [input (read)]\n      (skip-if-eol *in*)\n      input)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/repl.clj",
                                           :lines [62 78]},
                                  :full-name "cljs.repl/repl-read",
                                  :docstring "Default :read hook for repl. Reads from *in* which must either be an\ninstance of LineNumberingPushbackReader or duplicate its behavior of both\nsupporting .unread and collapsing all of CR, LF, and CRLF into a single\n\\newline. repl-read:\n  - skips whitespace, then\n    - returns request-prompt on start of line, or\n    - returns request-exit on end of stream, or\n    - reads an object from the input stream, then\n      - skips the next input character if it's end of line, then\n      - returns the object."},
           "syntax/list" {:syntax-equiv {:edn-url nil, :clj-url nil},
                          :ns "syntax",
                          :name "list",
                          :name-encode "list",
                          :type "syntax",
                          :full-name-encode "syntax/list",
                          :extra-sources ({:code "(defn- read-list\n  [rdr _]\n  (let [[start-line start-column] (when (indexing-reader? rdr)\n                                    [(get-line-number rdr) (int (dec (get-column-number rdr)))])\n        the-list (read-delimited \\) rdr true)\n        [end-line end-column] (when (indexing-reader? rdr)\n                                [(get-line-number rdr) (int (get-column-number rdr))])]\n    (with-meta (if (empty? the-list)\n                 '()\n                 (clojure.lang.PersistentList/create the-list))\n      (when start-line\n        (merge\n         (when-let [file (get-file-name rdr)]\n           {:file file})\n         {:line start-line\n          :column start-column\n          :end-line end-line\n          :end-column end-column})))))",
                                           :title "Reader code",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [169 186]}
                                          {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                           :title "Reader table",
                                           :repo "tools.reader",
                                           :tag "tools.reader-0.8.10",
                                           :filename "src/main/clojure/clojure/tools/reader.clj",
                                           :lines [591 610]}),
                          :full-name "syntax/list",
                          :history [["+" "0.0-1853"]]},
           "cljs.core/amap" {:ns "cljs.core",
                             :name "amap",
                             :signature ["[a idx ret expr]"],
                             :name-encode "amap",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/amap",
                             :source {:code "(defmacro amap\n  [a idx ret expr]\n  `(let [a# ~a\n         ~ret (aclone a#)]\n     (loop  [~idx 0]\n       (if (< ~idx  (alength a#))\n         (do\n           (aset ~ret ~idx ~expr)\n           (recur (inc ~idx)))\n         ~ret))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1496 1509]},
                             :full-name "cljs.core/amap",
                             :docstring "Maps an expression across an array a, using an index named idx, and\nreturn value named ret, initialized to a clone of a, then setting\neach element of ret to the evaluation of expr, returning the new\narray ret."},
           "syntax/uuid-literal" {:syntax-equiv {:edn-url nil,
                                                 :clj-url nil},
                                  :ns "syntax",
                                  :name "uuid-literal",
                                  :name-encode "uuid-literal",
                                  :type "tagged literal",
                                  :full-name-encode "syntax/uuid-literal",
                                  :extra-sources ({:code "(defn read-uuid\n  [form]\n  (when-not (string? form)\n    (throw (RuntimeException. \"UUID literal expects a string as its representation.\")))\n  (try\n    (java.util.UUID/fromString form)\n    (catch Throwable e\n      (throw (RuntimeException. (.getMessage e))))))",
                                                   :title "Reader code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [10 17]}
                                                  {:code "(def ^:dynamic *cljs-data-readers*\n  {'queue read-queue\n   'uuid  read-uuid\n   'inst  read-inst\n   'js    read-js})",
                                                   :title "Reader table",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/tagged_literals.clj",
                                                   :lines [44 48]}),
                                  :full-name "syntax/uuid-literal",
                                  :history [["+" "0.0-1424"]]},
           "clojure.zip/children" {:ns "clojure.zip",
                                   :name "children",
                                   :signature ["[loc]"],
                                   :name-encode "children",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "clojure.zip/children",
                                   :source {:code "(defn children\n  [loc]\n    (if (branch? loc)\n      ((:zip/children (meta loc)) (node loc))\n      (throw \"called children on a leaf node\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/clojure/zip.cljs",
                                            :lines [69 74]},
                                   :full-name "clojure.zip/children",
                                   :docstring "Returns a seq of the children of node at loc, which must be a branch"},
           "cljs.core/when-not" {:ns "cljs.core",
                                 :name "when-not",
                                 :signature ["[test & body]"],
                                 :name-encode "when-not",
                                 :history [["+" "0.0-927"]],
                                 :type "macro",
                                 :full-name-encode "cljs.core/when-not",
                                 :source {:code "(defmacro when-not\n  [test & body]\n    (list 'if test nil (cons 'do body)))",
                                          :title "Source code",
                                          :repo "clojure",
                                          :tag "clojure-1.6.0",
                                          :filename "src/clj/clojure/core.clj",
                                          :lines [477 481]},
                                 :full-name "cljs.core/when-not",
                                 :docstring "Evaluates test. If logical false, evaluates body in an implicit do."},
           "clojure.set/index" {:ns "clojure.set",
                                :name "index",
                                :signature ["[xrel ks]"],
                                :name-encode "index",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/index",
                                :source {:code "(defn index\n  [xrel ks]\n    (reduce\n     (fn [m x]\n       (let [ik (select-keys x ks)]\n         (assoc m ik (conj (get m ik #{}) x))))\n     {} xrel))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [87 95]},
                                :full-name "clojure.set/index",
                                :docstring "Returns a map of the distinct values of ks in the xrel mapped to a\nset of the maps in xrel with the corresponding values of ks."},
           "cljs.repl.browser/send-and-close" {:ns "cljs.repl.browser",
                                               :name "send-and-close",
                                               :signature ["[conn status form]"
                                                           "[conn status form content-type]"],
                                               :name-encode "send-and-close",
                                               :history [["+"
                                                          "0.0-927"]
                                                         ["-"
                                                          "0.0-1503"]],
                                               :type "function",
                                               :full-name-encode "cljs.repl.browser/send-and-close",
                                               :source {:code "(defn send-and-close\n  ([conn status form]\n     (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n     (let [utf-8-form (.getBytes form \"UTF-8\")\n           content-length (count utf-8-form)\n           headers (map #(.getBytes (str % \"\\r\\n\"))\n                        [(status-line status)\n                         \"Server: ClojureScript REPL\"\n                         (str \"Content-Type: \"\n                              content-type\n                              \"; charset=utf-8\")\n                         (str \"Content-Length: \" content-length)\n                         \"\"])]\n       (with-open [os (.getOutputStream conn)]\n         (do (doseq [header headers]\n               (.write os header 0 (count header)))\n             (.write os utf-8-form 0 content-length)\n             (.flush os)\n             (.close conn))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r1450",
                                                        :filename "src/clj/cljs/repl/browser.clj",
                                                        :lines [69 90]},
                                               :full-name "cljs.repl.browser/send-and-close",
                                               :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response.",
                                               :removed {:in "0.0-1503",
                                                         :last-seen "0.0-1450"}},
           "cljs.core/chunked-seq?" {:return-type boolean,
                                     :ns "cljs.core",
                                     :name "chunked-seq?",
                                     :signature ["[x]"],
                                     :name-encode "chunked-seqQMARK",
                                     :history [["+" "0.0-1424"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/chunked-seqQMARK",
                                     :source {:code "(defn ^boolean chunked-seq?\n  [x] (implements? IChunkedSeq x))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [1543 1544]},
                                     :full-name "cljs.core/chunked-seq?"},
           "clojure.browser.dom/log" {:ns "clojure.browser.dom",
                                      :name "log",
                                      :signature ["[& args]"],
                                      :name-encode "log",
                                      :type "function",
                                      :full-name-encode "clojure.browser.dom/log",
                                      :source {:code "(defn log [& args]\n  (.log js/console (apply pr-str args)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/clojure/browser/dom.cljs",
                                               :lines [20 21]},
                                      :full-name "clojure.browser.dom/log",
                                      :history [["+" "0.0-927"]]},
           "cljs.core/Vector.fromArray" {:ns "cljs.core",
                                         :name "Vector.fromArray",
                                         :signature ["[xs]"],
                                         :name-encode "VectorDOTfromArray",
                                         :history [["+" "0.0-927"]
                                                   ["-" "0.0-1798"]],
                                         :parent-type "Vector",
                                         :type "function",
                                         :full-name-encode "cljs.core/VectorDOTfromArray",
                                         :source {:code "(set! cljs.core.Vector/fromArray (fn [xs] (Vector. nil xs nil)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r1586",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [2861]},
                                         :full-name "cljs.core/Vector.fromArray",
                                         :removed {:in "0.0-1798",
                                                   :last-seen "0.0-1586"}},
           "cljs.core/make-array" {:return-type array,
                                   :ns "cljs.core",
                                   :name "make-array",
                                   :signature ["[size]" "[type size]"],
                                   :name-encode "make-array",
                                   :history [["+" "0.0-1211"]],
                                   :type "function/macro",
                                   :full-name-encode "cljs.core/make-array",
                                   :source {:code "(defn ^array make-array\n  ([size]\n     (js/Array. size))\n  ([type size]\n     (make-array size)))",
                                            :title "Function code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [163 167]},
                                   :extra-sources [{:code "(defmacro make-array\n  [size]\n  (vary-meta\n    (if (core/number? size)\n      `(array ~@(take size (repeat nil)))\n      `(js/Array. ~size))\n    assoc :tag 'array))",
                                                    :title "Macro code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/core.clj",
                                                    :lines [1406 1412]}],
                                   :full-name "cljs.core/make-array"},
           "cljs.core/sorted-set-by" {:ns "cljs.core",
                                      :name "sorted-set-by",
                                      :signature ["[comparator & keys]"],
                                      :name-encode "sorted-set-by",
                                      :history [["+" "0.0-1211"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/sorted-set-by",
                                      :source {:code "(defn sorted-set-by\n  ([comparator & keys]\n   (reduce -conj\n           (PersistentTreeSet. nil (sorted-map-by comparator) 0)\n           keys)))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7608 7613]},
                                      :full-name "cljs.core/sorted-set-by",
                                      :docstring "Returns a new sorted set with supplied keys, using the supplied comparator."},
           "cljs.repl.node/repl-env" {:ns "cljs.repl.node",
                                      :name "repl-env",
                                      :signature ["[& {:as options}]"],
                                      :name-encode "repl-env",
                                      :type "function",
                                      :full-name-encode "cljs.repl.node/repl-env",
                                      :source {:code "(defn repl-env\n  [& {:as options}]\n  (repl-env* options))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/clj/cljs/repl/node.clj",
                                               :lines [177 179]},
                                      :full-name "cljs.repl.node/repl-env",
                                      :history [["+" "0.0-2629"]]},
           "syntax/impure" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "impure",
                            :name-encode "impure",
                            :type "convention",
                            :full-name-encode "syntax/impure",
                            :full-name "syntax/impure",
                            :history [["+" "0.0-927"]]},
           "warnings/fn-deprecated" {:ns "warnings",
                                     :name "fn-deprecated",
                                     :type "warning",
                                     :full-name "warnings/fn-deprecated",
                                     :full-name-encode "warnings/fn-deprecated",
                                     :name-encode "fn-deprecated",
                                     :history [["+" "0.0-1835"]]},
           "cljs.core/partition-by" {:ns "cljs.core",
                                     :name "partition-by",
                                     :signature ["[f]" "[f coll]"],
                                     :name-encode "partition-by",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/partition-by",
                                     :source {:code "(defn partition-by\n  ([f]\n     (fn [rf]\n       (let [a (array-list)\n             pa (volatile! ::none)]\n         (fn\n           ([] (rf))\n           ([result]\n              (let [result (if (.isEmpty a)\n                             result\n                             (let [v (vec (.toArray a))]\n                               ;;clear first!\n                               (.clear a)\n                               (unreduced (rf result v))))]\n                (rf result)))\n           ([result input]\n              (let [pval @pa\n                    val (f input)]\n                (vreset! pa val)\n                (if (or (keyword-identical? pval ::none)\n                        (= val pval))\n                  (do\n                    (.add a input)\n                    result)\n                  (let [v (vec (.toArray a))]\n                    (.clear a)\n                    (let [ret (rf result v)]\n                      (when-not (reduced? ret)\n                        (.add a input))\n                      ret)))))))))\n  ([f coll]\n     (lazy-seq\n       (when-let [s (seq coll)]\n         (let [fst (first s)\n               fv (f fst)\n               run (cons fst (take-while #(= fv (f %)) (next s)))]\n           (cons run (partition-by f (seq (drop (count run) s)))))))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [7929 7968]},
                                     :full-name "cljs.core/partition-by",
                                     :docstring "Applies f to each value in coll, splitting it each time f returns a\nnew value.  Returns a lazy seq of partitions.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.repl/skip-if-eol" {:ns "cljs.repl",
                                    :name "skip-if-eol",
                                    :signature ["[s]"],
                                    :name-encode "skip-if-eol",
                                    :history [["+" "0.0-2719"]],
                                    :type "function",
                                    :full-name-encode "cljs.repl/skip-if-eol",
                                    :source {:code "(defn skip-if-eol\n  [s]\n  (let [c (.read s)]\n    (cond\n      (= c (int \\newline)) :line-start\n      (= c -1) :stream-end\n      :else (do (.unread s c) :body))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/repl.clj",
                                             :lines [30 42]},
                                    :full-name "cljs.repl/skip-if-eol",
                                    :docstring "If the next character on stream s is a newline, skips it, otherwise\nleaves the stream untouched. Returns :line-start, :stream-end, or :body\nto indicate the relative location of the next character on s. The stream\nmust either be an instance of LineNumberingPushbackReader or duplicate\nits behavior of both supporting .unread and collapsing all of CR, LF, and\nCRLF to a single \\newline."},
           "cljs.core/sort-by" {:ns "cljs.core",
                                :name "sort-by",
                                :signature ["[keyfn coll]"
                                            "[keyfn comp coll]"],
                                :name-encode "sort-by",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/sort-by",
                                :source {:code "(defn sort-by\n  ([keyfn coll]\n   (sort-by keyfn compare coll))\n  ([keyfn comp coll]\n     (sort (fn [x y] ((fn->comparator comp) (keyfn x) (keyfn y))) coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [1721 1729]},
                                :full-name "cljs.core/sort-by",
                                :docstring "Returns a sorted sequence of the items in coll, where the sort\norder is determined by comparing (keyfn item).  Comp can be\nboolean-valued comparison funcion, or a -/0/+ valued comparator.\nComp defaults to compare."},
           "cljs.core/with-meta" {:ns "cljs.core",
                                  :name "with-meta",
                                  :signature ["[o meta]"],
                                  :name-encode "with-meta",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/with-meta",
                                  :source {:code "(defn with-meta\n  [o meta]\n  (if (and (fn? o) (not (satisfies? IWithMeta o)))\n    (MetaFn. o meta)\n    (when-not (nil? o)\n      (-with-meta o meta))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1449 1456]},
                                  :full-name "cljs.core/with-meta",
                                  :docstring "Returns an object of the same type and value as obj, with\nmap m as its metadata."},
           "cljs.core/NeverEquiv" {:protocols #{"IEquiv"},
                                   :ns "cljs.core",
                                   :name "NeverEquiv",
                                   :signature ["[]"],
                                   :name-encode "NeverEquiv",
                                   :history [["+" "0.0-927"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/NeverEquiv",
                                   :source {:code "(deftype NeverEquiv []\n  Object\n  (equiv [this other]\n    (-equiv this other))\n  IEquiv\n  (-equiv [o other] false))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4977 4982]},
                                   :full-name "cljs.core/NeverEquiv"},
           "cljs.analyzer.api/in-cljs-user" {:ns "cljs.analyzer.api",
                                             :name "in-cljs-user",
                                             :signature ["[env & body]"],
                                             :name-encode "in-cljs-user",
                                             :history [["+"
                                                        "0.0-2629"]],
                                             :type "macro",
                                             :full-name-encode "cljs.analyzer.api/in-cljs-user",
                                             :source {:code "(defmacro in-cljs-user\n  [env & body]\n  `(binding [cljs.analyzer/*cljs-ns* 'cljs.user]\n     (cljs.env/with-compiler-env ~env\n       ~@body)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/clj/cljs/analyzer/api.clj",
                                                      :lines [51 57]},
                                             :full-name "cljs.analyzer.api/in-cljs-user",
                                             :docstring "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\nenvironment atom and runs body."},
           "cljs.core/select-keys" {:ns "cljs.core",
                                    :name "select-keys",
                                    :signature ["[map keyseq]"],
                                    :name-encode "select-keys",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/select-keys",
                                    :source {:code "(defn select-keys\n  [map keyseq]\n    (loop [ret {} keys (seq keyseq)]\n      (if keys\n        (let [key   (first keys)\n              entry (get map key ::not-found)]\n          (recur\n           (if (not= entry ::not-found)\n             (assoc ret key entry)\n             ret)\n           (next keys)))\n        (with-meta ret (meta map)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7333 7345]},
                                    :full-name "cljs.core/select-keys",
                                    :docstring "Returns a map containing only those entries in map whose key is in keys"},
           "cljs.core/ISeq" {:ns "cljs.core",
                             :name "ISeq",
                             :name-encode "ISeq",
                             :implementations #{"PersistentQueue"
                                                "PersistentArrayMapSeq"
                                                "EmptyList"
                                                "LazyTransformer"
                                                "ValSeq"
                                                "ChunkedCons"
                                                "Range"
                                                "PersistentQueueSeq"
                                                "ChunkedSeq"
                                                "ArrayNodeSeq"
                                                "KeySeq"
                                                "IndexedSeq"
                                                "PersistentTreeMapSeq"
                                                "ES6IteratorSeq"
                                                "RSeq"
                                                "NodeSeq"
                                                "List"
                                                "Cons"
                                                "LazySeq"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISeq",
                             :source {:code "(defprotocol ISeq\n  (-first [coll])\n  (^clj -rest [coll]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [275 277]},
                             :methods [{:name "-first",
                                        :signature ["[coll]"],
                                        :docstring nil}
                                       {:name "-rest",
                                        :signature ["[coll]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISeq"},
           "cljs.core/disj!" {:ns "cljs.core",
                              :name "disj!",
                              :signature ["[tcoll val]"
                                          "[tcoll val & vals]"],
                              :name-encode "disjBANG",
                              :history [["+" "0.0-1211"]],
                              :type "function",
                              :full-name-encode "cljs.core/disjBANG",
                              :source {:code "(defn disj!\n  ([tcoll val]\n    (-disjoin! tcoll val))\n  ([tcoll val & vals]\n    (let [ntcoll (-disjoin! tcoll val)]\n      (if vals\n        (recur ntcoll (first vals) (next vals))\n        ntcoll))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [2964 2973]},
                              :full-name "cljs.core/disj!",
                              :docstring "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\ndoes not contain key(s)."},
           "cljs.test/try-expr" {:ns "cljs.test",
                                 :name "try-expr",
                                 :signature ["[msg form]"],
                                 :name-encode "try-expr",
                                 :history [["+" "0.0-2496"]],
                                 :type "macro",
                                 :full-name-encode "cljs.test/try-expr",
                                 :source {:code "(defmacro try-expr\n  [msg form]\n  `(try\n     ~(cljs.test/assert-expr &env msg form)\n     (catch :default t#\n       (cljs.test/do-report \n         {:type :error, :message ~msg,\n          :expected '~form, :actual t#}))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/test.clj",
                                          :lines [135 144]},
                                 :full-name "cljs.test/try-expr",
                                 :docstring "Used by the 'is' macro to catch unexpected exceptions.\nYou don't call this."},
           "cljs.core/type->str" {:ns "cljs.core",
                                  :name "type->str",
                                  :signature ["[ty]"],
                                  :name-encode "type-GTstr",
                                  :type "function",
                                  :full-name-encode "cljs.core/type-GTstr",
                                  :source {:code "(defn type->str [ty]\n  (if-let [s (.-cljs$lang$ctorStr ty)]\n    s\n    (str ty)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [146 149]},
                                  :full-name "cljs.core/type->str",
                                  :history [["+" "0.0-1859"]]},
           "clojure.walk/postwalk-replace" {:ns "clojure.walk",
                                            :name "postwalk-replace",
                                            :signature ["[smap form]"],
                                            :name-encode "postwalk-replace",
                                            :history [["+" "0.0-927"]],
                                            :type "function",
                                            :full-name-encode "clojure.walk/postwalk-replace",
                                            :source {:code "(defn postwalk-replace\n  [smap form]\n  (postwalk (fn [x] (if (contains? smap x) (smap x) x)) form))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/walk.cljs",
                                                     :lines [88 94]},
                                            :full-name "clojure.walk/postwalk-replace",
                                            :docstring "Recursively transforms form by replacing keys in smap with their\nvalues.  Like clojure/replace but works on any data structure.  Does\nreplacement at the leaves of the tree first."},
           "cljs.core/ES6SetEntriesIterator" {:ns "cljs.core",
                                              :name "ES6SetEntriesIterator",
                                              :signature ["[s]"],
                                              :name-encode "ES6SetEntriesIterator",
                                              :type "type",
                                              :full-name-encode "cljs.core/ES6SetEntriesIterator",
                                              :source {:code "(deftype ES6SetEntriesIterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value #js [x x] :done false})\n      #js {:value nil :done true})))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [5170
                                                               5177]},
                                              :full-name "cljs.core/ES6SetEntriesIterator",
                                              :history [["+"
                                                         "0.0-2371"]]},
           "cljs.core/pr-with-opts" {:ns "cljs.core",
                                     :name "pr-with-opts",
                                     :signature ["[objs opts]"],
                                     :name-encode "pr-with-opts",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1503"]],
                                     :type "function",
                                     :full-name-encode "cljs.core/pr-with-opts",
                                     :source {:code "(defn pr-with-opts\n  [objs opts]\n  (doseq [string (pr-seq (first objs) opts)]\n    (string-print string))\n  (doseq [obj (next objs)]\n    (string-print \" \")\n    (doseq [string (pr-seq obj opts)]\n      (string-print string))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1450",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [6171 6180]},
                                     :full-name "cljs.core/pr-with-opts",
                                     :docstring "Prints a sequence of objects using string-print, observing all\nthe options given in opts",
                                     :removed {:in "0.0-1503",
                                               :last-seen "0.0-1450"}},
           "cljs.core/->>" {:ns "cljs.core",
                            :name "->>",
                            :signature ["[x & forms]"],
                            :name-encode "-GTGT",
                            :history [["+" "0.0-927"]],
                            :type "macro",
                            :full-name-encode "cljs.core/-GTGT",
                            :source {:code "(defmacro ->>\n  [x & forms]\n  (loop [x x, forms forms]\n    (if forms\n      (let [form (first forms)\n            threaded (if (seq? form)\n              (with-meta `(~(first form) ~@(next form)  ~x) (meta form))\n              (list form x))]\n        (recur threaded (next forms)))\n      x)))",
                                     :title "Source code",
                                     :repo "clojure",
                                     :tag "clojure-1.6.0",
                                     :filename "src/clj/clojure/core.clj",
                                     :lines [1574 1588]},
                            :full-name "cljs.core/->>",
                            :docstring "Threads the expr through the forms. Inserts x as the\nlast item in the first form, making a list of it if it is not a\nlist already. If there are more forms, inserts the first form as the\nlast item in second form, etc."},
           "cljs.core/defonce" {:ns "cljs.core",
                                :name "defonce",
                                :signature ["[x init]"],
                                :name-encode "defonce",
                                :type "macro",
                                :full-name-encode "cljs.core/defonce",
                                :source {:code "(defmacro defonce [x init]\n  `(when-not (exists? ~x)\n     (def ~x ~init)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/core.clj",
                                         :lines [70 72]},
                                :full-name "cljs.core/defonce",
                                :history [["+" "0.0-2156"]]},
           "cljs.core/nil?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "nil?",
                             :signature ["[x]"],
                             :name-encode "nilQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/nilQMARK",
                             :source {:code "(defn ^boolean nil?\n  [x]\n  (coercive-= x nil))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [85 88]},
                             :extra-sources [{:code "(defmacro nil? [x]\n  `(coercive-= ~x nil))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [258 259]}],
                             :full-name "cljs.core/nil?",
                             :docstring "Returns true if x is nil, false otherwise."},
           "cljs.repl.rhino/bootjs" {:return-type String,
                                     :ns "cljs.repl.rhino",
                                     :name "bootjs",
                                     :name-encode "bootjs",
                                     :type "var",
                                     :full-name-encode "cljs.repl.rhino/bootjs",
                                     :source {:code "(def ^String bootjs\n  (str \"var global = this;\"\n       \"goog.require = function(rule){\"\n       \"Packages.clojure.lang.RT[\\\"var\\\"](\\\"cljs.repl.rhino\\\",\\\"goog-require\\\")\"\n       \".invoke(___repl_env, __repl_opts, rule);}\"))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/repl/rhino.clj",
                                              :lines [20 24]},
                                     :full-name "cljs.repl.rhino/bootjs",
                                     :history [["+" "0.0-927"]]},
           "cljs.core/load-file*" {:ns "cljs.core",
                                   :name "load-file*",
                                   :signature ["[f]"],
                                   :name-encode "load-fileSTAR",
                                   :type "macro",
                                   :full-name-encode "cljs.core/load-fileSTAR",
                                   :source {:code "(defmacro load-file* [f]\n  (core/let [{:keys [target output-dir]} (:options @env/*compiler*)]\n    (core/condp = target\n      ;; under Node.js, always relative to JVM working directory\n      :nodejs `(. js/goog (~'nodeGlobalRequire (str ~output-dir ~File/separator ~f)))\n      `(. js/goog (~'importScript_ ~f)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1694 1699]},
                                   :full-name "cljs.core/load-file*",
                                   :history [["+" "0.0-2719"]]},
           "cljs.core/load-namespace" {:ns "cljs.core",
                                       :name "load-namespace",
                                       :name-encode "load-namespace",
                                       :type "special form (repl)",
                                       :full-name-encode "cljs.core/load-namespace",
                                       :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n         (when-not (and (= quote 'quote) (symbol? ns-name))\n           (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n         (when-not (ana/get-namespace ns-name)\n           (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n           (-evaluate repl-env \"<cljs repl>\" 1\n             (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n         (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require-macros\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n         (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))}))",
                                                :title "repl specials table",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [275 336]},
                                       :full-name "cljs.core/load-namespace",
                                       :repl-only? true,
                                       :history [["+" "0.0-927"]]},
           "clojure.walk/stringify-keys" {:ns "clojure.walk",
                                          :name "stringify-keys",
                                          :signature ["[m]"],
                                          :name-encode "stringify-keys",
                                          :history [["+" "0.0-927"]],
                                          :type "function",
                                          :full-name-encode "clojure.walk/stringify-keys",
                                          :source {:code "(defn stringify-keys\n  [m]\n  (let [f (fn [[k v]] (if (keyword? k) [(name k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/clojure/walk.cljs",
                                                   :lines [72 78]},
                                          :full-name "clojure.walk/stringify-keys",
                                          :docstring "Recursively transforms all map keys from keywords to strings."},
           "clojure.browser.repl/order" {:ns "clojure.browser.repl",
                                         :name "order",
                                         :name-encode "order",
                                         :type "var",
                                         :full-name-encode "clojure.browser.repl/order",
                                         :source {:code "(def order (atom 0))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/clojure/browser/repl.cljs",
                                                  :lines [55]},
                                         :full-name "clojure.browser.repl/order",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/memoize" {:ns "cljs.core",
                                :name "memoize",
                                :signature ["[f]"],
                                :name-encode "memoize",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/memoize",
                                :source {:code "(defn memoize\n  [f]\n  (let [mem (atom {})]\n    (fn [& args]\n      (let [v (get @mem args lookup-sentinel)]\n        (if (identical? v lookup-sentinel)\n          (let [ret (apply f args)]\n            (swap! mem assoc args ret)\n            ret)\n          v)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [8692 8705]},
                                :full-name "cljs.core/memoize",
                                :docstring "Returns a memoized version of a referentially transparent function. The\nmemoized version of the function keeps a cache of the mapping from arguments\nto results and, when calls with the same arguments are repeated often, has\nhigher performance at the expense of higher memory use."},
           "warnings/undeclared" {:ns "warnings",
                                  :name "undeclared",
                                  :type "warning",
                                  :full-name "warnings/undeclared",
                                  :full-name-encode "warnings/undeclared",
                                  :name-encode "undeclared",
                                  :history [["+" "0.0-1835"]
                                            ["-" "0.0-2014"]],
                                  :removed {:in "0.0-2014",
                                            :last-seen "0.0-1978"}},
           "cljs.core/pr-sequential" {:ns "cljs.core",
                                      :name "pr-sequential",
                                      :signature ["[print-one begin sep end opts coll]"],
                                      :name-encode "pr-sequential",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/pr-sequential",
                                      :source {:code "(defn ^:deprecated pr-sequential\n  [print-one begin sep end opts coll]\n  (concat [begin]\n          (flatten1\n            (interpose [sep] (map #(print-one % opts) coll)))\n          [end]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [6210 6217]},
                                      :full-name "cljs.core/pr-sequential",
                                      :docstring "Do not use this.  It is kept for backwards compatibility with the\nold IPrintable protocol.",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "warnings/undeclared-ns" {:ns "warnings",
                                     :name "undeclared-ns",
                                     :type "warning",
                                     :full-name "warnings/undeclared-ns",
                                     :full-name-encode "warnings/undeclared-ns",
                                     :name-encode "undeclared-ns",
                                     :history [["+" "0.0-2014"]]},
           "clojure.zip/make-node" {:ns "clojure.zip",
                                    :name "make-node",
                                    :signature ["[loc node children]"],
                                    :name-encode "make-node",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "clojure.zip/make-node",
                                    :source {:code "(defn make-node\n  [loc node children]\n    ((:zip/make-node (meta loc)) node children))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/clojure/zip.cljs",
                                             :lines [76 80]},
                                    :full-name "clojure.zip/make-node",
                                    :docstring "Returns a new branch node, given an existing node and new\nchildren. The loc is only used to supply the constructor."},
           "syntax/deref" {:syntax-equiv {:edn-url nil, :clj-url nil},
                           :ns "syntax",
                           :name "deref",
                           :name-encode "deref",
                           :type "syntax",
                           :full-name-encode "syntax/deref",
                           :extra-sources ({:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                            :title "Reader table",
                                            :repo "tools.reader",
                                            :tag "tools.reader-0.8.10",
                                            :filename "src/main/clojure/clojure/tools/reader.clj",
                                            :lines [591 610]}),
                           :full-name "syntax/deref",
                           :history [["+" "0.0-1853"]]},
           "cljs.core/PersistentVector.EMPTY" {:ns "cljs.core",
                                               :name "PersistentVector.EMPTY",
                                               :name-encode "PersistentVectorDOTEMPTY",
                                               :parent-type "PersistentVector",
                                               :type "var",
                                               :full-name-encode "cljs.core/PersistentVectorDOTEMPTY",
                                               :source {:code "(set! (.-EMPTY PersistentVector)\n  (PersistentVector. nil 0 5 (.-EMPTY-NODE PersistentVector) (array) empty-ordered-hash))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/core.cljs",
                                                        :lines [4456
                                                                4457]},
                                               :full-name "cljs.core/PersistentVector.EMPTY",
                                               :history [["+"
                                                          "0.0-1006"]]},
           "cljs.reader/float-pattern" {:ns "cljs.reader",
                                        :name "float-pattern",
                                        :name-encode "float-pattern",
                                        :type "var",
                                        :full-name-encode "cljs.reader/float-pattern",
                                        :source {:code "(def float-pattern (re-pattern \"^([-+]?[0-9]+(\\\\.[0-9]*)?([eE][-+]?[0-9]+)?)(M)?$\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/reader.cljs",
                                                 :lines [100]},
                                        :full-name "cljs.reader/float-pattern",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/ancestors" {:ns "cljs.core",
                                  :name "ancestors",
                                  :signature ["[tag]" "[h tag]"],
                                  :name-encode "ancestors",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/ancestors",
                                  :source {:code "(defn ancestors\n  ([tag] (ancestors @(get-global-hierarchy) tag))\n  ([h tag] (not-empty (get (:ancestors h) tag))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8794 8800]},
                                  :full-name "cljs.core/ancestors",
                                  :docstring "Returns the immediate and indirect parents of tag, either via a JavaScript type\ninheritance relationship or a relationship established via derive. h\nmust be a hierarchy obtained from make-hierarchy, if not supplied\ndefaults to the global hierarchy"},
           "cljs.core/integer?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "integer?",
                                 :signature ["[n]"],
                                 :name-encode "integerQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/integerQMARK",
                                 :source {:code "(defn ^boolean integer?\n  [n]\n  (and (number? n)\n       (not ^boolean (js/isNaN n))\n       (not (identical? n js/Infinity))\n       (== (js/parseFloat n) (js/parseInt n 10))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1610 1616]},
                                 :full-name "cljs.core/integer?",
                                 :docstring "Returns true if n is an integer."},
           "compiler-options/cache-analysis" {:ns "compiler-options",
                                              :name "cache-analysis",
                                              :name-encode "cache-analysis",
                                              :type "option",
                                              :full-name-encode "compiler-options/cache-analysis",
                                              :full-name "compiler-options/cache-analysis",
                                              :history [["+"
                                                         "0.0-2511"]]},
           "cljs.core/HashMap.EMPTY" {:ns "cljs.core",
                                      :name "HashMap.EMPTY",
                                      :name-encode "HashMapDOTEMPTY",
                                      :history [["+" "0.0-927"]
                                                ["-" "0.0-1798"]],
                                      :parent-type "HashMap",
                                      :type "var",
                                      :full-name-encode "cljs.core/HashMapDOTEMPTY",
                                      :source {:code "(set! cljs.core.HashMap/EMPTY (HashMap. nil 0 (js-obj) 0))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r1586",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [3830]},
                                      :full-name "cljs.core/HashMap.EMPTY",
                                      :removed {:in "0.0-1798",
                                                :last-seen "0.0-1586"}},
           "cljs.core/Vector.EMPTY" {:ns "cljs.core",
                                     :name "Vector.EMPTY",
                                     :name-encode "VectorDOTEMPTY",
                                     :history [["+" "0.0-927"]
                                               ["-" "0.0-1798"]],
                                     :parent-type "Vector",
                                     :type "var",
                                     :full-name-encode "cljs.core/VectorDOTEMPTY",
                                     :source {:code "(set! cljs.core.Vector/EMPTY (Vector. nil (array) 0))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r1586",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2859]},
                                     :full-name "cljs.core/Vector.EMPTY",
                                     :removed {:in "0.0-1798",
                                               :last-seen "0.0-1586"}},
           "clojure.zip/xml-zip" {:ns "clojure.zip",
                                  :name "xml-zip",
                                  :signature ["[root]"],
                                  :name-encode "xml-zip",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "clojure.zip/xml-zip",
                                  :source {:code "(defn xml-zip\n  [root]\n    (zipper (complement string?) \n            (comp seq :content)\n            (fn [node children]\n              (assoc node :content (and children (apply vector children))))\n            root))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/clojure/zip.cljs",
                                           :lines [50 58]},
                                  :full-name "clojure.zip/xml-zip",
                                  :docstring "Returns a zipper for xml elements (as from xml/parse),\ngiven a root element"},
           "clojure.walk/walk" {:ns "clojure.walk",
                                :name "walk",
                                :signature ["[inner outer form]"],
                                :name-encode "walk",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.walk/walk",
                                :source {:code "(defn walk\n  [inner outer form]\n  (cond\n   (seq? form) (outer (doall (map inner form)))\n   (coll? form) (outer (into (empty form) (map inner form)))\n   :else (outer form)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/walk.cljs",
                                         :lines [37 48]},
                                :full-name "clojure.walk/walk",
                                :docstring "Traverses form, an arbitrary data structure.  inner and outer are\nfunctions.  Applies inner to each element of form, building up a\ndata structure of the same type, then applies outer to the result.\nRecognizes all Clojure data structures. Consumes seqs as with doall."},
           "cljs.core/ifn?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "ifn?",
                             :signature ["[f]"],
                             :name-encode "ifnQMARK",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/ifnQMARK",
                             :source {:code "(defn ^boolean ifn? [f]\n  (or (fn? f) (satisfies? IFn f)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1607 1608]},
                             :full-name "cljs.core/ifn?"},
           "cljs.core/bit-xor" {:ns "cljs.core",
                                :name "bit-xor",
                                :signature ["[x y]" "[x y & more]"],
                                :name-encode "bit-xor",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/bit-xor",
                                :source {:code "(defn bit-xor\n  ([x y] (cljs.core/bit-xor x y))\n  ([x y & more]\n     (reduce bit-xor (cljs.core/bit-xor x y) more)))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2083 2087]},
                                :extra-sources [{:code "(defmacro ^::ana/numeric bit-xor\n  ([x y] (core/list 'js* \"(~{} ^ ~{})\" x y))\n  ([x y & more] `(bit-xor (bit-xor ~x ~y) ~@more)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [509 511]}],
                                :full-name "cljs.core/bit-xor",
                                :docstring "Bitwise exclusive or"},
           "clojure.set/union" {:ns "clojure.set",
                                :name "union",
                                :signature ["[]"
                                            "[s1]"
                                            "[s1 s2]"
                                            "[s1 s2 & sets]"],
                                :name-encode "union",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "clojure.set/union",
                                :source {:code "(defn union\n  ([] #{})\n  ([s1] s1)\n  ([s1 s2]\n     (if (< (count s1) (count s2))\n       (reduce conj s2 s1)\n       (reduce conj s1 s2)))\n  ([s1 s2 & sets]\n     (let [bubbled-sets (bubble-max-key count (conj sets s2 s1))]\n       (reduce into (first bubbled-sets) (rest bubbled-sets)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/set.cljs",
                                         :lines [19 29]},
                                :full-name "clojure.set/union",
                                :docstring "Return a set that is the union of the input sets"},
           "cljs.core/case" {:ns "cljs.core",
                             :name "case",
                             :signature ["[e & clauses]"],
                             :name-encode "case",
                             :type "macro",
                             :full-name-encode "cljs.core/case",
                             :source {:code "(defmacro case [e & clauses]\n  (core/let [default (if (odd? (count clauses))\n                       (last clauses)\n                       `(throw\n                          (js/Error.\n                            (core/str \"No matching clause: \" ~e))))\n             env     &env\n             pairs   (reduce\n                       (fn [m [test expr]]\n                         (core/cond\n                           (seq? test)\n                           (reduce\n                             (fn [m test]\n                               (let [test (if (core/symbol? test)\n                                            (core/list 'quote test)\n                                            test)]\n                                 (assoc-test m test expr env)))\n                             m test)\n                           (core/symbol? test)\n                           (assoc-test m (core/list 'quote test) expr env)\n                           :else\n                           (assoc-test m test expr env)))\n                     {} (partition 2 clauses))\n             esym    (gensym)\n             tests   (keys pairs)]\n    (cond\n      (every? (some-fn core/number? core/string? core/char?) tests)\n      (core/let [no-default (if (odd? (count clauses)) (butlast clauses) clauses)\n                 tests      (mapv #(if (seq? %) (vec %) [%]) (take-nth 2 no-default))\n                 thens      (vec (take-nth 2 (drop 1 no-default)))]\n        `(let [~esym ~e] (case* ~esym ~tests ~thens ~default)))\n\n      (every? core/keyword? tests)\n      (let [tests (->> tests\n                       (map #(.substring (core/str %) 1))\n                       vec\n                       (mapv #(if (seq? %) (vec %) [%])))\n            thens (vec (vals pairs))]\n        `(let [~esym (if (keyword? ~e) (.-fqn ~e) nil)]\n           (case* ~esym ~tests ~thens ~default)))\n      \n      ;; equality\n      :else\n      `(let [~esym ~e]\n         (cond\n           ~@(mapcat (fn [[m c]] `((cljs.core/= ~m ~esym) ~c)) pairs)\n           :else ~default)))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/clj/cljs/core.clj",
                                      :lines [1192 1238]},
                             :full-name "cljs.core/case",
                             :history [["+" "0.0-1211"]]},
           "cljs.repl/IJavaScriptEnv" {:ns "cljs.repl",
                                       :name "IJavaScriptEnv",
                                       :name-encode "IJavaScriptEnv",
                                       :type "protocol",
                                       :full-name-encode "cljs.repl/IJavaScriptEnv",
                                       :source {:code "(defprotocol IJavaScriptEnv\n  (-setup [this opts] \"initialize the environment\")\n  (-evaluate [this filename line js] \"evaluate a javascript string\")\n  (-load [this provides url] \"load code at url into the environment\")\n  (-tear-down [this] \"dispose of the environment\"))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl.clj",
                                                :lines [93 97]},
                                       :methods [{:name "-setup",
                                                  :signature ["[this opts]"],
                                                  :docstring "initialize the environment"}
                                                 {:name "-evaluate",
                                                  :signature ["[this filename line js]"],
                                                  :docstring "evaluate a javascript string"}
                                                 {:name "-load",
                                                  :signature ["[this provides url]"],
                                                  :docstring "load code at url into the environment"}
                                                 {:name "-tear-down",
                                                  :signature ["[this]"],
                                                  :docstring "dispose of the environment"}],
                                       :full-name "cljs.repl/IJavaScriptEnv",
                                       :history [["+" "0.0-927"]]},
           "cljs.reader/PushbackReader" {:ns "cljs.reader",
                                         :name "PushbackReader",
                                         :name-encode "PushbackReader",
                                         :type "protocol",
                                         :full-name-encode "cljs.reader/PushbackReader",
                                         :source {:code "(defprotocol PushbackReader\n  (read-char [reader] \"Returns the next char from the Reader,\nnil if the end of stream has been reached\")\n  (unread [reader ch] \"Push back a single character on to the stream\"))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/reader.cljs",
                                                  :lines [13 16]},
                                         :methods [{:name "read-char",
                                                    :signature ["[reader]"],
                                                    :docstring "Returns the next char from the Reader,\nnil if the end of stream has been reached"}
                                                   {:name "unread",
                                                    :signature ["[reader ch]"],
                                                    :docstring "Push back a single character on to the stream"}],
                                         :full-name "cljs.reader/PushbackReader",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/isa?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "isa?",
                             :signature ["[child parent]"
                                         "[h child parent]"],
                             :name-encode "isaQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/isaQMARK",
                             :source {:code "(defn ^boolean isa?\n  ([child parent] (isa? @(get-global-hierarchy) child parent))\n  ([h child parent]\n     (or (= child parent)\n         ;; (and (class? parent) (class? child)\n         ;;    (. ^Class parent isAssignableFrom child))\n         (contains? ((:ancestors h) child) parent)\n         ;;(and (class? child) (some #(contains? ((:ancestors h) %) parent) (supers child)))\n         (and (vector? parent) (vector? child)\n              (== (count parent) (count child))\n              (loop [ret true i 0]\n                (if (or (not ret) (== i (count parent)))\n                  ret\n                  (recur (isa? h (child i) (parent i)) (inc i))))))))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [8766 8784]},
                             :full-name "cljs.core/isa?",
                             :docstring "Returns true if (= child parent), or child is directly or indirectly derived from\nparent, either via a JavaScript type inheritance relationship or a\nrelationship established via derive. h must be a hierarchy obtained\nfrom make-hierarchy, if not supplied defaults to the global\nhierarchy"},
           "cljs.pprint/PrettyFlush" {:ns "cljs.pprint",
                                      :name "PrettyFlush",
                                      :name-encode "PrettyFlush",
                                      :type "protocol",
                                      :full-name-encode "cljs.pprint/PrettyFlush",
                                      :source {:code "(defprotocol PrettyFlush (ppflush [this]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/pprint.cljs",
                                               :lines [120]},
                                      :methods [{:name "ppflush",
                                                 :signature ["[this]"],
                                                 :docstring nil}],
                                      :full-name "cljs.pprint/PrettyFlush",
                                      :history [["+" "0.0-2496"]]},
           "clojure.browser.net/xhr-connection" {:ns "clojure.browser.net",
                                                 :name "xhr-connection",
                                                 :signature ["[]"],
                                                 :name-encode "xhr-connection",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.net/xhr-connection",
                                                 :source {:code "(defn xhr-connection\n  []\n  (XhrIo.))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/clojure/browser/net.cljs",
                                                          :lines [81
                                                                  84]},
                                                 :full-name "clojure.browser.net/xhr-connection",
                                                 :docstring "Returns an XhrIo connection"},
           "cljs.core/as->" {:ns "cljs.core",
                             :name "as->",
                             :signature ["[expr name & forms]"],
                             :name-encode "as-GT",
                             :history [["+" "0.0-1798"]],
                             :type "macro",
                             :full-name-encode "cljs.core/as-GT",
                             :source {:code "(defmacro as->\n  [expr name & forms]\n  `(let [~name ~expr\n         ~@(interleave (repeat name) forms)]\n     ~name))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [6913 6921]},
                             :full-name "cljs.core/as->",
                             :docstring "Binds name to expr, evaluates the first form in the lexical context\nof that binding, then binds name to that result, repeating for each\nsuccessive form, returning the result of the last form."},
           "clojure.core.reducers/reducer" {:ns "clojure.core.reducers",
                                            :name "reducer",
                                            :signature ["[coll xf]"],
                                            :name-encode "reducer",
                                            :history [["+" "0.0-1236"]],
                                            :type "function",
                                            :full-name-encode "clojure.core.reducers/reducer",
                                            :source {:code "(defn reducer\n  ([coll xf]\n     (reify\n       cljs.core/IReduce\n       (-reduce [this f1]\n         (-reduce this f1 (f1)))\n       (-reduce [_ f1 init]\n         (-reduce coll (xf f1) init)))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/clojure/core/reducers.cljs",
                                                     :lines [66 77]},
                                            :full-name "clojure.core.reducers/reducer",
                                            :docstring "Given a reducible collection, and a transformation function xf,\nreturns a reducible collection, where any supplied reducing\nfn will be transformed by xf. xf is a function of reducing fn to\nreducing fn."},
           "warnings/protocol-invalid-method" {:ns "warnings",
                                               :name "protocol-invalid-method",
                                               :type "warning",
                                               :full-name "warnings/protocol-invalid-method",
                                               :full-name-encode "warnings/protocol-invalid-method",
                                               :name-encode "protocol-invalid-method",
                                               :history [["+"
                                                          "0.0-2341"]]},
           "cljs.core/subs" {:ns "cljs.core",
                             :name "subs",
                             :signature ["[s start]" "[s start end]"],
                             :name-encode "subs",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/subs",
                             :source {:code "(defn subs\n  ([s start] (.substring s start))\n  ([s start end] (.substring s start end)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2204 2208]},
                             :full-name "cljs.core/subs",
                             :docstring "Returns the substring of s beginning at start inclusive, and ending\nat end (defaults to length of string), exclusive."},
           "syntax/unquote" {:syntax-equiv {:edn-url nil,
                                            :clj-url nil},
                             :ns "syntax",
                             :name "unquote",
                             :name-encode "unquote",
                             :type "syntax",
                             :full-name-encode "syntax/unquote",
                             :extra-sources ({:code "(defn- read-unquote\n  [rdr comma]\n  (if-let [ch (peek-char rdr)]\n    (if (identical? \\@ ch)\n      ((wrapping-reader 'clojure.core/unquote-splicing) (doto rdr read-char) \\@)\n      ((wrapping-reader 'clojure.core/unquote) rdr \\~))))",
                                              :title "Reader code",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [447 452]}
                                             {:code "(defn- macros [ch]\n  (case ch\n    \\\" read-string*\n    \\: read-keyword\n    \\; read-comment\n    \\' (wrapping-reader 'quote)\n    \\@ (wrapping-reader 'clojure.core/deref)\n    \\^ read-meta\n    \\` read-syntax-quote ;;(wrapping-reader 'syntax-quote)\n    \\~ read-unquote\n    \\( read-list\n    \\) read-unmatched-delimiter\n    \\[ read-vector\n    \\] read-unmatched-delimiter\n    \\{ read-map\n    \\} read-unmatched-delimiter\n    \\\\ read-char*\n    \\% read-arg\n    \\# read-dispatch\n    nil))",
                                              :title "Reader table",
                                              :repo "tools.reader",
                                              :tag "tools.reader-0.8.10",
                                              :filename "src/main/clojure/clojure/tools/reader.clj",
                                              :lines [591 610]}),
                             :full-name "syntax/unquote",
                             :history [["+" "0.0-1853"]]},
           "cljs.core/symbol?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "symbol?",
                                :signature ["[x]"],
                                :name-encode "symbolQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/symbolQMARK",
                                :source {:code "(defn ^boolean symbol? [x]\n  (instance? Symbol x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [572 573]},
                                :extra-sources [{:code "(defmacro symbol? [x]\n  (bool-expr `(instance? Symbol ~x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [334 335]}],
                                :full-name "cljs.core/symbol?"},
           "compiler-options/language-in" {:ns "compiler-options",
                                           :name "language-in",
                                           :name-encode "language-in",
                                           :type "option",
                                           :full-name-encode "compiler-options/language-in",
                                           :full-name "compiler-options/language-in",
                                           :history [["+" "0.0-2197"]]},
           "clojure.data/Diff" {:ns "clojure.data",
                                :name "Diff",
                                :name-encode "Diff",
                                :history [["+" "0.0-1503"]],
                                :type "protocol",
                                :full-name-encode "clojure.data/Diff",
                                :source {:code "(defprotocol Diff\n  \"Implementation detail. Subject to change.\"\n  (diff-similar [a b] \"Implementation detail. Subject to change.\"))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/data.cljs",
                                         :lines [79 81]},
                                :methods [{:name "diff-similar",
                                           :signature ["[a b]"],
                                           :docstring "Implementation detail. Subject to change."}],
                                :full-name "clojure.data/Diff",
                                :docstring "Implementation detail. Subject to change."},
           "clojure.string/replace" {:ns "clojure.string",
                                     :name "replace",
                                     :signature ["[s match replacement]"],
                                     :name-encode "replace",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.string/replace",
                                     :source {:code "(defn replace\n  [s match replacement]\n  (cond (string? match)\n        (.replace s (js/RegExp. (gstring/regExpEscape match) \"g\") replacement)\n        (.hasOwnProperty match \"source\")\n        (.replace s (js/RegExp. (.-source match) \"g\") replacement)\n        :else (throw (str \"Invalid match arg: \" match))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/string.cljs",
                                              :lines [27 38]},
                                     :full-name "clojure.string/replace",
                                     :docstring "Replaces all instance of match with replacement in s.\nmatch/replacement can be:\n\nstring / string\npattern / (string or function of match)."},
           "cljs.core/string?" {:return-type boolean,
                                :ns "cljs.core",
                                :name "string?",
                                :signature ["[x]"],
                                :name-encode "stringQMARK",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/stringQMARK",
                                :source {:code "(defn ^boolean string? [x]\n  (goog/isString x))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [109 110]},
                                :extra-sources [{:code "(defmacro string? [x]\n  (bool-expr (core/list 'js* \"typeof ~{} === 'string'\" x)))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [307 308]}],
                                :full-name "cljs.core/string?"},
           "cljs.core/partition-all" {:ns "cljs.core",
                                      :name "partition-all",
                                      :signature ["[n]"
                                                  "[n coll]"
                                                  "[n step coll]"],
                                      :name-encode "partition-all",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "cljs.core/partition-all",
                                      :source {:code "(defn partition-all\n  ([n]\n   (fn [rf]\n     (let [a (array-list)]\n       (fn\n         ([] (rf))\n         ([result]\n            (let [result (if (.isEmpty a)\n                           result\n                           (let [v (vec (.toArray a))]\n                             ;;clear first!\n                             (.clear a)\n                             (unreduced (rf result v))))]\n              (rf result)))\n         ([result input]\n            (.add a input)\n            (if (== n (.size a))\n              (let [v (vec (.toArray a))]\n                (.clear a)\n                (rf result v))\n              result))))))\n  ([n coll]\n     (partition-all n n coll))\n  ([n step coll]\n     (lazy-seq\n      (when-let [s (seq coll)]\n        (cons (take n s) (partition-all n step (drop step s)))))))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [7709 7738]},
                                      :full-name "cljs.core/partition-all",
                                      :docstring "Returns a lazy sequence of lists like partition, but may include\npartitions with fewer than n items at the end.  Returns a stateful\ntransducer when no collection is provided."},
           "cljs.core/Var" {:protocols #{"IFn"
                                         "IMeta"
                                         "IDeref"
                                         "Fn"
                                         "IPrintWithWriter"},
                            :ns "cljs.core",
                            :name "Var",
                            :signature ["[val sym _meta]"],
                            :name-encode "Var",
                            :history [["+" "0.0-2496"]],
                            :type "type",
                            :full-name-encode "cljs.core/Var",
                            :source {:code "(deftype Var [val sym _meta]\n  IDeref\n  (-deref [_] (val))\n  IMeta\n  (-meta [_] _meta)\n  Fn\n  IFn\n  (-invoke [_]\n    ((val)))\n  (-invoke [_ a]\n    ((val) a))\n  (-invoke [_ a b]\n    ((val) a b))\n  (-invoke [_ a b c]\n    ((val) a b c))\n  (-invoke [_ a b c d]\n    ((val) a b c d))\n  (-invoke [_ a b c d e]\n    ((val) a b c d e))\n  (-invoke [_ a b c d e f]\n    ((val) a b c d e f))\n  (-invoke [_ a b c d e f g]\n    ((val) a b c d e f g))\n  (-invoke [_ a b c d e f g h]\n    ((val) a b c d e f g h))\n  (-invoke [_ a b c d e f g h i]\n    ((val) a b c d e f g h i))\n  (-invoke [_ a b c d e f g h i j]\n    ((val) a b c d e f g h i j))\n  (-invoke [_ a b c d e f g h i j k]\n    ((val) a b c d e f g h i j k))\n  (-invoke [_ a b c d e f g h i j k l]\n    ((val) a b c d e f g h i j k l))\n  (-invoke [_ a b c d e f g h i j k l m]\n    ((val) a b c d e f g h i j k l m))\n  (-invoke [_ a b c d e f g h i j k l m n]\n    ((val) a b c d e f g h i j k l m n))\n  (-invoke [_ a b c d e f g h i j k l m n o]\n    ((val) a b c d e f g h i j k l m n o))\n  (-invoke [_ a b c d e f g h i j k l m n o p]\n    ((val) a b c d e f g h i j k l m n o p))\n  (-invoke [_ a b c d e f g h i j k l m n o p q]\n    ((val) a b c d e f g h i j k l m n o p q))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r]\n    ((val) a b c d e f g h i j k l m n o p q r))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s]\n    ((val) a b c d e f g h i j k l m n o p q r s))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t]\n    ((val) a b c d e f g h i j k l m n o p q r s t))\n  (-invoke [_ a b c d e f g h i j k l m n o p q r s t rest]\n    (apply (val) a b c d e f g h i j k l m n o p q r s t rest)))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [637 687]},
                            :full-name "cljs.core/Var"},
           "cljs.core/RedNode" {:protocols #{"IFn"
                                             "ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IStack"
                                             "IEmptyableCollection"
                                             "ICounted"
                                             "IReduce"
                                             "ILookup"
                                             "ISequential"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "IIndexed"
                                             "IAssociative"
                                             "IVector"
                                             "IEquiv"
                                             "IMapEntry"},
                                :ns "cljs.core",
                                :name "RedNode",
                                :signature ["[key val left right __hash]"],
                                :name-encode "RedNode",
                                :history [["+" "0.0-1211"]],
                                :type "type",
                                :full-name-encode "cljs.core/RedNode",
                                :source {:code "(deftype RedNode [key val left right ^:mutable __hash]\n  Object\n  (add-left [node ins]\n    (RedNode. key val ins right nil))\n\n  (add-right [node ins]\n    (RedNode. key val left ins nil))\n\n  (remove-left [node del]\n    (RedNode. key val del right nil))\n\n  (remove-right [node del]\n    (RedNode. key val left del nil))\n\n  (blacken [node]\n    (BlackNode. key val left right nil))\n\n  (redden [node]\n    (throw (js/Error. \"red-black tree invariant violation\")))\n\n  (balance-left [node parent]\n    (cond\n      (instance? RedNode left)\n      (RedNode. key val\n                (.blacken left)\n                (BlackNode. (.-key parent) (.-val parent) right (.-right parent) nil)\n                nil)\n\n      (instance? RedNode right)\n      (RedNode. (.-key right) (.-val right)\n                (BlackNode. key val left (.-left right) nil)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-right right)\n                            (.-right parent)\n                            nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) node (.-right parent) nil)))\n\n  (balance-right [node parent]\n    (cond\n      (instance? RedNode right)\n      (RedNode. key val\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            left\n                            nil)\n                (.blacken right)\n                nil)\n\n      (instance? RedNode left)\n      (RedNode. (.-key left) (.-val left)\n                (BlackNode. (.-key parent) (.-val parent)\n                            (.-left parent)\n                            (.-left left)\n                            nil)\n                (BlackNode. key val (.-right left) right nil)\n                nil)\n\n      :else\n      (BlackNode. (.-key parent) (.-val parent) (.-left parent) node nil)))\n\n  (replace [node key val left right]\n    (RedNode. key val left right nil))\n\n  (kv-reduce [node f init]\n    (tree-map-kv-reduce node f init))\n\n  IMapEntry\n  (-key [node] key)\n  (-val [node] val)\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IMeta\n  (-meta [node] nil)\n\n  IWithMeta\n  (-with-meta [node meta]\n    (with-meta [key val] meta))\n\n  IStack\n  (-peek [node] val)\n\n  (-pop [node] [key])\n\n  ICollection\n  (-conj [node o] [key val o])\n\n  IEmptyableCollection\n  (-empty [node] [])\n\n  ISequential\n  ISeqable\n  (-seq [node] (list key val))\n\n  ICounted\n  (-count [node] 2)\n\n  IIndexed\n  (-nth [node n]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    nil))\n\n  (-nth [node n not-found]\n    (cond (== n 0) key\n          (== n 1) val\n          :else    not-found))\n\n  ILookup\n  (-lookup [node k] (-nth node k nil))\n  (-lookup [node k not-found] (-nth node k not-found))\n\n  IAssociative\n  (-assoc [node k v]\n    (assoc [key val] k v))\n\n  IVector\n  (-assoc-n [node n v]\n    (-assoc-n [key val] n v))\n\n  IReduce\n  (-reduce [node f]\n    (ci-reduce node f))\n\n  (-reduce [node f start]\n    (ci-reduce node f start))\n\n  IFn\n  (-invoke [node k]\n    (-lookup node k))\n\n  (-invoke [node k not-found]\n    (-lookup node k not-found)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [6726 6865]},
                                :full-name "cljs.core/RedNode"},
           "cljs.core/ExceptionInfo" {:ns "cljs.core",
                                      :name "ExceptionInfo",
                                      :signature ["[message data cause]"],
                                      :name-encode "ExceptionInfo",
                                      :type "type",
                                      :full-name-encode "cljs.core/ExceptionInfo",
                                      :source {:code "(deftype ExceptionInfo [message data cause])",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/cljs/core.cljs",
                                               :lines [9166]},
                                      :full-name "cljs.core/ExceptionInfo",
                                      :history [["+" "0.0-1576"]]},
           "cljs.core/merge-with" {:ns "cljs.core",
                                   :name "merge-with",
                                   :signature ["[f & maps]"],
                                   :name-encode "merge-with",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/merge-with",
                                   :source {:code "(defn merge-with\n  [f & maps]\n  (when (some identity maps)\n    (let [merge-entry (fn [m e]\n                        (let [k (first e) v (second e)]\n                          (if (contains? m k)\n                            (assoc m k (f (get m k) v))\n                            (assoc m k v))))\n          merge2 (fn [m1 m2]\n                   (reduce merge-entry (or m1 {}) (seq m2)))]\n      (reduce merge2 maps))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7317 7331]},
                                   :full-name "cljs.core/merge-with",
                                   :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping(s)\nfrom the latter (left-to-right) will be combined with the mapping in\nthe result by calling (f val-in-result val-in-latter)."},
           "cljs.core/key" {:ns "cljs.core",
                            :name "key",
                            :signature ["[map-entry]"],
                            :name-encode "key",
                            :history [["+" "0.0-1211"]],
                            :type "function",
                            :full-name-encode "cljs.core/key",
                            :source {:code "(defn key\n  [map-entry]\n  (-key map-entry))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [7236 7239]},
                            :full-name "cljs.core/key",
                            :docstring "Returns the key of the map entry."},
           "clojure.browser.dom/set-properties" {:ns "clojure.browser.dom",
                                                 :name "set-properties",
                                                 :signature ["[e m]"],
                                                 :name-encode "set-properties",
                                                 :history [["+"
                                                            "0.0-927"]],
                                                 :type "function",
                                                 :full-name-encode "clojure.browser.dom/set-properties",
                                                 :source {:code "(defn set-properties\n  [e m]\n  (gdom/setProperties (ensure-element e)\n                      (apply gobject/create (interleave (keys m) (vals m)))))",
                                                          :title "Source code",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/cljs/clojure/browser/dom.cljs",
                                                          :lines [136
                                                                  140]},
                                                 :full-name "clojure.browser.dom/set-properties",
                                                 :docstring "Set properties on an element"},
           "clojure.data/diff" {:ns "clojure.data",
                                :name "diff",
                                :signature ["[a b]"],
                                :name-encode "diff",
                                :history [["+" "0.0-1503"]],
                                :type "function",
                                :full-name-encode "clojure.data/diff",
                                :source {:code "(defn diff\n  [a b]\n  (if (= a b)\n    [nil nil a]\n    (if (= (equality-partition a) (equality-partition b))\n      (diff-similar a b)\n      (atom-diff a b))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/data.cljs",
                                         :lines [144 161]},
                                :full-name "clojure.data/diff",
                                :docstring "Recursively compares a and b, returning a tuple of\n[things-only-in-a things-only-in-b things-in-both].\nComparison rules:\n\n* For equal a and b, return [nil nil a].\n* Maps are subdiffed where keys match and values differ.\n* Sets are never subdiffed.\n* All sequential things are treated as associative collections\n  by their indexes, with results returned as vectors.\n* Everything else (including strings!) is treated as\n  an atom and compared for equality."},
           "cljs.core/ITransientAssociative" {:ns "cljs.core",
                                              :name "ITransientAssociative",
                                              :name-encode "ITransientAssociative",
                                              :implementations #{"TransientArrayMap"
                                                                 "TransientVector"
                                                                 "TransientHashMap"},
                                              :history [["+"
                                                         "0.0-1211"]],
                                              :type "protocol",
                                              :full-name-encode "cljs.core/ITransientAssociative",
                                              :source {:code "(defprotocol ITransientAssociative\n  (^clj -assoc! [tcoll key val]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/cljs/core.cljs",
                                                       :lines [380
                                                               381]},
                                              :methods [{:name "-assoc!",
                                                         :signature ["[tcoll key val]"],
                                                         :docstring nil}],
                                              :full-name "cljs.core/ITransientAssociative"},
           "cljs.core/trampoline" {:ns "cljs.core",
                                   :name "trampoline",
                                   :signature ["[f]" "[f & args]"],
                                   :name-encode "trampoline",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/trampoline",
                                   :source {:code "(defn trampoline\n  ([f]\n     (let [ret (f)]\n       (if (fn? ret)\n         (recur ret)\n         ret)))\n  ([f & args]\n     (trampoline #(apply f args))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [8707 8721]},
                                   :full-name "cljs.core/trampoline",
                                   :docstring "trampoline can be used to convert algorithms requiring mutual\nrecursion without stack consumption. Calls f with supplied args, if\nany. If f returns a fn, calls that fn with no arguments, and\ncontinues to repeat, until the return value is not a fn, then\nreturns that non-fn value. Note that if you want to return a fn as a\nfinal value, you must wrap it in some data structure and unpack it\nafter trampoline returns."},
           "cljs.test/test-ns" {:ns "cljs.test",
                                :name "test-ns",
                                :signature ["[ns]"
                                            "[env [quote ns :as form]]"],
                                :name-encode "test-ns",
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/test-ns",
                                :source {:code "(defmacro test-ns\n  ([ns] `(cljs.test/test-ns (cljs.test/empty-env) ~ns))\n  ([env [quote ns :as form]]\n   (assert (and (= quote 'quote) (symbol? ns)) \"Argument to test-ns must be a quoted symbol\")\n   (assert (ana-api/find-ns ns) (str \"Namespace \" ns \" does not exist\"))\n   `(do\n      (cljs.test/set-env! ~env)\n      (cljs.test/do-report {:type :begin-test-ns, :ns ~form})\n      ;; If the namespace has a test-ns-hook function, call that:\n      ~(if-let [v (ana-api/ns-resolve ns 'test-ns-hook)]\n         `(~(symbol (name ns) \"test-ns-hook\"))\n         ;; Otherwise, just test every var in the namespace.\n         `(cljs.test/test-all-vars ~form))\n      (cljs.test/do-report {:type :end-test-ns, :ns ~form})\n      (let [ret# (cljs.test/get-current-env)]\n        (cljs.test/clear-env!)\n        ret#))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/test.clj",
                                         :lines [301 324]},
                                :full-name "cljs.test/test-ns",
                                :docstring "If the namespace defines a function named test-ns-hook, calls that.\nOtherwise, calls test-all-vars on the namespace.  'ns' is a\nnamespace object or a symbol.\n\nInternally binds *report-counters* to a ref initialized to\n*initial-report-counters*.  Returns the final, dereferenced state of\n*report-counters*."},
           "cljs.core/implements?" {:ns "cljs.core",
                                    :name "implements?",
                                    :signature ["[psym x]"],
                                    :name-encode "implementsQMARK",
                                    :history [["+" "0.0-2014"]],
                                    :type "macro",
                                    :full-name-encode "cljs.core/implementsQMARK",
                                    :source {:code "(defmacro implements?\n  [psym x]\n  (let [p          (:name\n                    (cljs.analyzer/resolve-var\n                      (dissoc &env :locals) psym))\n        prefix     (protocol-prefix p)\n        xsym       (bool-expr (gensym))\n        [part bit] (fast-path-protocols p)\n        msym       (symbol\n                      (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if ~xsym\n         (let [bit# ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))]\n           (if (or bit#\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             false))\n         false))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/core.clj",
                                             :lines [1052 1070]},
                                    :full-name "cljs.core/implements?",
                                    :docstring "EXPERIMENTAL"},
           "cljs.repl.browser/handle-connection" {:ns "cljs.repl.browser",
                                                  :name "handle-connection",
                                                  :signature ["[opts conn]"],
                                                  :name-encode "handle-connection",
                                                  :history [["+"
                                                             "0.0-927"]
                                                            ["-"
                                                             "0.0-1503"]],
                                                  :type "function",
                                                  :full-name-encode "cljs.repl.browser/handle-connection",
                                                  :source {:code "(defn handle-connection\n  [opts conn]\n  (let [rdr (BufferedReader. (InputStreamReader. (.getInputStream conn)))]\n    (if-let [request (read-request rdr)]\n      (case (:method request)\n        :get (handle-get opts conn request)\n        :post (handle-post conn (read-string (:content request)))\n        (.close conn))\n      (.close conn))))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r1450",
                                                           :filename "src/clj/cljs/repl/browser.clj",
                                                           :lines [248
                                                                   256]},
                                                  :full-name "cljs.repl.browser/handle-connection",
                                                  :removed {:in "0.0-1503",
                                                            :last-seen "0.0-1450"}},
           "clojure.browser.repl/send-print" {:ns "clojure.browser.repl",
                                              :name "send-print",
                                              :signature ["[url data]"
                                                          "[url data n]"],
                                              :name-encode "send-print",
                                              :history [["+"
                                                         "0.0-927"]],
                                              :type "function",
                                              :full-name-encode "clojure.browser.repl/send-print",
                                              :source {:code "(defn send-print\n  ([url data]\n     (send-print url data 0))\n  ([url data n]\n     (let [conn (net/xhr-connection)]\n       (event/listen conn :error\n                     (fn [_]\n                       (if (< n 10)\n                         (send-print url data (inc n))\n                         (.log js/console (str \"Could not send \" data \" after \" n \" attempts.\")))))\n       (net/transmit conn url \"POST\" data nil 0))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/cljs/clojure/browser/repl.cljs",
                                                       :lines [41 53]},
                                              :full-name "clojure.browser.repl/send-print",
                                              :docstring "Send data to be printed in the REPL. If there is an error, try again\nup to 10 times."},
           "cljs.core/ICounted" {:ns "cljs.core",
                                 :name "ICounted",
                                 :name-encode "ICounted",
                                 :implementations #{"Subvec"
                                                    "PersistentQueue"
                                                    "PersistentHashMap"
                                                    "PersistentTreeSet"
                                                    "PersistentArrayMapSeq"
                                                    "RedNode"
                                                    "TransientArrayMap"
                                                    "EmptyList"
                                                    "ObjMap"
                                                    "ArrayChunk"
                                                    "BlackNode"
                                                    "PersistentVector"
                                                    "ChunkBuffer"
                                                    "Range"
                                                    "TransientVector"
                                                    "IndexedSeq"
                                                    "PersistentTreeMap"
                                                    "PersistentTreeMapSeq"
                                                    "RSeq"
                                                    "PersistentArrayMap"
                                                    "PersistentHashSet"
                                                    "List"
                                                    "TransientHashMap"
                                                    "nil"
                                                    "TransientHashSet"},
                                 :history [["+" "0.0-927"]],
                                 :type "protocol",
                                 :full-name-encode "cljs.core/ICounted",
                                 :source {:code "(defprotocol ICounted\n  (^number -count [coll] \"constant time count\"))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [258 259]},
                                 :methods [{:name "-count",
                                            :signature ["[coll]"],
                                            :docstring "constant time count"}],
                                 :full-name "cljs.core/ICounted"},
           "cljs.core/quote" {:ns "cljs.core",
                              :name "quote",
                              :type "special form",
                              :source {:code "(defmethod parse 'quote\n  [_ env [_ x] _ _]\n  (analyze (assoc env :quoted? true) x))",
                                       :title "Parser code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/analyzer.clj",
                                       :lines [1003 1005]},
                              :full-name "cljs.core/quote",
                              :full-name-encode "cljs.core/quote",
                              :name-encode "quote",
                              :history [["+" "0.0-927"]]},
           "cljs.core/IEquiv" {:ns "cljs.core",
                               :name "IEquiv",
                               :name-encode "IEquiv",
                               :implementations #{"Subvec"
                                                  "Symbol"
                                                  "PersistentQueue"
                                                  "PersistentHashMap"
                                                  "PersistentTreeSet"
                                                  "js/Date"
                                                  "PersistentArrayMapSeq"
                                                  "RedNode"
                                                  "EmptyList"
                                                  "LazyTransformer"
                                                  "ObjMap"
                                                  "BlackNode"
                                                  "PersistentVector"
                                                  "ValSeq"
                                                  "ChunkedCons"
                                                  "Range"
                                                  "PersistentQueueSeq"
                                                  "ChunkedSeq"
                                                  "ArrayNodeSeq"
                                                  "KeySeq"
                                                  "IndexedSeq"
                                                  "number"
                                                  "PersistentTreeMap"
                                                  "PersistentTreeMapSeq"
                                                  "RSeq"
                                                  "PersistentArrayMap"
                                                  "Keyword"
                                                  "PersistentHashSet"
                                                  "NodeSeq"
                                                  "List"
                                                  "Atom"
                                                  "Cons"
                                                  "default"
                                                  "LazySeq"
                                                  "NeverEquiv"
                                                  "UUID"},
                               :history [["+" "0.0-927"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IEquiv",
                               :source {:code "(defprotocol IEquiv\n  (^boolean -equiv [o other]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [326 327]},
                               :methods [{:name "-equiv",
                                          :signature ["[o other]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IEquiv"},
           "cljs.core/reduce-kv" {:ns "cljs.core",
                                  :name "reduce-kv",
                                  :signature ["[f init coll]"],
                                  :name-encode "reduce-kv",
                                  :history [["+" "0.0-1211"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/reduce-kv",
                                  :source {:code "(defn reduce-kv\n  ([f init coll]\n    (if-not (nil? coll)\n      (-kv-reduce coll f init)\n      init)))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1798 1808]},
                                  :full-name "cljs.core/reduce-kv",
                                  :docstring "Reduces an associative collection. f should be a function of 3\narguments. Returns the result of applying f to init, the first key\nand the first value in coll, then applying f to that result and the\n2nd key and value, etc. If coll contains no entries, returns init\nand f is not called. Note that reduce-kv is supported on vectors,\nwhere the keys will be the ordinals."},
           "cljs.core/js-delete" {:ns "cljs.core",
                                  :name "js-delete",
                                  :signature ["[obj key]"],
                                  :name-encode "js-delete",
                                  :history [["+" "0.0-927"]],
                                  :type "function/macro",
                                  :full-name-encode "cljs.core/js-delete",
                                  :source {:code "(defn js-delete [obj key]\n  (cljs.core/js-delete obj key))",
                                           :title "Function code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [1558 1559]},
                                  :extra-sources [{:code "(defmacro js-delete [obj key]\n  (core/list 'js* \"delete ~{}[~{}]\" obj key))",
                                                   :title "Macro code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/core.clj",
                                                   :lines [287 288]}],
                                  :full-name "cljs.core/js-delete"},
           "cljs.core/PersistentTreeSet.EMPTY" {:ns "cljs.core",
                                                :name "PersistentTreeSet.EMPTY",
                                                :name-encode "PersistentTreeSetDOTEMPTY",
                                                :parent-type "PersistentTreeSet",
                                                :type "var",
                                                :full-name-encode "cljs.core/PersistentTreeSetDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY PersistentTreeSet)\n  (PersistentTreeSet. nil (.-EMPTY PersistentTreeMap) empty-unordered-hash))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [7571
                                                                 7572]},
                                                :full-name "cljs.core/PersistentTreeSet.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.core/comment" {:ns "cljs.core",
                                :name "comment",
                                :signature ["[& body]"],
                                :name-encode "comment",
                                :history [["+" "0.0-927"]],
                                :type "macro",
                                :full-name-encode "cljs.core/comment",
                                :source {:code "(defmacro comment\n  [& body])",
                                         :title "Source code",
                                         :repo "clojure",
                                         :tag "clojure-1.6.0",
                                         :filename "src/clj/clojure/core.clj",
                                         :lines [4341 4344]},
                                :full-name "cljs.core/comment",
                                :docstring "Ignores body, yields nil"},
           "cljs.reader/special-symbols" {:ns "cljs.reader",
                                          :name "special-symbols",
                                          :signature ["[t not-found]"],
                                          :name-encode "special-symbols",
                                          :type "function",
                                          :full-name-encode "cljs.reader/special-symbols",
                                          :source {:code "(defn special-symbols [t not-found]\n  (cond\n    (identical? t \"nil\") nil\n    (identical? t \"true\") true\n    (identical? t \"false\") false\n    (identical? t \"/\") '/\n    :else not-found))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [319 325]},
                                          :full-name "cljs.reader/special-symbols",
                                          :history [["+" "0.0-927"]]},
           "compiler-options/output-wrapper" {:ns "compiler-options",
                                              :name "output-wrapper",
                                              :name-encode "output-wrapper",
                                              :type "option",
                                              :full-name-encode "compiler-options/output-wrapper",
                                              :full-name "compiler-options/output-wrapper",
                                              :history [["+"
                                                         "0.0-1513"]]},
           "cljs.core/js*" {:ns "cljs.core",
                            :name "js*",
                            :type "special form",
                            :source {:code "(defmethod parse 'js*\n  [op env [_ jsform & args :as form] _ _]\n  (when-not (string? jsform)\n    (throw (error env \"Invalid js* form\")))\n  (if args\n    (disallowing-recur\n     (let [seg (fn seg [^String s]\n                 (let [idx (.indexOf s \"~{\")]\n                   (if (= -1 idx)\n                     (list s)\n                     (let [end (.indexOf s \"}\" idx)]\n                       (lazy-seq\n                         (cons (subs s 0 idx)\n                           (seg (subs s (inc end)))))))))\n           enve (assoc env :context :expr)\n           argexprs (vec (map #(analyze enve %) args))]\n       (when (-> form meta :numeric)\n         (let [types (map #(infer-tag env %) argexprs)]\n           (when-not (every?\n                       (fn [t]\n                         (or (nil? t)\n                             (and (symbol? t) ('#{any number} t))\n                             ;; TODO: type inference is not strong enough to detect that\n                             ;; when functions like first won't return nil, so variadic\n                             ;; numeric functions like cljs.core/< would produce a spurious\n                             ;; warning without this - David\n                             (and (set? t) (or (contains? t 'number) (contains? t 'any)))))\n                       types)\n             (warning :invalid-arithmetic env\n               {:js-op (-> form meta :js-op)\n                :types (into [] types)}))))\n       {:env env :op :js :segs (seg jsform) :args argexprs\n        :tag (or (-> form meta :tag)\n                 (and (-> form meta :numeric) 'number)\n                 nil)\n        :form form :children argexprs\n        :js-op (-> form meta :js-op)\n        :numeric (-> form meta :numeric)}))\n    (let [interp (fn interp [^String s]\n                   (let [idx (.indexOf s \"~{\")]\n                     (if (= -1 idx)\n                       (list s)\n                       (let [end (.indexOf s \"}\" idx)\n                             inner (:name (resolve-existing-var env (symbol (subs s (+ 2 idx) end))))]\n                         (lazy-seq\n                           (cons (subs s 0 idx)\n                             (cons inner\n                               (interp (subs s (inc end))))))))))]\n      {:env env :op :js :form form :code (apply str (interp jsform))\n       :tag (or (-> form meta :tag)\n                (and (-> form meta :numeric) 'number)\n                nil)\n       :js-op (-> form meta :js-op)\n       :numeric (-> form meta :numeric)})))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [1481 1534]},
                            :extra-sources ({:code "(defmethod emit* :js\n  [{:keys [env code segs args]}]\n  (emit-wrap env\n             (if code\n               (emits code)\n               (emits (interleave (concat segs (repeat nil))\n                                  (concat args [nil]))))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [886 892]}),
                            :full-name "cljs.core/js*",
                            :full-name-encode "cljs.core/jsSTAR",
                            :name-encode "jsSTAR",
                            :history [["+" "0.0-927"]]},
           "cljs.repl.node/setup" {:ns "cljs.repl.node",
                                   :name "setup",
                                   :signature ["[repl-env]"
                                               "[repl-env opts]"],
                                   :name-encode "setup",
                                   :type "function",
                                   :full-name-encode "cljs.repl.node/setup",
                                   :source {:code "(defn setup\n  ([repl-env] (setup repl-env nil))\n  ([repl-env opts]\n    (let [output-dir (io/file (:output-dir opts))\n          _    (.mkdirs output-dir)\n          of   (io/file output-dir \"node_repl.js\")\n          _   (spit of\n                (string/replace (slurp (io/resource \"cljs/repl/node_repl.js\"))\n                  \"var PORT = 5001;\"\n                  (str \"var PORT = \" (:port repl-env) \";\")))\n          bldr (ProcessBuilder. (into-array [(get opts :node-command \"node\")]))\n          _    (-> bldr\n                 (.redirectInput of)\n                 (.redirectOutput ProcessBuilder$Redirect/INHERIT)\n                 (.redirectError ProcessBuilder$Redirect/INHERIT))\n          proc (.start bldr)\n          env  (ana/empty-env)\n          core (io/resource \"cljs/core.cljs\")\n          root-path (.getCanonicalFile output-dir)\n          rewrite-path (str (.getPath root-path) File/separator \"goog\")]\n      ;; TODO: temporary hack, should wait till we can read the start string\n      ;; from the process - David\n      (Thread/sleep 300)\n      (reset! (:socket repl-env)\n        (socket (:host repl-env) (:port repl-env)))\n      (reset! (:proc repl-env) proc)\n      ;; compile cljs.core & its dependencies, goog/base.js must be available\n      ;; for bootstrap to load, use new closure/compile as it can handle\n      ;; resources in JARs\n      (let [core-js (closure/compile core\n                      (assoc opts\n                        :output-file\n                        (closure/src-file->target-file core)))\n            deps    (closure/add-dependencies opts core-js)]\n        ;; output unoptimized code and the deps file\n        ;; for all compiled namespaces\n        (apply closure/output-unoptimized\n          (assoc opts\n            :output-to (.getPath (io/file output-dir \"node_repl_deps.js\")))\n          deps))\n      ;; bootstrap, replace __dirname as __dirname won't be set\n      ;; properly due to how we are running it - David\n      (node-eval repl-env\n        (-> (slurp (io/resource \"cljs/bootstrap_node.js\"))\n          (string/replace \"__dirname\"\n            (str \"\\\"\" (str rewrite-path File/separator \"bootstrap\") \"\\\"\"))\n          (string/replace\n            \"path.join(\\\".\\\", \\\"..\\\", src)\"\n            (str \"path.join(\\\"\" rewrite-path \"\\\", src)\"))\n          (string/replace\n            \"var CLJS_ROOT = \\\".\\\";\"\n            (str \"var CLJS_ROOT = \\\"\" (.getPath root-path) \"\\\";\"))))\n      ;; load the deps file so we can goog.require cljs.core etc.\n      (node-eval repl-env\n        (str \"require('\"\n          (.getPath root-path)\n          File/separator \"node_repl_deps.js')\"))\n      ;; monkey-patch isProvided_ to avoid useless warnings - David\n      (node-eval repl-env\n        (str \"goog.isProvided_ = function(x) { return false; };\"))\n      ;; monkey-patch goog.require, skip all the loaded checks\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(set! (.-require js/goog)\n           (fn [name]\n             (js/CLOSURE_IMPORT_SCRIPT\n               (aget (.. js/goog -dependencies_ -nameToPath) name)))))\n      ;; load cljs.core, setup printing\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (.require js/goog \"cljs.core\")\n           (set! *print-fn* (.-print (js/require \"util\")))))\n      ;; redef goog.require to track loaded libs\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(set! (.-require js/goog)\n           (fn [name reload]\n             (when (or (not (contains? *loaded-libs* name)) reload)\n               (set! *loaded-libs* (conj (or *loaded-libs* #{}) name))\n               (js/CLOSURE_IMPORT_SCRIPT\n                 (aget (.. js/goog -dependencies_ -nameToPath) name))))))\n      )))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/repl/node.clj",
                                            :lines [73 152]},
                                   :full-name "cljs.repl.node/setup",
                                   :history [["+" "0.0-2629"]]},
           "cljs.core/BitmapIndexedNode.EMPTY" {:ns "cljs.core",
                                                :name "BitmapIndexedNode.EMPTY",
                                                :name-encode "BitmapIndexedNodeDOTEMPTY",
                                                :parent-type "BitmapIndexedNode",
                                                :type "var",
                                                :full-name-encode "cljs.core/BitmapIndexedNodeDOTEMPTY",
                                                :source {:code "(set! (.-EMPTY BitmapIndexedNode) (BitmapIndexedNode. nil 0 (make-array 0)))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [5847]},
                                                :full-name "cljs.core/BitmapIndexedNode.EMPTY",
                                                :history [["+"
                                                           "0.0-1211"]]},
           "cljs.reader/register-default-tag-parser!" {:ns "cljs.reader",
                                                       :name "register-default-tag-parser!",
                                                       :signature ["[f]"],
                                                       :name-encode "register-default-tag-parserBANG",
                                                       :type "function",
                                                       :full-name-encode "cljs.reader/register-default-tag-parserBANG",
                                                       :source {:code "(defn register-default-tag-parser!\n  [f]\n  (let [old-parser @*default-data-reader-fn*]\n    (swap! *default-data-reader-fn* (fn [_] f))\n    old-parser))",
                                                                :title "Source code",
                                                                :repo "clojurescript",
                                                                :tag "r2760",
                                                                :filename "src/cljs/cljs/reader.cljs",
                                                                :lines [602
                                                                        606]},
                                                       :full-name "cljs.reader/register-default-tag-parser!",
                                                       :history [["+"
                                                                  "0.0-1576"]]},
           "cljs.core/alength" {:return-type number,
                                :ns "cljs.core",
                                :name "alength",
                                :signature ["[array]"],
                                :name-encode "alength",
                                :history [["+" "0.0-927"]],
                                :type "function/macro",
                                :full-name-encode "cljs.core/alength",
                                :source {:code "(defn ^number alength\n  [array]\n  (cljs.core/alength array))",
                                         :title "Function code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [206 209]},
                                :extra-sources [{:code "(defmacro alength [a]\n  (vary-meta\n    (core/list 'js* \"~{}.length\" a)\n    assoc :tag 'number))",
                                                 :title "Macro code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [1491 1494]}],
                                :full-name "cljs.core/alength",
                                :docstring "Returns the length of the array. Works on arrays of all types."},
           "cljs.core/mk-bound-fn" {:ns "cljs.core",
                                    :name "mk-bound-fn",
                                    :signature ["[sc test key]"],
                                    :name-encode "mk-bound-fn",
                                    :type "function",
                                    :full-name-encode "cljs.core/mk-bound-fn",
                                    :source {:code "(defn mk-bound-fn\n  [sc test key]\n  (fn [e]\n    (let [comp (-comparator sc)]\n      (test (comp (-entry-key sc e) key) 0))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [7759 7763]},
                                    :full-name "cljs.core/mk-bound-fn",
                                    :history [["+" "0.0-1211"]]},
           "cljs.reader/validate-unicode-escape" {:ns "cljs.reader",
                                                  :name "validate-unicode-escape",
                                                  :signature ["[unicode-pattern reader escape-char unicode-str]"],
                                                  :name-encode "validate-unicode-escape",
                                                  :type "function",
                                                  :full-name-encode "cljs.reader/validate-unicode-escape",
                                                  :source {:code "(defn validate-unicode-escape [unicode-pattern reader escape-char unicode-str]\n  (if (re-matches unicode-pattern unicode-str)\n    unicode-str\n    (reader-error reader \"Unexpected unicode escape \\\\\" escape-char unicode-str)))",
                                                           :title "Source code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/cljs/cljs/reader.cljs",
                                                           :lines [184
                                                                   187]},
                                                  :full-name "cljs.reader/validate-unicode-escape",
                                                  :history [["+"
                                                             "0.0-1424"]]},
           "repl-options/static-dir" {:ns "repl-options",
                                      :name "static-dir",
                                      :name-encode "static-dir",
                                      :type "option",
                                      :full-name-encode "repl-options/static-dir",
                                      :full-name "repl-options/static-dir",
                                      :history [["+" "0.0-1211"]]},
           "cljs.core/VectorNode" {:ns "cljs.core",
                                   :name "VectorNode",
                                   :signature ["[edit arr]"],
                                   :name-encode "VectorNode",
                                   :type "type",
                                   :full-name-encode "cljs.core/VectorNode",
                                   :source {:code "(deftype VectorNode [edit arr])",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4153]},
                                   :full-name "cljs.core/VectorNode",
                                   :history [["+" "0.0-1211"]]},
           "cljs.core/string-hash-cache-count" {:ns "cljs.core",
                                                :name "string-hash-cache-count",
                                                :name-encode "string-hash-cache-count",
                                                :type "var",
                                                :full-name-encode "cljs.core/string-hash-cache-count",
                                                :source {:code "(def string-hash-cache-count 0)",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [510]},
                                                :full-name "cljs.core/string-hash-cache-count",
                                                :history [["+"
                                                           "0.0-1424"]]},
           "cljs.core/tree-seq" {:ns "cljs.core",
                                 :name "tree-seq",
                                 :signature ["[branch? children root]"],
                                 :name-encode "tree-seq",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/tree-seq",
                                 :source {:code "(defn tree-seq\n   [branch? children root]\n   (let [walk (fn walk [node]\n                (lazy-seq\n                 (cons node\n                  (when (branch? node)\n                    (mapcat walk (children node))))))]\n     (walk root)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3994 4007]},
                                 :full-name "cljs.core/tree-seq",
                                 :docstring "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n branch? must be a fn of one arg that returns true if passed a node\n that can have children (but may not).  children must be a fn of one\n arg that returns a sequence of the children. Will only be called on\n nodes for which branch? returns true. Root is the root node of the\ntree."},
           "cljs.reader/read-unmatched-delimiter" {:ns "cljs.reader",
                                                   :name "read-unmatched-delimiter",
                                                   :signature ["[rdr ch]"],
                                                   :name-encode "read-unmatched-delimiter",
                                                   :type "function",
                                                   :full-name-encode "cljs.reader/read-unmatched-delimiter",
                                                   :source {:code "(defn read-unmatched-delimiter\n  [rdr ch]\n  (reader-error rdr \"Unmatched delimiter \" ch))",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/cljs/reader.cljs",
                                                            :lines [260
                                                                    262]},
                                                   :full-name "cljs.reader/read-unmatched-delimiter",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "clojure.core.reducers/take-while" {:ns "clojure.core.reducers",
                                               :name "take-while",
                                               :signature ["[pred]"
                                                           "[pred coll]"],
                                               :name-encode "take-while",
                                               :history [["+"
                                                          "0.0-1236"]],
                                               :type "function",
                                               :full-name-encode "clojure.core.reducers/take-while",
                                               :source {:code "(defcurried take-while\n  \"Ends the reduction of coll when (pred val) returns logical false.\"\n  {}\n  [pred coll]\n  (reducer coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (if (pred k v)\n               (f1 ret k v)\n               (reduced ret)))))))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/clojure/core/reducers.cljs",
                                                        :lines [152
                                                                162]},
                                               :full-name "clojure.core.reducers/take-while",
                                               :docstring "Ends the reduction of coll when (pred val) returns logical false."},
           "cljs.reader/register-tag-parser!" {:ns "cljs.reader",
                                               :name "register-tag-parser!",
                                               :signature ["[tag f]"],
                                               :name-encode "register-tag-parserBANG",
                                               :type "function",
                                               :full-name-encode "cljs.reader/register-tag-parserBANG",
                                               :source {:code "(defn register-tag-parser!\n  [tag f]\n  (let [tag (str tag)\n        old-parser (get @*tag-table* tag)]\n    (swap! *tag-table* assoc tag f)\n    old-parser))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [588
                                                                593]},
                                               :full-name "cljs.reader/register-tag-parser!",
                                               :history [["+"
                                                          "0.0-1236"]]},
           "cljs.core/every-pred" {:ns "cljs.core",
                                   :name "every-pred",
                                   :signature ["[p]"
                                               "[p1 p2]"
                                               "[p1 p2 p3]"
                                               "[p1 p2 p3 & ps]"],
                                   :name-encode "every-pred",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/every-pred",
                                   :source {:code "(defn every-pred\n  ([p]\n     (fn ep1\n       ([] true)\n       ([x] (boolean (p x)))\n       ([x y] (boolean (and (p x) (p y))))\n       ([x y z] (boolean (and (p x) (p y) (p z))))\n       ([x y z & args] (boolean (and (ep1 x y z)\n                                     (every? p args))))))\n  ([p1 p2]\n     (fn ep2\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x))))\n       ([x y] (boolean (and (p1 x) (p1 y) (p2 x) (p2 y))))\n       ([x y z] (boolean (and (p1 x) (p1 y) (p1 z) (p2 x) (p2 y) (p2 z))))\n       ([x y z & args] (boolean (and (ep2 x y z)\n                                     (every? #(and (p1 %) (p2 %)) args))))))\n  ([p1 p2 p3]\n     (fn ep3\n       ([] true)\n       ([x] (boolean (and (p1 x) (p2 x) (p3 x))))\n       ([x y] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y))))\n       ([x y z] (boolean (and (p1 x) (p2 x) (p3 x) (p1 y) (p2 y) (p3 y) (p1 z) (p2 z) (p3 z))))\n       ([x y z & args] (boolean (and (ep3 x y z)\n                                     (every? #(and (p1 %) (p2 %) (p3 %)) args))))))\n  ([p1 p2 p3 & ps]\n     (let [ps (list* p1 p2 p3 ps)]\n       (fn epn\n         ([] true)\n         ([x] (every? #(% x) ps))\n         ([x y] (every? #(and (% x) (% y)) ps))\n         ([x y z] (every? #(and (% x) (% y) (% z)) ps))\n         ([x y z & args] (boolean (and (epn x y z)\n                                       (every? #(every? % args) ps))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3654 3691]},
                                   :full-name "cljs.core/every-pred",
                                   :docstring "Takes a set of predicates and returns a function f that returns true if all of its\ncomposing predicates return a logical true value against all of its arguments, else it returns\nfalse. Note that f is short-circuiting in that it will stop execution on the first\nargument that triggers a logical false result against the original predicates."},
           "cljs.core/PersistentHashSet" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IEditableCollection"
                                                       "IEmptyableCollection"
                                                       "ISet"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentHashSet",
                                          :signature ["[meta hash-map __hash]"],
                                          :name-encode "PersistentHashSet",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentHashSet",
                                          :source {:code "(deftype PersistentHashSet [meta hash-map ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (seq coll)))\n  (entries [coll]\n    (es6-set-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (seq coll)))\n  (has [coll k]\n    (contains? coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  ICloneable\n  (-clone [_] (PersistentHashSet. meta hash-map __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentHashSet. meta hash-map __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll o]\n    (PersistentHashSet. meta (assoc hash-map o nil) nil))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY PersistentHashSet) meta))\n\n  IEquiv\n  (-equiv [coll other]\n    (and\n     (set? other)\n     (== (count coll) (count other))\n     (every? #(contains? coll %)\n             other)))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ISeqable\n  (-seq [coll] (keys hash-map))\n\n  ICounted\n  (-count [coll] (-count hash-map))\n\n  ILookup\n  (-lookup [coll v]\n    (-lookup coll v nil))\n  (-lookup [coll v not-found]\n    (if (-contains-key? hash-map v)\n      v\n      not-found))\n\n  ISet\n  (-disjoin [coll v]\n    (PersistentHashSet. meta (-dissoc hash-map v) nil))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  IEditableCollection\n  (-as-transient [coll] (TransientHashSet. (-as-transient hash-map))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [7351 7423]},
                                          :full-name "cljs.core/PersistentHashSet"},
           "cljs.repl/doc" {:ns "cljs.repl",
                            :name "doc",
                            :signature ["[sym]"],
                            :name-encode "doc",
                            :history [["+" "0.0-2496"]],
                            :type "macro",
                            :full-name-encode "cljs.repl/doc",
                            :source {:code "(defmacro doc\n  [sym]\n  `(cljs.repl/print-doc (meta (var ~sym))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/repl.clj",
                                     :lines [434 437]},
                            :full-name "cljs.repl/doc",
                            :docstring "Prints documentation for a var or special form given its name"},
           "clojure.set/rename-keys" {:ns "clojure.set",
                                      :name "rename-keys",
                                      :signature ["[map kmap]"],
                                      :name-encode "rename-keys",
                                      :history [["+" "0.0-927"]],
                                      :type "function",
                                      :full-name-encode "clojure.set/rename-keys",
                                      :source {:code "(defn rename-keys\n  [map kmap]\n    (reduce\n     (fn [m [old new]]\n       (if (contains? map old)\n         (assoc m new (get map old))\n         m))\n     (apply dissoc map (keys kmap)) kmap))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/clojure/set.cljs",
                                               :lines [72 80]},
                                      :full-name "clojure.set/rename-keys",
                                      :docstring "Returns the map with the keys in kmap renamed to the vals in kmap"},
           "cljs.core/peek" {:ns "cljs.core",
                             :name "peek",
                             :signature ["[coll]"],
                             :name-encode "peek",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/peek",
                             :source {:code "(defn peek\n  [coll]\n  (when-not (nil? coll)\n    (-peek coll)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1465 1470]},
                             :full-name "cljs.core/peek",
                             :docstring "For a list or queue, same as first, for a vector, same as, but much\nmore efficient than, last. If the collection is empty, returns nil."},
           "cljs.core/pr-str-with-opts" {:ns "cljs.core",
                                         :name "pr-str-with-opts",
                                         :signature ["[objs opts]"],
                                         :name-encode "pr-str-with-opts",
                                         :history [["+" "0.0-927"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/pr-str-with-opts",
                                         :source {:code "(defn pr-str-with-opts\n  [objs opts]\n  (if (empty? objs)\n    \"\"\n    (str (pr-sb-with-opts objs opts))))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [8239 8245]},
                                         :full-name "cljs.core/pr-str-with-opts",
                                         :docstring "Prints a sequence of objects to a string, observing all the\noptions given in opts"},
           "cljs.core/IChunk" {:ns "cljs.core",
                               :name "IChunk",
                               :name-encode "IChunk",
                               :implementations #{"ArrayChunk"},
                               :history [["+" "0.0-1424"]],
                               :type "protocol",
                               :full-name-encode "cljs.core/IChunk",
                               :source {:code "(defprotocol IChunk\n  (-drop-first [coll]))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [396 397]},
                               :methods [{:name "-drop-first",
                                          :signature ["[coll]"],
                                          :docstring nil}],
                               :full-name "cljs.core/IChunk"},
           "cljs.core/ITransientVector" {:ns "cljs.core",
                                         :name "ITransientVector",
                                         :name-encode "ITransientVector",
                                         :implementations #{"TransientVector"},
                                         :history [["+" "0.0-1211"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/ITransientVector",
                                         :source {:code "(defprotocol ITransientVector\n  (^clj -assoc-n! [tcoll n val])\n  (^clj -pop! [tcoll]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [386 388]},
                                         :methods [{:name "-assoc-n!",
                                                    :signature ["[tcoll n val]"],
                                                    :docstring nil}
                                                   {:name "-pop!",
                                                    :signature ["[tcoll]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/ITransientVector"},
           "cljs.core/IPrintWithWriter" {:ns "cljs.core",
                                         :name "IPrintWithWriter",
                                         :name-encode "IPrintWithWriter",
                                         :implementations #{"Subvec"
                                                            "Symbol"
                                                            "PersistentQueue"
                                                            "PersistentHashMap"
                                                            "PersistentTreeSet"
                                                            "PersistentArrayMapSeq"
                                                            "RedNode"
                                                            "EmptyList"
                                                            "LazyTransformer"
                                                            "ObjMap"
                                                            "BlackNode"
                                                            "PersistentVector"
                                                            "ValSeq"
                                                            "ChunkedCons"
                                                            "Range"
                                                            "PersistentQueueSeq"
                                                            "ChunkedSeq"
                                                            "ArrayNodeSeq"
                                                            "KeySeq"
                                                            "IndexedSeq"
                                                            "PersistentTreeMap"
                                                            "PersistentTreeMapSeq"
                                                            "ES6IteratorSeq"
                                                            "RSeq"
                                                            "PersistentArrayMap"
                                                            "Keyword"
                                                            "PersistentHashSet"
                                                            "NodeSeq"
                                                            "List"
                                                            "Atom"
                                                            "Cons"
                                                            "Var"
                                                            "LazySeq"
                                                            "Eduction"
                                                            "UUID"
                                                            "Volatile"},
                                         :history [["+" "0.0-1503"]],
                                         :type "protocol",
                                         :full-name-encode "cljs.core/IPrintWithWriter",
                                         :source {:code "(defprotocol IPrintWithWriter\n  \"The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.\"\n  (-pr-writer [o writer opts]))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [357 363]},
                                         :methods [{:name "-pr-writer",
                                                    :signature ["[o writer opts]"],
                                                    :docstring nil}],
                                         :full-name "cljs.core/IPrintWithWriter",
                                         :docstring "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append."},
           "cljs.core/test" {:ns "cljs.core",
                             :name "test",
                             :signature ["[v]"],
                             :name-encode "test",
                             :history [["+" "0.0-2496"]],
                             :type "function",
                             :full-name-encode "cljs.core/test",
                             :source {:code "(defn test\n  [v]\n  (let [f (.-cljs$lang$test v)]\n    (if f\n      (do (f) :ok)\n      :no-test)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [9237 9244]},
                             :full-name "cljs.core/test",
                             :docstring "test [v] finds fn at key :test in var metadata and calls it,\npresuming failure will throw exception"},
           "cljs.core/map?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "map?",
                             :signature ["[x]"],
                             :name-encode "mapQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/mapQMARK",
                             :source {:code "(defn ^boolean map?\n  [x]\n  (if (nil? x)\n    false\n    (satisfies? IMap x)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1530 1535]},
                             :full-name "cljs.core/map?",
                             :docstring "Return true if x satisfies IMap"},
           "compiler-options/elide-asserts" {:ns "compiler-options",
                                             :name "elide-asserts",
                                             :name-encode "elide-asserts",
                                             :type "option",
                                             :full-name-encode "compiler-options/elide-asserts",
                                             :full-name "compiler-options/elide-asserts",
                                             :history [["+"
                                                        "0.0-2156"]]},
           "syntax/predicate" {:syntax-equiv {:edn-url nil,
                                              :clj-url nil},
                               :ns "syntax",
                               :name "predicate",
                               :name-encode "predicate",
                               :type "convention",
                               :full-name-encode "syntax/predicate",
                               :full-name "syntax/predicate",
                               :history [["+" "0.0-927"]]},
           "cljs.repl.node/node-eval" {:ns "cljs.repl.node",
                                       :name "node-eval",
                                       :signature ["[repl-env js]"],
                                       :name-encode "node-eval",
                                       :history [["+" "0.0-2629"]],
                                       :type "function",
                                       :full-name-encode "cljs.repl.node/node-eval",
                                       :source {:code "(defn node-eval\n  [repl-env js]\n  (let [{:keys [in out]} @(:socket repl-env)]\n    ;; escape backslash for Node.js under Windows\n    (write out (string/replace js \"\\\\\" \"\\\\\\\\\"))\n    (let [result (json/read-str\n                   (read-response in) :key-fn keyword)]\n      (condp = (:status result)\n        \"success\"\n        {:status :success\n         :value (:value result)}\n\n        \"exception\"\n        {:status :exception\n         :value (:value result)}))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl/node.clj",
                                                :lines [50 65]},
                                       :full-name "cljs.repl.node/node-eval",
                                       :docstring "Evaluate a JavaScript string in the Node REPL process."},
           "cljs.reader/StringPushbackReader" {:protocols #{"PushbackReader"},
                                               :ns "cljs.reader",
                                               :name "StringPushbackReader",
                                               :signature ["[s buffer idx]"],
                                               :name-encode "StringPushbackReader",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "type",
                                               :full-name-encode "cljs.reader/StringPushbackReader",
                                               :source {:code "(deftype StringPushbackReader [s buffer ^:mutable idx]\n  PushbackReader\n  (read-char [reader]\n    (if (zero? (alength buffer))\n      (do\n        (set! idx (inc idx))\n        (aget s idx))\n      (.pop buffer)))\n  (unread [reader ch]\n    (.push buffer ch)))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/cljs/reader.cljs",
                                                        :lines [18 27]},
                                               :full-name "cljs.reader/StringPushbackReader"},
           "cljs.core/PersistentTreeMap" {:protocols #{"IFn"
                                                       "ISeqable"
                                                       "IMap"
                                                       "IMeta"
                                                       "IWithMeta"
                                                       "IKVReduce"
                                                       "IReversible"
                                                       "IEmptyableCollection"
                                                       "ICounted"
                                                       "ILookup"
                                                       "ISorted"
                                                       "ICollection"
                                                       "IHash"
                                                       "IPrintWithWriter"
                                                       "IAssociative"
                                                       "IEquiv"
                                                       "ICloneable"},
                                          :ns "cljs.core",
                                          :name "PersistentTreeMap",
                                          :signature ["[comp tree cnt meta __hash]"],
                                          :name-encode "PersistentTreeMap",
                                          :history [["+" "0.0-1211"]],
                                          :type "type",
                                          :full-name-encode "cljs.core/PersistentTreeMap",
                                          :source {:code "(deftype PersistentTreeMap [comp tree cnt meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  ;; EXPERIMENTAL: subject to change\n  (keys [coll]\n    (es6-iterator (keys coll)))\n  (entries [coll]\n    (es6-entries-iterator (seq coll)))\n  (values [coll]\n    (es6-iterator (vals coll)))\n  (has [coll k]\n    (contains? coll k))\n  (get [coll k]\n    (-lookup coll k))\n  (forEach [coll f]\n    (doseq [[k v] coll]\n      (f v k)))\n\n  (entry-at [coll k]\n    (loop [t tree]\n      (if-not (nil? t)\n        (let [c (comp k (.-key t))]\n          (cond (zero? c) t\n                (neg? c)  (recur (.-left t))\n                :else     (recur (.-right t)))))))\n\n  ICloneable\n  (-clone [_] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IWithMeta\n  (-with-meta [coll meta] (PersistentTreeMap. comp tree cnt meta __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ICollection\n  (-conj [coll entry]\n    (if (vector? entry)\n      (-assoc coll (-nth entry 0) (-nth entry 1))\n      (loop [ret coll es (seq entry)]\n        (if (nil? es)\n          ret\n          (let [e (first es)]\n            (if (vector? e)\n              (recur (-assoc ret (-nth e 0) (-nth e 1))\n                     (next es))\n              (throw (js/Error. \"conj on a map takes map entries or seqables of map entries\"))))))))\n\n  IEmptyableCollection\n  (-empty [coll] (PersistentTreeMap. comp nil 0 meta 0))\n\n  IEquiv\n  (-equiv [coll other] (equiv-map coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-unordered-coll __hash))\n\n  ICounted\n  (-count [coll] cnt)\n\n  IKVReduce\n  (-kv-reduce [coll f init]\n    (if-not (nil? tree)\n      (tree-map-kv-reduce tree f init)\n      init))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found))\n\n  ISeqable\n  (-seq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree true cnt)))\n\n  IReversible\n  (-rseq [coll]\n    (if (pos? cnt)\n      (create-tree-map-seq tree false cnt)))\n\n  ILookup\n  (-lookup [coll k]\n    (-lookup coll k nil))\n\n  (-lookup [coll k not-found]\n    (let [n (.entry-at coll k)]\n      (if-not (nil? n)\n        (.-val n)\n        not-found)))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [found (array nil)\n          t     (tree-map-add comp tree k v found)]\n      (if (nil? t)\n        (let [found-node (nth found 0)]\n          (if (= v (.-val found-node))\n            coll\n            (PersistentTreeMap. comp (tree-map-replace comp tree k v) cnt meta nil)))\n        (PersistentTreeMap. comp (.blacken t) (inc cnt) meta nil))))\n\n  (-contains-key? [coll k]\n    (not (nil? (.entry-at coll k))))\n\n  IMap\n  (-dissoc [coll k]\n    (let [found (array nil)\n          t     (tree-map-remove comp tree k found)]\n      (if (nil? t)\n        (if (nil? (nth found 0))\n          coll\n          (PersistentTreeMap. comp nil 0 meta nil))\n        (PersistentTreeMap. comp (.blacken t) (dec cnt) meta nil))))\n\n  ISorted\n  (-sorted-seq [coll ascending?]\n    (if (pos? cnt)\n      (create-tree-map-seq tree ascending? cnt)))\n\n  (-sorted-seq-from [coll k ascending?]\n    (if (pos? cnt)\n      (loop [stack nil t tree]\n        (if-not (nil? t)\n          (let [c (comp k (.-key t))]\n            (cond\n              (zero? c)  (PersistentTreeMapSeq. nil (conj stack t) ascending? -1 nil)\n              ascending? (if (neg? c)\n                           (recur (conj stack t) (.-left t))\n                           (recur stack          (.-right t)))\n              :else      (if (pos? c)\n                           (recur (conj stack t) (.-right t))\n                           (recur stack          (.-left t)))))\n          (when-not (nil? stack)\n            (PersistentTreeMapSeq. nil stack ascending? -1 nil))))))\n\n  (-entry-key [coll entry] (key entry))\n\n  (-comparator [coll] comp))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/core.cljs",
                                                   :lines [6976 7120]},
                                          :full-name "cljs.core/PersistentTreeMap"},
           "cljs.core/HashMap.fromArrays" {:ns "cljs.core",
                                           :name "HashMap.fromArrays",
                                           :signature ["[ks vs]"],
                                           :name-encode "HashMapDOTfromArrays",
                                           :history [["+" "0.0-927"]
                                                     ["-" "0.0-1798"]],
                                           :parent-type "HashMap",
                                           :type "function",
                                           :full-name-encode "cljs.core/HashMapDOTfromArrays",
                                           :source {:code "(set! cljs.core.HashMap/fromArrays (fn [ks vs]\n  (let [len (alength ks)]\n    (loop [i 0, out cljs.core.HashMap/EMPTY]\n      (if (< i len)\n        (recur (inc i) (assoc out (aget ks i) (aget vs i)))\n        out)))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r1586",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [3832 3837]},
                                           :full-name "cljs.core/HashMap.fromArrays",
                                           :removed {:in "0.0-1798",
                                                     :last-seen "0.0-1586"}},
           "cljs.core/deref" {:ns "cljs.core",
                              :name "deref",
                              :signature ["[o]"],
                              :name-encode "deref",
                              :type "function",
                              :full-name-encode "cljs.core/deref",
                              :source {:code "(defn deref\n  [o]\n  (-deref o))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [916 918]},
                              :full-name "cljs.core/deref",
                              :history [["+" "0.0-927"]]},
           "cljs.core/reductions" {:ns "cljs.core",
                                   :name "reductions",
                                   :signature ["[f coll]"
                                               "[f init coll]"],
                                   :name-encode "reductions",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/reductions",
                                   :source {:code "(defn reductions\n  ([f coll]\n     (lazy-seq\n      (if-let [s (seq coll)]\n        (reductions f (first s) (rest s))\n        (list (f)))))\n  ([f init coll]\n     (cons init\n           (lazy-seq\n            (when-let [s (seq coll)]\n              (reductions f (f init (first s)) (rest s)))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [7979 7991]},
                                   :full-name "cljs.core/reductions",
                                   :docstring "Returns a lazy seq of the intermediate values of the reduction (as\nper reduce) of coll by f, starting with init."},
           "cljs.core/false?" {:return-type boolean,
                               :ns "cljs.core",
                               :name "false?",
                               :signature ["[x]"],
                               :name-encode "falseQMARK",
                               :history [["+" "0.0-927"]],
                               :type "function/macro",
                               :full-name-encode "cljs.core/falseQMARK",
                               :source {:code "(defn ^boolean false?\n  [x] (cljs.core/false? x))",
                                        :title "Function code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [1581 1583]},
                               :extra-sources [{:code "(defmacro false? [x]\n  (bool-expr (core/list 'js* \"~{} === false\" x)))",
                                                :title "Macro code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/core.clj",
                                                :lines [299 300]}],
                               :full-name "cljs.core/false?",
                               :docstring "Returns true if x is the value false, false otherwise."},
           "warnings/undeclared-protocol-symbol" {:ns "warnings",
                                                  :name "undeclared-protocol-symbol",
                                                  :type "warning",
                                                  :full-name "warnings/undeclared-protocol-symbol",
                                                  :full-name-encode "warnings/undeclared-protocol-symbol",
                                                  :name-encode "undeclared-protocol-symbol",
                                                  :history [["+"
                                                             "0.0-2014"]]},
           "cljs.core/bit-flip" {:ns "cljs.core",
                                 :name "bit-flip",
                                 :signature ["[x n]"],
                                 :name-encode "bit-flip",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/bit-flip",
                                 :source {:code "(defn bit-flip\n  [x n]\n  (cljs.core/bit-flip x n))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2112 2115]},
                                 :extra-sources [{:code "(defmacro ^::ana/numeric bit-flip [x n]\n  (core/list 'js* \"(~{} ^ (1 << ~{}))\" x n))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [520 521]}],
                                 :full-name "cljs.core/bit-flip",
                                 :docstring "Flip bit at index n"},
           "cljs.test/deftest" {:ns "cljs.test",
                                :name "deftest",
                                :signature ["[name & body]"],
                                :name-encode "deftest",
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/deftest",
                                :source {:code "(defmacro deftest\n  [name & body]\n  (when ana/*load-tests*\n    `(do\n       (def ~(vary-meta name assoc :test `(fn [] ~@body))\n         (fn [] (cljs.test/test-var (.-cljs$lang$var ~name))))\n       (set! (.-cljs$lang$var ~name) (var ~name)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/test.clj",
                                         :lines [204 220]},
                                :full-name "cljs.test/deftest",
                                :docstring "Defines a test function with no arguments.  Test functions may call\nother tests, so tests may be composed.  If you compose tests, you\nshould also define a function named test-ns-hook; run-tests will\ncall test-ns-hook instead of testing all vars.\n\nNote: Actually, the test body goes in the :test metadata on the var,\nand the real function (the value of the var) calls test-var on\nitself.\n\nWhen cljs.analyzer/*load-tests* is false, deftest is ignored."},
           "cljs.core/ISet" {:ns "cljs.core",
                             :name "ISet",
                             :name-encode "ISet",
                             :implementations #{"PersistentTreeSet"
                                                "PersistentHashSet"},
                             :history [["+" "0.0-927"]],
                             :type "protocol",
                             :full-name-encode "cljs.core/ISet",
                             :source {:code "(defprotocol ISet\n  (^clj -disjoin [coll v]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [298 299]},
                             :methods [{:name "-disjoin",
                                        :signature ["[coll v]"],
                                        :docstring nil}],
                             :full-name "cljs.core/ISet"},
           "repl-options/working-dir" {:ns "repl-options",
                                       :name "working-dir",
                                       :name-encode "working-dir",
                                       :type "option",
                                       :full-name-encode "repl-options/working-dir",
                                       :full-name "repl-options/working-dir",
                                       :history [["+" "0.0-971"]]},
           "cljs.core/require" {:ns "cljs.core",
                                :name "require",
                                :name-encode "require",
                                :type "special form (repl)",
                                :full-name-encode "cljs.core/require",
                                :source {:code "(def default-special-fns\n  (let [load-file-fn\n        (fn self\n          ([repl-env env form]\n            (self repl-env env form nil))\n          ([repl-env env [_ file :as form] opts]\n            (load-file repl-env file opts)))]\n    {'in-ns\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ [quote ns-name] :as form] _]\n         ;; guard against craziness like '5 which wreaks havoc\n         (when-not (and (= quote 'quote) (symbol? ns-name))\n           (throw (IllegalArgumentException. \"Argument to in-ns must be a symbol.\")))\n         (when-not (ana/get-namespace ns-name)\n           (swap! env/*compiler* assoc-in [::ana/namespaces ns-name] {:name ns-name})\n           (-evaluate repl-env \"<cljs repl>\" 1\n             (str \"goog.provide('\" (comp/munge ns-name) \"');\")))\n         (set! ana/*cljs-ns* ns-name)))\n     'require\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'require-macros\n     (fn self\n       ([repl-env env form]\n         (self repl-env env form nil))\n       ([repl-env env [_ & specs :as form] opts]\n         (evaluate-form repl-env env \"<cljs repl>\"\n           (with-meta\n             `(~'ns ~ana/*cljs-ns*\n                (:require-macros\n                  ~@(map\n                      (fn [quoted-spec-or-kw]\n                        (if (keyword? quoted-spec-or-kw)\n                          quoted-spec-or-kw\n                          (second quoted-spec-or-kw)))\n                      specs)))\n             {:merge true :line 1 :column 1})\n           identity opts)))\n     'load-file load-file-fn\n     'clojure.core/load-file load-file-fn\n     'load-namespace\n     (fn self\n       ([repl-env env form]\n         (self env repl-env form nil))\n       ([repl-env env [_ ns :as form] opts]\n         (load-namespace repl-env ns opts)))}))",
                                         :title "repl specials table",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/repl.clj",
                                         :lines [275 336]},
                                :full-name "cljs.core/require",
                                :repl-only? true,
                                :history [["+" "0.0-2629"]]},
           "cljs.core/StringIter" {:ns "cljs.core",
                                   :name "StringIter",
                                   :signature ["[s i]"],
                                   :name-encode "StringIter",
                                   :type "type",
                                   :full-name-encode "cljs.core/StringIter",
                                   :source {:code "(deftype StringIter [s ^:mutable i]\n  Object\n  (hasNext [_] (< i (alength s)))\n  (next [_]\n    (let [ret (.charAt s i)]\n      (set! i (inc i))\n      ret))\n  (remove [_] (js/Error. \"Unsupported operation\")))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3065 3072]},
                                   :full-name "cljs.core/StringIter",
                                   :history [["+" "0.0-2301"]]},
           "cljs.core/LazySeq" {:protocols #{"ISeqable"
                                             "IMeta"
                                             "IWithMeta"
                                             "IEmptyableCollection"
                                             "IReduce"
                                             "ISequential"
                                             "ISeq"
                                             "ICollection"
                                             "IHash"
                                             "IPrintWithWriter"
                                             "INext"
                                             "IEquiv"},
                                :ns "cljs.core",
                                :name "LazySeq",
                                :signature ["[meta fn s __hash]"],
                                :name-encode "LazySeq",
                                :history [["+" "0.0-927"]],
                                :type "type",
                                :full-name-encode "cljs.core/LazySeq",
                                :source {:code "(deftype LazySeq [meta ^:mutable fn ^:mutable s ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  (sval [coll]\n    (if (nil? fn)\n      s\n      (do\n        (set! s (fn))\n        (set! fn nil)\n        s)))\n\n  IWithMeta\n  (-with-meta [coll meta] (LazySeq. meta fn s __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISeq\n  (-first [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (first s)))\n  (-rest [coll]\n    (-seq coll)\n    (if-not (nil? s)\n      (rest s)\n      ()))\n\n  INext\n  (-next [coll]\n    (-seq coll)\n    (when-not (nil? s)\n      (next s)))\n\n  ICollection\n  (-conj [coll o] (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (.sval coll)\n    (when-not (nil? s)\n      (loop [ls s]\n        (if (instance? LazySeq ls)\n          (recur (.sval ls))\n          (do (set! s ls)\n            (seq s))))))\n\n  IReduce\n  (-reduce [coll f] (seq-reduce f coll))\n  (-reduce [coll f start] (seq-reduce f start coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2551 2613]},
                                :full-name "cljs.core/LazySeq"},
           "cljs.core/pop!" {:ns "cljs.core",
                             :name "pop!",
                             :signature ["[tcoll]"],
                             :name-encode "popBANG",
                             :history [["+" "0.0-1211"]],
                             :type "function",
                             :full-name-encode "cljs.core/popBANG",
                             :source {:code "(defn pop!\n  [tcoll]\n  (-pop! tcoll))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2958 2962]},
                             :full-name "cljs.core/pop!",
                             :docstring "Removes the last item from a transient vector. If\nthe collection is empty, throws an exception. Returns coll"},
           "cljs.reader/parse-timestamp" {:ns "cljs.reader",
                                          :name "parse-timestamp",
                                          :signature ["[ts]"],
                                          :name-encode "parse-timestamp",
                                          :type "function",
                                          :full-name-encode "cljs.reader/parse-timestamp",
                                          :source {:code "(defn parse-timestamp\n  [ts]\n  (if-let [[years months days hours minutes seconds ms offset]\n           (parse-and-validate-timestamp ts)]\n    (js/Date.\n     (- (.UTC js/Date years (dec months) days hours minutes seconds ms)\n        (* offset 60 1000)))\n    (reader-error nil (str \"Unrecognized date/time syntax: \" ts))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/cljs/reader.cljs",
                                                   :lines [517 524]},
                                          :full-name "cljs.reader/parse-timestamp",
                                          :history [["+" "0.0-1424"]]},
           "compiler-options/source-map-timestamp" {:ns "compiler-options",
                                                    :name "source-map-timestamp",
                                                    :name-encode "source-map-timestamp",
                                                    :type "option",
                                                    :full-name-encode "compiler-options/source-map-timestamp",
                                                    :full-name "compiler-options/source-map-timestamp",
                                                    :history [["+"
                                                               "0.0-2505"]]},
           "cljs.repl.rhino/IEval" {:ns "cljs.repl.rhino",
                                    :name "IEval",
                                    :name-encode "IEval",
                                    :type "protocol",
                                    :full-name-encode "cljs.repl.rhino/IEval",
                                    :source {:code "(defprotocol IEval\n  (-eval [this env filename line]))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/repl/rhino.clj",
                                             :lines [29 30]},
                                    :methods [{:name "-eval",
                                               :signature ["[this env filename line]"],
                                               :docstring nil}],
                                    :full-name "cljs.repl.rhino/IEval",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/chunk-first" {:ns "cljs.core",
                                    :name "chunk-first",
                                    :signature ["[s]"],
                                    :name-encode "chunk-first",
                                    :type "function",
                                    :full-name-encode "cljs.core/chunk-first",
                                    :source {:code "(defn chunk-first [s]\n  (-chunked-first s))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2743 2744]},
                                    :full-name "cljs.core/chunk-first",
                                    :history [["+" "0.0-1424"]]},
           "cljs.core/ChunkedSeq" {:protocols #{"IChunkedNext"
                                                "ISeqable"
                                                "IMeta"
                                                "IWithMeta"
                                                "IEmptyableCollection"
                                                "IReduce"
                                                "ISequential"
                                                "ISeq"
                                                "ICollection"
                                                "IHash"
                                                "ASeq"
                                                "IPrintWithWriter"
                                                "IChunkedSeq"
                                                "INext"
                                                "IEquiv"},
                                   :ns "cljs.core",
                                   :name "ChunkedSeq",
                                   :signature ["[vec node i off meta __hash]"],
                                   :name-encode "ChunkedSeq",
                                   :history [["+" "0.0-1424"]],
                                   :type "type",
                                   :full-name-encode "cljs.core/ChunkedSeq",
                                   :source {:code "(deftype ChunkedSeq [vec node i off meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n\n  IWithMeta\n  (-with-meta [coll m]\n    (chunked-seq vec node i off m))\n  IMeta\n  (-meta [coll] meta)\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ASeq\n  ISeq\n  (-first [coll]\n    (aget node off))\n  (-rest [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          ()\n          s))\n      (-chunked-rest coll)))\n\n  INext\n  (-next [coll]\n    (if (< (inc off) (alength node))\n      (let [s (chunked-seq vec node i (inc off))]\n        (if (nil? s)\n          nil\n          s))\n      (-chunked-next coll)))\n\n  ICollection\n  (-conj [coll o]\n    (cons o coll))\n\n  IEmptyableCollection\n  (-empty [coll]\n    (with-meta (.-EMPTY PersistentVector) meta))\n\n  IChunkedSeq\n  (-chunked-first [coll]\n    (array-chunk node off))\n  (-chunked-rest [coll]\n    (let [end (+ i (alength node))]\n      (if (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0)\n        ())))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (let [end (+ i (alength node))]\n      (when (< end (-count vec))\n        (chunked-seq vec (unchecked-array-for vec end) end 0))))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash))\n\n  IReduce\n  (-reduce [coll f]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f))\n\n  (-reduce [coll f start]\n    (ci-reduce (subvec vec (+ i off) (count vec)) f start)))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [4489 4561]},
                                   :full-name "cljs.core/ChunkedSeq"},
           "cljs.test/testing" {:ns "cljs.test",
                                :name "testing",
                                :signature ["[string & body]"],
                                :name-encode "testing",
                                :history [["+" "0.0-2496"]],
                                :type "macro",
                                :full-name-encode "cljs.test/testing",
                                :source {:code "(defmacro testing\n  ([string & body]\n   `(do\n      (cljs.test/update-current-env! [:testing-contexts] conj ~string)\n      (let [ret# (do ~@body)]\n        (cljs.test/update-current-env! [:testing-contexts] rest)\n        ret#))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/test.clj",
                                         :lines [191 199]},
                                :full-name "cljs.test/testing",
                                :docstring "Adds a new string to the list of testing contexts.  May be nested,\nbut must occur inside a test function (deftest)."},
           "cljs.analyzer.api/resolve" {:ns "cljs.analyzer.api",
                                        :name "resolve",
                                        :signature ["[env sym]"],
                                        :name-encode "resolve",
                                        :history [["+" "0.0-2496"]],
                                        :type "function",
                                        :full-name-encode "cljs.analyzer.api/resolve",
                                        :source {:code "(defn resolve\n  [env sym]\n  {:pre [(map? env) (symbol? sym)]}\n  (try\n    (ana/resolve-var env sym\n      (ana/confirm-var-exists-throw))\n    (catch Exception e)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/analyzer/api.clj",
                                                 :lines [14 22]},
                                        :full-name "cljs.analyzer.api/resolve",
                                        :docstring "Given an analysis environment resolve a var. Analogous to\nclojure.core/resolve"},
           "cljs.repl.browser/start-server" {:ns "cljs.repl.browser",
                                             :name "start-server",
                                             :signature ["[opts]"],
                                             :name-encode "start-server",
                                             :history [["+" "0.0-927"]
                                                       ["-"
                                                        "0.0-1503"]],
                                             :type "function",
                                             :full-name-encode "cljs.repl.browser/start-server",
                                             :source {:code "(defn start-server\n  [opts]\n  (let [ss (ServerSocket. (:port opts))]\n    (future (server-loop opts ss))\n    (swap! server-state (fn [old] (assoc old :socket ss :port (:port opts))))))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r1450",
                                                      :filename "src/clj/cljs/repl/browser.clj",
                                                      :lines [265 270]},
                                             :full-name "cljs.repl.browser/start-server",
                                             :docstring "Start the server on the specified port.",
                                             :removed {:in "0.0-1503",
                                                       :last-seen "0.0-1450"}},
           "cljs.core/*2" {:ns "cljs.core",
                           :name "*2",
                           :name-encode "STAR2",
                           :type "var",
                           :full-name-encode "cljs.core/STAR2",
                           :source {:code "(def\n  ^{:doc \"bound in a repl thread to the second most recent value printed\"}\n  *2)",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [63 65]},
                           :full-name "cljs.core/*2",
                           :docstring "bound in a repl thread to the second most recent value printed",
                           :history [["+" "0.0-927"]]},
           "cljs.repl.server/send-and-close" {:ns "cljs.repl.server",
                                              :name "send-and-close",
                                              :signature ["[conn status form]"
                                                          "[conn status form content-type]"],
                                              :name-encode "send-and-close",
                                              :history [["+"
                                                         "0.0-1503"]],
                                              :type "function",
                                              :full-name-encode "cljs.repl.server/send-and-close",
                                              :source {:code "(defn send-and-close\n  ([conn status form]\n    (send-and-close conn status form \"text/html\"))\n  ([conn status form content-type]\n    (let [utf-8-form (.getBytes form \"UTF-8\")\n          content-length (count utf-8-form)\n          headers (map #(.getBytes (str % \"\\r\\n\"))\n                    [(status-line status)\n                     \"Server: ClojureScript REPL\"\n                     (str \"Content-Type: \"\n                       content-type\n                       \"; charset=utf-8\")\n                     (str \"Content-Length: \" content-length)\n                     \"\"])]\n      (with-open [os (.getOutputStream conn)]\n        (doseq [header headers]\n          (.write os header 0 (count header)))\n        (.write os utf-8-form 0 content-length)\n        (.flush os)\n        (.close conn)))))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2760",
                                                       :filename "src/clj/cljs/repl/server.clj",
                                                       :lines [109
                                                               130]},
                                              :full-name "cljs.repl.server/send-and-close",
                                              :docstring "Use the passed connection to send a form to the browser. Send a\nproper HTTP response."},
           "compiler-options/compiler-stats" {:ns "compiler-options",
                                              :name "compiler-stats",
                                              :name-encode "compiler-stats",
                                              :type "option",
                                              :full-name-encode "compiler-options/compiler-stats",
                                              :full-name "compiler-options/compiler-stats",
                                              :history [["+"
                                                         "0.0-2629"]]},
           "clojure.browser.event/total-listener-count" {:ns "clojure.browser.event",
                                                         :name "total-listener-count",
                                                         :signature ["[]"],
                                                         :name-encode "total-listener-count",
                                                         :type "function",
                                                         :full-name-encode "clojure.browser.event/total-listener-count",
                                                         :source {:code "(defn total-listener-count []\n  (events/getTotalListenerCount))",
                                                                  :title "Source code",
                                                                  :repo "clojurescript",
                                                                  :tag "r2760",
                                                                  :filename "src/cljs/clojure/browser/event.cljs",
                                                                  :lines [87
                                                                          88]},
                                                         :full-name "clojure.browser.event/total-listener-count",
                                                         :history [["+"
                                                                    "0.0-927"]]},
           "cljs.core/MultiStepper" {:ns "cljs.core",
                                     :name "MultiStepper",
                                     :signature ["[xform iters nexts]"],
                                     :name-encode "MultiStepper",
                                     :type "type",
                                     :full-name-encode "cljs.core/MultiStepper",
                                     :source {:code "(deftype MultiStepper [xform iters nexts]\n  Object\n  (hasNext [_]\n    (loop [iters (seq iters)]\n      (if-not (nil? iters)\n        (let [iter (first iters)]\n          (if-not (.hasNext iter)\n            false\n            (recur (next iters))))\n        true)))\n  (next [_]\n    (dotimes [i (alength iters)]\n      (aset nexts i (.next (aget iters i))))\n    (prim-seq nexts 0))\n  (step [this lt]\n    (loop []\n      (if (and (not (nil? (.-stepper lt)))\n               (.hasNext this))\n        (if (reduced? (apply xform (cons lt (.next this))))\n          (when-not (nil? (.-rest lt))\n            (set! (.. lt -rest -stepper) nil))\n          (recur))))\n    (when-not (nil? (.-stepper lt))\n      (xform lt))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [3156 3179]},
                                     :full-name "cljs.core/MultiStepper",
                                     :history [["+" "0.0-2301"]]},
           "cljs.core/alter-meta!" {:ns "cljs.core",
                                    :name "alter-meta!",
                                    :signature ["[iref f & args]"],
                                    :name-encode "alter-metaBANG",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.core/alter-metaBANG",
                                    :source {:code "(defn alter-meta!\n  [iref f & args]\n  (set! (.-meta iref) (apply f (.-meta iref) args)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [8451 8458]},
                                    :full-name "cljs.core/alter-meta!",
                                    :docstring "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n(apply f its-current-meta args)\n\nf must be free of side-effects"},
           "clojure.browser.dom/click-element" {:ns "clojure.browser.dom",
                                                :name "click-element",
                                                :signature ["[e]"],
                                                :name-encode "click-element",
                                                :type "function",
                                                :full-name-encode "clojure.browser.dom/click-element",
                                                :source {:code "(defn click-element\n  [e]\n  (.click (ensure-element e) ()))",
                                                         :title "Source code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/clojure/browser/dom.cljs",
                                                         :lines [147
                                                                 149]},
                                                :full-name "clojure.browser.dom/click-element",
                                                :history [["+"
                                                           "0.0-927"]]},
           "cljs.core/seq-iter" {:ns "cljs.core",
                                 :name "seq-iter",
                                 :signature ["[coll]"],
                                 :name-encode "seq-iter",
                                 :type "function",
                                 :full-name-encode "cljs.core/seq-iter",
                                 :source {:code "(defn seq-iter [coll]\n  (SeqIter. INIT coll))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [3110 3111]},
                                 :full-name "cljs.core/seq-iter",
                                 :history [["+" "0.0-2301"]]},
           "closure-warnings/constant-property" {:ns "closure-warnings",
                                                 :name "constant-property",
                                                 :type "warning",
                                                 :full-name "closure-warnings/constant-property",
                                                 :full-name-encode "closure-warnings/constant-property",
                                                 :name-encode "constant-property",
                                                 :history [["+"
                                                            "0.0-2120"]]},
           "cljs.core/unchecked-remainder-int" {:ns "cljs.core",
                                                :name "unchecked-remainder-int",
                                                :signature ["[x n]"],
                                                :name-encode "unchecked-remainder-int",
                                                :history [["+"
                                                           "0.0-1798"]],
                                                :type "function/macro",
                                                :full-name-encode "cljs.core/unchecked-remainder-int",
                                                :source {:code "(defn unchecked-remainder-int [x n]\n  (cljs.core/unchecked-remainder-int x n))",
                                                         :title "Function code",
                                                         :repo "clojurescript",
                                                         :tag "r2760",
                                                         :filename "src/cljs/cljs/core.cljs",
                                                         :lines [2010
                                                                 2011]},
                                                :extra-sources [{:code "(defmacro ^::ana/numeric unchecked-remainder-int\n  ([x n] `(mod ~x ~n)))",
                                                                 :title "Macro code",
                                                                 :repo "clojurescript",
                                                                 :tag "r2760",
                                                                 :filename "src/clj/cljs/core.clj",
                                                                 :lines [405
                                                                         406]}],
                                                :full-name "cljs.core/unchecked-remainder-int"},
           "cljs.core/bit-shift-right-zero-fill" {:ns "cljs.core",
                                                  :name "bit-shift-right-zero-fill",
                                                  :signature ["[x n]"],
                                                  :name-encode "bit-shift-right-zero-fill",
                                                  :history [["+"
                                                             "0.0-1211"]],
                                                  :type "function/macro",
                                                  :full-name-encode "cljs.core/bit-shift-right-zero-fill",
                                                  :source {:code "(defn bit-shift-right-zero-fill\n  [x n] (cljs.core/bit-shift-right-zero-fill x n))",
                                                           :title "Function code",
                                                           :repo "clojurescript",
                                                           :tag "r2760",
                                                           :filename "src/cljs/cljs/core.cljs",
                                                           :lines [2139
                                                                   2141]},
                                                  :extra-sources [{:code "(defmacro ^::ana/numeric bit-shift-right-zero-fill [x n]\n  (core/list 'js* \"(~{} >>> ~{})\" x n))",
                                                                   :title "Macro code",
                                                                   :repo "clojurescript",
                                                                   :tag "r2760",
                                                                   :filename "src/clj/cljs/core.clj",
                                                                   :lines [532
                                                                           533]}],
                                                  :full-name "cljs.core/bit-shift-right-zero-fill",
                                                  :docstring "DEPRECATED: Bitwise shift right with zero fill"},
           "cljs.core/when-some" {:ns "cljs.core",
                                  :name "when-some",
                                  :signature ["[bindings & body]"],
                                  :name-encode "when-some",
                                  :history [["+" "0.0-2261"]],
                                  :type "macro",
                                  :full-name-encode "cljs.core/when-some",
                                  :source {:code "(defmacro when-some\n  [bindings & body]\n  (assert-args\n     (vector? bindings) \"a vector for its binding\"\n     (= 2 (count bindings)) \"exactly 2 forms in binding vector\")\n   (let [form (bindings 0) tst (bindings 1)]\n    `(let [temp# ~tst]\n       (if (nil? temp#)\n         nil\n         (let [~form temp#]\n           ~@body)))))",
                                           :title "Source code",
                                           :repo "clojure",
                                           :tag "clojure-1.6.0",
                                           :filename "src/clj/clojure/core.clj",
                                           :lines [1776 1791]},
                                  :full-name "cljs.core/when-some",
                                  :docstring "bindings => binding-form test\n\nWhen test is not nil, evaluates body with binding-form bound to the\nvalue of test"},
           "cljs.repl.browser/server-loop" {:ns "cljs.repl.browser",
                                            :name "server-loop",
                                            :signature ["[opts server-socket]"],
                                            :name-encode "server-loop",
                                            :history [["+" "0.0-927"]
                                                      ["-" "0.0-1503"]],
                                            :type "function",
                                            :full-name-encode "cljs.repl.browser/server-loop",
                                            :source {:code "(defn server-loop\n  [opts server-socket]\n  (let [conn (.accept server-socket)]\n    (do (.setKeepAlive conn true)\n        (future (handle-connection opts conn))\n        (recur opts server-socket))))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r1450",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [258 263]},
                                            :full-name "cljs.repl.browser/server-loop",
                                            :removed {:in "0.0-1503",
                                                      :last-seen "0.0-1450"}},
           "cljs.reader/read-meta" {:ns "cljs.reader",
                                    :name "read-meta",
                                    :signature ["[rdr _]"],
                                    :name-encode "read-meta",
                                    :type "function",
                                    :full-name-encode "cljs.reader/read-meta",
                                    :source {:code "(defn read-meta\n  [rdr _]\n  (let [m (desugar-meta (read rdr true nil true))]\n    (when-not (map? m)\n      (reader-error rdr \"Metadata must be Symbol,Keyword,String or Map\"))\n    (let [o (read rdr true nil true)]\n      (if (satisfies? IWithMeta o)\n        (with-meta o (merge (meta o) m))\n        (reader-error rdr \"Metadata can only be applied to IWithMetas\")))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [371 379]},
                                    :full-name "cljs.reader/read-meta",
                                    :history [["+" "0.0-927"]]},
           "cljs.repl.server/send-404" {:ns "cljs.repl.server",
                                        :name "send-404",
                                        :signature ["[conn path]"],
                                        :name-encode "send-404",
                                        :type "function",
                                        :full-name-encode "cljs.repl.server/send-404",
                                        :source {:code "(defn send-404 [conn path]\n  (send-and-close conn 404\n    (str\n      \"<html><body>\"\n      \"<h2>Page not found</h2>\"\n      \"No page \" path \" found on this server.\"\n      \"</body></html>\")\n    \"text/html\"))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/repl/server.clj",
                                                 :lines [132 139]},
                                        :full-name "cljs.repl.server/send-404",
                                        :history [["+" "0.0-1503"]]},
           "syntax/ignore" {:syntax-equiv {:edn-url nil, :clj-url nil},
                            :ns "syntax",
                            :name "ignore",
                            :name-encode "ignore",
                            :type "syntax",
                            :full-name-encode "syntax/ignore",
                            :extra-sources ({:code "(defn- read-discard\n  [rdr _]\n  (doto rdr\n    (read true nil true)))",
                                             :title "Reader code",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [375 378]}
                                            {:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                             :title "Reader table",
                                             :repo "tools.reader",
                                             :tag "tools.reader-0.8.10",
                                             :filename "src/main/clojure/clojure/tools/reader.clj",
                                             :lines [612 623]}),
                            :full-name "syntax/ignore",
                            :history [["+" "0.0-1853"]]},
           "syntax/destructure-vector" {:syntax-equiv {:edn-url nil,
                                                       :clj-url nil},
                                        :ns "syntax",
                                        :name "destructure-vector",
                                        :name-encode "destructure-vector",
                                        :type "binding",
                                        :full-name-encode "syntax/destructure-vector",
                                        :source {:code "(defn destructure [bindings]\n  (core/let [bents (partition 2 bindings)\n         pb (fn pb [bvec b v]\n              (core/let [pvec\n                     (fn [bvec b val]\n                       (core/let [gvec (gensym \"vec__\")]\n                         (core/loop [ret (-> bvec (conj gvec) (conj val))\n                                     n 0\n                                     bs b\n                                     seen-rest? false]\n                           (if (seq bs)\n                             (core/let [firstb (first bs)]\n                               (core/cond\n                                 (= firstb '&) (recur (pb ret (second bs) (core/list `nthnext gvec n))\n                                                      n\n                                                      (nnext bs)\n                                                      true)\n                                 (= firstb :as) (pb ret (second bs) gvec)\n                                 :else (if seen-rest?\n                                         (throw (new Exception \"Unsupported binding form, only :as can follow & parameter\"))\n                                         (recur (pb ret firstb (core/list `nth gvec n nil))\n                                                (core/inc n)\n                                                (next bs)\n                                                seen-rest?))))\n                             ret))))\n                     pmap\n                     (fn [bvec b v]\n                       (core/let [gmap (gensym \"map__\")\n                                  defaults (:or b)]\n                         (core/loop [ret (-> bvec (conj gmap) (conj v)\n                                             (conj gmap) (conj `(if (seq? ~gmap) (apply core/hash-map ~gmap) ~gmap))\n                                             ((fn [ret]\n                                                (if (:as b)\n                                                  (conj ret (:as b) gmap)\n                                                  ret))))\n                                     bes (reduce\n                                          (fn [bes entry]\n                                            (reduce #(assoc %1 %2 ((val entry) %2))\n                                                    (dissoc bes (key entry))\n                                                    ((key entry) bes)))\n                                          (dissoc b :as :or)\n                                          {:keys #(if (core/keyword? %) % (keyword (core/str %))),\n                                           :strs core/str, :syms #(core/list `quote %)})]\n                           (if (seq bes)\n                             (core/let [bb (key (first bes))\n                                        bk (val (first bes))\n                                        has-default (contains? defaults bb)]\n                               (recur (pb ret bb (if has-default\n                                                   (core/list `get gmap bk (defaults bb))\n                                                   (core/list `get gmap bk)))\n                                      (next bes)))\n                             ret))))]\n                    (core/cond\n                      (core/symbol? b) (-> bvec (conj (if (namespace b) (symbol (name b)) b)) (conj v))\n                      (core/keyword? b) (-> bvec (conj (symbol (name b))) (conj v))\n                      (vector? b) (pvec bvec b v)\n                      (map? b) (pmap bvec b v)\n                      :else (throw (new Exception (core/str \"Unsupported binding form: \" b))))))\n         process-entry (fn [bvec b] (pb bvec (first b) (second b)))]\n        (if (every? core/symbol? (map first bents))\n          bindings\n          (if-let [kwbs (seq (filter #(core/keyword? (first %)) bents))]\n            (throw (new Exception (core/str \"Unsupported binding key: \" (ffirst kwbs))))\n            (reduce process-entry [] bents)))))",
                                                 :title "Parser code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/clj/cljs/core.clj",
                                                 :lines [82 145]},
                                        :full-name "syntax/destructure-vector",
                                        :history [["+" "0.0-927"]]},
           "cljs.core/range" {:ns "cljs.core",
                              :name "range",
                              :signature ["[]"
                                          "[end]"
                                          "[start end]"
                                          "[start end step]"],
                              :name-encode "range",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/range",
                              :source {:code "(defn range\n  ([] (range 0 (.-MAX-VALUE js/Number) 1))\n  ([end] (range 0 end 1))\n  ([start end] (range start end 1))\n  ([start end step] (Range. nil start end step nil)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7896 7903]},
                              :full-name "cljs.core/range",
                              :docstring "Returns a lazy seq of nums from start (inclusive) to end\n(exclusive), by step, where start defaults to 0, step to 1,\nand end to infinity."},
           "cljs.repl.browser/read-post" {:ns "cljs.repl.browser",
                                          :name "read-post",
                                          :signature ["[line rdr]"],
                                          :name-encode "read-post",
                                          :history [["+" "0.0-927"]
                                                    ["-" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.browser/read-post",
                                          :source {:code "(defn read-post [line rdr]\n  (let [[_ path _] (str/split line #\" \")\n        headers (parse-headers (read-headers rdr))\n        content-length (Integer/parseInt (:content-length headers))\n        content (char-array content-length)]\n    (io! (.read rdr content 0 content-length)\n         {:method :post\n          :path path\n          :headers headers\n          :content (String. content)})))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r1450",
                                                   :filename "src/clj/cljs/repl/browser.clj",
                                                   :lines [143 152]},
                                          :full-name "cljs.repl.browser/read-post",
                                          :removed {:in "0.0-1503",
                                                    :last-seen "0.0-1450"}},
           "cljs.core/reify" {:ns "cljs.core",
                              :name "reify",
                              :signature ["[& impls]"],
                              :name-encode "reify",
                              :type "macro",
                              :full-name-encode "cljs.core/reify",
                              :source {:code "(defmacro reify [& impls]\n  (let [t        (with-meta (gensym \"t\") {:anonymous true})\n        meta-sym (gensym \"meta\")\n        this-sym (gensym \"_\")\n        locals   (keys (:locals &env))\n        ns       (-> &env :ns :name)\n        munge    cljs.compiler/munge]\n    `(do\n       (when-not (exists? ~(symbol (core/str ns) (core/str t)))\n         (deftype ~t [~@locals ~meta-sym]\n           IWithMeta\n           (~'-with-meta [~this-sym ~meta-sym]\n             (new ~t ~@locals ~meta-sym))\n           IMeta\n           (~'-meta [~this-sym] ~meta-sym)\n           ~@impls))\n       (new ~t ~@locals ~(meta &form)))))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/clj/cljs/core.clj",
                                       :lines [613 629]},
                              :full-name "cljs.core/reify",
                              :history [["+" "0.0-927"]]},
           "cljs.core/satisfies?" {:ns "cljs.core",
                                   :name "satisfies?",
                                   :signature ["[psym x]"],
                                   :name-encode "satisfiesQMARK",
                                   :history [["+" "0.0-927"]],
                                   :type "macro",
                                   :full-name-encode "cljs.core/satisfiesQMARK",
                                   :source {:code "(defmacro satisfies?\n  [psym x]\n  (let [p          (:name\n                     (cljs.analyzer/resolve-var\n                       (dissoc &env :locals) psym))\n         prefix     (protocol-prefix p)\n         xsym       (bool-expr (gensym))\n         [part bit] (fast-path-protocols p)\n         msym       (symbol\n                      (core/str \"-cljs$lang$protocol_mask$partition\" part \"$\"))]\n    `(let [~xsym ~x]\n       (if ~xsym\n         (let [bit# ~(if bit `(unsafe-bit-and (. ~xsym ~msym) ~bit))]\n           (if (or bit#\n                 ~(bool-expr `(. ~xsym ~(symbol (core/str \"-\" prefix)))))\n             true\n             (if (coercive-not (. ~xsym ~msym))\n               (cljs.core/native-satisfies? ~psym ~xsym)\n               false)))\n         (cljs.core/native-satisfies? ~psym ~xsym)))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [1072 1092]},
                                   :full-name "cljs.core/satisfies?",
                                   :docstring "Returns true if x satisfies the protocol"},
           "cljs.core/nth" {:ns "cljs.core",
                            :name "nth",
                            :signature ["[coll n]"
                                        "[coll n not-found]"],
                            :name-encode "nth",
                            :history [["+" "0.0-927"]],
                            :type "function",
                            :full-name-encode "cljs.core/nth",
                            :source {:code "(defn nth\n  ([coll n]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number\"))\n\n      (nil? coll)\n      coll\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n)\n\n      (array? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (string? coll)\n      (when (< n (.-length coll))\n        (aget coll n))\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      (satisfies? ISeq coll)\n      (linear-traversal-nth coll n)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll)))))))\n  ([coll n not-found]\n    (cond\n      (not (number? n))\n      (throw (js/Error. \"index argument to nth must be a number.\"))\n\n      (nil? coll)\n      not-found\n\n      (implements? IIndexed coll)\n      (-nth ^not-native coll n not-found)\n\n      (array? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (string? coll)\n      (if (< n (.-length coll))\n        (aget coll n)\n        not-found)\n\n      (native-satisfies? IIndexed coll)\n      (-nth coll n)\n\n      (satisfies? ISeq coll)\n      (linear-traversal-nth coll n not-found)\n\n      :else\n      (throw (js/Error. (str \"nth not supported on this type \"\n                          (type->str (type coll))))))))",
                                     :title "Source code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/cljs/cljs/core.cljs",
                                     :lines [1248 1310]},
                            :full-name "cljs.core/nth",
                            :docstring "Returns the value at the index. get returns nil if index out of\nbounds, nth throws an exception unless not-found is supplied.  nth\nalso works for strings, arrays, regex Matchers and Lists, and,\nin O(n) time, for sequences."},
           "cljs.core/list" {:ns "cljs.core",
                             :name "list",
                             :signature ["[& xs]"],
                             :name-encode "list",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/list",
                             :source {:code "(defn list [& xs]\n  (let [arr (if (and (instance? IndexedSeq xs) (zero? (.-i xs)))\n              (.-arr xs)\n              (let [arr (array)]\n                (loop [^not-native xs xs]\n                  (if-not (nil? xs)\n                    (do\n                      (.push arr (-first xs))\n                      (recur (-next xs)))\n                    arr))))]\n    (loop [i (alength arr) ^not-native r ()]\n      (if (> i 0)\n        (recur (dec i) (-conj r (aget arr (dec i))))\n        r))))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2400 2413]},
                             :extra-sources [{:code "(defmacro list\n  ([] '(.-EMPTY cljs.core/List))\n  ([x & xs]\n    `(-conj (list ~@xs) ~x)))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [1414 1417]}],
                             :full-name "cljs.core/list"},
           "cljs.core/defn" {:ns "cljs.core",
                             :name "defn",
                             :signature ["[name doc-string? attr-map? [params*] prepost-map? body]"
                                         "[name doc-string? attr-map? ([params*] prepost-map? body) + attr-map?]"],
                             :name-encode "defn",
                             :history [["+" "0.0-927"]],
                             :type "macro",
                             :full-name-encode "cljs.core/defn",
                             :source {:code "(def \n\n ^{:doc \"Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.\"\n   :arglists '([name doc-string? attr-map? [params*] prepost-map? body]\n                [name doc-string? attr-map? ([params*] prepost-map? body)+ attr-map?])\n   :added \"1.0\"}\n defn (fn defn [&form &env name & fdecl]\n        ;; Note: Cannot delegate this check to def because of the call to (with-meta name ..)\n        (if (instance? clojure.lang.Symbol name)\n          nil\n          (throw (IllegalArgumentException. \"First argument to defn must be a symbol\")))\n        (let [m (if (string? (first fdecl))\n                  {:doc (first fdecl)}\n                  {})\n              fdecl (if (string? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              m (if (map? (first fdecl))\n                  (conj m (first fdecl))\n                  m)\n              fdecl (if (map? (first fdecl))\n                      (next fdecl)\n                      fdecl)\n              fdecl (if (vector? (first fdecl))\n                      (list fdecl)\n                      fdecl)\n              m (if (map? (last fdecl))\n                  (conj m (last fdecl))\n                  m)\n              fdecl (if (map? (last fdecl))\n                      (butlast fdecl)\n                      fdecl)\n              m (conj {:arglists (list 'quote (sigs fdecl))} m)\n              m (let [inline (:inline m)\n                      ifn (first inline)\n                      iname (second inline)]\n                  ;; same as: (if (and (= 'fn ifn) (not (symbol? iname))) ...)\n                  (if (if (clojure.lang.Util/equiv 'fn ifn)\n                        (if (instance? clojure.lang.Symbol iname) false true))\n                    ;; inserts the same fn name to the inline fn if it does not have one\n                    (assoc m :inline (cons ifn (cons (clojure.lang.Symbol/intern (.concat (.getName ^clojure.lang.Symbol name) \"__inliner\"))\n                                                     (next inline))))\n                    m))\n              m (conj (if (meta name) (meta name) {}) m)]\n          (list 'def (with-meta name m)\n                ;;todo - restore propagation of fn name\n                ;;must figure out how to convey primitive hints to self calls first\n                (cons `fn fdecl) ))))",
                                      :title "Source code",
                                      :repo "clojure",
                                      :tag "clojure-1.6.0",
                                      :filename "src/clj/clojure/core.clj",
                                      :lines [266 316]},
                             :full-name "cljs.core/defn",
                             :docstring "Same as (def name (fn [params* ] exprs*)) or (def\n name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n to the var metadata. prepost-map defines a map with optional keys\n :pre and :post that contain collections of pre or post conditions."},
           "cljs.core/rand-nth" {:ns "cljs.core",
                                 :name "rand-nth",
                                 :signature ["[coll]"],
                                 :name-encode "rand-nth",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/rand-nth",
                                 :source {:code "(defn rand-nth\n  [coll]\n  (nth coll (rand-int (count coll))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [8733 8738]},
                                 :full-name "cljs.core/rand-nth",
                                 :docstring "Return a random element of the (sequential) collection. Will have\nthe same performance characteristics as nth for the given\ncollection."},
           "cljs.core/ex-cause" {:ns "cljs.core",
                                 :name "ex-cause",
                                 :signature ["[ex]"],
                                 :name-encode "ex-cause",
                                 :history [["+" "0.0-1576"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/ex-cause",
                                 :source {:code "(defn ex-cause\n  [ex]\n  (when (instance? ExceptionInfo ex)\n    (.-cause ex)))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [9216 9223]},
                                 :full-name "cljs.core/ex-cause",
                                 :docstring "Alpha - subject to change.\nReturns exception cause (an Error / ExceptionInfo) if ex is an\nExceptionInfo.\nOtherwise returns nil."},
           "cljs.core/def" {:ns "cljs.core",
                            :name "def",
                            :type "special form",
                            :source {:code "(defmethod parse 'def\n  [op env form name _]\n  (let [pfn (fn\n              ([_ sym] {:sym sym})\n              ([_ sym init] {:sym sym :init init})\n              ([_ sym doc init] {:sym sym :doc doc :init init}))\n        args (apply pfn form)\n        sym (:sym args)\n        sym-meta (meta sym)\n        tag (-> sym meta :tag)\n        protocol (-> sym meta :protocol)\n        dynamic (-> sym meta :dynamic)\n        ns-name (-> env :ns :name)\n        locals (:locals env)]\n    (when (namespace sym)\n      (throw (error env \"Can't def ns-qualified name\")))\n    (when-let [doc (:doc args)]\n      (when-not (string? doc)\n        (throw (error env \"Too many arguments to def\"))))\n    (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n      (when (and (not *allow-redef*)\n                 (not (:declared v))\n                 (not (:declared sym-meta))\n                 (= (:file v) *cljs-file*)\n                 (not= \"<cljs repl>\" *cljs-file*))\n        (warning :redef-in-file env {:sym sym :line (:line v)})))\n    (let [env (if (or (and (not= ns-name 'cljs.core)\n                           (core-name? env sym))\n                      (get-in @env/*compiler* [::namespaces ns-name :uses sym]))\n                (let [ev (resolve-existing-var (dissoc env :locals) sym)]\n                  (warning :redef env {:sym sym :ns (:ns ev) :ns-name ns-name})\n                  (swap! env/*compiler* update-in [::namespaces ns-name :excludes] conj sym)\n                  (update-in env [:ns :excludes] conj sym))\n                env)\n          var-name (:name (resolve-var (dissoc env :locals) sym))\n          init-expr (when (contains? args :init)\n                      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n                        (merge\n                          {:name var-name}\n                          sym-meta\n                          (when dynamic {:dynamic true})\n                          (source-info var-name env)))\n                      (disallowing-recur\n                        (analyze (assoc env :context :expr) (:init args) sym)))\n          fn-var? (and init-expr (= (:op init-expr) :fn))\n          tag (if fn-var?\n                (or (:ret-tag init-expr) tag)\n                tag)\n          export-as (when-let [export-val (-> sym meta :export)]\n                      (if (= true export-val) var-name export-val))\n          doc (or (:doc args) (-> sym meta :doc))]\n      (when-let [v (get-in @env/*compiler* [::namespaces ns-name :defs sym])]\n        (when (and (not (-> sym meta :declared))\n                   (and (:fn-var v) (not fn-var?)))\n          (warning :fn-var env {:ns-name ns-name :sym sym})))\n      (swap! env/*compiler* assoc-in [::namespaces ns-name :defs sym]\n        (merge \n          {:name var-name}\n          ;; elide test metadata, as it includes non-valid EDN - David\n          (cond-> sym-meta\n            :test (-> (dissoc :test) (assoc :test true)))\n          (when doc {:doc doc})\n          (when dynamic {:dynamic true})\n          (source-info var-name env)\n          ;; the protocol a protocol fn belongs to\n          (when protocol\n            {:protocol protocol})\n          ;; symbol for reified protocol\n          (when-let [protocol-symbol (-> sym meta :protocol-symbol)]\n            {:protocol-symbol protocol-symbol\n             :info (-> protocol-symbol meta :protocol-info)\n             :impls #{}})\n          (when fn-var?\n            (let [params (map #(vec (map :name (:params %))) (:methods init-expr))]\n              {:fn-var true\n               ;; protocol implementation context\n               :protocol-impl (:protocol-impl init-expr)\n               ;; inline protocol implementation context\n               :protocol-inline (:protocol-inline init-expr)\n               :variadic (:variadic init-expr)\n               :max-fixed-arity (:max-fixed-arity init-expr)\n               :method-params params\n               :arglists (:arglists sym-meta)\n               :arglists-meta (doall (map meta (:arglists sym-meta)))\n               :methods (map (fn [method]\n                               (let [tag (infer-tag env (assoc method :op :method))]\n                                 (cond-> (select-keys method\n                                           [:max-fixed-arity :variadic])\n                                   tag (assoc :tag tag))))\n                          (:methods init-expr))}) )\n          (when (and fn-var? tag)\n            {:ret-tag tag})))\n      (merge {:env env :op :def :form form\n              :name var-name\n              :var (assoc\n                     (analyze\n                       (-> env (dissoc :locals)\n                         (assoc :context :expr)\n                         (assoc :def-var true))\n                       sym)\n                     :op :var)\n              :doc doc :init init-expr}\n        (when-let [test (:test sym-meta)]\n          {:test (analyze (assoc env :context :expr) test)})\n        (when tag\n          (if fn-var?\n            {:ret-tag tag}\n            {:tag tag}))\n        (when dynamic {:dynamic true})\n        (when export-as {:export export-as})\n        (when init-expr {:children [init-expr]})))))",
                                     :title "Parser code",
                                     :repo "clojurescript",
                                     :tag "r2760",
                                     :filename "src/clj/cljs/analyzer.clj",
                                     :lines [662 772]},
                            :extra-sources ({:code "(defmethod emit* :def\n  [{:keys [name var init env doc export test]}]\n  (let [mname (munge name)]\n    (when init\n      (emit-comment doc (:jsdoc init))\n      (emits var)\n      (emits \" = \" init)\n      ;; NOTE: JavaScriptCore does not like this under advanced compilation\n      ;; this change was primarily for REPL interactions - David\n      ;(emits \" = (typeof \" mname \" != 'undefined') ? \" mname \" : undefined\")\n      (when-not (= :expr (:context env)) (emitln \";\"))\n      (when export\n        (emitln \"goog.exportSymbol('\" (munge export) \"', \" mname \");\"))\n      (when (and ana/*load-tests* test)\n        (when (= :expr (:context env))\n          (emitln \";\"))\n        (emitln var \".cljs$lang$test = \" test \";\")))))",
                                             :title "Emitting code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/clj/cljs/compiler.clj",
                                             :lines [425 441]}),
                            :full-name "cljs.core/def",
                            :full-name-encode "cljs.core/def",
                            :name-encode "def",
                            :history [["+" "0.0-927"]]},
           "cljs.core/atom" {:ns "cljs.core",
                             :name "atom",
                             :signature ["[x]"
                                         "[x & {:keys [meta validator]}]"],
                             :name-encode "atom",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/atom",
                             :source {:code "(defn atom\n  ([x] (Atom. x nil nil nil))\n  ([x & {:keys [meta validator]}] (Atom. x meta validator nil)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [3516 3531]},
                             :full-name "cljs.core/atom",
                             :docstring "Creates and returns an Atom with an initial value of x and zero or\nmore options (in any order):\n\n:meta metadata-map\n\n:validator validate-fn\n\nIf metadata-map is supplied, it will be come the metadata on the\natom. validate-fn must be nil or a side-effect-free fn of one\nargument, which will be passed the intended new state on any state\nchange. If the new state is unacceptable, the validate-fn should\nreturn false or throw an Error.  If either of these error conditions\noccur, then the value of the atom will not change."},
           "cljs.reader/read-keyword" {:ns "cljs.reader",
                                       :name "read-keyword",
                                       :signature ["[reader initch]"],
                                       :name-encode "read-keyword",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-keyword",
                                       :source {:code "(defn read-keyword\n  [reader initch]\n  (let [token (read-token reader (read-char reader))\n        a (re-matches* symbol-pattern token)\n        token (aget a 0)\n        ns (aget a 1)\n        name (aget a 2)]\n    (if (or (and (not (undefined? ns))\n                 (identical? (. ns (substring (- (.-length ns) 2) (.-length ns))) \":/\"))\n            (identical? (aget name (dec (.-length name))) \":\")\n            (not (== (.indexOf token \"::\" 1) -1)))\n      (reader-error reader \"Invalid token: \" token)\n      (if (and (not (nil? ns)) (> (.-length ns) 0))\n        (keyword (.substring ns 0 (.indexOf ns \"/\")) name)\n        (keyword token)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [337 351]},
                                       :full-name "cljs.reader/read-keyword",
                                       :history [["+" "0.0-927"]]},
           "cljs.core/Vector" {:protocols #{"IFn"
                                            "ISeqable"
                                            "IMeta"
                                            "IWithMeta"
                                            "IStack"
                                            "IEmptyableCollection"
                                            "ICounted"
                                            "IReduce"
                                            "ILookup"
                                            "ISequential"
                                            "ICollection"
                                            "IHash"
                                            "IPrintWithWriter"
                                            "IIndexed"
                                            "IAssociative"
                                            "IVector"
                                            "IPrintable"
                                            "IEquiv"},
                               :ns "cljs.core",
                               :name "Vector",
                               :signature ["[meta array __hash]"],
                               :name-encode "Vector",
                               :history [["+" "0.0-927"]
                                         ["-" "0.0-1798"]],
                               :type "type",
                               :full-name-encode "cljs.core/Vector",
                               :source {:code "(deftype Vector [meta array ^:mutable __hash]\n  Object\n  (toString [this]\n    (pr-str this))\n\n  IWithMeta\n  (-with-meta [coll meta] (Vector. meta array __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  IStack\n  (-peek [coll]\n    (let [count (alength array)]\n      (when (> count 0)\n        (aget array (dec count)))))\n  (-pop [coll]\n    (if (> (alength array) 0)\n      (let [new-array (aclone array)]\n        (. new-array (pop))\n        (Vector. meta new-array nil))\n      (throw (js/Error. \"Can't pop empty vector\"))))\n\n  ICollection\n  (-conj [coll o]\n    (let [new-array (aclone array)]\n      (.push new-array o)\n      (Vector. meta new-array nil)))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta cljs.core.Vector/EMPTY meta))\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-coll __hash))\n\n  ISeqable\n  (-seq [coll]\n    (when (> (alength array) 0)\n      (let [vector-seq\n             (fn vector-seq [i]\n               (lazy-seq\n                 (when (< i (alength array))\n                   (cons (aget array i) (vector-seq (inc i))))))]\n        (vector-seq 0))))\n\n  ICounted\n  (-count [coll] (alength array))\n\n  IIndexed\n  (-nth [coll n]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      #_(throw (js/Error. (str \"No item \" n \" in vector of length \" (alength array))))))\n  (-nth [coll n not-found]\n    (if (and (<= 0 n) (< n (alength array)))\n      (aget array n)\n      not-found))\n\n  ILookup\n  (-lookup [coll k] (-nth coll k nil))\n  (-lookup [coll k not-found] (-nth coll k not-found))\n\n  IAssociative\n  (-assoc [coll k v]\n    (let [new-array (aclone array)]\n      (aset new-array k v)\n      (Vector. meta new-array nil)))\n\n  IVector\n  (-assoc-n [coll n val] (-assoc coll n val))\n\n  IReduce\n  (-reduce [v f]\n    (ci-reduce array f))\n  (-reduce [v f start]\n    (ci-reduce array f start))\n\n  IFn\n  (-invoke [coll k]\n    (-lookup coll k))\n  (-invoke [coll k not-found]\n    (-lookup coll k not-found)))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r1586",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [2772 2857]},
                               :full-name "cljs.core/Vector",
                               :removed {:in "0.0-1798",
                                         :last-seen "0.0-1586"}},
           "cljs.reader/skip-line" {:ns "cljs.reader",
                                    :name "skip-line",
                                    :signature ["[reader _]"],
                                    :name-encode "skip-line",
                                    :history [["+" "0.0-927"]],
                                    :type "function",
                                    :full-name-encode "cljs.reader/skip-line",
                                    :source {:code "(defn skip-line\n  [reader _]\n  (loop []\n    (let [ch (read-char reader)]\n      (if (or (identical? ch \\newline) (identical? ch \\return) (nil? ch))\n        reader\n        (recur)))))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/reader.cljs",
                                             :lines [89 96]},
                                    :full-name "cljs.reader/skip-line",
                                    :docstring "Advances the reader to the end of a line. Returns the reader"},
           "cljs.core/namespace" {:ns "cljs.core",
                                  :name "namespace",
                                  :signature ["[x]"],
                                  :name-encode "namespace",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/namespace",
                                  :source {:code "(defn namespace\n  [x]\n  (if (implements? INamed x)\n    (-namespace ^not-native x)\n    (throw (js/Error. (str \"Doesn't support namespace: \" x)))))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [2529 2534]},
                                  :full-name "cljs.core/namespace",
                                  :docstring "Returns the namespace String of a symbol or keyword, or nil if not present."},
           "cljs.nodejs/require" {:ns "cljs.nodejs",
                                  :name "require",
                                  :name-encode "require",
                                  :type "var",
                                  :full-name-encode "cljs.nodejs/require",
                                  :source {:code "(def require (js* \"require\"))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/nodejs.cljs",
                                           :lines [15]},
                                  :full-name "cljs.nodejs/require",
                                  :history [["+" "0.0-927"]]},
           "cljs.core/chunk-rest" {:ns "cljs.core",
                                   :name "chunk-rest",
                                   :signature ["[s]"],
                                   :name-encode "chunk-rest",
                                   :type "function",
                                   :full-name-encode "cljs.core/chunk-rest",
                                   :source {:code "(defn chunk-rest [s]\n  (-chunked-rest s))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [2746 2747]},
                                   :full-name "cljs.core/chunk-rest",
                                   :history [["+" "0.0-1424"]]},
           "cljs.core/unchecked-long" {:ns "cljs.core",
                                       :name "unchecked-long",
                                       :signature ["[x]"],
                                       :name-encode "unchecked-long",
                                       :history [["+" "0.0-1798"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/unchecked-long",
                                       :source {:code "(defn unchecked-long\n  [x]\n  (fix x))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [2047 2050]},
                                       :full-name "cljs.core/unchecked-long",
                                       :docstring "Coerce to long by stripping decimal places. Identical to `int'."},
           "cljs.repl.server/connection" {:ns "cljs.repl.server",
                                          :name "connection",
                                          :signature ["[]"],
                                          :name-encode "connection",
                                          :history [["+" "0.0-1503"]],
                                          :type "function",
                                          :full-name-encode "cljs.repl.server/connection",
                                          :source {:code "(defn connection\n  []\n  (let [p    (promise)\n        conn (:connection @state)]\n    (if (and conn (not (.isClosed conn)))\n      (do\n        (deliver p conn)\n        p)\n      (do\n        (swap! state (fn [old] (assoc old :promised-conn p)))\n        p))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/repl/server.clj",
                                                   :lines [14 26]},
                                          :full-name "cljs.repl.server/connection",
                                          :docstring "Promise to return a connection when one is available. If a\nconnection is not available, store the promise in server/state."},
           "clojure.browser.event/EventType" {:ns "clojure.browser.event",
                                              :name "EventType",
                                              :name-encode "EventType",
                                              :history [["+"
                                                         "0.0-927"]
                                                        ["-"
                                                         "0.0-2301"]],
                                              :type "protocol",
                                              :full-name-encode "clojure.browser.event/EventType",
                                              :source {:code "(defprotocol EventType\n  (event-types [this]))",
                                                       :title "Source code",
                                                       :repo "clojurescript",
                                                       :tag "r2280",
                                                       :filename "src/cljs/clojure/browser/event.cljs",
                                                       :lines [17 18]},
                                              :methods [{:name "event-types",
                                                         :signature ["[this]"],
                                                         :docstring nil}],
                                              :full-name "clojure.browser.event/EventType",
                                              :removed {:in "0.0-2301",
                                                        :last-seen "0.0-2280"}},
           "cljs.core/ranged-iterator" {:ns "cljs.core",
                                        :name "ranged-iterator",
                                        :signature ["[v start end]"],
                                        :name-encode "ranged-iterator",
                                        :type "function",
                                        :full-name-encode "cljs.core/ranged-iterator",
                                        :source {:code "(defn ranged-iterator [v start end]\n  (let [i start]\n    (RangedIterator. i (- i (js-mod i 32))\n      (when (< start (count v))\n        (unchecked-array-for v i))\n      v start end)))",
                                                 :title "Source code",
                                                 :repo "clojurescript",
                                                 :tag "r2760",
                                                 :filename "src/cljs/cljs/core.cljs",
                                                 :lines [4262 4267]},
                                        :full-name "cljs.core/ranged-iterator",
                                        :history [["+" "0.0-2371"]]},
           "cljs.repl.rhino/rhino-setup" {:ns "cljs.repl.rhino",
                                          :name "rhino-setup",
                                          :signature ["[repl-env opts]"],
                                          :name-encode "rhino-setup",
                                          :type "function",
                                          :full-name-encode "cljs.repl.rhino/rhino-setup",
                                          :source {:code "(defn rhino-setup [repl-env opts]\n  (let [env   (ana/empty-env)\n        scope (:scope repl-env)]\n    (ScriptableObject/putProperty scope \"__repl_opts\"\n      (Context/javaToJS opts scope))\n    (repl/load-file repl-env \"cljs/core.cljs\" opts)\n    (repl/evaluate-form repl-env env \"<cljs repl>\"\n      '(ns cljs.user))\n    (ScriptableObject/putProperty scope\n      \"out\" (Context/javaToJS *out* scope))\n    (binding [ana/*cljs-ns* 'cljs.core]\n      (repl/evaluate-form repl-env env \"<cljs repl>\"\n        '(do\n           (set! (.-isProvided_ js/goog) (fn [_] false))\n           (set! *print-fn* (fn [x] (.write js/out x))))))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/clj/cljs/repl/rhino.clj",
                                                   :lines [118 132]},
                                          :full-name "cljs.repl.rhino/rhino-setup",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/merge" {:ns "cljs.core",
                              :name "merge",
                              :signature ["[& maps]"],
                              :name-encode "merge",
                              :history [["+" "0.0-927"]],
                              :type "function",
                              :full-name-encode "cljs.core/merge",
                              :source {:code "(defn merge\n  [& maps]\n  (when (some identity maps)\n    (reduce #(conj (or %1 {}) %2) maps)))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/cljs/core.cljs",
                                       :lines [7309 7315]},
                              :full-name "cljs.core/merge",
                              :docstring "Returns a map that consists of the rest of the maps conj-ed onto\nthe first.  If a key occurs in more than one map, the mapping from\nthe latter (left-to-right) will be the mapping in the result."},
           "clojure.core.reducers/remove" {:ns "clojure.core.reducers",
                                           :name "remove",
                                           :signature ["[pred]"
                                                       "[pred coll]"],
                                           :name-encode "remove",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/remove",
                                           :source {:code "(defcurried remove\n  \"Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.\"\n  {}\n  [pred coll]\n  (filter (complement pred) coll))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [145 150]},
                                           :full-name "clojure.core.reducers/remove",
                                           :docstring "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable."},
           "cljs.build.api/src-file->goog-require" {:return-type String,
                                                    :ns "cljs.build.api",
                                                    :name "src-file->goog-require",
                                                    :signature ["[src]"
                                                                "[src options]"],
                                                    :name-encode "src-file-GTgoog-require",
                                                    :history [["+"
                                                               "0.0-2629"]],
                                                    :type "function",
                                                    :full-name-encode "cljs.build.api/src-file-GTgoog-require",
                                                    :source {:code "(defn ^String src-file->goog-require\n  ([src] (closure/src-file->goog-require src))\n  ([src options]\n    (closure/src-file->goog-require src options)))",
                                                             :title "Source code",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/clj/cljs/build/api.clj",
                                                             :lines [86
                                                                     91]},
                                                    :full-name "cljs.build.api/src-file->goog-require",
                                                    :docstring "Given a ClojureScript or Google Closure style JavaScript source file return\nthe goog.require statement for it."},
           "cljs.repl.node/write" {:ns "cljs.repl.node",
                                   :name "write",
                                   :signature ["[out js]"],
                                   :name-encode "write",
                                   :type "function",
                                   :full-name-encode "cljs.repl.node/write",
                                   :source {:code "(defn write [^BufferedWriter out ^String js]\n  (.write out js)\n  (.write out (int 0)) ;; terminator\n  (.flush out))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/repl/node.clj",
                                            :lines [33 36]},
                                   :full-name "cljs.repl.node/write",
                                   :history [["+" "0.0-2629"]]},
           "cljs.core/set-entries-iterator" {:ns "cljs.core",
                                             :name "set-entries-iterator",
                                             :signature ["[coll]"],
                                             :name-encode "set-entries-iterator",
                                             :history [["+"
                                                        "0.0-2268"]
                                                       ["-"
                                                        "0.0-2371"]],
                                             :type "function",
                                             :full-name-encode "cljs.core/set-entries-iterator",
                                             :source {:code "(defn set-entries-iterator [coll]\n  (SetEntriesIterator. (seq coll)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2356",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [4896
                                                              4897]},
                                             :full-name "cljs.core/set-entries-iterator",
                                             :removed {:in "0.0-2371",
                                                       :last-seen "0.0-2356"}},
           "clojure.browser.repl/send-result" {:ns "clojure.browser.repl",
                                               :name "send-result",
                                               :signature ["[connection url data]"],
                                               :name-encode "send-result",
                                               :type "function",
                                               :full-name-encode "clojure.browser.repl/send-result",
                                               :source {:code "(defn send-result [connection url data]\n  (net/transmit connection url \"POST\" data nil 0))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/clojure/browser/repl.cljs",
                                                        :lines [38 39]},
                                               :full-name "clojure.browser.repl/send-result",
                                               :history [["+"
                                                          "0.0-927"]]},
           "clojure.walk/keywordize-keys" {:ns "clojure.walk",
                                           :name "keywordize-keys",
                                           :signature ["[m]"],
                                           :name-encode "keywordize-keys",
                                           :history [["+" "0.0-927"]],
                                           :type "function",
                                           :full-name-encode "clojure.walk/keywordize-keys",
                                           :source {:code "(defn keywordize-keys\n  [m]\n  (let [f (fn [[k v]] (if (string? k) [(keyword k) v] [k v]))]\n    ;; only apply to maps\n    (postwalk (fn [x] (if (map? x) (into {} (map f x)) x)) m)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/walk.cljs",
                                                    :lines [64 70]},
                                           :full-name "clojure.walk/keywordize-keys",
                                           :docstring "Recursively transforms all map keys from strings to keywords."},
           "cljs.core/entries-iterator" {:ns "cljs.core",
                                         :name "entries-iterator",
                                         :signature ["[coll]"],
                                         :name-encode "entries-iterator",
                                         :history [["+" "0.0-2268"]
                                                   ["-" "0.0-2371"]],
                                         :type "function",
                                         :full-name-encode "cljs.core/entries-iterator",
                                         :source {:code "(defn entries-iterator [coll]\n  (EntriesIterator. (seq coll)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2356",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [4883 4884]},
                                         :full-name "cljs.core/entries-iterator",
                                         :removed {:in "0.0-2371",
                                                   :last-seen "0.0-2356"}},
           "closure-warnings/unknown-defines" {:ns "closure-warnings",
                                               :name "unknown-defines",
                                               :type "warning",
                                               :full-name "closure-warnings/unknown-defines",
                                               :full-name-encode "closure-warnings/unknown-defines",
                                               :name-encode "unknown-defines",
                                               :history [["+"
                                                          "0.0-2120"]]},
           "cljs.core/reduced" {:ns "cljs.core",
                                :name "reduced",
                                :signature ["[x]"],
                                :name-encode "reduced",
                                :history [["+" "0.0-1211"]],
                                :type "function",
                                :full-name-encode "cljs.core/reduced",
                                :source {:code "(defn reduced\n  [x]\n  (Reduced. x))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [894 897]},
                                :full-name "cljs.core/reduced",
                                :docstring "Wraps x in a way such that a reduce will terminate with the value x"},
           "cljs.reader/read-string*" {:ns "cljs.reader",
                                       :name "read-string*",
                                       :signature ["[reader _]"],
                                       :name-encode "read-stringSTAR",
                                       :type "function",
                                       :full-name-encode "cljs.reader/read-stringSTAR",
                                       :source {:code "(defn read-string*\n  [reader _]\n  (loop [buffer (gstring/StringBuffer.)\n         ch (read-char reader)]\n    (cond\n     (nil? ch) (reader-error reader \"EOF while reading\")\n     (identical? \"\\\\\" ch) (recur (do (.append buffer (escape-char buffer reader)) buffer)\n                        (read-char reader))\n     (identical? \\\" ch) (. buffer (toString))\n     :default (recur (do (.append buffer ch) buffer) (read-char reader)))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/reader.cljs",
                                                :lines [293 302]},
                                       :full-name "cljs.reader/read-string*",
                                       :history [["+" "0.0-1236"]]},
           "cljs.core/ChunkedCons" {:protocols #{"IChunkedNext"
                                                 "ISeqable"
                                                 "IMeta"
                                                 "IWithMeta"
                                                 "IEmptyableCollection"
                                                 "ISequential"
                                                 "ISeq"
                                                 "ICollection"
                                                 "IHash"
                                                 "ASeq"
                                                 "IPrintWithWriter"
                                                 "IChunkedSeq"
                                                 "INext"
                                                 "IEquiv"},
                                    :ns "cljs.core",
                                    :name "ChunkedCons",
                                    :signature ["[chunk more meta __hash]"],
                                    :name-encode "ChunkedCons",
                                    :history [["+" "0.0-1424"]],
                                    :type "type",
                                    :full-name-encode "cljs.core/ChunkedCons",
                                    :source {:code "(deftype ChunkedCons [chunk more meta ^:mutable __hash]\n  Object\n  (toString [coll]\n    (pr-str* coll))\n  (equiv [this other]\n    (-equiv this other))\n  \n  IWithMeta\n  (-with-meta [coll m]\n    (ChunkedCons. chunk more m __hash))\n\n  IMeta\n  (-meta [coll] meta)\n\n  ISequential\n  IEquiv\n  (-equiv [coll other] (equiv-sequential coll other))\n\n  ISeqable\n  (-seq [coll] coll)\n\n  ASeq\n  ISeq\n  (-first [coll] (-nth chunk 0))\n  (-rest [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (if (nil? more)\n        ()\n        more)))\n\n  INext\n  (-next [coll]\n    (if (> (-count chunk) 1)\n      (ChunkedCons. (-drop-first chunk) more meta nil)\n      (let [more (-seq more)]\n        (when-not (nil? more)\n          more))))\n\n  IChunkedSeq\n  (-chunked-first [coll] chunk)\n  (-chunked-rest [coll]\n    (if (nil? more)\n      ()\n      more))\n\n  IChunkedNext\n  (-chunked-next [coll]\n    (if (nil? more)\n      nil\n      more))\n\n  ICollection\n  (-conj [this o]\n    (cons o this))\n\n  IEmptyableCollection\n  (-empty [coll] (with-meta (.-EMPTY List) meta))\n\n  IHash\n  (-hash [coll] (caching-hash coll hash-ordered-coll __hash)))",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [2668 2728]},
                                    :full-name "cljs.core/ChunkedCons"},
           "cljs.core/derive" {:ns "cljs.core",
                               :name "derive",
                               :signature ["[tag parent]"
                                           "[h tag parent]"],
                               :name-encode "derive",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/derive",
                               :source {:code "(defn derive\n  ([tag parent]\n   (assert (namespace parent))\n   ;; (assert (or (class? tag) (and (instance? cljs.core.Named tag) (namespace tag))))\n   (swap-global-hierarchy! derive tag parent) nil)\n  ([h tag parent]\n   (assert (not= tag parent))\n   ;; (assert (or (class? tag) (instance? clojure.lang.Named tag)))\n   ;; (assert (instance? clojure.lang.INamed tag))\n   ;; (assert (instance? clojure.lang.INamed parent))\n   (let [tp (:parents h)\n         td (:descendants h)\n         ta (:ancestors h)\n         tf (fn [m source sources target targets]\n              (reduce (fn [ret k]\n                        (assoc ret k\n                               (reduce conj (get targets k #{}) (cons target (targets target)))))\n                      m (cons source (sources source))))]\n     (or\n      (when-not (contains? (tp tag) parent)\n        (when (contains? (ta tag) parent)\n          (throw (js/Error. (str tag \"already has\" parent \"as ancestor\"))))\n        (when (contains? (ta parent) tag)\n          (throw (js/Error. (str \"Cyclic derivation:\" parent \"has\" tag \"as ancestor\"))))\n        {:parents (assoc (:parents h) tag (conj (get tp tag #{}) parent))\n         :ancestors (tf (:ancestors h) tag td parent ta)\n         :descendants (tf (:descendants h) parent ta tag td)})\n      h))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [8811 8843]},
                               :full-name "cljs.core/derive",
                               :docstring "Establishes a parent/child relationship between parent and\ntag. Parent must be a namespace-qualified symbol or keyword and\nchild can be either a namespace-qualified symbol or keyword or a\nclass. h must be a hierarchy obtained from make-hierarchy, if not\nsupplied defaults to, and modifies, the global hierarchy."},
           "clojure.zip/zipper" {:ns "clojure.zip",
                                 :name "zipper",
                                 :signature ["[branch? children make-node root]"],
                                 :name-encode "zipper",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/zipper",
                                 :source {:code "(defn zipper\n  [branch? children make-node root]\n    ^{:zip/branch? branch? :zip/children children :zip/make-node make-node}\n    [root nil])",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [18 32]},
                                 :full-name "clojure.zip/zipper",
                                 :docstring "Creates a new zipper structure. \n\nbranch? is a fn that, given a node, returns true if can have\nchildren, even if it currently doesn't.\n\nchildren is a fn that, given a branch node, returns a seq of its\nchildren.\n\nmake-node is a fn that, given an existing node and a seq of\nchildren, returns a new branch node with the supplied children.\nroot is the root node."},
           "cljs.test/empty-env" {:ns "cljs.test",
                                  :name "empty-env",
                                  :signature ["[]" "[reporter]"],
                                  :name-encode "empty-env",
                                  :type "function",
                                  :full-name-encode "cljs.test/empty-env",
                                  :source {:code "(defn empty-env\n  ([] (empty-env ::default))\n  ([reporter]\n   {:report-counters {:test 0 :pass 0 :fail 0 :error 0}\n    :testing-vars ()\n    :testing-contexts ()\n    :reporter reporter}))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/test.cljs",
                                           :lines [216 222]},
                                  :full-name "cljs.test/empty-env",
                                  :history [["+" "0.0-2496"]]},
           "clojure.core.reducers/mapcat" {:ns "clojure.core.reducers",
                                           :name "mapcat",
                                           :signature ["[f]"
                                                       "[f coll]"],
                                           :name-encode "mapcat",
                                           :history [["+" "0.0-1236"]],
                                           :type "function",
                                           :full-name-encode "clojure.core.reducers/mapcat",
                                           :source {:code "(defcurried mapcat\n  \"Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.\"\n  {}\n  [f coll]\n  (folder coll\n   (fn [f1]\n     (rfn [f1 k]\n          ([ret k v]\n             (reduce f1 ret (f k v)))))))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/core/reducers.cljs",
                                                    :lines [106 115]},
                                           :full-name "clojure.core.reducers/mapcat",
                                           :docstring "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable."},
           "clojure.zip/remove" {:ns "clojure.zip",
                                 :name "remove",
                                 :signature ["[loc]"],
                                 :name-encode "remove",
                                 :history [["+" "0.0-927"]],
                                 :type "function",
                                 :full-name-encode "clojure.zip/remove",
                                 :source {:code "(defn remove\n  [loc]\n    (let [[node {l :l, ppath :ppath, pnodes :pnodes, rs :r, :as path}] loc]\n      (if (nil? path)\n        (throw \"Remove at top\")\n        (if (pos? (count l))\n          (loop [loc (with-meta [(peek l) (assoc path :l (pop l) :changed? true)] (meta loc))]\n            (if-let [child (and (branch? loc) (down loc))]\n              (recur (rightmost child))\n              loc))\n          (with-meta [(make-node loc (peek pnodes) rs) \n                      (and ppath (assoc ppath :changed? true))]\n                     (meta loc))))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/clojure/zip.cljs",
                                          :lines [237 251]},
                                 :full-name "clojure.zip/remove",
                                 :docstring "Removes the node at loc, returning the loc that would have preceded\nit in a depth-first walk."},
           "syntax/var" {:syntax-equiv {:edn-url nil, :clj-url nil},
                         :ns "syntax",
                         :name "var",
                         :name-encode "var",
                         :type "syntax",
                         :full-name-encode "syntax/var",
                         :extra-sources ({:code "(defn- dispatch-macros [ch]\n  (case ch\n    \\^ read-meta                ;deprecated\n    \\' (wrapping-reader 'var)\n    \\( read-fn\n    \\= read-eval\n    \\{ read-set\n    \\< (throwing-reader \"Unreadable form\")\n    \\\" read-regex\n    \\! read-comment\n    \\_ read-discard\n    nil))",
                                          :title "Reader table",
                                          :repo "tools.reader",
                                          :tag "tools.reader-0.8.10",
                                          :filename "src/main/clojure/clojure/tools/reader.clj",
                                          :lines [612 623]}),
                         :full-name "syntax/var",
                         :history [["+" "0.0-1853"]]},
           "cljs.repl.browser/handle-post" {:ns "cljs.repl.browser",
                                            :name "handle-post",
                                            :signature ["[m _ _]"],
                                            :name-encode "handle-post",
                                            :history [["+" "0.0-927"]],
                                            :type "multimethod",
                                            :full-name-encode "cljs.repl.browser/handle-post",
                                            :source {:code "(defmulti handle-post (fn [m _ _ ] (:type m)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/clj/cljs/repl/browser.clj",
                                                     :lines [117]},
                                            :extra-sources ({:code "(defmethod handle-post :ready [_ conn _]\n  (reset! loaded-libs @preloaded-libs)\n  (send ordering (fn [_] {:expecting nil :fns {}}))\n  (send-for-eval conn\n    (cljsc/-compile\n      '[(ns cljs.user)\n        (set! *print-fn* clojure.browser.repl/repl-print)] {})\n    identity))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [123
                                                                     130]}
                                                            {:code "(defmethod handle-post :print [{:keys [content order]} conn _ ]\n  (constrain-order order\n    (fn []\n      (print (read-string content))\n      (.flush *out*)))\n  (server/send-and-close conn 200 \"ignore__\"))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [151
                                                                     156]}
                                                            {:code "(defmethod handle-post :result [{:keys [content order]} conn _ ]\n  (constrain-order order\n    (fn []\n      (return-value content)\n      (server/set-connection conn))))",
                                                             :title "Dispatch method",
                                                             :repo "clojurescript",
                                                             :tag "r2760",
                                                             :filename "src/clj/cljs/repl/browser.clj",
                                                             :lines [158
                                                                     162]}),
                                            :full-name "cljs.repl.browser/handle-post"},
           "cljs.core/find" {:ns "cljs.core",
                             :name "find",
                             :signature ["[coll k]"],
                             :name-encode "find",
                             :history [["+" "0.0-927"]],
                             :type "function",
                             :full-name-encode "cljs.core/find",
                             :source {:code "(defn find\n  [coll k]\n  (when (and (not (nil? coll))\n             (associative? coll)\n             (contains? coll k))\n    [k (get coll k)]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [1629 1635]},
                             :full-name "cljs.core/find",
                             :docstring "Returns the map entry for key, or nil if key not present."},
           "cljs.repl.node/repl-env*" {:ns "cljs.repl.node",
                                       :name "repl-env*",
                                       :signature ["[options]"],
                                       :name-encode "repl-envSTAR",
                                       :type "function",
                                       :full-name-encode "cljs.repl.node/repl-envSTAR",
                                       :source {:code "(defn repl-env* [options]\n  (let [{:keys [host port]}\n        (merge\n          {:host \"localhost\"\n           :port (+ 49000 (rand-int 10000))}\n          options)]\n    (NodeEnv. host port (atom nil) (atom nil))))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/clj/cljs/repl/node.clj",
                                                :lines [169 175]},
                                       :full-name "cljs.repl.node/repl-env*",
                                       :history [["+" "0.0-2629"]]},
           "cljs.core/hash-set" {:ns "cljs.core",
                                 :name "hash-set",
                                 :signature ["[]" "[& keys]"],
                                 :name-encode "hash-set",
                                 :history [["+" "0.0-1443"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/hash-set",
                                 :source {:code "(defn hash-set\n  ([] #{})\n  ([& keys] (set keys)))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [7599 7601]},
                                 :extra-sources [{:code "(defmacro hash-set\n  ([] `(.-EMPTY cljs.core/PersistentHashSet))\n  ([& xs]\n    (if (core/and (core/<= (count xs) 8)\n                  (every? #(= (:op %) :constant)\n                    (map #(cljs.analyzer/analyze &env %) xs))\n                  (= (count (into #{} xs)) (count xs)))\n      `(cljs.core/PersistentHashSet. nil\n         (cljs.core/PersistentArrayMap. nil ~(count xs) (array ~@(interleave xs (repeat nil))) nil)\n         nil)\n      (vary-meta\n        `(.fromArray cljs.core/PersistentHashSet (array ~@xs) true)\n        assoc :tag 'cljs.core/PersistentHashSet))))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [1450 1462]}],
                                 :full-name "cljs.core/hash-set"},
           "cljs.core/*print-dup*" {:ns "cljs.core",
                                    :name "*print-dup*",
                                    :name-encode "STARprint-dupSTAR",
                                    :type "dynamic var",
                                    :full-name-encode "cljs.core/STARprint-dupSTAR",
                                    :source {:code "(def ^:dynamic *print-dup* false)",
                                             :title "Source code",
                                             :repo "clojurescript",
                                             :tag "r2760",
                                             :filename "src/cljs/cljs/core.cljs",
                                             :lines [36]},
                                    :full-name "cljs.core/*print-dup*",
                                    :history [["+" "0.0-927"]]},
           "cljs.core/set-from-indexed-seq" {:ns "cljs.core",
                                             :name "set-from-indexed-seq",
                                             :signature ["[iseq]"],
                                             :name-encode "set-from-indexed-seq",
                                             :type "function",
                                             :full-name-encode "cljs.core/set-from-indexed-seq",
                                             :source {:code "(defn set-from-indexed-seq [iseq]\n  (let [arr (.-arr iseq)\n        ret (areduce arr i ^not-native res (-as-transient #{})\n              (-conj! res (aget arr i)))]\n    (-persistent! ^not-native ret)))",
                                                      :title "Source code",
                                                      :repo "clojurescript",
                                                      :tag "r2760",
                                                      :filename "src/cljs/cljs/core.cljs",
                                                      :lines [7576
                                                              7580]},
                                             :full-name "cljs.core/set-from-indexed-seq",
                                             :history [["+"
                                                        "0.0-1877"]]},
           "cljs.core/object-array" {:ns "cljs.core",
                                     :name "object-array",
                                     :signature ["[size-or-seq]"
                                                 "[size init-val-or-seq]"],
                                     :name-encode "object-array",
                                     :type "function",
                                     :full-name-encode "cljs.core/object-array",
                                     :source {:code "(defn object-array\n  ([size-or-seq]\n     (if (number? size-or-seq)\n       (object-array size-or-seq nil)\n       (into-array size-or-seq)))\n  ([size init-val-or-seq]\n     (let [a (make-array size)]\n       (if (seq? init-val-or-seq)\n         (let [s (seq init-val-or-seq)]\n           (loop [i 0 s s]\n             (if (and s (< i size))\n               (do\n                 (aset a i (first s))\n                 (recur (inc i) (next s)))\n               a)))\n         (do\n           (dotimes [i size]\n             (aset a i init-val-or-seq))\n           a)))))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/cljs/core.cljs",
                                              :lines [2837 2855]},
                                     :full-name "cljs.core/object-array",
                                     :history [["+" "0.0-1211"]]},
           "cljs.core/indexed?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "indexed?",
                                 :signature ["[x]"],
                                 :name-encode "indexedQMARK",
                                 :history [["+" "0.0-1211"]],
                                 :type "function",
                                 :full-name-encode "cljs.core/indexedQMARK",
                                 :source {:code "(defn ^boolean indexed?\n  [x] (satisfies? IIndexed x))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [990 992]},
                                 :full-name "cljs.core/indexed?",
                                 :docstring "Returns true if coll implements nth in constant time"},
           "cljs.core/partial" {:ns "cljs.core",
                                :name "partial",
                                :signature ["[f]"
                                            "[f arg1]"
                                            "[f arg1 arg2]"
                                            "[f arg1 arg2 arg3]"
                                            "[f arg1 arg2 arg3 & more]"],
                                :name-encode "partial",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/partial",
                                :source {:code "(defn partial\n  ([f] f)\n  ([f arg1]\n   (fn\n     ([] (f arg1))\n     ([x] (f arg1 x))\n     ([x y] (f arg1 x y))\n     ([x y z] (f arg1 x y z))\n     ([x y z & args] (apply f arg1 x y z args))))\n  ([f arg1 arg2]\n   (fn\n     ([] (f arg1 arg2))\n     ([x] (f arg1 arg2 x))\n     ([x y] (f arg1 arg2 x y))\n     ([x y z] (f arg1 arg2 x y z))\n     ([x y z & args] (apply f arg1 arg2 x y z args))))\n  ([f arg1 arg2 arg3]\n   (fn\n     ([] (f arg1 arg2 arg3))\n     ([x] (f arg1 arg2 arg3 x))\n     ([x y] (f arg1 arg2 arg3 x y))\n     ([x y z] (f arg1 arg2 arg3 x y z))\n     ([x y z & args] (apply f arg1 arg2 arg3 x y z args))))\n  ([f arg1 arg2 arg3 & more]\n   (fn [& args] (apply f arg1 arg2 arg3 (concat more args)))))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3372 3399]},
                                :full-name "cljs.core/partial",
                                :docstring "Takes a function f and fewer than the normal arguments to f, and\nreturns a fn that takes a variable number of additional args. When\ncalled, the returned function calls f with args + additional args."},
           "closure-warnings/invalid-casts" {:ns "closure-warnings",
                                             :name "invalid-casts",
                                             :type "warning",
                                             :full-name "closure-warnings/invalid-casts",
                                             :full-name-encode "closure-warnings/invalid-casts",
                                             :name-encode "invalid-casts",
                                             :history [["+"
                                                        "0.0-2120"]]},
           "cljs.core/keyword?" {:return-type boolean,
                                 :ns "cljs.core",
                                 :name "keyword?",
                                 :signature ["[x]"],
                                 :name-encode "keywordQMARK",
                                 :history [["+" "0.0-927"]],
                                 :type "function/macro",
                                 :full-name-encode "cljs.core/keywordQMARK",
                                 :source {:code "(defn ^boolean keyword? [x]\n  (instance? Keyword x))",
                                          :title "Function code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [2518 2519]},
                                 :extra-sources [{:code "(defmacro keyword? [x]\n  (bool-expr `(instance? Keyword ~x)))",
                                                  :title "Macro code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/core.clj",
                                                  :lines [337 338]}],
                                 :full-name "cljs.core/keyword?"},
           "cljs.repl.rhino/stacktrace" {:ns "cljs.repl.rhino",
                                         :name "stacktrace",
                                         :name-encode "stacktrace",
                                         :type "multimethod",
                                         :full-name-encode "cljs.repl.rhino/stacktrace",
                                         :source {:code "(defmulti stacktrace class)",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/repl/rhino.clj",
                                                  :lines [45]},
                                         :full-name "cljs.repl.rhino/stacktrace",
                                         :extra-sources ({:code "(defmethod stacktrace :default [e]\n  (apply str\n    (interpose \"\\n\"\n      (map #(str \"        \" (.toString %))\n        (.getStackTrace e)))))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/clj/cljs/repl/rhino.clj",
                                                          :lines [47
                                                                  51]}
                                                         {:code "(defmethod stacktrace RhinoException [^RhinoException e]\n  (.getScriptStackTrace e))",
                                                          :title "Dispatch method",
                                                          :repo "clojurescript",
                                                          :tag "r2760",
                                                          :filename "src/clj/cljs/repl/rhino.clj",
                                                          :lines [53
                                                                  54]}),
                                         :history [["+" "0.0-927"]]},
           "compiler-options/output-to" {:ns "compiler-options",
                                         :name "output-to",
                                         :name-encode "output-to",
                                         :type "option",
                                         :full-name-encode "compiler-options/output-to",
                                         :full-name "compiler-options/output-to",
                                         :history [["+" "0.0-971"]]},
           "clojure.browser.event/fire-listeners" {:ns "clojure.browser.event",
                                                   :name "fire-listeners",
                                                   :signature ["[obj type capture event]"],
                                                   :name-encode "fire-listeners",
                                                   :type "function",
                                                   :full-name-encode "clojure.browser.event/fire-listeners",
                                                   :source {:code "(defn fire-listeners\n  [obj type capture event])",
                                                            :title "Source code",
                                                            :repo "clojurescript",
                                                            :tag "r2760",
                                                            :filename "src/cljs/clojure/browser/event.cljs",
                                                            :lines [84
                                                                    85]},
                                                   :full-name "clojure.browser.event/fire-listeners",
                                                   :history [["+"
                                                              "0.0-927"]]},
           "cljs.core/Iterator" {:ns "cljs.core",
                                 :name "Iterator",
                                 :signature ["[s]"],
                                 :name-encode "Iterator",
                                 :history [["+" "0.0-2268"]
                                           ["-" "0.0-2371"]],
                                 :type "type",
                                 :full-name-encode "cljs.core/Iterator",
                                 :source {:code "(deftype Iterator [^:mutable s]\n  Object\n  (next [_]\n    (if-not (nil? s)\n      (let [x (first s)]\n        (set! s (next s))\n        #js {:value x :done false})\n      #js {:value nil :done true})))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2356",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [4861 4868]},
                                 :full-name "cljs.core/Iterator",
                                 :removed {:in "0.0-2371",
                                           :last-seen "0.0-2356"}},
           "cljs.core/vreset!" {:ns "cljs.core",
                                :name "vreset!",
                                :signature ["[vol newval]"],
                                :name-encode "vresetBANG",
                                :history [["+" "0.0-2496"]],
                                :type "function",
                                :full-name-encode "cljs.core/vresetBANG",
                                :source {:code "(defn vreset!\n  [vol newval]  (-vreset! vol newval))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [3613 3616]},
                                :full-name "cljs.core/vreset!",
                                :docstring "Sets the value of volatile to newval without regard for the\ncurrent value. Returns newval."},
           "cljs.core/interleave" {:ns "cljs.core",
                                   :name "interleave",
                                   :signature ["[c1 c2]"
                                               "[c1 c2 & colls]"],
                                   :name-encode "interleave",
                                   :history [["+" "0.0-927"]],
                                   :type "function",
                                   :full-name-encode "cljs.core/interleave",
                                   :source {:code "(defn interleave\n  ([c1 c2]\n     (lazy-seq\n      (let [s1 (seq c1) s2 (seq c2)]\n        (when (and s1 s2)\n          (cons (first s1) (cons (first s2)\n                                 (interleave (rest s1) (rest s2))))))))\n  ([c1 c2 & colls]\n     (lazy-seq\n      (let [ss (map seq (conj colls c2 c1))]\n        (when (every? identity ss)\n          (concat (map first ss) (apply interleave (map rest ss))))))))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/cljs/cljs/core.cljs",
                                            :lines [3898 3910]},
                                   :full-name "cljs.core/interleave",
                                   :docstring "Returns a lazy seq of the first item in each coll, then the second etc."},
           "cljs.core/TransientHashSet" {:protocols #{"IFn"
                                                      "ITransientCollection"
                                                      "ICounted"
                                                      "ITransientSet"
                                                      "ILookup"},
                                         :ns "cljs.core",
                                         :name "TransientHashSet",
                                         :signature ["[transient-map]"],
                                         :name-encode "TransientHashSet",
                                         :history [["+" "0.0-1211"]],
                                         :type "type",
                                         :full-name-encode "cljs.core/TransientHashSet",
                                         :source {:code "(deftype TransientHashSet [^:mutable transient-map]\n  ITransientCollection\n  (-conj! [tcoll o]\n    (set! transient-map (assoc! transient-map o nil))\n    tcoll)\n\n  (-persistent! [tcoll]\n    (PersistentHashSet. nil (persistent! transient-map) nil))\n\n  ITransientSet\n  (-disjoin! [tcoll v]\n    (set! transient-map (dissoc! transient-map v))\n    tcoll)\n\n  ICounted\n  (-count [tcoll] (count transient-map))\n\n  ILookup\n  (-lookup [tcoll v]\n    (-lookup tcoll v nil))\n\n  (-lookup [tcoll v not-found]\n    (if (identical? (-lookup transient-map v lookup-sentinel) lookup-sentinel)\n      not-found\n      v))\n\n  IFn\n  (-invoke [tcoll k]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      nil\n      k))\n\n  (-invoke [tcoll k not-found]\n    (if (identical? (-lookup transient-map k lookup-sentinel) lookup-sentinel)\n      not-found\n      k)))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/cljs/cljs/core.cljs",
                                                  :lines [7446 7481]},
                                         :full-name "cljs.core/TransientHashSet"},
           "cljs.core/*flush-on-newline*" {:ns "cljs.core",
                                           :name "*flush-on-newline*",
                                           :name-encode "STARflush-on-newlineSTAR",
                                           :type "dynamic var",
                                           :full-name-encode "cljs.core/STARflush-on-newlineSTAR",
                                           :source {:code "(def ^:dynamic *flush-on-newline* true)",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/cljs/core.cljs",
                                                    :lines [32]},
                                           :full-name "cljs.core/*flush-on-newline*",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/get-in" {:ns "cljs.core",
                               :name "get-in",
                               :signature ["[m ks]"
                                           "[m ks not-found]"],
                               :name-encode "get-in",
                               :history [["+" "0.0-927"]],
                               :type "function",
                               :full-name-encode "cljs.core/get-in",
                               :source {:code "(defn get-in\n  ([m ks]\n     (get-in m ks nil))\n  ([m ks not-found]\n     (loop [sentinel lookup-sentinel\n            m m\n            ks (seq ks)]\n       (if ks\n         (if (not (satisfies? ILookup m))\n           not-found\n           (let [m (get m (first ks) sentinel)]\n             (if (identical? sentinel m)\n               not-found\n               (recur sentinel m (next ks)))))\n         m))))",
                                        :title "Source code",
                                        :repo "clojurescript",
                                        :tag "r2760",
                                        :filename "src/cljs/cljs/core.cljs",
                                        :lines [4078 4097]},
                               :full-name "cljs.core/get-in",
                               :docstring "Returns the value in a nested associative structure,\nwhere ks is a sequence of keys. Returns nil if the key is not present,\nor the not-found value if supplied."},
           "clojure.browser.dom/element" {:ns "clojure.browser.dom",
                                          :name "element",
                                          :signature ["[tag-or-text]"
                                                      "[tag & children]"],
                                          :name-encode "element",
                                          :type "function",
                                          :full-name-encode "clojure.browser.dom/element",
                                          :source {:code "(defn element\n  ([tag-or-text]\n     (log \"(element \" tag-or-text \")\")\n     (-element tag-or-text))\n  ([tag & children]\n     (log \"(element \" tag \" \" children \")\")\n     (let [attrs (first children)]\n       (if (map? attrs)\n         (-element tag attrs (rest children))\n         (-element tag nil children)))))",
                                                   :title "Source code",
                                                   :repo "clojurescript",
                                                   :tag "r2760",
                                                   :filename "src/cljs/clojure/browser/dom.cljs",
                                                   :lines [81 90]},
                                          :full-name "clojure.browser.dom/element",
                                          :history [["+" "0.0-927"]]},
           "cljs.core/prim-seq" {:ns "cljs.core",
                                 :name "prim-seq",
                                 :signature ["[prim]" "[prim i]"],
                                 :name-encode "prim-seq",
                                 :type "function",
                                 :full-name-encode "cljs.core/prim-seq",
                                 :source {:code "(defn prim-seq\n  ([prim]\n     (prim-seq prim 0))\n  ([prim i]\n     (when (< i (alength prim))\n       (IndexedSeq. prim i))))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/cljs/core.cljs",
                                          :lines [1073 1078]},
                                 :full-name "cljs.core/prim-seq",
                                 :history [["+" "0.0-927"]]},
           "cljs.core/<=" {:return-type boolean,
                           :ns "cljs.core",
                           :name "<=",
                           :signature ["[x]" "[x y]" "[x y & more]"],
                           :name-encode "LTEQ",
                           :history [["+" "0.0-927"]],
                           :type "function/macro",
                           :full-name-encode "cljs.core/LTEQ",
                           :source {:code "(defn ^boolean <=\n  ([x] true)\n  ([x y] (cljs.core/<= x y))\n  ([x y & more]\n   (if (cljs.core/<= x y)\n     (if (next more)\n       (recur y (first more) (next more))\n       (cljs.core/<= y (first more)))\n     false)))",
                                    :title "Function code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [1881 1891]},
                           :extra-sources [{:code "(defmacro ^::ana/numeric <=\n  ([x] true)\n  ([x y] (bool-expr (core/list 'js* \"(~{} <= ~{})\" x y)))\n  ([x y & more] `(and (<= ~x ~y) (<= ~y ~@more))))",
                                            :title "Macro code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/core.clj",
                                            :lines [440 443]}],
                           :full-name "cljs.core/<=",
                           :docstring "Returns non-nil if nums are in monotonically non-decreasing order,\notherwise false."},
           "clojure.set/map-invert" {:ns "clojure.set",
                                     :name "map-invert",
                                     :signature ["[m]"],
                                     :name-encode "map-invert",
                                     :history [["+" "0.0-927"]],
                                     :type "function",
                                     :full-name-encode "clojure.set/map-invert",
                                     :source {:code "(defn map-invert\n  [m] (reduce (fn [m [k v]] (assoc m v k)) {} m))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/set.cljs",
                                              :lines [97 99]},
                                     :full-name "clojure.set/map-invert",
                                     :docstring "Returns the map with the vals mapped to the keys."},
           "clojure.browser.event/listen" {:ns "clojure.browser.event",
                                           :name "listen",
                                           :signature ["[src type fn]"
                                                       "[src type fn capture?]"],
                                           :name-encode "listen",
                                           :type "function",
                                           :full-name-encode "clojure.browser.event/listen",
                                           :source {:code "(defn listen\n  ([src type fn]\n     (listen src type fn false))\n  ([src type fn capture?]\n     (events/listen src\n                    (get (event-types src) type type)\n                    fn\n                    capture?)))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/cljs/clojure/browser/event.cljs",
                                                    :lines [46 53]},
                                           :full-name "clojure.browser.event/listen",
                                           :history [["+" "0.0-927"]]},
           "cljs.core/neg?" {:return-type boolean,
                             :ns "cljs.core",
                             :name "neg?",
                             :signature ["[x]"],
                             :name-encode "negQMARK",
                             :history [["+" "0.0-927"]],
                             :type "function/macro",
                             :full-name-encode "cljs.core/negQMARK",
                             :source {:code "(defn ^boolean neg?\n  [x] (cljs.core/neg? x))",
                                      :title "Function code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/core.cljs",
                                      :lines [2174 2176]},
                             :extra-sources [{:code "(defmacro ^::ana/numeric neg? [x]\n  `(< ~x 0))",
                                              :title "Macro code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/clj/cljs/core.clj",
                                              :lines [472 473]}],
                             :full-name "cljs.core/neg?",
                             :docstring "Returns true if num is less than zero, else false"},
           "cljs.analyzer.api/ns-interns" {:ns "cljs.analyzer.api",
                                           :name "ns-interns",
                                           :signature ["[ns]"],
                                           :name-encode "ns-interns",
                                           :history [["+" "0.0-2496"]],
                                           :type "function",
                                           :full-name-encode "cljs.analyzer.api/ns-interns",
                                           :source {:code "(defn ns-interns\n  [ns]\n  {:pre [(symbol? ns)]}\n  (get-in @env/*compiler* [::ana/namespaces ns :defs]))",
                                                    :title "Source code",
                                                    :repo "clojurescript",
                                                    :tag "r2760",
                                                    :filename "src/clj/cljs/analyzer/api.clj",
                                                    :lines [37 42]},
                                           :full-name "cljs.analyzer.api/ns-interns",
                                           :docstring "Given a namespace return all the var analysis maps. Analagous to\nclojure.core/ns-interns but returns var analysis maps not vars."},
           "cljs.core/mix-collection-hash" {:return-type number,
                                            :ns "cljs.core",
                                            :name "mix-collection-hash",
                                            :signature ["[hash-basis count]"],
                                            :name-encode "mix-collection-hash",
                                            :history [["+" "0.0-2261"]],
                                            :type "function",
                                            :full-name-encode "cljs.core/mix-collection-hash",
                                            :source {:code "(defn ^number mix-collection-hash\n  [hash-basis count]\n  (let [h1 m3-seed\n        k1 (m3-mix-K1 hash-basis)\n        h1 (m3-mix-H1 h1 k1)]\n    (m3-fmix h1 count)))",
                                                     :title "Source code",
                                                     :repo "clojurescript",
                                                     :tag "r2760",
                                                     :filename "src/cljs/cljs/core.cljs",
                                                     :lines [809 819]},
                                            :full-name "cljs.core/mix-collection-hash",
                                            :docstring "Mix final collection hash for ordered or unordered collections.\nhash-basis is the combined collection hash, count is the number\nof elements included in the basis. Note this is the hash code\nconsistent with =, different from .hashCode.\nSee http://clojure.org/data_structures#hash for full algorithms."},
           "clojure.browser.dom/replace-node" {:ns "clojure.browser.dom",
                                               :name "replace-node",
                                               :signature ["[old-node new-node]"],
                                               :name-encode "replace-node",
                                               :history [["+"
                                                          "0.0-927"]],
                                               :type "function",
                                               :full-name-encode "clojure.browser.dom/replace-node",
                                               :source {:code "(defn replace-node\n  [old-node new-node]\n  (let [old-node (ensure-element old-node)\n        new-node (ensure-element new-node)]\n    (gdom/replaceNode new-node old-node)\n    new-node))",
                                                        :title "Source code",
                                                        :repo "clojurescript",
                                                        :tag "r2760",
                                                        :filename "src/cljs/clojure/browser/dom.cljs",
                                                        :lines [114
                                                                122]},
                                               :full-name "clojure.browser.dom/replace-node",
                                               :docstring "Replace old-node with new-node. old-node can be an element or a\nkeyword which is the id of the node to replace.  new-node can be an\nelement or an html string."},
           "repl-options/repl-verbose" {:ns "repl-options",
                                        :name "repl-verbose",
                                        :name-encode "repl-verbose",
                                        :type "option",
                                        :full-name-encode "repl-options/repl-verbose",
                                        :full-name "repl-options/repl-verbose",
                                        :history [["+" "0.0-2719"]]},
           "cljs.core/reverse" {:ns "cljs.core",
                                :name "reverse",
                                :signature ["[coll]"],
                                :name-encode "reverse",
                                :history [["+" "0.0-927"]],
                                :type "function",
                                :full-name-encode "cljs.core/reverse",
                                :source {:code "(defn reverse\n  [coll]\n  (if (reversible? coll)\n    (rseq coll)\n    (reduce conj () coll)))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/cljs/core.cljs",
                                         :lines [2393 2398]},
                                :full-name "cljs.core/reverse",
                                :docstring "Returns a seq of the items in coll in reverse order. Not lazy."},
           "cljs.repl.browser/ordering" {:ns "cljs.repl.browser",
                                         :name "ordering",
                                         :name-encode "ordering",
                                         :type "var",
                                         :full-name-encode "cljs.repl.browser/ordering",
                                         :source {:code "(def ordering (agent {:expecting nil :fns {}}))",
                                                  :title "Source code",
                                                  :repo "clojurescript",
                                                  :tag "r2760",
                                                  :filename "src/clj/cljs/repl/browser.clj",
                                                  :lines [121]},
                                         :full-name "cljs.repl.browser/ordering",
                                         :history [["+" "0.0-927"]]},
           "cljs.core/realized?" {:return-type boolean,
                                  :ns "cljs.core",
                                  :name "realized?",
                                  :signature ["[d]"],
                                  :name-encode "realizedQMARK",
                                  :history [["+" "0.0-927"]],
                                  :type "function",
                                  :full-name-encode "cljs.core/realizedQMARK",
                                  :source {:code "(defn ^boolean realized?\n  [d]\n  (-realized? d))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/cljs/cljs/core.cljs",
                                           :lines [8542 8545]},
                                  :full-name "cljs.core/realized?",
                                  :docstring "Returns true if a value has been produced for a promise, delay, future or lazy sequence."},
           "cljs.core/ensure-reduced" {:ns "cljs.core",
                                       :name "ensure-reduced",
                                       :signature ["[x]"],
                                       :name-encode "ensure-reduced",
                                       :history [["+" "0.0-2411"]],
                                       :type "function",
                                       :full-name-encode "cljs.core/ensure-reduced",
                                       :source {:code "(defn ensure-reduced\n  [x]\n  (if (reduced? x) x (reduced x)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/cljs/core.cljs",
                                                :lines [904 907]},
                                       :full-name "cljs.core/ensure-reduced",
                                       :docstring "If x is already reduced?, returns it, else returns (reduced x)"}},
 :namespaces {"cljs.repl.server" {:ns "cljs.repl.server",
                                  :name-encode "cljs.repl.server",
                                  :type "namespace",
                                  :full-name-encode "cljs.repl.server",
                                  :source {:code "(ns cljs.repl.server\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.string :as str])\n  (:import java.io.BufferedReader\n           java.io.InputStreamReader\n           java.net.ServerSocket))",
                                           :title "Source code",
                                           :repo "clojurescript",
                                           :tag "r2760",
                                           :filename "src/clj/cljs/repl/server.clj",
                                           :lines [1 6]},
                                  :full-name "cljs.repl.server",
                                  :history [["+" "0.0-1503"]]},
              "clojure.zip" {:ns "clojure.zip",
                             :name-encode "clojure.zip",
                             :type "namespace",
                             :full-name-encode "clojure.zip",
                             :source {:code "(ns ^{:doc \"Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet\"\n       :author \"Rich Hickey\"}\n  clojure.zip\n  (:refer-clojure :exclude (replace remove next)))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/clojure/zip.cljs",
                                      :lines [12 16]},
                             :author "Rich Hickey",
                             :full-name "clojure.zip",
                             :docstring "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet",
                             :history [["+" "0.0-927"]]},
              "clojure.reflect" {:ns "clojure.reflect",
                                 :name-encode "clojure.reflect",
                                 :type "namespace",
                                 :full-name-encode "clojure.reflect",
                                 :source {:code "(ns clojure.reflect\n  (:refer-clojure :exclude [meta])\n  (:require [clojure.browser.net :as net]\n            [clojure.browser.event :as event]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/cljs/clojure/reflect.cljs",
                                          :lines [1 4]},
                                 :full-name "clojure.reflect",
                                 :history [["+" "0.0-1503"]]},
              "cljs.test" {:ns "cljs.test",
                           :name-encode "cljs.test",
                           :type "namespace",
                           :full-name-encode "cljs.test",
                           :source {:code "(ns\n^{:author \"Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, and David Nolen\",\n     :doc \"A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \\\"is\\\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \\\"abcde\\\" \\\"ab\\\"))\n\n   You can type an \\\"is\\\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \\\"expected:\\\" line shows you the original expression, and the\n   \\\"actual:\\\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \\\"false\\\" on the last line is the value returned from the\n   expression.  The \\\"is\\\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \\\"(is (thrown? c ...))\\\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \\\"(is (thrown-with-msg? c re ...))\\\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\\\"Divide by zero\\\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \\\"is\\\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \\\"Crazy arithmetic\\\")\n\n   In addition, you can document groups of assertions with the\n   \\\"testing\\\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \\\"testing\\\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \\\"Arithmetic\\\"\n     (testing \\\"with positive integers\\\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \\\"with negative integers\\\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \\\"testing\\\" macro may only be used\n   INSIDE a \\\"deftest\\\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \\\"addition\\\" and \\\"subtraction\\\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \\\"Practical Common Lisp\\\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \\\"(arithmetic addition)\\\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function \\\"(run-tests namespaces...)\\\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \\\"(run-all-tests)\\\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \\\"arithmetic\\\" example above, you\n   probably do not want the \\\"addition\\\" and \\\"subtraction\\\" tests run\n   separately.  In that case, you must define a special function\n   named \\\"test-ns-hook\\\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \\\"run-tests\\\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \\\"empty-env\\\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \\\"test-ns\\\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \\\"run-tests\\\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \\\":load-tests\\\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \\\"deftest\\\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  \\\"each\\\"\n   fixtures are run repeatedly, once for each test function created\n   with \\\"deftest\\\".  \\\"each\\\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \\\"each\\\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a \\\"once\\\" fixture, is only run once,\n   around ALL the tests in the namespace.  \\\"once\\\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \\\"once\\\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \\\"is\\\" macro by defining new\n   methods for the \\\"assert-expr\\\" multimethod.  These methods are\n   called during expansion of the \\\"is\\\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \\\"report\\\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \\\"testing\\\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n\"}\n  cljs.test\n  (:require-macros [clojure.template :as temp])\n  (:require [clojure.string :as string]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/test.cljs",
                                    :lines [9 211]},
                           :author "Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, and David Nolen",
                           :full-name "cljs.test",
                           :docstring "A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \"run-tests\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \"empty-env\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \"test-ns\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \"run-tests\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \":load-tests\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \"report\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n",
                           :history [["+" "0.0-2496"]]},
              "cljs.repl.browser" {:ns "cljs.repl.browser",
                                   :name-encode "cljs.repl.browser",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.browser",
                                   :source {:code "(ns cljs.repl.browser\n  (:refer-clojure :exclude [loaded-libs])\n  (:require [clojure.java.io :as io]\n            [clojure.string :as string]\n            [cljs.compiler :as comp]\n            [cljs.util :as util]\n            [cljs.env :as env]\n            [cljs.closure :as cljsc]\n            [cljs.repl :as repl]\n            [cljs.repl.server :as server])\n  (:import [java.util.regex Pattern]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/repl/browser.clj",
                                            :lines [9 19]},
                                   :full-name "cljs.repl.browser",
                                   :history [["+" "0.0-927"]]},
              "cljs.repl.rhino" {:ns "cljs.repl.rhino",
                                 :name-encode "cljs.repl.rhino",
                                 :type "namespace",
                                 :full-name-encode "cljs.repl.rhino",
                                 :source {:code "(ns cljs.repl.rhino\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.repl :as repl]\n            [cljs.util :as util])\n  (:import [java.io File Reader]\n           [org.mozilla.javascript Context ScriptableObject\n                                   RhinoException Undefined]))",
                                          :title "Source code",
                                          :repo "clojurescript",
                                          :tag "r2760",
                                          :filename "src/clj/cljs/repl/rhino.clj",
                                          :lines [9 18]},
                                 :full-name "cljs.repl.rhino",
                                 :history [["+" "0.0-927"]]},
              "clojure.browser.dom" {:ns "clojure.browser.dom",
                                     :name-encode "clojure.browser.dom",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.dom",
                                     :source {:code "(ns clojure.browser.dom\n  (:require [goog.dom :as gdom]\n            [goog.object :as gobject]))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/browser/dom.cljs",
                                              :lines [9 11]},
                                     :full-name "clojure.browser.dom",
                                     :history [["+" "0.0-927"]]},
              "clojure.set" {:ns "clojure.set",
                             :name-encode "clojure.set",
                             :type "namespace",
                             :full-name-encode "clojure.set",
                             :source {:code "(ns ^{:doc \"Set operations such as union/intersection.\"\n       :author \"Rich Hickey\"}\n       clojure.set)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/clojure/set.cljs",
                                      :lines [9 11]},
                             :author "Rich Hickey",
                             :full-name "clojure.set",
                             :docstring "Set operations such as union/intersection.",
                             :history [["+" "0.0-927"]]},
              "cljs.repl.node" {:ns "cljs.repl.node",
                                :name-encode "cljs.repl.node",
                                :type "namespace",
                                :full-name-encode "cljs.repl.node",
                                :source {:code "(ns cljs.repl.node\n  (:require [clojure.string :as string]\n            [clojure.java.io :as io]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.repl :as repl]\n            [cljs.closure :as closure]\n            [clojure.data.json :as json])\n  (:import java.net.Socket\n           java.lang.StringBuilder\n           [java.io File BufferedReader BufferedWriter]\n           [java.lang ProcessBuilder ProcessBuilder$Redirect]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/repl/node.clj",
                                         :lines [9 20]},
                                :full-name "cljs.repl.node",
                                :history [["+" "0.0-2629"]]},
              "cljs.nodejs" {:ns "cljs.nodejs",
                             :name-encode "cljs.nodejs",
                             :type "namespace",
                             :full-name-encode "cljs.nodejs",
                             :source {:code "(ns cljs.nodejs)",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/nodejs.cljs",
                                      :lines [12]},
                             :full-name "cljs.nodejs",
                             :history [["+" "0.0-927"]]},
              "cljs.repl.reflect" {:ns "cljs.repl.reflect",
                                   :name-encode "cljs.repl.reflect",
                                   :type "namespace",
                                   :full-name-encode "cljs.repl.reflect",
                                   :source {:code "(ns cljs.repl.reflect\n  (:refer-clojure :exclude [macroexpand])\n  (:require [cljs.repl.server :as server]\n            [cljs.analyzer :as analyzer]\n            [cljs.compiler :as compiler]\n            [clojure.string :as str]\n            [clojure.pprint :as pprint]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/repl/reflect.clj",
                                            :lines [1 7]},
                                   :full-name "cljs.repl.reflect",
                                   :history [["+" "0.0-1503"]]},
              "clojure.walk" {:ns "clojure.walk",
                              :name-encode "clojure.walk",
                              :type "namespace",
                              :full-name-encode "clojure.walk",
                              :source {:code "(ns \n  ^{:author \"Stuart Sierra\",\n     :doc \"This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \\\"walk\\\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.\"}\n  clojure.walk)",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/clojure/walk.cljs",
                                       :lines [23 35]},
                              :author "Stuart Sierra",
                              :full-name "clojure.walk",
                              :docstring "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.",
                              :history [["+" "0.0-927"]]},
              "closure-warnings" {:pseudo-ns? true,
                                  :sub-options-sym "compiler-options/closure-warnings",
                                  :ns "closure-warnings",
                                  :type "namespace",
                                  :full-name-encode "closure-warnings",
                                  :full-name "closure-warnings",
                                  :history [["+" "0.0-2120"]]},
              "cljs.build.api" {:ns "cljs.build.api",
                                :name-encode "cljs.build.api",
                                :type "namespace",
                                :full-name-encode "cljs.build.api",
                                :source {:code "(ns cljs.build.api\n  \"This is intended to be a stable api for those who intend to create\n  tools that use compiler data.\n\n  For example: a build script may need to how to invalidate compiled\n  files so that they will be recompiled.\"\n  (:require [cljs.util :as util]\n            [cljs.env :as env]\n            [cljs.analyzer :as ana]\n            [cljs.compiler :as comp]\n            [cljs.closure :as closure]\n            [clojure.set :refer [intersection]]\n            [cljs.js-deps :as js-deps]\n            [clojure.java.io :as io])\n  (:import java.io.File))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/clj/cljs/build/api.clj",
                                         :lines [8 22]},
                                :full-name "cljs.build.api",
                                :docstring "This is intended to be a stable api for those who intend to create\n  tools that use compiler data.\n\n  For example: a build script may need to how to invalidate compiled\n  files so that they will be recompiled.",
                                :history [["+" "0.0-2496"]]},
              "clojure.browser.event" {:ns "clojure.browser.event",
                                       :name-encode "clojure.browser.event",
                                       :type "namespace",
                                       :full-name-encode "clojure.browser.event",
                                       :source {:code "(ns ^{:doc \"This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.\"\n      :author \"Bobby Calderwood\"}\n  clojure.browser.event\n  (:require [goog.events :as events])\n  (:import (goog.events EventTarget EventType)))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/clojure/browser/event.cljs",
                                                :lines [9 14]},
                                       :author "Bobby Calderwood",
                                       :full-name "clojure.browser.event",
                                       :docstring "This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.",
                                       :history [["+" "0.0-927"]]},
              "cljs.reader" {:ns "cljs.reader",
                             :name-encode "cljs.reader",
                             :type "namespace",
                             :full-name-encode "cljs.reader",
                             :source {:code "(ns cljs.reader\n  (:require [goog.string :as gstring])\n  (:import goog.string.StringBuffer))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/reader.cljs",
                                      :lines [9 11]},
                             :full-name "cljs.reader",
                             :history [["+" "0.0-927"]]},
              "clojure.string" {:ns "clojure.string",
                                :name-encode "clojure.string",
                                :type "namespace",
                                :full-name-encode "clojure.string",
                                :source {:code "(ns clojure.string\n  (:refer-clojure :exclude [replace reverse])\n  (:require [goog.string :as gstring])\n  (:import [goog.string StringBuffer]))",
                                         :title "Source code",
                                         :repo "clojurescript",
                                         :tag "r2760",
                                         :filename "src/cljs/clojure/string.cljs",
                                         :lines [9 12]},
                                :full-name "clojure.string",
                                :history [["+" "0.0-927"]]},
              "cljs.repl" {:ns "cljs.repl",
                           :name-encode "cljs.repl",
                           :type "namespace",
                           :full-name-encode "cljs.repl",
                           :source {:code "(ns cljs.repl\n  (:refer-clojure :exclude [load-file])\n  (:require [clojure.java.io :as io]\n            [cljs.compiler :as comp]\n            [cljs.analyzer :as ana]\n            [cljs.env :as env]\n            [cljs.tagged-literals :as tags]\n            [cljs.closure :as cljsc]\n            [cljs.source-map :as sm]\n            [clojure.tools.reader :as reader]\n            [clojure.tools.reader.reader-types :as readers]\n            [cljs.util :as util]\n            [clojure.stacktrace :as trace])\n  (:import [java.io File PushbackReader]\n           [javax.xml.bind DatatypeConverter]))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/clj/cljs/repl.clj",
                                    :lines [9 23]},
                           :full-name "cljs.repl",
                           :history [["+" "0.0-927"]]},
              "clojure.browser.net" {:ns "clojure.browser.net",
                                     :name-encode "clojure.browser.net",
                                     :type "namespace",
                                     :full-name-encode "clojure.browser.net",
                                     :source {:code "(ns ^{:doc \"Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.\"\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.net\n  (:require [clojure.browser.event :as event]\n            [goog.json :as gjson])\n  (:import (goog.net XhrIo EventType)\n           (goog.net.xpc CfgFields CrossPageChannel)\n           goog.Uri))",
                                              :title "Source code",
                                              :repo "clojurescript",
                                              :tag "r2760",
                                              :filename "src/cljs/clojure/browser/net.cljs",
                                              :lines [9 17]},
                                     :author "Bobby Calderwood and Alex Redington",
                                     :full-name "clojure.browser.net",
                                     :docstring "Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.",
                                     :history [["+" "0.0-927"]]},
              "syntax" {:ns "syntax",
                        :pseudo-ns? true,
                        :type "namespace",
                        :full-name "syntax",
                        :full-name-encode "syntax",
                        :history [["+" "0.0-927"]]},
              "repl-options" {:ns "repl-options",
                              :pseudo-ns? true,
                              :type "namespace",
                              :full-name "repl-options",
                              :full-name-encode "repl-options",
                              :history [["+" "0.0-971"]]},
              "warnings" {:pseudo-ns? true,
                          :sub-options-sym "compiler-options/warnings",
                          :ns "warnings",
                          :type "namespace",
                          :full-name-encode "warnings",
                          :full-name "warnings",
                          :history [["+" "0.0-1835"]]},
              "cljs.core" {:ns "cljs.core",
                           :name-encode "cljs.core",
                           :type "namespace",
                           :full-name-encode "cljs.core",
                           :source {:code "(ns cljs.core\n  (:require [goog.string :as gstring]\n            [goog.object :as gobject]\n            [goog.array :as garray])\n  (:import goog.string.StringBuffer))",
                                    :title "Source code",
                                    :repo "clojurescript",
                                    :tag "r2760",
                                    :filename "src/cljs/cljs/core.cljs",
                                    :lines [9 13]},
                           :full-name "cljs.core",
                           :history [["+" "0.0-927"]]},
              "cljs.analyzer.api" {:ns "cljs.analyzer.api",
                                   :name-encode "cljs.analyzer.api",
                                   :type "namespace",
                                   :full-name-encode "cljs.analyzer.api",
                                   :source {:code "(ns cljs.analyzer.api\n  (:refer-clojure :exclude [all-ns ns-interns ns-resolve resolve find-ns])\n  (:require [cljs.env :as env]\n            [cljs.analyzer :as ana]))",
                                            :title "Source code",
                                            :repo "clojurescript",
                                            :tag "r2760",
                                            :filename "src/clj/cljs/analyzer/api.clj",
                                            :lines [9 12]},
                                   :full-name "cljs.analyzer.api",
                                   :history [["+" "0.0-2496"]]},
              "cljs.pprint" {:ns "cljs.pprint",
                             :name-encode "cljs.pprint",
                             :type "namespace",
                             :full-name-encode "cljs.pprint",
                             :source {:code "(ns \n    ^{:author \"Tom Faulhaber\",\n      :doc \"A Pretty Printer for ClojureScript\n\ncljs.pprint implements a flexible system for printing structured data\nin a pleasing, easy-to-understand format. Basic use of the pretty printer is \nsimple, just call pprint instead of println. More advanced users can use \nthe building blocks provided to create custom output formats. \n\nOut of the box, pprint supports a simple structured format for basic data \nand a specialized format for Clojure source code. More advanced formats,\nincluding formats that don't look like Clojure data at all like XML and \nJSON, can be rendered by creating custom dispatch functions. \n\nIn addition to the pprint function, this module contains cl-format, a text \nformatting function which is fully compatible with the format function in \nCommon Lisp. Because pretty printing directives are directly integrated with\ncl-format, it supports very concise custom dispatch. It also provides\na more powerful alternative to Clojure's standard format function.\n\nSee documentation for pprint and cl-format for more information or \ncomplete documentation on the the clojure web site on github.\"}\n    cljs.pprint\n    (:require [clojure.walk :refer [walk]]))",
                                      :title "Source code",
                                      :repo "clojurescript",
                                      :tag "r2760",
                                      :filename "src/cljs/cljs/pprint.cljs",
                                      :lines [14 37]},
                             :author "Tom Faulhaber",
                             :full-name "cljs.pprint",
                             :docstring "A Pretty Printer for ClojureScript\n\ncljs.pprint implements a flexible system for printing structured data\nin a pleasing, easy-to-understand format. Basic use of the pretty printer is \nsimple, just call pprint instead of println. More advanced users can use \nthe building blocks provided to create custom output formats. \n\nOut of the box, pprint supports a simple structured format for basic data \nand a specialized format for Clojure source code. More advanced formats,\nincluding formats that don't look like Clojure data at all like XML and \nJSON, can be rendered by creating custom dispatch functions. \n\nIn addition to the pprint function, this module contains cl-format, a text \nformatting function which is fully compatible with the format function in \nCommon Lisp. Because pretty printing directives are directly integrated with\ncl-format, it supports very concise custom dispatch. It also provides\na more powerful alternative to Clojure's standard format function.\n\nSee documentation for pprint and cl-format for more information or \ncomplete documentation on the the clojure web site on github.",
                             :history [["+" "0.0-2496"]]},
              "clojure.data" {:ns "clojure.data",
                              :name-encode "clojure.data",
                              :type "namespace",
                              :full-name-encode "clojure.data",
                              :source {:code "(ns \n  ^{:author \"Stuart Halloway\",\n    :doc \"Non-core data functions.\"}\n  clojure.data\n  (:require [clojure.set :as set]))",
                                       :title "Source code",
                                       :repo "clojurescript",
                                       :tag "r2760",
                                       :filename "src/cljs/clojure/data.cljs",
                                       :lines [9 13]},
                              :author "Stuart Halloway",
                              :full-name "clojure.data",
                              :docstring "Non-core data functions.",
                              :history [["+" "0.0-1503"]]},
              "clojure.core.reducers" {:ns "clojure.core.reducers",
                                       :name-encode "clojure.core.reducers",
                                       :type "namespace",
                                       :full-name-encode "clojure.core.reducers",
                                       :source {:code "(ns ^{:doc\n      \"A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.\"\n      :author \"Rich Hickey\"}\n  clojure.core.reducers\n  (:refer-clojure :exclude [reduce map mapcat filter remove take take-while drop flatten cat])\n  (:require [cljs.core :as core]))",
                                                :title "Source code",
                                                :repo "clojurescript",
                                                :tag "r2760",
                                                :filename "src/cljs/clojure/core/reducers.cljs",
                                                :lines [9 17]},
                                       :author "Rich Hickey",
                                       :full-name "clojure.core.reducers",
                                       :docstring "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.",
                                       :history [["+" "0.0-1236"]]},
              "compiler-options" {:ns "compiler-options",
                                  :pseudo-ns? true,
                                  :type "namespace",
                                  :full-name "compiler-options",
                                  :full-name-encode "compiler-options",
                                  :history [["+" "0.0-971"]]},
              "clojure.browser.repl" {:ns "clojure.browser.repl",
                                      :name-encode "clojure.browser.repl",
                                      :type "namespace",
                                      :full-name-encode "clojure.browser.repl",
                                      :source {:code "(ns ^{:doc \"Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!\"\n\n      :author \"Bobby Calderwood and Alex Redington\"}\n  clojure.browser.repl\n  (:require [clojure.browser.net   :as net]\n            [clojure.browser.event :as event]))",
                                               :title "Source code",
                                               :repo "clojurescript",
                                               :tag "r2760",
                                               :filename "src/cljs/clojure/browser/repl.cljs",
                                               :lines [9 19]},
                                      :author "Bobby Calderwood and Alex Redington",
                                      :full-name "clojure.browser.repl",
                                      :docstring "Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!",
                                      :history [["+" "0.0-927"]]}},
 :api {:syntax {:changes {"0.0-2030" {},
                          "0.0-2067" {},
                          "0.0-2134" {},
                          "0.0-2322" {},
                          "0.0-1803" {},
                          "0.0-2371" {},
                          "0.0-2307" {},
                          "0.0-1886" {},
                          "0.0-2138" {},
                          "0.0-2505" {},
                          "0.0-2311" {},
                          "0.0-2740" {},
                          "0.0-2725" {},
                          "0.0-2127" {},
                          "0.0-2280" {},
                          "0.0-2199" {},
                          "0.0-2120" {:added #{"syntax/js-literal"}},
                          "0.0-1878" {},
                          "0.0-1236" {},
                          "0.0-2060" {},
                          "0.0-1424" {:added #{"syntax/inst-literal"
                                               "syntax/queue-literal"
                                               "syntax/uuid-literal"}},
                          "0.0-2342" {},
                          "0.0-1885" {},
                          "0.0-1535" {},
                          "0.0-1859" {},
                          "0.0-2755" {},
                          "0.0-1853" {:added #{"syntax/symbol"
                                               "syntax/vector"
                                               "syntax/string"
                                               "syntax/comment"
                                               "syntax/quote"
                                               "syntax/keyword-qualify"
                                               "syntax/meta"
                                               "syntax/regex"
                                               "syntax/eval"
                                               "syntax/unquote-splicing"
                                               "syntax/true"
                                               "syntax/keyword"
                                               "syntax/character"
                                               "syntax/unreadable"
                                               "syntax/arg"
                                               "syntax/false"
                                               "syntax/set"
                                               "syntax/tagged-literal"
                                               "syntax/syntax-quote"
                                               "syntax/dispatch"
                                               "syntax/shebang"
                                               "syntax/function"
                                               "syntax/nil"
                                               "syntax/map"
                                               "syntax/number"
                                               "syntax/list"
                                               "syntax/deref"
                                               "syntax/unquote"
                                               "syntax/ignore"
                                               "syntax/var"}},
                          "0.0-2197" {},
                          "0.0-2075" {},
                          "0.0-2277" {},
                          "0.0-2301" {},
                          "0.0-1909" {},
                          "0.0-2723" {},
                          "0.0-2727" {},
                          "0.0-1552" {},
                          "0.0-2080" {},
                          "0.0-2234" {},
                          "0.0-2644" {},
                          "0.0-2268" {},
                          "0.0-2511" {},
                          "0.0-1806" {},
                          "0.0-2341" {},
                          "0.0-2629" {},
                          "0.0-2719" {},
                          "0.0-2227" {},
                          "0.0-1576" {},
                          "0.0-1844" {},
                          "0.0-1586" {},
                          "0.0-2498" {},
                          "0.0-1443" {},
                          "0.0-1006" {},
                          "0.0-1913" {},
                          "0.0-2069" {},
                          "0.0-2655" {},
                          "0.0-1513" {},
                          "0.0-1503" {},
                          "0.0-1933" {},
                          "0.0-1895" {},
                          "0.0-971" {},
                          "0.0-2027" {},
                          "0.0-1978" {},
                          "0.0-1843" {},
                          "0.0-2758" {},
                          "0.0-1835" {},
                          "0.0-1450" {},
                          "0.0-2173" {},
                          "0.0-1798" {},
                          "0.0-1877" {},
                          "0.0-1211" {},
                          "0.0-1449" {},
                          "0.0-993" {},
                          "0.0-1011" {},
                          "0.0-2356" {},
                          "0.0-2156" {},
                          "0.0-1847" {},
                          "0.0-2496" {},
                          "0.0-927" {:added #{"syntax/whitespace"
                                              "syntax/earmuffs"
                                              "syntax/Math-namespace"
                                              "syntax/comma"
                                              "syntax/js-namespace"
                                              "syntax/namespace"
                                              "syntax/dot"
                                              "syntax/unused"
                                              "syntax/rest"
                                              "syntax/auto-gensym"
                                              "syntax/destructure-map"
                                              "syntax/impure"
                                              "syntax/predicate"
                                              "syntax/destructure-vector"}},
                          "0.0-1934" {},
                          "0.0-2202" {},
                          "0.0-1820" {},
                          "0.0-2261" {},
                          "0.0-2024" {},
                          "0.0-1889" {},
                          "0.0-2657" {},
                          "0.0-1896" {},
                          "0.0-2014" {},
                          "0.0-2411" {},
                          "0.0-2665" {},
                          "0.0-2760" {}},
                :symbol-names #{"syntax/symbol"
                                "syntax/vector"
                                "syntax/inst-literal"
                                "syntax/whitespace"
                                "syntax/earmuffs"
                                "syntax/Math-namespace"
                                "syntax/comma"
                                "syntax/string"
                                "syntax/comment"
                                "syntax/js-namespace"
                                "syntax/quote"
                                "syntax/namespace"
                                "syntax/keyword-qualify"
                                "syntax/meta"
                                "syntax/regex"
                                "syntax/eval"
                                "syntax/dot"
                                "syntax/unused"
                                "syntax/unquote-splicing"
                                "syntax/true"
                                "syntax/rest"
                                "syntax/keyword"
                                "syntax/character"
                                "syntax/unreadable"
                                "syntax/auto-gensym"
                                "syntax/arg"
                                "syntax/false"
                                "syntax/set"
                                "syntax/tagged-literal"
                                "syntax/destructure-map"
                                "syntax/syntax-quote"
                                "syntax/dispatch"
                                "syntax/queue-literal"
                                "syntax/shebang"
                                "syntax/function"
                                "syntax/nil"
                                "syntax/map"
                                "syntax/number"
                                "syntax/js-literal"
                                "syntax/list"
                                "syntax/uuid-literal"
                                "syntax/impure"
                                "syntax/deref"
                                "syntax/unquote"
                                "syntax/predicate"
                                "syntax/ignore"
                                "syntax/destructure-vector"
                                "syntax/var"},
                :namespace-names #{"syntax"}},
       :options {:changes {"0.0-2030" {},
                           "0.0-2067" {:added #{"warnings/invalid-arithmetic"}},
                           "0.0-2134" {},
                           "0.0-2322" {},
                           "0.0-1803" {},
                           "0.0-2371" {:added #{"warnings/preamble-missing"}},
                           "0.0-2307" {},
                           "0.0-1886" {},
                           "0.0-2138" {},
                           "0.0-2505" {:added #{"compiler-options/source-map-timestamp"}},
                           "0.0-2311" {},
                           "0.0-2740" {},
                           "0.0-2725" {},
                           "0.0-2127" {:added #{"compiler-options/preamble"}},
                           "0.0-2280" {},
                           "0.0-2199" {},
                           "0.0-2120" {:added #{"closure-warnings/externs-validation"
                                                "closure-warnings/duplicate-message"
                                                "closure-warnings/tweaks"
                                                "closure-warnings/es5-strict"
                                                "closure-warnings/check-types"
                                                "closure-warnings/undefined-variables"
                                                "closure-warnings/const"
                                                "closure-warnings/access-controls"
                                                "closure-warnings/fileoverview-jsdoc"
                                                "closure-warnings/debugger-statement-present"
                                                "closure-warnings/undefined-names"
                                                "closure-warnings/missing-properties"
                                                "closure-warnings/ambiguous-function-decl"
                                                "closure-warnings/check-regexp"
                                                "compiler-options/closure-warnings"
                                                "closure-warnings/check-useless-code"
                                                "closure-warnings/strict-module-dep-check"
                                                "closure-warnings/non-standard-jsdoc"
                                                "closure-warnings/check-variables"
                                                "compiler-options/closure-defines"
                                                "closure-warnings/visiblity"
                                                "closure-warnings/internet-explorer-checks"
                                                "closure-warnings/global-this"
                                                "closure-warnings/deprecated"
                                                "closure-warnings/constant-property"
                                                "closure-warnings/unknown-defines"
                                                "closure-warnings/invalid-casts"}},
                           "0.0-1878" {},
                           "0.0-1236" {},
                           "0.0-2060" {:added #{"warnings/invoke-ctor"
                                                "compiler-options/source-map-path"}},
                           "0.0-1424" {:added #{"compiler-options/static-fns"}},
                           "0.0-2342" {},
                           "0.0-1885" {},
                           "0.0-1535" {},
                           "0.0-1859" {},
                           "0.0-2755" {},
                           "0.0-1853" {:added #{"warnings/fn-arity"}},
                           "0.0-2197" {:added #{"compiler-options/hashbang"
                                                "compiler-options/language-out"
                                                "compiler-options/language-in"}},
                           "0.0-2075" {},
                           "0.0-2277" {},
                           "0.0-2301" {},
                           "0.0-1909" {},
                           "0.0-2723" {},
                           "0.0-2727" {:added #{"compiler-options/asset-path"}},
                           "0.0-1552" {:added #{"repl-options/analyze-path"}},
                           "0.0-2080" {},
                           "0.0-2234" {},
                           "0.0-2644" {},
                           "0.0-2268" {},
                           "0.0-2511" {:added #{"compiler-options/cache-analysis"}},
                           "0.0-1806" {},
                           "0.0-2341" {:added #{"warnings/protocol-multiple-impls"
                                                "warnings/protocol-duped-method"
                                                "warnings/protocol-invalid-method"}},
                           "0.0-2629" {:added #{"warnings/redef-in-file"
                                                "compiler-options/compiler-stats"}},
                           "0.0-2719" {:added #{"repl-options/repl-verbose"}},
                           "0.0-2227" {:added #{"compiler-options/pseudo-names"}},
                           "0.0-1576" {},
                           "0.0-1844" {},
                           "0.0-1586" {},
                           "0.0-2498" {},
                           "0.0-1443" {:added #{"compiler-options/warnings"}},
                           "0.0-1006" {},
                           "0.0-1913" {},
                           "0.0-2069" {},
                           "0.0-2655" {},
                           "0.0-1513" {:added #{"compiler-options/output-wrapper"}},
                           "0.0-1503" {:added #{"repl-options/src"}},
                           "0.0-1933" {},
                           "0.0-1895" {},
                           "0.0-971" {:added #{"compiler-options/verbose"
                                               "compiler-options/libs"
                                               "repl-options/warn-on-undeclared"
                                               "compiler-options/optimizations"
                                               "compiler-options/pretty-print"
                                               "compiler-options/target"
                                               "compiler-options/use-only-custom-externs"
                                               "compiler-options/main"
                                               "compiler-options/output-dir"
                                               "compiler-options/print-input-delimiter"
                                               "compiler-options/foreign-libs"
                                               "compiler-options/externs"
                                               "repl-options/working-dir"
                                               "compiler-options/output-to"}},
                           "0.0-2027" {},
                           "0.0-1978" {},
                           "0.0-1843" {},
                           "0.0-2758" {},
                           "0.0-1835" {:added #{"warnings/redef"
                                                "warnings/protocol-deprecated"
                                                "warnings/fn-var"
                                                "warnings/dynamic"
                                                "warnings/fn-deprecated"
                                                "warnings/undeclared"}},
                           "0.0-1450" {},
                           "0.0-2173" {:added #{"warnings/unprovided"}},
                           "0.0-1798" {:added #{"compiler-options/source-map"}},
                           "0.0-1877" {:added #{"compiler-options/optimize-constants"}},
                           "0.0-1211" {:added #{"repl-options/static-dir"}},
                           "0.0-1449" {},
                           "0.0-993" {},
                           "0.0-1011" {},
                           "0.0-2356" {},
                           "0.0-2156" {:added #{"compiler-options/elide-asserts"}},
                           "0.0-1847" {},
                           "0.0-2496" {},
                           "0.0-927" {},
                           "0.0-1934" {},
                           "0.0-2202" {},
                           "0.0-1820" {},
                           "0.0-2261" {},
                           "0.0-2024" {:added #{"warnings/extending-base-js-type"}},
                           "0.0-1889" {},
                           "0.0-2657" {},
                           "0.0-1896" {},
                           "0.0-2014" {:added #{"warnings/undeclared-var"
                                                "warnings/variadic-max-arity"
                                                "warnings/invalid-protocol-symbol"
                                                "warnings/multiple-variadic-overloads"
                                                "warnings/overload-arity"
                                                "warnings/undeclared-ns-form"
                                                "warnings/undeclared-ns"
                                                "warnings/undeclared-protocol-symbol"},
                                       :removed #{"warnings/undeclared"}},
                           "0.0-2411" {:added #{"compiler-options/anon-fn-naming-policy"}},
                           "0.0-2665" {},
                           "0.0-2760" {}},
                 :symbol-names #{"warnings/invoke-ctor"
                                 "closure-warnings/externs-validation"
                                 "warnings/redef"
                                 "warnings/preamble-missing"
                                 "closure-warnings/duplicate-message"
                                 "closure-warnings/tweaks"
                                 "closure-warnings/es5-strict"
                                 "warnings/protocol-deprecated"
                                 "closure-warnings/check-types"
                                 "warnings/protocol-multiple-impls"
                                 "compiler-options/verbose"
                                 "closure-warnings/undefined-variables"
                                 "compiler-options/libs"
                                 "compiler-options/pseudo-names"
                                 "closure-warnings/const"
                                 "repl-options/warn-on-undeclared"
                                 "compiler-options/optimizations"
                                 "warnings/redef-in-file"
                                 "compiler-options/static-fns"
                                 "compiler-options/pretty-print"
                                 "compiler-options/target"
                                 "closure-warnings/access-controls"
                                 "warnings/undeclared-var"
                                 "repl-options/src"
                                 "closure-warnings/fileoverview-jsdoc"
                                 "warnings/extending-base-js-type"
                                 "closure-warnings/debugger-statement-present"
                                 "closure-warnings/undefined-names"
                                 "compiler-options/asset-path"
                                 "closure-warnings/missing-properties"
                                 "closure-warnings/ambiguous-function-decl"
                                 "warnings/variadic-max-arity"
                                 "compiler-options/preamble"
                                 "closure-warnings/check-regexp"
                                 "compiler-options/closure-warnings"
                                 "warnings/invalid-protocol-symbol"
                                 "warnings/fn-arity"
                                 "compiler-options/use-only-custom-externs"
                                 "closure-warnings/check-useless-code"
                                 "warnings/protocol-duped-method"
                                 "warnings/multiple-variadic-overloads"
                                 "compiler-options/hashbang"
                                 "closure-warnings/strict-module-dep-check"
                                 "compiler-options/warnings"
                                 "compiler-options/main"
                                 "closure-warnings/non-standard-jsdoc"
                                 "warnings/invalid-arithmetic"
                                 "compiler-options/output-dir"
                                 "warnings/overload-arity"
                                 "compiler-options/source-map"
                                 "warnings/fn-var"
                                 "compiler-options/anon-fn-naming-policy"
                                 "warnings/dynamic"
                                 "warnings/undeclared-ns-form"
                                 "closure-warnings/check-variables"
                                 "compiler-options/optimize-constants"
                                 "repl-options/analyze-path"
                                 "compiler-options/source-map-path"
                                 "compiler-options/print-input-delimiter"
                                 "compiler-options/closure-defines"
                                 "closure-warnings/visiblity"
                                 "closure-warnings/internet-explorer-checks"
                                 "compiler-options/foreign-libs"
                                 "compiler-options/externs"
                                 "closure-warnings/global-this"
                                 "closure-warnings/deprecated"
                                 "compiler-options/language-out"
                                 "warnings/unprovided"
                                 "warnings/fn-deprecated"
                                 "warnings/undeclared"
                                 "warnings/undeclared-ns"
                                 "compiler-options/cache-analysis"
                                 "warnings/protocol-invalid-method"
                                 "compiler-options/language-in"
                                 "compiler-options/output-wrapper"
                                 "repl-options/static-dir"
                                 "compiler-options/elide-asserts"
                                 "warnings/undeclared-protocol-symbol"
                                 "repl-options/working-dir"
                                 "compiler-options/source-map-timestamp"
                                 "compiler-options/compiler-stats"
                                 "closure-warnings/constant-property"
                                 "closure-warnings/unknown-defines"
                                 "closure-warnings/invalid-casts"
                                 "compiler-options/output-to"
                                 "repl-options/repl-verbose"},
                 :namespace-names #{"closure-warnings"
                                    "repl-options"
                                    "warnings"
                                    "compiler-options"}},
       :library {:changes {"0.0-2030" {},
                           "0.0-2067" {},
                           "0.0-2134" {:added #{"cljs.core/clone"
                                                "cljs.core/ICloneable"}},
                           "0.0-2322" {},
                           "0.0-1803" {:added #{"cljs.core/special-symbol?"
                                                "cljs.core/lazy-cat"}},
                           "0.0-2371" {:added #{"cljs.core/RangeIterator"
                                                "cljs.core/es6-set-entries-iterator"
                                                "cljs.core/es6-entries-iterator"
                                                "cljs.core/PersistentArrayMapIterator"
                                                "cljs.core/ES6EntriesIterator"
                                                "cljs.core/IndexedSeqIterator"
                                                "cljs.core/RangedIterator"
                                                "cljs.core/es6-iterator"
                                                "cljs.core/eduction"
                                                "cljs.core/ES6Iterator"
                                                "cljs.core/Eduction"
                                                "cljs.core/ES6SetEntriesIterator"
                                                "cljs.core/ranged-iterator"},
                                       :removed #{"cljs.core/iterator"
                                                  "cljs.core/SetEntriesIterator"
                                                  "cljs.core/EntriesIterator"
                                                  "cljs.core/Iteration"
                                                  "cljs.core/iteration"
                                                  "cljs.core/set-entries-iterator"
                                                  "cljs.core/entries-iterator"
                                                  "cljs.core/Iterator"}},
                           "0.0-2307" {},
                           "0.0-1886" {},
                           "0.0-2138" {:added #{"cljs.core/specify"}},
                           "0.0-2505" {},
                           "0.0-2311" {},
                           "0.0-2740" {},
                           "0.0-2725" {},
                           "0.0-2127" {},
                           "0.0-2280" {},
                           "0.0-2199" {},
                           "0.0-2120" {:added #{"cljs.core/print-map"
                                                "cljs.core/sorted?"
                                                "cljs.core/*print-level*"
                                                "clojure.core.reducers/CollFold"
                                                "cljs.core/sequence"
                                                "cljs.core/object?"}},
                           "0.0-1878" {},
                           "0.0-1236" {:added #{"clojure.core.reducers/drop"
                                                "clojure.core.reducers/folder"
                                                "clojure.core.reducers/Cat"
                                                "clojure.core.reducers/foldcat"
                                                "clojure.core.reducers/fold"
                                                "clojure.core.reducers/monoid"
                                                "clojure.core.reducers/map"
                                                "clojure.core.reducers/cat"
                                                "clojure.core.reducers/take"
                                                "cljs.reader/maybe-read-tagged-type"
                                                "clojure.core.reducers/reduce"
                                                "cljs.core/letfn*"
                                                "clojure.core.reducers/flatten"
                                                "cljs.reader/*tag-table*"
                                                "clojure.core.reducers/filter"
                                                "cljs.core/simple-benchmark"
                                                "clojure.core.reducers/append!"
                                                "clojure.core.reducers/reducer"
                                                "clojure.core.reducers/take-while"
                                                "cljs.reader/register-tag-parser!"
                                                "clojure.core.reducers/remove"
                                                "cljs.reader/read-string*"
                                                "clojure.core.reducers/mapcat"}},
                           "0.0-2060" {:added #{"cljs.core/enable-console-print!"
                                                "cljs.core/*print-length*"
                                                "cljs.core/*print-newline*"}},
                           "0.0-1424" {:added #{"cljs.core/Box"
                                                "cljs.core/array-chunk"
                                                "cljs.core/string-hash-cache"
                                                "cljs.reader/read-2-chars"
                                                "cljs.core/chunk"
                                                "cljs.core/chunk-next"
                                                "cljs.reader/make-unicode-char"
                                                "cljs.core/shuffle"
                                                "cljs.core/ArrayChunk"
                                                "cljs.core/chunk-cons"
                                                "cljs.core/chunked-seq"
                                                "cljs.reader/unicode-4-pattern"
                                                "cljs.core/IComparable"
                                                "cljs.reader/unicode-2-pattern"
                                                "cljs.core/check-string-hash-cache"
                                                "cljs.core/Keyword"
                                                "cljs.core/key-test"
                                                "cljs.core/IChunkedSeq"
                                                "cljs.core/chunk-append"
                                                "cljs.core/regexp?"
                                                "cljs.reader/read-4-chars"
                                                "cljs.core/UUID"
                                                "cljs.reader/deregister-tag-parser!"
                                                "cljs.core/INext"
                                                "cljs.core/RSeq"
                                                "cljs.core/add-to-string-hash-cache"
                                                "cljs.core/chunk-buffer"
                                                "cljs.core/IChunkedNext"
                                                "cljs.core/ChunkBuffer"
                                                "cljs.core/chunked-seq?"
                                                "cljs.reader/validate-unicode-escape"
                                                "cljs.core/string-hash-cache-count"
                                                "cljs.core/IChunk"
                                                "cljs.reader/parse-timestamp"
                                                "cljs.core/chunk-first"
                                                "cljs.core/ChunkedSeq"
                                                "cljs.core/chunk-rest"
                                                "cljs.core/ChunkedCons"},
                                       :removed #{"cljs.core/vector-seq"
                                                  "cljs.reader/read-unicode-char"}},
                           "0.0-2342" {},
                           "0.0-1885" {:removed #{"cljs.core/printf"
                                                  "cljs.core/format"}},
                           "0.0-1535" {:added #{"cljs.core/with-out-str"}},
                           "0.0-1859" {:added #{"cljs.core/type->str"}},
                           "0.0-2755" {},
                           "0.0-1853" {:added #{"cljs.reader/parse-and-validate-timestamp"}},
                           "0.0-2197" {},
                           "0.0-2075" {},
                           "0.0-2277" {:removed #{"cljs.core/unchecked-substract-int"
                                                  "cljs.core/unchecked-substract"}},
                           "0.0-2301" {:added #{"cljs.core/LazyTransformer.createMulti"
                                                "cljs.core/flatmap"
                                                "cljs.core/ArrayList"
                                                "cljs.core/stepper"
                                                "cljs.core/LazyTransformer.create"
                                                "cljs.core/ArrayIter"
                                                "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                                "cljs.core/LazyTransformer"
                                                "cljs.core/dedupe"
                                                "cljs.core/string-iter"
                                                "cljs.core/run!"
                                                "cljs.core/lazy-transformer"
                                                "cljs.core/random-sample"
                                                "cljs.core/iter"
                                                "cljs.core/multi-stepper"
                                                "cljs.core/Iteration"
                                                "cljs.core/PersistentVector.EMPTY-NODE"
                                                "clojure.browser.event/IEventType"
                                                "cljs.core/SeqIter"
                                                "cljs.core/Stepper"
                                                "cljs.core/transduce"
                                                "cljs.core/iteration"
                                                "cljs.core/array-iter"
                                                "cljs.core/array-list"
                                                "cljs.core/nil-iter"
                                                "cljs.core/StringIter"
                                                "cljs.core/MultiStepper"
                                                "cljs.core/seq-iter"},
                                       :removed #{"cljs.core/PersistentVector.EMPTY_NODE"
                                                  "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                                  "clojure.browser.event/EventType"}},
                           "0.0-1909" {},
                           "0.0-2723" {},
                           "0.0-2727" {},
                           "0.0-1552" {:added #{"cljs.core/Fn"
                                                "cljs.core/IEncodeJS"
                                                "cljs.core/js-mod"
                                                "cljs.core/IEncodeClojure"
                                                "cljs.core/clj->js"}},
                           "0.0-2080" {:added #{"cljs.core/unsigned-bit-shift-right"}},
                           "0.0-2234" {:added #{"cljs.core/MetaFn"}},
                           "0.0-2644" {},
                           "0.0-2268" {:added #{"cljs.core/iterator"
                                                "cljs.core/SetEntriesIterator"
                                                "cljs.core/EntriesIterator"
                                                "cljs.core/set-entries-iterator"
                                                "cljs.core/entries-iterator"
                                                "cljs.core/Iterator"}},
                           "0.0-2511" {},
                           "0.0-1806" {:added #{"cljs.core/with-redefs"
                                                "cljs.core/pr-str*"}},
                           "0.0-2341" {:added #{"cljs.core/js-str"
                                                "cljs.core/cat"
                                                "cljs.core/completing"},
                                       :removed #{"cljs.core/flatmap"}},
                           "0.0-2629" {:added #{"cljs.test/are"
                                                "cljs.core/require"}},
                           "0.0-2719" {:added #{"cljs.repl/with-read-known"
                                                "cljs.core/PersistentHashMap.fromArray"
                                                "cljs.core/load-file*"}},
                           "0.0-2227" {:added #{"cljs.core/case*"}},
                           "0.0-1576" {:added #{"cljs.core/ex-message"
                                                "cljs.reader/deregister-default-tag-parser!"
                                                "cljs.core/ex-data"
                                                "cljs.core/ex-info"
                                                "cljs.reader/*default-data-reader-fn*"
                                                "cljs.core/ExceptionInfo"
                                                "cljs.reader/register-default-tag-parser!"
                                                "cljs.core/ex-cause"}},
                           "0.0-1844" {},
                           "0.0-1586" {:added #{"cljs.core/comparator"}},
                           "0.0-2498" {:added #{"cljs.test/use-fixtures"}},
                           "0.0-1443" {:added #{"cljs.core/printf"
                                                "cljs.core/format"
                                                "cljs.core/obj-map"
                                                "cljs.core/memfn"
                                                "cljs.core/PersistentHashSet.fromArray"
                                                "cljs.core/hash-set"}},
                           "0.0-1006" {:added #{"cljs.core/PersistentVector.EMPTY_NODE"
                                                "cljs.core/PersistentVector.fromArray"
                                                "cljs.core/PersistentVector"
                                                "cljs.core/PersistentVector.EMPTY"}},
                           "0.0-1913" {},
                           "0.0-2069" {},
                           "0.0-2655" {:added #{"cljs.core/*loaded-libs*"}},
                           "0.0-1513" {},
                           "0.0-1503" {:added #{"clojure.data/EqualityPartition"
                                                "clojure.reflect/meta"
                                                "cljs.core/write-all"
                                                "cljs.core/pr-sequential-writer"
                                                "cljs.core/StringBufferWriter"
                                                "clojure.reflect/macroexpand"
                                                "cljs.core/pr-seq-writer"
                                                "clojure.reflect/print-doc"
                                                "clojure.reflect/doc"
                                                "cljs.core/IWriter"
                                                "clojure.data/Diff"
                                                "clojure.data/diff"
                                                "cljs.core/IPrintWithWriter"},
                                       :removed #{"cljs.core/pr-with-opts"}},
                           "0.0-1933" {:removed #{"cljs.core/try*"}},
                           "0.0-1895" {},
                           "0.0-971" {:added #{"cljs.core/type"
                                               "cljs.core/IFn"}},
                           "0.0-2027" {},
                           "0.0-1978" {},
                           "0.0-1843" {},
                           "0.0-2758" {},
                           "0.0-1835" {},
                           "0.0-1450" {},
                           "0.0-2173" {:added #{"cljs.core/IReset"
                                                "cljs.core/IAtom"
                                                "cljs.core/ISwap"}},
                           "0.0-1798" {:added #{"cljs.core/unchecked-negate"
                                                "cljs.core/float"
                                                "cljs.core/int-array"
                                                "cljs.core/unchecked-multiply-int"
                                                "cljs.core/cond->"
                                                "cljs.core/unchecked-add"
                                                "cljs.core/Symbol"
                                                "cljs.core/chars"
                                                "cljs.core/short"
                                                "cljs.core/longs"
                                                "cljs.core/unchecked-multiply"
                                                "cljs.core/some->"
                                                "cljs.core/unchecked-negate-int"
                                                "cljs.core/unchecked-substract-int"
                                                "cljs.core/unchecked-double"
                                                "cljs.core/set-print-fn!"
                                                "cljs.core/unchecked-inc-int"
                                                "cljs.core/unchecked-subtract"
                                                "cljs.core/unchecked-add-int"
                                                "cljs.core/some->>"
                                                "cljs.core/unchecked-inc"
                                                "cljs.core/unchecked-subtract-int"
                                                "cljs.core/unchecked-substract"
                                                "cljs.core/unchecked-dec"
                                                "cljs.core/unchecked-divide-int"
                                                "cljs.core/ints"
                                                "cljs.core/PersistentArrayMap.fromArray"
                                                "cljs.core/unchecked-dec-int"
                                                "cljs.core/array?"
                                                "cljs.core/unchecked-char"
                                                "cljs.core/key->js"
                                                "cljs.core/char"
                                                "cljs.core/floats"
                                                "cljs.core/cond->>"
                                                "cljs.core/booleans"
                                                "cljs.core/not-native"
                                                "cljs.core/bytes"
                                                "cljs.core/unchecked-byte"
                                                "cljs.core/unchecked-short"
                                                "cljs.core/byte"
                                                "cljs.core/INamed"
                                                "cljs.core/shorts"
                                                "cljs.core/unchecked-int"
                                                "cljs.core/double"
                                                "cljs.core/exists?"
                                                "cljs.core/doubles"
                                                "cljs.core/unchecked-float"
                                                "cljs.core/divide"
                                                "cljs.core/as->"
                                                "cljs.core/unchecked-remainder-int"
                                                "cljs.core/unchecked-long"},
                                       :removed #{"cljs.core/PersistentArrayMap.fromArrays"
                                                  "cljs.core/HashMap"
                                                  "cljs.core/IPrintable"
                                                  "cljs.core/Vector.fromArray"
                                                  "cljs.core/pr-sequential"
                                                  "cljs.core/HashMap.EMPTY"
                                                  "cljs.core/Vector.EMPTY"
                                                  "cljs.core/HashMap.fromArrays"
                                                  "cljs.core/Vector"}},
                           "0.0-1877" {:added #{"cljs.core/keyword-identical?"
                                                "cljs.core/set-from-indexed-seq"}},
                           "0.0-1211" {:added #{"cljs.core/ITransientCollection"
                                                "cljs.core/transient"
                                                "cljs.core/dissoc!"
                                                "cljs.core/PersistentArrayMap.fromArrays"
                                                "cljs.core/ITransientSet"
                                                "cljs.core/array-map"
                                                "cljs.core/rseq"
                                                "cljs.core/ITransientMap"
                                                "cljs.core/ArrayNodeSeq"
                                                "cljs.core/list?"
                                                "cljs.core/val"
                                                "cljs.core/BitmapIndexedNode"
                                                "cljs.core/IMapEntry"
                                                "cljs.core/*unchecked-if*"
                                                "cljs.core/seqable?"
                                                "cljs.core/sorted-map"
                                                "cljs.core/ASeq"
                                                "cljs.core/reduceable?"
                                                "cljs.core/vector-seq"
                                                "cljs.core/conj!"
                                                "cljs.core/PersistentHashMap"
                                                "cljs.core/IReversible"
                                                "cljs.core/IKVReduce"
                                                "cljs.core/BlackNode"
                                                "cljs.core/PersistentHashSet.EMPTY"
                                                "cljs.core/PersistentArrayMap"
                                                "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                                "cljs.core/int"
                                                "cljs.core/ISorted"
                                                "cljs.core/double-array"
                                                "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                                "cljs.core/PersistentArrayMap.EMPTY"
                                                "cljs.core/reduced?"
                                                "cljs.core/PersistentTreeMapSeq"
                                                "cljs.core/persistent!"
                                                "cljs.core/PersistentHashMap.fromArrays"
                                                "cljs.core/sorted-set"
                                                "cljs.core/PersistentTreeMap.EMPTY"
                                                "cljs.core/IList"
                                                "cljs.core/PersistentHashMap.EMPTY"
                                                "cljs.core/to-array-2d"
                                                "cljs.core/filterv"
                                                "cljs.core/IEditableCollection"
                                                "cljs.core/ArrayNode"
                                                "cljs.core/TransientHashMap"
                                                "cljs.core/TransientArrayMap"
                                                "cljs.core/mapv"
                                                "cljs.core/long"
                                                "cljs.core/reversible?"
                                                "cljs.core/HashCollisionNode"
                                                "cljs.core/into-array"
                                                "cljs.core/TransientVector"
                                                "cljs.core/PersistentTreeSet"
                                                "cljs.core/Reduced"
                                                "cljs.core/long-array"
                                                "cljs.core/subseq"
                                                "cljs.core/bit-count"
                                                "cljs.core/assoc!"
                                                "cljs.core/sorted-map-by"
                                                "cljs.core/NodeSeq"
                                                "cljs.core/gen-apply-to"
                                                "cljs.core/rsubseq"
                                                "cljs.core/make-array"
                                                "cljs.core/sorted-set-by"
                                                "cljs.core/disj!"
                                                "cljs.core/ifn?"
                                                "cljs.core/case"
                                                "cljs.core/RedNode"
                                                "cljs.core/key"
                                                "cljs.core/ITransientAssociative"
                                                "cljs.core/reduce-kv"
                                                "cljs.core/PersistentTreeSet.EMPTY"
                                                "cljs.core/BitmapIndexedNode.EMPTY"
                                                "cljs.core/mk-bound-fn"
                                                "cljs.core/VectorNode"
                                                "cljs.core/PersistentHashSet"
                                                "cljs.core/ITransientVector"
                                                "cljs.core/PersistentTreeMap"
                                                "cljs.core/pop!"
                                                "cljs.core/bit-shift-right-zero-fill"
                                                "cljs.core/reduced"
                                                "cljs.core/object-array"
                                                "cljs.core/indexed?"
                                                "cljs.core/TransientHashSet"},
                                       :removed #{"cljs.core/Set"
                                                  "cljs.core/Set.EMPTY"}},
                           "0.0-1449" {},
                           "0.0-993" {},
                           "0.0-1011" {:added #{"cljs.core/println-str"
                                                "cljs.core/print-str"
                                                "cljs.core/prn-str-with-opts"
                                                "cljs.core/prn-str"}},
                           "0.0-2356" {:added #{"cljs.core/IIterable"
                                                "cljs.core/iterable?"}},
                           "0.0-2156" {:added #{"cljs.nodejs/enable-util-print!"
                                                "cljs.core/cloneable?"
                                                "cljs.core/specify!"
                                                "cljs.core/defonce"}},
                           "0.0-1847" {},
                           "0.0-2496" {:added #{"cljs.test/report"
                                                "cljs.test/get-current-env"
                                                "cljs.test/join-fixtures"
                                                "cljs.core/var"
                                                "cljs.test/testing-contexts-str"
                                                "cljs.test/do-report"
                                                "cljs.test/set-env!"
                                                "cljs.test/run-tests"
                                                "cljs.repl/print-doc"
                                                "cljs.test/js-filename"
                                                "cljs.core/vswap!"
                                                "cljs.core/IVolatile"
                                                "cljs.test/file-and-line"
                                                "cljs.test/test-all-vars"
                                                "cljs.test/testing-vars-str"
                                                "cljs.test/compose-fixtures"
                                                "cljs.test/is"
                                                "cljs.core/js-debugger"
                                                "cljs.test/clear-env!"
                                                "cljs.core/Volatile"
                                                "cljs.core/ns-interns"
                                                "cljs.test/mapped-line-and-column"
                                                "cljs.test/test-var"
                                                "cljs.test/js-line-and-column"
                                                "cljs.core/volatile!"
                                                "cljs.test/*current-env*"
                                                "cljs.test/update-current-env!"
                                                "cljs.test/successful?"
                                                "cljs.test/inc-report-counter!"
                                                "cljs.core/volatile?"
                                                "cljs.test/test-vars"
                                                "cljs.test/run-all-tests"
                                                "cljs.test/try-expr"
                                                "cljs.pprint/PrettyFlush"
                                                "cljs.core/Var"
                                                "cljs.test/test-ns"
                                                "cljs.repl/doc"
                                                "cljs.core/test"
                                                "cljs.test/deftest"
                                                "cljs.test/testing"
                                                "cljs.test/empty-env"
                                                "cljs.core/vreset!"}},
                           "0.0-927" {:added #{"cljs.core/keys"
                                               "cljs.core/reset!"
                                               "clojure.set/select"
                                               "cljs.core/delay"
                                               "cljs.core/bit-not"
                                               "cljs.core/partition"
                                               "cljs.core/parents"
                                               "cljs.core/aclone"
                                               "cljs.core/reset-meta!"
                                               "cljs.reader/dispatch-macros"
                                               "cljs.core/ICollection"
                                               "cljs.core/every?"
                                               "clojure.zip/node"
                                               "cljs.core/IEmptyableCollection"
                                               "clojure.zip/right"
                                               "cljs.core/=="
                                               "clojure.browser.net/*timeout*"
                                               "cljs.core/let*"
                                               "cljs.core/remove-method"
                                               "cljs.core/frequencies"
                                               "cljs.core/pop"
                                               "cljs.core/not-every?"
                                               "cljs.core/some-fn"
                                               "clojure.browser.event/remove-all"
                                               "cljs.core/doto"
                                               "cljs.core/take-while"
                                               "cljs.reader/escape-char-map"
                                               "clojure.browser.event/all-listeners"
                                               "cljs.core/vals"
                                               "cljs.core/IDeref"
                                               "clojure.browser.dom/log-obj"
                                               "cljs.core/for"
                                               "cljs.core/instance?"
                                               "cljs.reader/read-comment"
                                               "cljs.reader/read-number"
                                               "cljs.core/ILookup"
                                               "cljs.core/when"
                                               "clojure.browser.dom/set-value"
                                               "cljs.reader/read-past"
                                               "cljs.core/to-array"
                                               "cljs.core/interpose"
                                               "clojure.browser.net/ICrossPageChannel"
                                               "cljs.core/Cons"
                                               "cljs.core/re-find"
                                               "cljs.core/IMeta"
                                               "cljs.core/assoc-in"
                                               "clojure.string/join"
                                               "clojure.zip/rights"
                                               "cljs.core/split-at"
                                               "clojure.zip/append-child"
                                               "cljs.core/binding"
                                               "cljs.core/Set"
                                               "cljs.reader/macro-terminating?"
                                               "cljs.core/prefers"
                                               "cljs.core/vary-meta"
                                               "cljs.core/when-let"
                                               "cljs.core/drop"
                                               "cljs.core/while"
                                               "cljs.core/import-macros"
                                               "cljs.core/string-print"
                                               "cljs.core/-"
                                               "cljs.core/loop*"
                                               "clojure.zip/vector-zip"
                                               "cljs.core/js->clj"
                                               "cljs.core/List"
                                               "cljs.core/identical?"
                                               "cljs.core/*main-cli-fn*"
                                               "clojure.browser.dom/html->dom"
                                               "cljs.core/some"
                                               "cljs.core/if"
                                               "cljs.core/doall"
                                               "cljs.core/condp"
                                               "clojure.zip/down"
                                               "cljs.core/IPending"
                                               "cljs.core/count"
                                               "cljs.core/bit-test"
                                               "cljs.core/loop"
                                               "cljs.core/subvec"
                                               "cljs.core/bit-clear"
                                               "cljs.core/gensym"
                                               "cljs.core/in-ns"
                                               "cljs.core/+"
                                               "cljs.core/comp"
                                               "cljs.reader/desugar-meta"
                                               "cljs.core/pr"
                                               "clojure.string/upper-case"
                                               "clojure.browser.event/expose"
                                               "clojure.browser.event/listen-once"
                                               "cljs.core/empty?"
                                               "cljs.core/newline"
                                               "cljs.core/replace"
                                               "cljs.core/rand"
                                               "cljs.core/add-watch"
                                               "clojure.string/capitalize"
                                               "cljs.core/replicate"
                                               "cljs.core/sequential?"
                                               "cljs.core/underive"
                                               "cljs.core/get-method"
                                               "cljs.core/="
                                               "cljs.core/defn-"
                                               "cljs.reader/read-symbol"
                                               "cljs.reader/push-back-reader"
                                               "cljs.core/deftype"
                                               "cljs.core/Subvec"
                                               "cljs.core/."
                                               "cljs.core/extend-protocol"
                                               "cljs.reader/read"
                                               "cljs.core/EmptyList"
                                               "clojure.walk/postwalk"
                                               "clojure.zip/edit"
                                               "cljs.core/re-seq"
                                               "cljs.reader/read-list"
                                               "cljs.core/Atom"
                                               "cljs.core/IMap"
                                               "cljs.reader/read-vector"
                                               "clojure.set/join"
                                               "cljs.core/HashMap"
                                               "cljs.reader/int-pattern"
                                               "cljs.core/swap!"
                                               "cljs.core/finally"
                                               "cljs.core/dec"
                                               "clojure.browser.dom/remove-children"
                                               "cljs.core/get-validator"
                                               "cljs.core/coll?"
                                               "cljs.core/bit-or"
                                               "cljs.core/nfirst"
                                               "cljs.core/keep"
                                               "cljs.core/take"
                                               "cljs.core/cond"
                                               "cljs.core/bit-and"
                                               "cljs.core/ObjMap.fromObject"
                                               "clojure.browser.event/unique-event-id"
                                               "clojure.set/project"
                                               "clojure.string/trim-newline"
                                               "clojure.zip/insert-left"
                                               "cljs.core/true?"
                                               "clojure.browser.net/xpc-connection"
                                               "cljs.core/not"
                                               "cljs.core/js-obj"
                                               "cljs.core/complement"
                                               "cljs.core/spread"
                                               "cljs.core/keyword"
                                               "cljs.core/sort"
                                               "clojure.string/trim"
                                               "cljs.core/meta"
                                               "cljs.core/time"
                                               "cljs.core/boolean"
                                               "cljs.reader/read-token"
                                               "cljs.core/update-in"
                                               "cljs.core/map-indexed"
                                               "cljs.core/IStack"
                                               "cljs.core/IIndexed"
                                               "clojure.browser.repl/repl-print"
                                               "clojure.browser.net/xpc-config-fields"
                                               "cljs.core/nnext"
                                               "cljs.core/*print-meta*"
                                               "cljs.reader/read-dispatch"
                                               "cljs.core/distinct"
                                               "cljs.reader/wrapping-reader"
                                               "cljs.core/prn"
                                               "clojure.zip/leftmost"
                                               "cljs.core/>="
                                               "cljs.reader/macros"
                                               "cljs.core/doseq"
                                               "cljs.core/*"
                                               "cljs.core/into"
                                               "cljs.core/defmethod"
                                               "cljs.core/rest"
                                               "cljs.core/dotimes"
                                               "clojure.zip/lefts"
                                               "clojure.browser.dom/ensure-element"
                                               "cljs.core/defmacro"
                                               "cljs.core/remove"
                                               "cljs.core/ns"
                                               "cljs.core/if-not"
                                               "clojure.zip/path"
                                               "cljs.core/mapcat"
                                               "cljs.core/IWatchable"
                                               "clojure.zip/rightmost"
                                               "cljs.core/->"
                                               "cljs.core/remove-all-methods"
                                               "clojure.string/replace-first"
                                               "clojure.browser.dom/get-value"
                                               "cljs.nodejs/process"
                                               "cljs.core/not="
                                               "cljs.core/js-keys"
                                               "clojure.zip/seq-zip"
                                               "cljs.core/IVector"
                                               "cljs.core/empty"
                                               "cljs.core/re-matches"
                                               "clojure.browser.dom/DOMBuilder"
                                               "cljs.core/extend-type"
                                               "cljs.core/ISeqable"
                                               "cljs.core/assoc"
                                               "clojure.browser.repl/xpc-connection"
                                               "cljs.core/IDerefWithTimeout"
                                               "clojure.browser.repl/start-evaluator"
                                               "clojure.browser.event/unlisten"
                                               "cljs.core/do"
                                               "cljs.core/fnil"
                                               "cljs.core/this-as"
                                               "cljs.core/PersistentQueueSeq"
                                               "cljs.core/counted?"
                                               "clojure.string/trimr"
                                               "cljs.core/force"
                                               "cljs.core/compare-and-set!"
                                               "cljs.core/set?"
                                               "cljs.core/load-file"
                                               "clojure.string/escape"
                                               "cljs.core/remove-watch"
                                               "cljs.core/IMultiFn"
                                               "clojure.zip/end?"
                                               "clojure.set/superset?"
                                               "clojure.browser.net/IConnection"
                                               "cljs.core/let"
                                               "cljs.core/dorun"
                                               "cljs.core/pr-str"
                                               "cljs.core/IPrintable"
                                               "cljs.core/defprotocol"
                                               "cljs.core/assert"
                                               "cljs.core/declare"
                                               "cljs.core/fn?"
                                               "cljs.core/associative?"
                                               "cljs.core/list*"
                                               "cljs.core/reduce"
                                               "clojure.browser.event/has-listener"
                                               "cljs.core/compare"
                                               "cljs.core/contains?"
                                               "cljs.core/prefer-method"
                                               "cljs.core/array-seq"
                                               "cljs.core/PersistentQueue"
                                               "cljs.core/drop-last"
                                               "cljs.reader/read-string"
                                               "cljs.core/vector?"
                                               "cljs.core/defmulti"
                                               "cljs.core/List.EMPTY"
                                               "clojure.browser.event/dispatch-event"
                                               "clojure.string/split-lines"
                                               "cljs.core/areduce"
                                               "cljs.core/disj"
                                               "clojure.browser.net/event-types"
                                               "clojure.string/lower-case"
                                               "cljs.core/*print-fn*"
                                               "cljs.core/str"
                                               "cljs.core/ISequential"
                                               "cljs.core/try*"
                                               "cljs.core/set"
                                               "cljs.core/print"
                                               "clojure.string/blank?"
                                               "clojure.browser.dom/append"
                                               "cljs.core/take-last"
                                               "clojure.set/intersection"
                                               "cljs.core/fnext"
                                               "cljs.core/apply"
                                               "clojure.walk/prewalk"
                                               "cljs.core/flatten"
                                               "cljs.core/get"
                                               "cljs.core/.."
                                               "cljs.core/Range"
                                               "cljs.core/zero?"
                                               "cljs.core/identity"
                                               "cljs.core/first"
                                               "cljs.reader/ratio-pattern"
                                               "cljs.core/>"
                                               "cljs.core/juxt"
                                               "cljs.core/max"
                                               "cljs.core/*3"
                                               "cljs.core/number?"
                                               "cljs.core/array"
                                               "cljs.core/nthnext"
                                               "cljs.core/re-pattern"
                                               "cljs.core/missing-protocol"
                                               "clojure.browser.dom/set-text"
                                               "clojure.zip/up"
                                               "cljs.core/IWithMeta"
                                               "cljs.core/bit-and-not"
                                               "clojure.string/triml"
                                               "clojure.string/split"
                                               "cljs.core/hash-map"
                                               "cljs.core/rem"
                                               "cljs.core/IRecord"
                                               "cljs.core/constantly"
                                               "clojure.browser.dom/get-element"
                                               "cljs.core/and"
                                               "clojure.browser.repl/wrap-message"
                                               "clojure.browser.event/unlisten-by-key"
                                               "cljs.core/new"
                                               "cljs.core/try"
                                               "cljs.core/iterate"
                                               "cljs.core/lazy-seq"
                                               "cljs.core/IndexedSeq"
                                               "cljs.core/next"
                                               "cljs.core/*print-readably*"
                                               "cljs.core/last"
                                               "cljs.core/bit-shift-left"
                                               "clojure.string/reverse"
                                               "cljs.core/min"
                                               "cljs.reader/escape-char"
                                               "cljs.reader/read-map"
                                               "cljs.core/seq"
                                               "cljs.core/defrecord*"
                                               "cljs.core/not-empty"
                                               "cljs.core/println"
                                               "clojure.browser.repl/connect"
                                               "clojure.browser.dom/insert-at"
                                               "cljs.core/quot"
                                               "clojure.browser.event/get-listener"
                                               "cljs.core/filter"
                                               "clojure.zip/branch?"
                                               "cljs.core/ObjMap"
                                               "cljs.core/zipmap"
                                               "cljs.core/hash-combine"
                                               "cljs.core/max-key"
                                               "clojure.zip/insert-child"
                                               "cljs.core/defrecord"
                                               "cljs.core/butlast"
                                               "cljs.core/hash"
                                               "cljs.core/bit-set"
                                               "cljs.core/concat"
                                               "cljs.core/conj"
                                               "clojure.set/difference"
                                               "cljs.core/when-first"
                                               "cljs.core/distinct?"
                                               "cljs.core/pos?"
                                               "cljs.core/IHash"
                                               "cljs.core/is_proto_"
                                               "cljs.core/keep-indexed"
                                               "cljs.core/bit-shift-right"
                                               "clojure.zip/insert-right"
                                               "cljs.core/make-hierarchy"
                                               "cljs.core/repeat"
                                               "cljs.core/MultiFn"
                                               "cljs.core/not-any?"
                                               "cljs.reader/read-regex"
                                               "clojure.zip/next"
                                               "cljs.core/aget"
                                               "cljs.core/if-let"
                                               "cljs.core//"
                                               "cljs.core/min-key"
                                               "clojure.zip/root"
                                               "cljs.core/drop-while"
                                               "clojure.browser.repl/evaluate-javascript"
                                               "cljs.core/set-validator!"
                                               "cljs.core/<"
                                               "cljs.core/catch"
                                               "cljs.core/deftype*"
                                               "cljs.core/fn"
                                               "cljs.core/split-with"
                                               "cljs.core/IReduce"
                                               "cljs.reader/symbol-pattern"
                                               "cljs.core/repeatedly"
                                               "cljs.reader/read-delimited-list"
                                               "cljs.core/undefined?"
                                               "clojure.zip/prev"
                                               "cljs.core/seq?"
                                               "cljs.core/odd?"
                                               "cljs.core/cons"
                                               "cljs.reader/read-set"
                                               "cljs.core/descendants"
                                               "cljs.core/take-nth"
                                               "cljs.reader/throwing-reader"
                                               "cljs.core/even?"
                                               "clojure.set/subset?"
                                               "cljs.core/flush"
                                               "cljs.reader/reader-error"
                                               "clojure.walk/prewalk-replace"
                                               "cljs.core/*1"
                                               "cljs.core/Set.EMPTY"
                                               "cljs.reader/read-unicode-char"
                                               "cljs.core/dissoc"
                                               "cljs.core/ffirst"
                                               "clojure.zip/replace"
                                               "cljs.core/vec"
                                               "cljs.core/or"
                                               "cljs.core/mod"
                                               "cljs.core/aset"
                                               "cljs.core/second"
                                               "cljs.core/set!"
                                               "clojure.set/rename"
                                               "cljs.core/delay?"
                                               "clojure.zip/left"
                                               "cljs.reader/not-implemented"
                                               "cljs.core/IAssociative"
                                               "cljs.core/ObjMap.EMPTY"
                                               "cljs.core/group-by"
                                               "cljs.core/symbol"
                                               "cljs.core/Delay"
                                               "cljs.core/methods"
                                               "cljs.core/vector"
                                               "cljs.core/rand-int"
                                               "cljs.core/throw"
                                               "cljs.core/PersistentQueue.EMPTY"
                                               "cljs.core/letfn"
                                               "cljs.core/recur"
                                               "cljs.reader/read-discard"
                                               "cljs.core/inc"
                                               "cljs.core/name"
                                               "cljs.core/cycle"
                                               "cljs.core/fn*"
                                               "cljs.core/map"
                                               "cljs.core/amap"
                                               "clojure.zip/children"
                                               "cljs.core/when-not"
                                               "clojure.set/index"
                                               "clojure.browser.dom/log"
                                               "cljs.core/Vector.fromArray"
                                               "cljs.core/partition-by"
                                               "cljs.core/sort-by"
                                               "cljs.core/with-meta"
                                               "cljs.core/NeverEquiv"
                                               "cljs.core/select-keys"
                                               "cljs.core/ISeq"
                                               "clojure.walk/postwalk-replace"
                                               "cljs.core/pr-with-opts"
                                               "cljs.core/->>"
                                               "cljs.core/nil?"
                                               "cljs.core/load-namespace"
                                               "clojure.walk/stringify-keys"
                                               "clojure.browser.repl/order"
                                               "cljs.core/memoize"
                                               "cljs.core/pr-sequential"
                                               "clojure.zip/make-node"
                                               "cljs.reader/float-pattern"
                                               "cljs.core/ancestors"
                                               "cljs.core/integer?"
                                               "cljs.core/HashMap.EMPTY"
                                               "cljs.core/Vector.EMPTY"
                                               "clojure.zip/xml-zip"
                                               "clojure.walk/walk"
                                               "cljs.core/bit-xor"
                                               "clojure.set/union"
                                               "cljs.reader/PushbackReader"
                                               "cljs.core/isa?"
                                               "clojure.browser.net/xhr-connection"
                                               "cljs.core/subs"
                                               "cljs.core/symbol?"
                                               "clojure.string/replace"
                                               "cljs.core/string?"
                                               "cljs.core/partition-all"
                                               "cljs.core/merge-with"
                                               "clojure.browser.dom/set-properties"
                                               "cljs.core/trampoline"
                                               "clojure.browser.repl/send-print"
                                               "cljs.core/ICounted"
                                               "cljs.core/quote"
                                               "cljs.core/IEquiv"
                                               "cljs.core/js-delete"
                                               "cljs.core/comment"
                                               "cljs.reader/special-symbols"
                                               "cljs.core/js*"
                                               "cljs.core/alength"
                                               "cljs.core/tree-seq"
                                               "cljs.reader/read-unmatched-delimiter"
                                               "cljs.core/every-pred"
                                               "clojure.set/rename-keys"
                                               "cljs.core/peek"
                                               "cljs.core/pr-str-with-opts"
                                               "cljs.core/map?"
                                               "cljs.reader/StringPushbackReader"
                                               "cljs.core/HashMap.fromArrays"
                                               "cljs.core/deref"
                                               "cljs.core/reductions"
                                               "cljs.core/false?"
                                               "cljs.core/bit-flip"
                                               "cljs.core/ISet"
                                               "cljs.core/LazySeq"
                                               "cljs.core/*2"
                                               "clojure.browser.event/total-listener-count"
                                               "cljs.core/alter-meta!"
                                               "clojure.browser.dom/click-element"
                                               "cljs.reader/read-meta"
                                               "cljs.core/range"
                                               "cljs.core/reify"
                                               "cljs.core/satisfies?"
                                               "cljs.core/nth"
                                               "cljs.core/list"
                                               "cljs.core/defn"
                                               "cljs.core/rand-nth"
                                               "cljs.core/def"
                                               "cljs.core/atom"
                                               "cljs.reader/read-keyword"
                                               "cljs.core/Vector"
                                               "cljs.reader/skip-line"
                                               "cljs.core/namespace"
                                               "cljs.nodejs/require"
                                               "clojure.browser.event/EventType"
                                               "cljs.core/merge"
                                               "clojure.browser.repl/send-result"
                                               "clojure.walk/keywordize-keys"
                                               "cljs.core/derive"
                                               "clojure.zip/zipper"
                                               "clojure.zip/remove"
                                               "cljs.core/find"
                                               "cljs.core/*print-dup*"
                                               "cljs.core/partial"
                                               "cljs.core/keyword?"
                                               "clojure.browser.event/fire-listeners"
                                               "cljs.core/interleave"
                                               "cljs.core/*flush-on-newline*"
                                               "cljs.core/get-in"
                                               "clojure.browser.dom/element"
                                               "cljs.core/prim-seq"
                                               "cljs.core/<="
                                               "clojure.set/map-invert"
                                               "clojure.browser.event/listen"
                                               "cljs.core/neg?"
                                               "clojure.browser.dom/replace-node"
                                               "cljs.core/reverse"
                                               "cljs.core/realized?"}},
                           "0.0-1934" {},
                           "0.0-2202" {},
                           "0.0-1820" {:added #{"cljs.core/ValSeq"
                                                "cljs.core/PersistentArrayMapSeq"
                                                "cljs.core/KeySeq"
                                                "cljs.core/persistent-array-map-seq"}},
                           "0.0-2261" {:added #{"cljs.core/hash-unordered-coll"
                                                "cljs.core/int-rotate-left"
                                                "cljs.core/some?"
                                                "cljs.core/hash-string*"
                                                "cljs.core/m3-C1"
                                                "cljs.core/m3-fmix"
                                                "cljs.core/if-some"
                                                "cljs.core/m3-mix-H1"
                                                "cljs.core/m3-C2"
                                                "cljs.core/hash-string"
                                                "cljs.core/m3-hash-unencoded-chars"
                                                "cljs.reader/read-raw-string*"
                                                "cljs.core/m3-mix-K1"
                                                "cljs.core/hash-keyword"
                                                "cljs.core/m3-hash-int"
                                                "cljs.core/m3-seed"
                                                "cljs.core/hash-ordered-coll"
                                                "cljs.core/when-some"
                                                "cljs.core/mix-collection-hash"},
                                       :removed #{"cljs.core/check-string-hash-cache"}},
                           "0.0-2024" {},
                           "0.0-1889" {},
                           "0.0-2657" {:added #{"cljs.core/require-macros"}},
                           "0.0-1896" {},
                           "0.0-2014" {:added #{"cljs.core/*clojurescript-version*"
                                                "cljs.core/implements?"}},
                           "0.0-2411" {:added #{"cljs.core/js-invoke"
                                                "cljs.core/ES6IteratorSeq"
                                                "cljs.core/unreduced"
                                                "cljs.core/es6-iterable"
                                                "cljs.core/nthrest"
                                                "cljs.core/js-in"
                                                "cljs.core/update"
                                                "cljs.core/es6-iterator-seq"
                                                "cljs.core/ensure-reduced"}},
                           "0.0-2665" {},
                           "0.0-2760" {}},
                 :symbol-names #{"cljs.core/keys"
                                 "cljs.core/unchecked-negate"
                                 "cljs.core/reset!"
                                 "cljs.core/ITransientCollection"
                                 "cljs.core/transient"
                                 "cljs.core/Fn"
                                 "clojure.data/EqualityPartition"
                                 "cljs.core/ex-message"
                                 "clojure.set/select"
                                 "cljs.core/hash-unordered-coll"
                                 "cljs.core/delay"
                                 "cljs.core/float"
                                 "cljs.core/bit-not"
                                 "cljs.core/partition"
                                 "cljs.core/IEncodeJS"
                                 "cljs.core/parents"
                                 "cljs.core/aclone"
                                 "cljs.core/reset-meta!"
                                 "cljs.core/IReset"
                                 "cljs.core/Box"
                                 "cljs.reader/dispatch-macros"
                                 "cljs.core/int-rotate-left"
                                 "cljs.core/ICollection"
                                 "cljs.core/every?"
                                 "clojure.zip/node"
                                 "cljs.core/IEmptyableCollection"
                                 "clojure.zip/right"
                                 "cljs.core/int-array"
                                 "cljs.core/LazyTransformer.createMulti"
                                 "cljs.core/=="
                                 "cljs.core/dissoc!"
                                 "clojure.reflect/meta"
                                 "clojure.browser.net/*timeout*"
                                 "cljs.core/let*"
                                 "cljs.core/remove-method"
                                 "cljs.core/array-chunk"
                                 "clojure.core.reducers/drop"
                                 "cljs.core/PersistentArrayMap.fromArrays"
                                 "cljs.core/frequencies"
                                 "cljs.core/require-macros"
                                 "cljs.core/pop"
                                 "cljs.repl/with-read-known"
                                 "cljs.core/flatmap"
                                 "cljs.core/not-every?"
                                 "cljs.core/js-invoke"
                                 "cljs.core/some-fn"
                                 "clojure.browser.event/remove-all"
                                 "cljs.core/doto"
                                 "cljs.core/take-while"
                                 "cljs.reader/escape-char-map"
                                 "clojure.browser.event/all-listeners"
                                 "cljs.core/ITransientSet"
                                 "cljs.core/vals"
                                 "cljs.core/IDeref"
                                 "cljs.core/string-hash-cache"
                                 "cljs.core/array-map"
                                 "cljs.test/report"
                                 "clojure.browser.dom/log-obj"
                                 "cljs.nodejs/enable-util-print!"
                                 "cljs.core/for"
                                 "cljs.core/unchecked-multiply-int"
                                 "cljs.core/cond->"
                                 "cljs.core/instance?"
                                 "cljs.core/ValSeq"
                                 "cljs.core/rseq"
                                 "cljs.core/PersistentVector.EMPTY_NODE"
                                 "cljs.reader/read-comment"
                                 "cljs.core/ITransientMap"
                                 "cljs.core/*loaded-libs*"
                                 "cljs.reader/read-number"
                                 "cljs.core/ILookup"
                                 "cljs.core/when"
                                 "cljs.core/ArrayNodeSeq"
                                 "cljs.core/list?"
                                 "cljs.core/val"
                                 "clojure.browser.dom/set-value"
                                 "cljs.core/BitmapIndexedNode"
                                 "cljs.reader/read-past"
                                 "cljs.core/to-array"
                                 "cljs.core/interpose"
                                 "cljs.core/IMapEntry"
                                 "clojure.browser.net/ICrossPageChannel"
                                 "cljs.core/Cons"
                                 "cljs.core/re-find"
                                 "cljs.core/IMeta"
                                 "cljs.core/js-str"
                                 "cljs.test/are"
                                 "cljs.core/RangeIterator"
                                 "cljs.core/iterator"
                                 "cljs.core/assoc-in"
                                 "clojure.string/join"
                                 "cljs.core/*unchecked-if*"
                                 "cljs.core/some?"
                                 "cljs.core/seqable?"
                                 "clojure.zip/rights"
                                 "cljs.core/split-at"
                                 "clojure.zip/append-child"
                                 "cljs.core/binding"
                                 "cljs.test/get-current-env"
                                 "cljs.core/Set"
                                 "cljs.core/sorted-map"
                                 "cljs.reader/macro-terminating?"
                                 "cljs.test/join-fixtures"
                                 "cljs.core/prefers"
                                 "cljs.core/vary-meta"
                                 "cljs.core/unchecked-add"
                                 "cljs.core/when-let"
                                 "clojure.core.reducers/folder"
                                 "cljs.core/ASeq"
                                 "cljs.core/drop"
                                 "cljs.core/var"
                                 "cljs.core/ArrayList"
                                 "cljs.core/stepper"
                                 "cljs.core/IAtom"
                                 "cljs.core/reduceable?"
                                 "cljs.core/while"
                                 "cljs.core/import-macros"
                                 "cljs.core/string-print"
                                 "cljs.core/ES6IteratorSeq"
                                 "cljs.core/-"
                                 "cljs.core/loop*"
                                 "cljs.core/vector-seq"
                                 "cljs.core/IIterable"
                                 "cljs.test/testing-contexts-str"
                                 "clojure.zip/vector-zip"
                                 "cljs.reader/read-2-chars"
                                 "cljs.core/chunk"
                                 "cljs.core/conj!"
                                 "cljs.test/do-report"
                                 "cljs.core/print-map"
                                 "cljs.core/js->clj"
                                 "cljs.core/List"
                                 "cljs.core/identical?"
                                 "cljs.core/*main-cli-fn*"
                                 "clojure.browser.dom/html->dom"
                                 "cljs.core/LazyTransformer.create"
                                 "cljs.core/chunk-next"
                                 "cljs.core/enable-console-print!"
                                 "cljs.core/sorted?"
                                 "cljs.core/some"
                                 "cljs.core/PersistentArrayMapSeq"
                                 "cljs.reader/make-unicode-char"
                                 "cljs.core/if"
                                 "clojure.core.reducers/Cat"
                                 "cljs.core/write-all"
                                 "cljs.core/doall"
                                 "cljs.core/condp"
                                 "clojure.zip/down"
                                 "cljs.core/IPending"
                                 "cljs.core/count"
                                 "cljs.core/bit-test"
                                 "cljs.core/js-mod"
                                 "cljs.core/es6-set-entries-iterator"
                                 "cljs.test/set-env!"
                                 "cljs.core/SetEntriesIterator"
                                 "cljs.core/loop"
                                 "cljs.core/subvec"
                                 "cljs.core/bit-clear"
                                 "cljs.core/gensym"
                                 "cljs.core/in-ns"
                                 "cljs.core/Symbol"
                                 "cljs.core/hash-string*"
                                 "cljs.core/shuffle"
                                 "cljs.core/+"
                                 "cljs.core/clone"
                                 "cljs.core/comp"
                                 "cljs.core/ArrayIter"
                                 "cljs.reader/desugar-meta"
                                 "cljs.core/pr"
                                 "cljs.test/run-tests"
                                 "clojure.string/upper-case"
                                 "cljs.core/chars"
                                 "clojure.browser.event/expose"
                                 "clojure.browser.event/listen-once"
                                 "cljs.core/m3-C1"
                                 "cljs.core/empty?"
                                 "cljs.core/m3-fmix"
                                 "cljs.core/newline"
                                 "cljs.core/PersistentHashMap"
                                 "cljs.core/replace"
                                 "cljs.core/rand"
                                 "cljs.core/add-watch"
                                 "cljs.core/cloneable?"
                                 "clojure.string/capitalize"
                                 "cljs.core/short"
                                 "cljs.core/replicate"
                                 "cljs.core/es6-entries-iterator"
                                 "cljs.core/ArrayChunk"
                                 "cljs.core/sequential?"
                                 "cljs.core/underive"
                                 "cljs.core/PersistentArrayMapIterator"
                                 "cljs.core/get-method"
                                 "cljs.core/="
                                 "cljs.reader/deregister-default-tag-parser!"
                                 "cljs.core/defn-"
                                 "cljs.reader/read-symbol"
                                 "cljs.reader/push-back-reader"
                                 "cljs.core/deftype"
                                 "cljs.repl/print-doc"
                                 "cljs.core/longs"
                                 "cljs.core/Subvec"
                                 "cljs.core/."
                                 "cljs.core/if-some"
                                 "cljs.test/js-filename"
                                 "cljs.core/IReversible"
                                 "cljs.core/extend-protocol"
                                 "cljs.reader/read"
                                 "cljs.core/EmptyList"
                                 "cljs.core/specify!"
                                 "cljs.core/cat"
                                 "clojure.walk/postwalk"
                                 "cljs.core/PersistentArrayMap.HASHMAP-THRESHOLD"
                                 "clojure.zip/edit"
                                 "cljs.core/unreduced"
                                 "cljs.core/re-seq"
                                 "cljs.reader/read-list"
                                 "cljs.core/IKVReduce"
                                 "cljs.core/Atom"
                                 "clojure.core.reducers/foldcat"
                                 "cljs.core/specify"
                                 "cljs.core/IMap"
                                 "cljs.core/pr-sequential-writer"
                                 "cljs.core/unchecked-multiply"
                                 "cljs.reader/read-vector"
                                 "clojure.set/join"
                                 "cljs.core/HashMap"
                                 "cljs.core/es6-iterable"
                                 "cljs.reader/int-pattern"
                                 "cljs.core/swap!"
                                 "cljs.core/finally"
                                 "cljs.core/dec"
                                 "cljs.core/EntriesIterator"
                                 "cljs.core/*clojurescript-version*"
                                 "clojure.core.reducers/fold"
                                 "cljs.core/StringBufferWriter"
                                 "clojure.browser.dom/remove-children"
                                 "cljs.core/BlackNode"
                                 "cljs.core/some->"
                                 "cljs.core/get-validator"
                                 "cljs.core/coll?"
                                 "cljs.core/unchecked-negate-int"
                                 "cljs.core/bit-or"
                                 "cljs.core/nfirst"
                                 "cljs.core/keep"
                                 "cljs.core/take"
                                 "cljs.core/PersistentHashSet.EMPTY"
                                 "cljs.core/cond"
                                 "cljs.core/bit-and"
                                 "cljs.core/MetaFn"
                                 "cljs.core/ObjMap.fromObject"
                                 "cljs.core/PersistentArrayMap"
                                 "clojure.browser.event/unique-event-id"
                                 "cljs.core/vswap!"
                                 "cljs.core/ObjMap.HASHMAP_THRESHOLD"
                                 "clojure.set/project"
                                 "cljs.core/int"
                                 "clojure.reflect/macroexpand"
                                 "clojure.string/trim-newline"
                                 "cljs.core/pr-seq-writer"
                                 "cljs.core/chunk-cons"
                                 "clojure.zip/insert-left"
                                 "cljs.core/*print-level*"
                                 "cljs.core/true?"
                                 "cljs.core/unchecked-substract-int"
                                 "clojure.browser.net/xpc-connection"
                                 "cljs.core/ES6EntriesIterator"
                                 "cljs.core/not"
                                 "cljs.core/js-obj"
                                 "cljs.core/complement"
                                 "cljs.core/spread"
                                 "cljs.core/unchecked-double"
                                 "cljs.core/keyword"
                                 "cljs.core/sort"
                                 "clojure.string/trim"
                                 "cljs.core/meta"
                                 "clojure.core.reducers/monoid"
                                 "cljs.core/time"
                                 "cljs.core/boolean"
                                 "cljs.reader/read-token"
                                 "cljs.core/update-in"
                                 "cljs.core/map-indexed"
                                 "cljs.core/IVolatile"
                                 "cljs.core/printf"
                                 "clojure.core.reducers/map"
                                 "cljs.core/IStack"
                                 "cljs.reader/parse-and-validate-timestamp"
                                 "cljs.core/ISorted"
                                 "cljs.test/file-and-line"
                                 "cljs.core/IIndexed"
                                 "clojure.browser.repl/repl-print"
                                 "clojure.browser.net/xpc-config-fields"
                                 "cljs.core/ISwap"
                                 "cljs.core/nnext"
                                 "cljs.core/*print-meta*"
                                 "cljs.reader/read-dispatch"
                                 "cljs.core/distinct"
                                 "cljs.reader/wrapping-reader"
                                 "cljs.core/LazyTransformer"
                                 "cljs.core/double-array"
                                 "cljs.core/prn"
                                 "cljs.core/chunked-seq"
                                 "clojure.zip/leftmost"
                                 "cljs.core/nthrest"
                                 "cljs.core/js-in"
                                 "cljs.core/>="
                                 "cljs.reader/macros"
                                 "cljs.core/doseq"
                                 "cljs.core/*"
                                 "cljs.core/into"
                                 "cljs.core/defmethod"
                                 "cljs.core/rest"
                                 "cljs.reader/unicode-4-pattern"
                                 "cljs.core/dotimes"
                                 "cljs.core/dedupe"
                                 "clojure.zip/lefts"
                                 "clojure.browser.dom/ensure-element"
                                 "cljs.core/defmacro"
                                 "cljs.core/remove"
                                 "cljs.test/test-all-vars"
                                 "cljs.core/set-print-fn!"
                                 "cljs.core/PersistentArrayMap.HASHMAP_THRESHOLD"
                                 "cljs.core/ns"
                                 "cljs.core/if-not"
                                 "cljs.core/string-iter"
                                 "clojure.zip/path"
                                 "cljs.core/mapcat"
                                 "cljs.core/m3-mix-H1"
                                 "cljs.core/IWatchable"
                                 "cljs.core/PersistentHashMap.fromArray"
                                 "cljs.core/run!"
                                 "cljs.core/IndexedSeqIterator"
                                 "cljs.core/unchecked-inc-int"
                                 "cljs.test/testing-vars-str"
                                 "clojure.zip/rightmost"
                                 "cljs.core/PersistentArrayMap.EMPTY"
                                 "cljs.core/m3-C2"
                                 "cljs.test/compose-fixtures"
                                 "cljs.core/unchecked-subtract"
                                 "cljs.core/->"
                                 "cljs.core/remove-all-methods"
                                 "cljs.core/unchecked-add-int"
                                 "clojure.string/replace-first"
                                 "cljs.core/reduced?"
                                 "clojure.browser.dom/get-value"
                                 "clojure.core.reducers/CollFold"
                                 "cljs.nodejs/process"
                                 "cljs.core/some->>"
                                 "cljs.core/unchecked-inc"
                                 "cljs.core/not="
                                 "cljs.core/unchecked-subtract-int"
                                 "cljs.core/ex-data"
                                 "cljs.core/PersistentTreeMapSeq"
                                 "cljs.core/js-keys"
                                 "clojure.zip/seq-zip"
                                 "cljs.core/lazy-transformer"
                                 "cljs.core/random-sample"
                                 "cljs.core/IVector"
                                 "cljs.core/iter"
                                 "cljs.core/persistent!"
                                 "cljs.core/empty"
                                 "cljs.core/re-matches"
                                 "clojure.browser.dom/DOMBuilder"
                                 "cljs.core/extend-type"
                                 "cljs.core/ISeqable"
                                 "cljs.core/assoc"
                                 "clojure.browser.repl/xpc-connection"
                                 "cljs.core/IDerefWithTimeout"
                                 "cljs.core/multi-stepper"
                                 "clojure.core.reducers/cat"
                                 "cljs.core/unchecked-substract"
                                 "cljs.core/Iteration"
                                 "clojure.browser.repl/start-evaluator"
                                 "clojure.browser.event/unlisten"
                                 "cljs.test/is"
                                 "cljs.core/do"
                                 "cljs.test/use-fixtures"
                                 "cljs.core/PersistentHashMap.fromArrays"
                                 "cljs.core/special-symbol?"
                                 "cljs.core/case*"
                                 "cljs.core/js-debugger"
                                 "cljs.core/format"
                                 "cljs.core/sorted-set"
                                 "cljs.core/fnil"
                                 "cljs.core/update"
                                 "cljs.core/this-as"
                                 "cljs.core/PersistentQueueSeq"
                                 "cljs.core/counted?"
                                 "clojure.string/trimr"
                                 "clojure.core.reducers/take"
                                 "cljs.core/force"
                                 "cljs.core/compare-and-set!"
                                 "cljs.core/set?"
                                 "cljs.core/hash-string"
                                 "cljs.core/load-file"
                                 "cljs.core/unchecked-dec"
                                 "cljs.core/PersistentVector.EMPTY-NODE"
                                 "clojure.string/escape"
                                 "cljs.core/remove-watch"
                                 "cljs.core/m3-hash-unencoded-chars"
                                 "cljs.core/es6-iterator-seq"
                                 "cljs.core/IMultiFn"
                                 "clojure.browser.event/IEventType"
                                 "clojure.zip/end?"
                                 "cljs.test/clear-env!"
                                 "clojure.set/superset?"
                                 "clojure.browser.net/IConnection"
                                 "cljs.core/let"
                                 "cljs.core/unchecked-divide-int"
                                 "cljs.core/dorun"
                                 "cljs.core/with-redefs"
                                 "cljs.core/SeqIter"
                                 "cljs.core/unsigned-bit-shift-right"
                                 "cljs.core/iterable?"
                                 "cljs.core/pr-str"
                                 "cljs.core/IPrintable"
                                 "cljs.core/defprotocol"
                                 "cljs.core/ints"
                                 "cljs.core/assert"
                                 "cljs.core/declare"
                                 "cljs.core/PersistentTreeMap.EMPTY"
                                 "cljs.core/fn?"
                                 "cljs.core/associative?"
                                 "cljs.core/IList"
                                 "cljs.core/list*"
                                 "cljs.core/PersistentArrayMap.fromArray"
                                 "cljs.core/reduce"
                                 "clojure.browser.event/has-listener"
                                 "cljs.core/unchecked-dec-int"
                                 "cljs.core/PersistentHashMap.EMPTY"
                                 "cljs.core/compare"
                                 "cljs.core/contains?"
                                 "cljs.core/Stepper"
                                 "cljs.core/prefer-method"
                                 "cljs.core/array-seq"
                                 "cljs.core/to-array-2d"
                                 "cljs.core/ICloneable"
                                 "cljs.core/*print-length*"
                                 "cljs.core/PersistentQueue"
                                 "cljs.core/drop-last"
                                 "cljs.core/array?"
                                 "cljs.core/PersistentVector.fromArray"
                                 "cljs.core/filterv"
                                 "cljs.core/IComparable"
                                 "cljs.reader/read-string"
                                 "cljs.reader/unicode-2-pattern"
                                 "cljs.core/Volatile"
                                 "cljs.core/check-string-hash-cache"
                                 "cljs.core/vector?"
                                 "cljs.core/defmulti"
                                 "cljs.core/Keyword"
                                 "cljs.core/List.EMPTY"
                                 "clojure.browser.event/dispatch-event"
                                 "cljs.core/ns-interns"
                                 "clojure.string/split-lines"
                                 "cljs.test/mapped-line-and-column"
                                 "cljs.core/areduce"
                                 "cljs.core/disj"
                                 "cljs.core/IEditableCollection"
                                 "cljs.core/unchecked-char"
                                 "cljs.core/keyword-identical?"
                                 "clojure.browser.net/event-types"
                                 "clojure.string/lower-case"
                                 "cljs.core/*print-fn*"
                                 "cljs.core/str"
                                 "cljs.core/ISequential"
                                 "cljs.core/try*"
                                 "cljs.core/key-test"
                                 "cljs.core/set"
                                 "cljs.core/obj-map"
                                 "cljs.core/print"
                                 "cljs.core/ArrayNode"
                                 "cljs.core/type"
                                 "clojure.string/blank?"
                                 "cljs.reader/maybe-read-tagged-type"
                                 "cljs.core/IChunkedSeq"
                                 "clojure.browser.dom/append"
                                 "cljs.core/take-last"
                                 "cljs.core/key->js"
                                 "cljs.core/TransientHashMap"
                                 "clojure.set/intersection"
                                 "cljs.core/fnext"
                                 "cljs.core/apply"
                                 "clojure.walk/prewalk"
                                 "cljs.core/flatten"
                                 "cljs.core/get"
                                 "cljs.core/char"
                                 "cljs.core/.."
                                 "cljs.core/floats"
                                 "cljs.core/Range"
                                 "cljs.core/zero?"
                                 "cljs.core/identity"
                                 "cljs.core/first"
                                 "cljs.reader/ratio-pattern"
                                 "cljs.core/println-str"
                                 "cljs.core/>"
                                 "cljs.core/juxt"
                                 "cljs.core/max"
                                 "cljs.core/completing"
                                 "cljs.core/transduce"
                                 "cljs.test/test-var"
                                 "cljs.core/with-out-str"
                                 "cljs.core/*3"
                                 "cljs.core/memfn"
                                 "cljs.core/IEncodeClojure"
                                 "cljs.core/TransientArrayMap"
                                 "cljs.core/cond->>"
                                 "cljs.core/number?"
                                 "cljs.core/array"
                                 "cljs.core/nthnext"
                                 "cljs.core/re-pattern"
                                 "cljs.core/missing-protocol"
                                 "clojure.browser.dom/set-text"
                                 "cljs.test/js-line-and-column"
                                 "clojure.zip/up"
                                 "cljs.core/IWithMeta"
                                 "cljs.core/bit-and-not"
                                 "clojure.string/triml"
                                 "cljs.core/chunk-append"
                                 "cljs.core/regexp?"
                                 "clojure.string/split"
                                 "cljs.reader/read-4-chars"
                                 "cljs.core/iteration"
                                 "cljs.core/hash-map"
                                 "cljs.core/mapv"
                                 "cljs.core/rem"
                                 "cljs.core/IRecord"
                                 "cljs.core/RangedIterator"
                                 "cljs.core/volatile!"
                                 "cljs.core/constantly"
                                 "cljs.test/*current-env*"
                                 "clojure.browser.dom/get-element"
                                 "cljs.core/UUID"
                                 "clojure.core.reducers/reduce"
                                 "cljs.core/and"
                                 "clojure.browser.repl/wrap-message"
                                 "cljs.reader/deregister-tag-parser!"
                                 "clojure.reflect/print-doc"
                                 "clojure.browser.event/unlisten-by-key"
                                 "cljs.core/new"
                                 "cljs.core/try"
                                 "cljs.core/iterate"
                                 "cljs.core/lazy-seq"
                                 "cljs.test/update-current-env!"
                                 "cljs.core/IndexedSeq"
                                 "cljs.core/KeySeq"
                                 "cljs.core/next"
                                 "cljs.core/*print-readably*"
                                 "cljs.core/booleans"
                                 "cljs.core/not-native"
                                 "cljs.core/last"
                                 "cljs.core/pr-str*"
                                 "cljs.core/letfn*"
                                 "cljs.core/bit-shift-left"
                                 "clojure.string/reverse"
                                 "cljs.core/min"
                                 "cljs.reader/escape-char"
                                 "cljs.reader/read-raw-string*"
                                 "cljs.core/INext"
                                 "cljs.reader/read-map"
                                 "cljs.core/seq"
                                 "cljs.core/defrecord*"
                                 "cljs.core/*print-newline*"
                                 "cljs.core/long"
                                 "cljs.core/es6-iterator"
                                 "cljs.core/not-empty"
                                 "cljs.core/println"
                                 "clojure.browser.repl/connect"
                                 "cljs.core/bytes"
                                 "cljs.core/unchecked-byte"
                                 "clojure.browser.dom/insert-at"
                                 "cljs.core/quot"
                                 "clojure.browser.event/get-listener"
                                 "cljs.core/filter"
                                 "cljs.core/RSeq"
                                 "clojure.zip/branch?"
                                 "cljs.core/ObjMap"
                                 "cljs.core/sequence"
                                 "cljs.core/zipmap"
                                 "cljs.core/hash-combine"
                                 "cljs.core/reversible?"
                                 "clojure.core.reducers/flatten"
                                 "cljs.core/max-key"
                                 "clojure.zip/insert-child"
                                 "cljs.core/defrecord"
                                 "cljs.core/eduction"
                                 "cljs.core/ex-info"
                                 "cljs.core/butlast"
                                 "cljs.core/array-iter"
                                 "cljs.core/print-str"
                                 "cljs.core/hash"
                                 "cljs.core/bit-set"
                                 "cljs.core/clj->js"
                                 "cljs.core/concat"
                                 "cljs.core/conj"
                                 "cljs.core/unchecked-short"
                                 "clojure.set/difference"
                                 "cljs.core/byte"
                                 "cljs.core/when-first"
                                 "cljs.reader/*tag-table*"
                                 "cljs.core/distinct?"
                                 "clojure.core.reducers/filter"
                                 "cljs.core/INamed"
                                 "cljs.core/add-to-string-hash-cache"
                                 "cljs.core/HashCollisionNode"
                                 "cljs.core/m3-mix-K1"
                                 "cljs.core/object?"
                                 "cljs.core/pos?"
                                 "cljs.core/into-array"
                                 "cljs.core/PersistentVector"
                                 "cljs.core/IHash"
                                 "clojure.reflect/doc"
                                 "cljs.core/is_proto_"
                                 "cljs.core/shorts"
                                 "cljs.core/TransientVector"
                                 "cljs.core/keep-indexed"
                                 "cljs.core/bit-shift-right"
                                 "cljs.core/comparator"
                                 "cljs.core/ES6Iterator"
                                 "cljs.core/PersistentTreeSet"
                                 "clojure.zip/insert-right"
                                 "cljs.core/make-hierarchy"
                                 "cljs.core/repeat"
                                 "cljs.core/array-list"
                                 "cljs.core/prn-str-with-opts"
                                 "cljs.core/MultiFn"
                                 "cljs.test/successful?"
                                 "cljs.core/hash-keyword"
                                 "cljs.core/Reduced"
                                 "cljs.core/not-any?"
                                 "cljs.reader/read-regex"
                                 "clojure.zip/next"
                                 "cljs.core/IFn"
                                 "cljs.core/aget"
                                 "cljs.core/if-let"
                                 "cljs.core//"
                                 "cljs.core/unchecked-int"
                                 "cljs.core/min-key"
                                 "clojure.zip/root"
                                 "cljs.core/drop-while"
                                 "clojure.browser.repl/evaluate-javascript"
                                 "cljs.core/set-validator!"
                                 "cljs.core/<"
                                 "cljs.core/catch"
                                 "cljs.core/deftype*"
                                 "cljs.core/fn"
                                 "cljs.core/split-with"
                                 "cljs.core/IWriter"
                                 "cljs.core/IReduce"
                                 "cljs.reader/symbol-pattern"
                                 "cljs.core/PersistentHashSet.fromArray"
                                 "cljs.core/repeatedly"
                                 "cljs.reader/read-delimited-list"
                                 "cljs.test/inc-report-counter!"
                                 "cljs.core/undefined?"
                                 "clojure.zip/prev"
                                 "cljs.core/seq?"
                                 "cljs.core/prn-str"
                                 "cljs.core/chunk-buffer"
                                 "cljs.core/odd?"
                                 "cljs.core/cons"
                                 "cljs.reader/read-set"
                                 "cljs.core/descendants"
                                 "cljs.core/take-nth"
                                 "cljs.reader/throwing-reader"
                                 "cljs.core/double"
                                 "cljs.core/even?"
                                 "cljs.core/simple-benchmark"
                                 "cljs.core/persistent-array-map-seq"
                                 "clojure.set/subset?"
                                 "cljs.core/flush"
                                 "cljs.core/long-array"
                                 "cljs.reader/reader-error"
                                 "clojure.walk/prewalk-replace"
                                 "cljs.core/*1"
                                 "cljs.core/subseq"
                                 "cljs.core/Eduction"
                                 "cljs.core/Set.EMPTY"
                                 "cljs.reader/read-unicode-char"
                                 "cljs.core/dissoc"
                                 "cljs.core/exists?"
                                 "cljs.core/ffirst"
                                 "clojure.zip/replace"
                                 "cljs.core/vec"
                                 "cljs.core/or"
                                 "cljs.core/doubles"
                                 "cljs.core/mod"
                                 "cljs.core/aset"
                                 "cljs.core/second"
                                 "cljs.core/IChunkedNext"
                                 "cljs.core/set!"
                                 "cljs.core/bit-count"
                                 "clojure.set/rename"
                                 "cljs.core/m3-hash-int"
                                 "cljs.core/assoc!"
                                 "cljs.core/delay?"
                                 "clojure.zip/left"
                                 "cljs.reader/not-implemented"
                                 "cljs.core/IAssociative"
                                 "cljs.core/ObjMap.EMPTY"
                                 "cljs.core/group-by"
                                 "cljs.reader/*default-data-reader-fn*"
                                 "cljs.core/sorted-map-by"
                                 "cljs.core/symbol"
                                 "cljs.core/volatile?"
                                 "cljs.core/Delay"
                                 "cljs.core/methods"
                                 "cljs.test/test-vars"
                                 "cljs.core/lazy-cat"
                                 "cljs.core/vector"
                                 "cljs.core/rand-int"
                                 "cljs.core/m3-seed"
                                 "cljs.core/throw"
                                 "cljs.core/PersistentQueue.EMPTY"
                                 "cljs.core/unchecked-float"
                                 "clojure.core.reducers/append!"
                                 "cljs.core/NodeSeq"
                                 "cljs.core/letfn"
                                 "cljs.core/recur"
                                 "cljs.reader/read-discard"
                                 "cljs.core/gen-apply-to"
                                 "cljs.core/inc"
                                 "cljs.core/name"
                                 "cljs.core/cycle"
                                 "cljs.core/rsubseq"
                                 "cljs.core/divide"
                                 "cljs.core/hash-ordered-coll"
                                 "cljs.core/nil-iter"
                                 "cljs.core/fn*"
                                 "cljs.test/run-all-tests"
                                 "cljs.core/map"
                                 "cljs.core/ChunkBuffer"
                                 "cljs.core/amap"
                                 "clojure.zip/children"
                                 "cljs.core/when-not"
                                 "clojure.set/index"
                                 "cljs.core/chunked-seq?"
                                 "clojure.browser.dom/log"
                                 "cljs.core/Vector.fromArray"
                                 "cljs.core/make-array"
                                 "cljs.core/sorted-set-by"
                                 "cljs.core/partition-by"
                                 "cljs.core/sort-by"
                                 "cljs.core/with-meta"
                                 "cljs.core/NeverEquiv"
                                 "cljs.core/select-keys"
                                 "cljs.core/ISeq"
                                 "cljs.core/disj!"
                                 "cljs.test/try-expr"
                                 "cljs.core/type->str"
                                 "clojure.walk/postwalk-replace"
                                 "cljs.core/ES6SetEntriesIterator"
                                 "cljs.core/pr-with-opts"
                                 "cljs.core/->>"
                                 "cljs.core/defonce"
                                 "cljs.core/nil?"
                                 "cljs.core/load-file*"
                                 "cljs.core/load-namespace"
                                 "clojure.walk/stringify-keys"
                                 "clojure.browser.repl/order"
                                 "cljs.core/memoize"
                                 "cljs.core/pr-sequential"
                                 "clojure.zip/make-node"
                                 "cljs.core/PersistentVector.EMPTY"
                                 "cljs.reader/float-pattern"
                                 "cljs.core/ancestors"
                                 "cljs.core/integer?"
                                 "cljs.core/HashMap.EMPTY"
                                 "cljs.core/Vector.EMPTY"
                                 "clojure.zip/xml-zip"
                                 "clojure.walk/walk"
                                 "cljs.core/ifn?"
                                 "cljs.core/bit-xor"
                                 "clojure.set/union"
                                 "cljs.core/case"
                                 "cljs.reader/PushbackReader"
                                 "cljs.core/isa?"
                                 "cljs.pprint/PrettyFlush"
                                 "clojure.browser.net/xhr-connection"
                                 "cljs.core/as->"
                                 "clojure.core.reducers/reducer"
                                 "cljs.core/subs"
                                 "cljs.core/symbol?"
                                 "clojure.data/Diff"
                                 "clojure.string/replace"
                                 "cljs.core/string?"
                                 "cljs.core/partition-all"
                                 "cljs.core/Var"
                                 "cljs.core/RedNode"
                                 "cljs.core/ExceptionInfo"
                                 "cljs.core/merge-with"
                                 "cljs.core/key"
                                 "clojure.browser.dom/set-properties"
                                 "clojure.data/diff"
                                 "cljs.core/ITransientAssociative"
                                 "cljs.core/trampoline"
                                 "cljs.test/test-ns"
                                 "cljs.core/implements?"
                                 "clojure.browser.repl/send-print"
                                 "cljs.core/ICounted"
                                 "cljs.core/quote"
                                 "cljs.core/IEquiv"
                                 "cljs.core/reduce-kv"
                                 "cljs.core/js-delete"
                                 "cljs.core/PersistentTreeSet.EMPTY"
                                 "cljs.core/comment"
                                 "cljs.reader/special-symbols"
                                 "cljs.core/js*"
                                 "cljs.core/BitmapIndexedNode.EMPTY"
                                 "cljs.reader/register-default-tag-parser!"
                                 "cljs.core/alength"
                                 "cljs.core/mk-bound-fn"
                                 "cljs.reader/validate-unicode-escape"
                                 "cljs.core/VectorNode"
                                 "cljs.core/string-hash-cache-count"
                                 "cljs.core/tree-seq"
                                 "cljs.reader/read-unmatched-delimiter"
                                 "clojure.core.reducers/take-while"
                                 "cljs.reader/register-tag-parser!"
                                 "cljs.core/every-pred"
                                 "cljs.core/PersistentHashSet"
                                 "cljs.repl/doc"
                                 "clojure.set/rename-keys"
                                 "cljs.core/peek"
                                 "cljs.core/pr-str-with-opts"
                                 "cljs.core/IChunk"
                                 "cljs.core/ITransientVector"
                                 "cljs.core/IPrintWithWriter"
                                 "cljs.core/test"
                                 "cljs.core/map?"
                                 "cljs.reader/StringPushbackReader"
                                 "cljs.core/PersistentTreeMap"
                                 "cljs.core/HashMap.fromArrays"
                                 "cljs.core/deref"
                                 "cljs.core/reductions"
                                 "cljs.core/false?"
                                 "cljs.core/bit-flip"
                                 "cljs.test/deftest"
                                 "cljs.core/ISet"
                                 "cljs.core/require"
                                 "cljs.core/StringIter"
                                 "cljs.core/LazySeq"
                                 "cljs.core/pop!"
                                 "cljs.reader/parse-timestamp"
                                 "cljs.core/chunk-first"
                                 "cljs.core/ChunkedSeq"
                                 "cljs.test/testing"
                                 "cljs.core/*2"
                                 "clojure.browser.event/total-listener-count"
                                 "cljs.core/MultiStepper"
                                 "cljs.core/alter-meta!"
                                 "clojure.browser.dom/click-element"
                                 "cljs.core/seq-iter"
                                 "cljs.core/unchecked-remainder-int"
                                 "cljs.core/bit-shift-right-zero-fill"
                                 "cljs.core/when-some"
                                 "cljs.reader/read-meta"
                                 "cljs.core/range"
                                 "cljs.core/reify"
                                 "cljs.core/satisfies?"
                                 "cljs.core/nth"
                                 "cljs.core/list"
                                 "cljs.core/defn"
                                 "cljs.core/rand-nth"
                                 "cljs.core/ex-cause"
                                 "cljs.core/def"
                                 "cljs.core/atom"
                                 "cljs.reader/read-keyword"
                                 "cljs.core/Vector"
                                 "cljs.reader/skip-line"
                                 "cljs.core/namespace"
                                 "cljs.nodejs/require"
                                 "cljs.core/chunk-rest"
                                 "cljs.core/unchecked-long"
                                 "clojure.browser.event/EventType"
                                 "cljs.core/ranged-iterator"
                                 "cljs.core/merge"
                                 "clojure.core.reducers/remove"
                                 "cljs.core/set-entries-iterator"
                                 "clojure.browser.repl/send-result"
                                 "clojure.walk/keywordize-keys"
                                 "cljs.core/entries-iterator"
                                 "cljs.core/reduced"
                                 "cljs.reader/read-string*"
                                 "cljs.core/ChunkedCons"
                                 "cljs.core/derive"
                                 "clojure.zip/zipper"
                                 "cljs.test/empty-env"
                                 "clojure.core.reducers/mapcat"
                                 "clojure.zip/remove"
                                 "cljs.core/find"
                                 "cljs.core/hash-set"
                                 "cljs.core/*print-dup*"
                                 "cljs.core/set-from-indexed-seq"
                                 "cljs.core/object-array"
                                 "cljs.core/indexed?"
                                 "cljs.core/partial"
                                 "cljs.core/keyword?"
                                 "clojure.browser.event/fire-listeners"
                                 "cljs.core/Iterator"
                                 "cljs.core/vreset!"
                                 "cljs.core/interleave"
                                 "cljs.core/TransientHashSet"
                                 "cljs.core/*flush-on-newline*"
                                 "cljs.core/get-in"
                                 "clojure.browser.dom/element"
                                 "cljs.core/prim-seq"
                                 "cljs.core/<="
                                 "clojure.set/map-invert"
                                 "clojure.browser.event/listen"
                                 "cljs.core/neg?"
                                 "cljs.core/mix-collection-hash"
                                 "clojure.browser.dom/replace-node"
                                 "cljs.core/reverse"
                                 "cljs.core/realized?"
                                 "cljs.core/ensure-reduced"},
                 :namespace-names #{"clojure.zip"
                                    "clojure.reflect"
                                    "cljs.test"
                                    "clojure.browser.dom"
                                    "clojure.set"
                                    "cljs.nodejs"
                                    "clojure.walk"
                                    "clojure.browser.event"
                                    "cljs.reader"
                                    "clojure.string"
                                    "cljs.repl"
                                    "clojure.browser.net"
                                    "cljs.core"
                                    "cljs.pprint"
                                    "clojure.data"
                                    "clojure.core.reducers"
                                    "clojure.browser.repl"}},
       :compiler {:changes {"0.0-2030" {},
                            "0.0-2067" {},
                            "0.0-2134" {},
                            "0.0-2322" {},
                            "0.0-1803" {},
                            "0.0-2371" {},
                            "0.0-2307" {},
                            "0.0-1886" {},
                            "0.0-2138" {},
                            "0.0-2505" {},
                            "0.0-2311" {},
                            "0.0-2740" {},
                            "0.0-2725" {},
                            "0.0-2127" {},
                            "0.0-2280" {},
                            "0.0-2199" {},
                            "0.0-2120" {},
                            "0.0-1878" {},
                            "0.0-1236" {},
                            "0.0-2060" {},
                            "0.0-1424" {:added #{"cljs.repl.browser/preloaded-libs"}},
                            "0.0-2342" {},
                            "0.0-1885" {},
                            "0.0-1535" {},
                            "0.0-1859" {},
                            "0.0-2755" {},
                            "0.0-1853" {},
                            "0.0-2197" {},
                            "0.0-2075" {},
                            "0.0-2277" {},
                            "0.0-2301" {},
                            "0.0-1909" {},
                            "0.0-2723" {},
                            "0.0-2727" {},
                            "0.0-1552" {},
                            "0.0-2080" {},
                            "0.0-2234" {},
                            "0.0-2644" {},
                            "0.0-2268" {},
                            "0.0-2511" {},
                            "0.0-1806" {},
                            "0.0-2341" {},
                            "0.0-2629" {:added #{"cljs.build.api/parse-js-ns"
                                                 "cljs.repl.node/socket"
                                                 "cljs.repl.node/close-socket"
                                                 "cljs.repl/repl*"
                                                 "cljs.repl.node/load-javascript"
                                                 "cljs.repl/update-require-spec"
                                                 "cljs.build.api/src-file->target-file"
                                                 "cljs.repl/merge-require"
                                                 "cljs.repl.node/read-response"
                                                 "cljs.repl/merge-spec"
                                                 "cljs.repl/spec-sort"
                                                 "cljs.build.api/cljs-ns-dependents"
                                                 "cljs.analyzer.api/ns-specs"
                                                 "cljs.repl.node/repl-env"
                                                 "cljs.analyzer.api/in-cljs-user"
                                                 "cljs.repl.node/setup"
                                                 "cljs.repl.node/node-eval"
                                                 "cljs.build.api/src-file->goog-require"
                                                 "cljs.repl.node/write"
                                                 "cljs.repl.node/repl-env*"},
                                        :removed #{"cljs.repl.rhino/current-repl-env"}},
                            "0.0-2719" {:added #{"cljs.repl/with-read-known"
                                                 "cljs.repl/IReplEnvOptions"
                                                 "cljs.repl/skip-whitespace"
                                                 "cljs.repl/repl-read"
                                                 "cljs.repl/skip-if-eol"}},
                            "0.0-2227" {},
                            "0.0-1576" {:removed #{"cljs.repl.rhino/loaded-libs"}},
                            "0.0-1844" {},
                            "0.0-1586" {},
                            "0.0-2498" {},
                            "0.0-1443" {},
                            "0.0-1006" {},
                            "0.0-1913" {},
                            "0.0-2069" {},
                            "0.0-2655" {:removed #{"cljs.repl/update-require-spec"
                                                   "cljs.repl/merge-require"
                                                   "cljs.repl/merge-spec"
                                                   "cljs.repl/spec-sort"
                                                   "cljs.analyzer.api/ns-specs"}},
                            "0.0-1513" {},
                            "0.0-1503" {:added #{"cljs.repl.server/handlers"
                                                 "cljs.repl.server/dispatch-on"
                                                 "cljs.repl.server/start"
                                                 "cljs.repl.reflect/parse-param"
                                                 "cljs.repl/analyze-source"
                                                 "cljs.repl.server/state"
                                                 "cljs.repl.reflect/macroexpand"
                                                 "cljs.repl.server/read-request"
                                                 "cljs.repl.server/set-connection"
                                                 "cljs.repl.server/read-post"
                                                 "cljs.repl.server/parse-headers"
                                                 "cljs.repl.reflect/handle-reflect-query"
                                                 "cljs.repl.server/stop"
                                                 "cljs.repl.server/read-get"
                                                 "cljs.repl.reflect/read-url-string"
                                                 "cljs.repl.browser/browser-state"
                                                 "cljs.repl.server/read-headers"
                                                 "cljs.repl.server/send-and-close"
                                                 "cljs.repl.server/send-404"
                                                 "cljs.repl.server/connection"},
                                        :removed #{"cljs.repl.browser/read-get"
                                                   "cljs.repl.browser/handle-get"
                                                   "cljs.repl.browser/stop-server"
                                                   "cljs.repl.browser/read-request"
                                                   "cljs.repl.browser/server-state"
                                                   "cljs.repl.browser/read-headers"
                                                   "cljs.repl.browser/parse-headers"
                                                   "cljs.repl.browser/send-404"
                                                   "cljs.repl.browser/send-and-close"
                                                   "cljs.repl.browser/handle-connection"
                                                   "cljs.repl.browser/start-server"
                                                   "cljs.repl.browser/server-loop"
                                                   "cljs.repl.browser/read-post"}},
                            "0.0-1933" {},
                            "0.0-1895" {},
                            "0.0-971" {},
                            "0.0-2027" {},
                            "0.0-1978" {},
                            "0.0-1843" {},
                            "0.0-2758" {},
                            "0.0-1835" {},
                            "0.0-1450" {},
                            "0.0-2173" {},
                            "0.0-1798" {},
                            "0.0-1877" {},
                            "0.0-1211" {:added #{"cljs.repl.browser/send-static"}},
                            "0.0-1449" {},
                            "0.0-993" {:added #{"cljs.repl/default-special-fns"}},
                            "0.0-1011" {},
                            "0.0-2356" {},
                            "0.0-2156" {},
                            "0.0-1847" {},
                            "0.0-2496" {:added #{"cljs.build.api/cljs-dependents-for-macro-namespaces"
                                                 "cljs.analyzer.api/find-ns"
                                                 "cljs.build.api/target-file-for-cljs-ns"
                                                 "cljs.analyzer.api/ns-resolve"
                                                 "cljs.build.api/mark-cljs-ns-for-recompile!"
                                                 "cljs.analyzer.api/all-ns"
                                                 "cljs.repl/doc"
                                                 "cljs.analyzer.api/resolve"
                                                 "cljs.analyzer.api/ns-interns"}},
                            "0.0-927" {:added #{"cljs.repl.rhino/current-repl-env"
                                                "cljs.repl/evaluate-form"
                                                "cljs.repl/load-stream"
                                                "cljs.repl.rhino/eval-result"
                                                "cljs.repl.browser/read-get"
                                                "cljs.repl.browser/load-javascript"
                                                "cljs.repl.browser/add-in-order"
                                                "cljs.repl/load-namespace"
                                                "cljs.repl.rhino/loaded-libs"
                                                "cljs.repl.browser/run-in-order"
                                                "cljs.repl.browser/compile-client-js"
                                                "cljs.repl.browser/handle-get"
                                                "cljs.repl.browser/stop-server"
                                                "cljs.repl.browser/read-request"
                                                "cljs.repl/load-file"
                                                "cljs.repl.browser/browser-eval"
                                                "cljs.repl.browser/server-state"
                                                "cljs.repl.browser/send-for-eval"
                                                "cljs.repl.browser/constrain-order"
                                                "cljs.repl.rhino/rhino-eval"
                                                "cljs.repl.browser/read-headers"
                                                "cljs.repl/repl"
                                                "cljs.repl.rhino/load-javascript"
                                                "cljs.repl.browser/create-client-js-file"
                                                "cljs.repl/*cljs-verbose*"
                                                "cljs.repl.browser/loaded-libs"
                                                "cljs.repl.browser/repl-client-js"
                                                "cljs.repl.browser/parse-headers"
                                                "cljs.repl.browser/send-404"
                                                "cljs.repl.browser/repl-env"
                                                "cljs.repl.rhino/repl-env"
                                                "cljs.repl.rhino/goog-require"
                                                "cljs.repl.browser/send-repl-client-page"
                                                "cljs.repl.browser/send-and-close"
                                                "cljs.repl.rhino/bootjs"
                                                "cljs.repl/IJavaScriptEnv"
                                                "cljs.repl.browser/handle-connection"
                                                "cljs.repl.rhino/IEval"
                                                "cljs.repl.browser/start-server"
                                                "cljs.repl.browser/server-loop"
                                                "cljs.repl.browser/read-post"
                                                "cljs.repl.rhino/rhino-setup"
                                                "cljs.repl.browser/handle-post"
                                                "cljs.repl.rhino/stacktrace"
                                                "cljs.repl.browser/ordering"}},
                            "0.0-1934" {},
                            "0.0-2202" {},
                            "0.0-1820" {},
                            "0.0-2261" {},
                            "0.0-2024" {},
                            "0.0-1889" {},
                            "0.0-2657" {},
                            "0.0-1896" {},
                            "0.0-2014" {},
                            "0.0-2411" {},
                            "0.0-2665" {:added #{"cljs.repl.browser/setup"}},
                            "0.0-2760" {}},
                  :symbol-names #{"cljs.repl.rhino/current-repl-env"
                                  "cljs.build.api/cljs-dependents-for-macro-namespaces"
                                  "cljs.repl/with-read-known"
                                  "cljs.repl/evaluate-form"
                                  "cljs.build.api/parse-js-ns"
                                  "cljs.repl/load-stream"
                                  "cljs.repl.rhino/eval-result"
                                  "cljs.repl.node/socket"
                                  "cljs.repl.browser/read-get"
                                  "cljs.repl.node/close-socket"
                                  "cljs.repl.browser/load-javascript"
                                  "cljs.repl/repl*"
                                  "cljs.repl.browser/add-in-order"
                                  "cljs.repl.server/handlers"
                                  "cljs.repl.node/load-javascript"
                                  "cljs.repl/load-namespace"
                                  "cljs.analyzer.api/find-ns"
                                  "cljs.repl.rhino/loaded-libs"
                                  "cljs.repl.server/dispatch-on"
                                  "cljs.repl.browser/run-in-order"
                                  "cljs.repl.browser/compile-client-js"
                                  "cljs.repl.server/start"
                                  "cljs.repl.browser/handle-get"
                                  "cljs.repl.reflect/parse-param"
                                  "cljs.repl/analyze-source"
                                  "cljs.repl.browser/stop-server"
                                  "cljs.repl.browser/read-request"
                                  "cljs.build.api/target-file-for-cljs-ns"
                                  "cljs.repl.server/state"
                                  "cljs.repl.reflect/macroexpand"
                                  "cljs.repl.server/read-request"
                                  "cljs.repl/load-file"
                                  "cljs.repl.browser/browser-eval"
                                  "cljs.repl.browser/server-state"
                                  "cljs.repl.browser/send-for-eval"
                                  "cljs.repl.browser/constrain-order"
                                  "cljs.repl/default-special-fns"
                                  "cljs.repl.rhino/rhino-eval"
                                  "cljs.repl.browser/read-headers"
                                  "cljs.repl/IReplEnvOptions"
                                  "cljs.repl.server/set-connection"
                                  "cljs.analyzer.api/ns-resolve"
                                  "cljs.repl/update-require-spec"
                                  "cljs.repl/repl"
                                  "cljs.build.api/src-file->target-file"
                                  "cljs.repl.rhino/load-javascript"
                                  "cljs.repl/merge-require"
                                  "cljs.repl.browser/create-client-js-file"
                                  "cljs.repl/*cljs-verbose*"
                                  "cljs.repl.server/read-post"
                                  "cljs.repl.browser/loaded-libs"
                                  "cljs.repl.browser/setup"
                                  "cljs.repl/skip-whitespace"
                                  "cljs.repl.server/parse-headers"
                                  "cljs.repl.node/read-response"
                                  "cljs.repl.browser/repl-client-js"
                                  "cljs.repl.browser/parse-headers"
                                  "cljs.repl.reflect/handle-reflect-query"
                                  "cljs.repl.browser/send-404"
                                  "cljs.repl.browser/repl-env"
                                  "cljs.repl/merge-spec"
                                  "cljs.repl.rhino/repl-env"
                                  "cljs.repl.server/stop"
                                  "cljs.repl.rhino/goog-require"
                                  "cljs.repl/spec-sort"
                                  "cljs.repl.server/read-get"
                                  "cljs.repl.browser/send-repl-client-page"
                                  "cljs.repl.reflect/read-url-string"
                                  "cljs.repl.browser/preloaded-libs"
                                  "cljs.build.api/mark-cljs-ns-for-recompile!"
                                  "cljs.repl.browser/browser-state"
                                  "cljs.repl.browser/send-static"
                                  "cljs.build.api/cljs-ns-dependents"
                                  "cljs.analyzer.api/ns-specs"
                                  "cljs.repl.server/read-headers"
                                  "cljs.analyzer.api/all-ns"
                                  "cljs.repl/repl-read"
                                  "cljs.repl.browser/send-and-close"
                                  "cljs.repl.node/repl-env"
                                  "cljs.repl/skip-if-eol"
                                  "cljs.analyzer.api/in-cljs-user"
                                  "cljs.repl.rhino/bootjs"
                                  "cljs.repl/IJavaScriptEnv"
                                  "cljs.repl.browser/handle-connection"
                                  "cljs.repl.node/setup"
                                  "cljs.repl/doc"
                                  "cljs.repl.node/node-eval"
                                  "cljs.repl.rhino/IEval"
                                  "cljs.analyzer.api/resolve"
                                  "cljs.repl.browser/start-server"
                                  "cljs.repl.server/send-and-close"
                                  "cljs.repl.browser/server-loop"
                                  "cljs.repl.server/send-404"
                                  "cljs.repl.browser/read-post"
                                  "cljs.repl.server/connection"
                                  "cljs.repl.rhino/rhino-setup"
                                  "cljs.build.api/src-file->goog-require"
                                  "cljs.repl.node/write"
                                  "cljs.repl.browser/handle-post"
                                  "cljs.repl.node/repl-env*"
                                  "cljs.repl.rhino/stacktrace"
                                  "cljs.analyzer.api/ns-interns"
                                  "cljs.repl.browser/ordering"},
                  :namespace-names #{"cljs.repl.server"
                                     "cljs.repl.browser"
                                     "cljs.repl.rhino"
                                     "cljs.repl.node"
                                     "cljs.repl.reflect"
                                     "cljs.build.api"
                                     "cljs.repl"
                                     "cljs.analyzer.api"}}}}
